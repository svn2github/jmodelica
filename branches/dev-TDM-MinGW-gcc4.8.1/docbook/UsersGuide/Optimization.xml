<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ch_optimization"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Optimization</title>

  <section xml:id="opt_sec_intro">
    <title>Introduction</title>

    <para>JModelica.org supports optimization of dynamic and steady state
    models. Many engineering problems can be cast as optimization problems,
    including optimal control, minimum time problems, optimal design, and
    model calibration. These different types of problems will be illustrated
    and it will be shown how they can be formulated and solved. The chapter
    starts with an introductory example in <xref linkend="opt-sec-first"/> and
    in <xref linkend="opt-sec-solve"/>, the details of how the optimization
    algorithms are invoked are explained. The following sections contain
    tutorial exercises that illustrates how to set up and solve different
    kinds of optimization problems.</para>

    <para>When formulating optimization problems, models are expressed in the
    Modelica language, whereas optimization specifications are given in the
    Optimica extension which is described in <xref linkend="chap-optimica"/>.
    The tutorial exercises in this chapter assumes that the reader is familiar
    with the basics of Modelica and Optimica.</para>
  </section>

  <section xml:id="opt-sec-first">
    <title>A first example</title>

    <para>In this section, a simple optimal control problem will be solved.
    Consider the optimal control problem for the Van der Pol oscillator
    model:</para>

    <programlisting language="optimica">optimization VDP_Opt (objective = cost(finalTime),
                      startTime = 0,
                      finalTime = 20)

  // The states
  Real x1(start=0,fixed=true);
  Real x2(start=1,fixed=true);

  // The control signal
  input Real u;

  Real cost(start=0,fixed=true);

equation
  der(x1) = (1 - x2^2) * x1 - x2 + u;
  der(x2) = x1;
  der(cost) = x1^2 + x2^2 + u^2;
constraint 
   u&lt;=0.75;
end VDP_Opt;
</programlisting>

    <para>Create a new file named <filename>VDP_Opt.mop</filename> and save it
    in you working directory. Notice that this model contains both the dynamic
    system to be optimized and the optimization specification. This is
    possible since Optimica is an extension of Modelica and thereby supports
    also Modelica constructs such as variable declarations and equations. In
    most cases, however, Modelica models are stored separately from the
    Optimica specifications.</para>

    <para>Next, create a Python script file and a write (or copy paste) the
    following commands:</para>

    <programlisting language="python"># Import the function for compilation of models and the JMUModel class
from pymodelica import compile_jmu
from pyjmi import JMUModel

# Import the plotting library
import matplotlib.pyplot as plt
</programlisting>

    <para>Next, we compile and load the model:</para>

    <programlisting language="python"># Compile model
jmu_name = compile_jmu("VDP_Opt","VDP_Opt.mop")
# Load model
vdp = JMUModel(jmu_name)
</programlisting>

    <para>The function <literal>compile_jmu</literal> invokes the Optimica
    compiler and compiles the model into a DLL, which is then loaded when the
    <literal>vdp</literal> object is created. This object represents the
    compiled model and is used to invoke the optimization algorithm:</para>

    <programlisting language="python">res = vdp.optimize()
</programlisting>

    <para>In this case, we use the default settings for the optimization
    algorithm. The result object can now be used to access the optimization
    result:</para>

    <programlisting language="python"># Extract variable profiles
x1=res['x1']
x2=res['x2']
u=res['u']
t=res['time']
</programlisting>

    <para>The variable trajectories are returned as numpy arrays and can be
    used for further analysis of the optimization result or for
    visualization:</para>

    <programlisting language="python">plt.figure(1)
plt.clf()
plt.subplot(311)
plt.plot(t,x1)
plt.grid()
plt.ylabel('x1')

plt.subplot(312)
plt.plot(t,x2)
plt.grid()
plt.ylabel('x2')

plt.subplot(313)
plt.plot(t,u)
plt.grid()
plt.ylabel('u')
plt.xlabel('time')
plt.show()
</programlisting>

    <para>You should now see the optimization result as shown in <xref
    linkend="fig-vdp-opt"/>.</para>

    <figure floatstyle="top" xml:id="fig-vdp-opt">
      <title>Optimal profiles for the VDP oscillator</title>

      <mediaobject>
        <imageobject>
          <imagedata align="left" fileref="images/vdp.svg" scalefit="1"
                     width="60%"/>
        </imageobject>
      </mediaobject>

      <caption>
        <para>Optimal control and state profiles for the Van Der Pol optimal
        control problem.</para>
      </caption>
    </figure>
  </section>

  <section xml:id="opt-sec-solve">
    <title>Solving optimization problems</title>

    <para>The first step when solving an optimization problem is to formulate
    a model and an optimization specification and then compile the model as
    described in the following sections in this chapter. There are four
    different optimization algorithms available in JModelica.org, which are
    suitable for different classes of optimization problems.</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Dynamic optimization of DAEs using direct
        collocation with JMUs</emphasis>. This algorithm is the default
        algorithm for solving optimal control and parameter estimation
        problems. It is implemented in C, uses CppAD for computing function
        derivatives and IPOPT for solving the resulting nonlinear program
        (NLP). Functions and records in models are supported by this
        algorithm. Use this method if your model is a DAE and does not contain
        discontinuities.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Dynamic optimization of DAEs using direct
        collocation with CasADi.</emphasis> This algorithm solves optimal
        control and parameter estimation problems. It is implemented in
        Python, uses CasADi for computing function derivatives and IPOPT or
        WORHP for solving the resulting NLP. In terms of functionality, this
        algorithm is very similar to the default JMU-based algorithm, but
        offers significant performance improvements in several regards. It is
        however still in a state of development, and is not as mature as the
        default algorithm.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Pseudospectral optimization of ODEs using
        CasADi.</emphasis> This algorithm solves optimal control problems with
        multiple phases using a pseudospectral method. It is implemented in
        Python, uses CasADi for computing function derivatives and IPOPT for
        solving the resulting NLP. Use this algorithm if your model is a
        continuous time ODE that contains multiple phases. Use this algorithm
        with caution as it is experimental.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Derivative free calibration and
        optimization of ODEs with FMUs.</emphasis> This algorithm solves
        parameter optimization and model calibration problems and is based on
        FMUs. The algorithm is implemented in Python and relies on a
        Nelder-Mead derivative free optimization algorithm. Use this method if
        your model is of large scale and/or contains discontinuities or hybrid
        elements. Note that this algorithm is applicable to models which have
        been exported as FMUs also by other tools than JModelica.org.</para>
      </listitem>
    </itemizedlist>

    <para>To illustrate how to solve optimization problems the Van der Pol
    problem presented above is used. First, the model is compiled and
    loaded:</para>

    <programlisting language="python">model_name = compile_jmu("VDP_Opt","VDP_Opt.mop")
model = JMUModel(model_name)
</programlisting>

    <para>In this case, a JMU is compiled, corresponding compilation functions
    are available for the other algorithms. All operations that can be
    performed on the model are available as methods of the
    <literal>model</literal> object and can be accessed by tab completion.
    Invoking an optimization algorithm is done by calling the method
    <literal>JMUModel.optimize</literal>, which performs the following
    tasks:</para>

    <itemizedlist>
      <listitem>
        <para>Sets up the selected algorithm with default or user defined
        options</para>
      </listitem>

      <listitem>
        <para>Invokes the algorithm to find a numerical solution to the
        problem</para>
      </listitem>

      <listitem>
        <para>Writes the result to file</para>
      </listitem>

      <listitem>
        <para>Returns a result object from which the solution can be
        retrieved</para>
      </listitem>
    </itemizedlist>

    <para>The interactive help for the <literal>optimize</literal> method is
    displayed by the command:</para>

    <programlisting>&gt;&gt;&gt; help(model.optimize)
    Solve an optimization problem.
        
    Parameters::
        
        algorithm --
            The algorithm which will be used for the optimization is 
            specified by passing the algorithm class name as string or 
            class object in this argument. 'algorithm' can be any 
            class which implements the abstract class AlgorithmBase 
            (found in algorithm_drivers.py). In this way it is 
            possible to write custom algorithms and to use them with this 
            function.
    
            The following algorithms are available:
            - 'CollocationLagrangePolynomialsAlg'. This algorithm is based on
              direct collocation on finite elements and the algorithm IPOPT
              is used to obtain a numerical solution to the problem.
            Default: 'CollocationLagrangePolynomialsAlg'
            
        options -- 
            The options that should be used in the algorithm. The options
            documentation can be retrieved from an options object:
            
                &gt;&gt;&gt; myModel = JMUModel(...)
                &gt;&gt;&gt; opts = myModel.optimize_options()
                &gt;&gt;&gt; opts?
    
            Valid values are: 
            - A dict that overrides some or all of the default values
              provided by CollocationLagrangePolynomialsAlgOptions. An empty
              dict will thus give all options with default values.
            - A CollocationLagrangePolynomialsAlgOptions object.
            Default: Empty dict
        
    Returns::
        
        A result object, subclass of algorithm_drivers.ResultBase.
</programlisting>

    <para>Again, note that the parameters differs for different model classes.
    The optimize method can be invoked without any arguments, in which case
    the default optimization algorithm, with default options, is
    invoked:</para>

    <programlisting>res = vdp.optimize()
</programlisting>

    <para>In the remainder of this chapter the available algorithms are
    described in detail. Options for an algorithm can be set using the
    <literal>options</literal> argument to the <literal>optimize</literal>
    method. It is convenient to first obtain an options object in order to
    access the documentation and default option values. This is done by
    invoking the method optimize_options:</para>

    <programlisting>&gt;&gt;&gt; help(m.optimize_options)
    Returns an instance of the optimize options class containing options 
    default values. If called without argument then the options class for 
    the default optimization algorithm will be returned.
    
    Parameters::
    
        algorithm --
            The algorithm for which the options class should be returned. 
            Possible values are: 'CollocationLagrangePolynomialsAlg'.
            Default: 'CollocationLagrangePolynomialsAlg'
            
    Returns::
    
        Options class for the algorithm specified with default values.
</programlisting>

    <para>The option object is essentially a Python dictionary and options are
    set simply by using standard dictionary syntax:</para>

    <programlisting language="python">opts = vdp.optimize_options()
opts['n_e'] = 5
</programlisting>

    <para>The optimization algorithm may then be invoked again with the new
    options:</para>

    <programlisting language="python">res = vdp.optimize(options=opts)
</programlisting>

    <para>Available options for each algorithm are documented in their
    respective sections in this Chapter.</para>

    <para>The <literal>optimize</literal> method returns a result object
    containing the optimization result and some meta information about the
    solution. The most common operation is to retrieve variable trajectories
    from the result object:</para>

    <programlisting language="python">time = res['time']
x1 = res['x1']
</programlisting>

    <para>Variable data is returned as NumPy arrays. The result object also
    contains references to the model that was optimized, the name of the
    result file that was written to disk, a solver object representing the
    optimization algorithm and an options object that was used when solving
    the optimization problem.</para>
  </section>

  <section>
    <title>Scaling</title>

    <para>Many physical models contain variables with values that differ
    several orders of magnitude. A typical example is thermodynamic models
    containing pressures, temperatures and mass flows. Such large differences
    in values may have a severe deteriorating effect on the performance of
    numerical algorithms, and may in some cases even lead to the algorithm
    failing. In order to relieve the user from the burden of manually scaling
    variables, Modelica offers the <literal>nominal</literal> attribute, which
    can be used to automatically scale a model. Consider the Modelica variable
    declaration:</para>

    <programlisting language="python">Real pressure(start=101.3e3, nominal=1e5);
</programlisting>

    <para>Here, the <literal>nominal</literal> attribute is used to specify
    that the variable pressure takes on values which are about 1e5. In order
    to use <literal>nominal</literal> attributes for scaling with JMUs, the
    compiler option <literal>enable_variable_scaling</literal> is set to
    <literal>True</literal>, see <xref
    linkend="models_sec_compiler_options"/>. For CasADi-based algorithms,
    scaling is instead enabled by setting the algorithm option
    <literal>variable_scaling</literal> to <literal>True</literal>, and is
    enabled by default . In both cases, all variables with a set nominal
    attribute are then scaled by dividing the variable value with its nominal
    value, i.e., from an algorithm point of view, all variables will take on
    values close to one. Notice that variables typically vary during a
    simulation or optimization and that it is therefore not possible to obtain
    perfect scaling. In order to ensure that model equations are fulfilled,
    each occurrence of a variable is multiplied with its nominal value in
    equations. For example, the equation:</para>

    <programlisting language="python">T = f(p)
</programlisting>

    <para>is replaced by the equation</para>

    <programlisting language="python">T_scaled*T_nom = f(p_scaled*p_nom)
</programlisting>

    <para>when <literal>variable scaling</literal> is enabled.</para>

    <para>The algorithm in <xref linkend="opt-sec-dae-casadi"/> also has
    support for providing trajectories (obtained by for example simulation)
    that are used for scaling. This means that it usually is not necessary to
    provide nominal values for all variables, and that it is possible to use
    time-varying scaling factors.</para>

    <para>For debugging purposes, is is sometimes useful to write a
    simulation/optimization/initialization result to file in scaled format, in
    order to detect if there are some variables which require additional
    scaling. The option <literal>write_scaled_result</literal> has been
    introduced as an option to the <literal>initialize</literal>,
    <literal>simulate</literal> and <literal>optimize</literal> methods for
    this purpose.</para>
  </section>

  <section xml:id="opt-sec-dae-jmu">
    <title>Dynamic optimization of DAEs using direct collocation with
    JMUs</title>

    <para>The default direct collocation method supported by JModelica.org can
    be used to solve dynamic optimization problems, including optimal control
    problems and parameter optimization problems. In the collocation method,
    the dynamic model variable profiles are approximated by piecewise
    polynomials. This method of approximating a differential equation
    corresponds to a fixed step implicit Runge-Kutta scheme, where the mesh
    defines the length of each step. Also, the number of collocation points in
    each element, or step, needs to be provided. This number corresponds to
    the stage order of the Runge-Kutta scheme. The selection of mesh is
    analogous to the choice of step length in a one-step algorithm for solving
    differential equations. Accordingly, the mesh needs to be fine-grained
    enough to ensure sufficiently accurate approximation of the differential
    constraint. For an overview of simultaneous optimization algorithms, see
    [2]. The algorithm <link
    xlink:href="https://projects.coin-or.org/Ipopt">IPOPT</link> is used to
    solve the non-linear program resulting from collocation.</para>

    <para>The collocation method implemented in JModelica.org requires that
    the model to be optimized does not contain discontinuities such as if
    equations, when clauses or integer variables.</para>

    <para>The mathematical formulation of the algorithm can be found in the
    <link
    xlink:href="http://www.jmodelica.org/api-docs/jmi/group__jmi__opt__sim__lp.html">JMI
    API documentation</link>.</para>

    <para>The collocation algorithm provides a number of options, summarized
    in <xref linkend="opt-tab-collopts"/>.</para>

    <table xml:id="opt-tab-collopts">
      <title>Options for the JMU and collocation-based optimization
      algorithm</title>

      <tgroup cols="3">
        <colspec align="left" colname="col–opt" colwidth="1*"/>

        <colspec align="left" colname="col–desc" colwidth="1*"/>

        <colspec align="left" colname="col–def" colwidth="2*"/>

        <thead>
          <row>
            <entry align="center">Option</entry>

            <entry align="center">Default</entry>

            <entry align="center">Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal>n_e</literal></entry>

            <entry>50</entry>

            <entry>Number of elements of the finite element mesh.</entry>
          </row>

          <row>
            <entry><literal>n_cp</literal></entry>

            <entry>3</entry>

            <entry>Number of collocation points in each element. Values
            between 1 and 10 are supported.</entry>
          </row>

          <row>
            <entry><literal>hs</literal></entry>

            <entry>Equidistant points using default n_e</entry>

            <entry>A vector containing n_e elements representing the finite
            element lengths. The sum of all element should equal to 1.</entry>
          </row>

          <row>
            <entry><literal>blocking_factors</literal></entry>

            <entry>None (not used)</entry>

            <entry>A vector of blocking factors. Blocking factors are
            specified by a vector of integers, where each entry in the vector
            corresponds to the number of elements for which the control
            profile should be kept constant. For example, the blocking factor
            specification [2,1,5] means that u_0=u_1 and u_3=u_4=u_5=u_6=u_7
            assuming that the number of elements is 8. Notice that
            specification of blocking factors implies that controls are
            present in only one collocation point (the first) in each element.
            The number of constant control levels in the optimization interval
            is equal to the length of the blocking factor vector. In the
            example above, this implies that there are three constant control
            levels. If the sum of the entries in the blocking factor vector is
            not equal to the number of elements, the vector is normalized,
            either by truncation (if the sum of the entries is larger than the
            number of element) or by increasing the last entry of the vector.
            For example, if the number of elements is 4, the normalized
            blocking factor vector in the example is [2,1,1]. If the number of
            elements is 10, then the normalized vector is [2,1,7].</entry>
          </row>

          <row>
            <entry><literal>init_traj</literal></entry>

            <entry>None (i.e. not used, set this argument to activate
            initialization)</entry>

            <entry>Variable trajectory data used for initialization of the
            optimization problem. The data is represented by an object of the
            type
            <literal>pyjmi.common.io.ResultDymolaTextual.</literal></entry>
          </row>

          <row>
            <entry><literal>result_mode</literal></entry>

            <entry>'default'</entry>

            <entry>Specifies the output format of the optimization result.
            'default' gives the the optimization result at the collocation
            points. 'element_interpolation' computes the values of the
            variable trajectories using the collocation interpolation
            polynomials. The option 'n_interpolation_points' is used to
            specify the number of evaluation points within each finite
            element. 'mesh_interpolation' computes the values of the variable
            trajectories at points defined by the option
            'result_mesh'.</entry>
          </row>

          <row>
            <entry><literal>n_interpolation_points</literal></entry>

            <entry>20</entry>

            <entry>Number of interpolation points in each finite element if
            the result reporting option result_mode is set to
            'element_interpolation'.</entry>
          </row>

          <row>
            <entry><literal>result_mesh</literal></entry>

            <entry>None</entry>

            <entry>A vector of time points at which the the optimization
            result is computed. This option is used if result_mode is set to
            'mesh_interpolation'.</entry>
          </row>

          <row>
            <entry><literal>result_file_name</literal></entry>

            <entry>Empty string (default generated file name will be
            used)</entry>

            <entry>Specifies the name of the file where the optimization
            result is written. Setting this option to an empty string results
            in a default file name that is based on the name of the
            optimization class.</entry>
          </row>

          <row>
            <entry><literal>result_format</literal></entry>

            <entry>'txt'</entry>

            <entry>Specifies in which format to write the result. Currently
            only textual mode is supported.</entry>
          </row>

          <row>
            <entry><literal>write_scaled_result</literal></entry>

            <entry>False</entry>

            <entry>Write the scaled optimization result if set to true. This
            option is only applicable when automatic variable scaling is
            enabled. Only for debugging use.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>In addition to the options for the collocation algorithm, IPOPT
    options can also be set by modifying the dictionary
    <literal>IPOPT_options</literal> contained in the collocation algorithm
    options object. Here, all valid IPOPT options can be specified, see the
    <link xlink:href="http://www.coin-or.org/Ipopt/documentation/">IPOPT
    documentation</link> for further information. For example, setting the
    option <literal>max_iter</literal>:</para>

    <programlisting language="python">opts['IPOPT_options']['max_iter'] = 300
</programlisting>

    <para>makes IPOPT terminate after 300 iterations even if no optimal
    solution has been found.</para>

    <para>Some statistics from IPOPT can be obtained by issuing the
    command:</para>

    <programlisting>res_opt.solver.opt_coll_ipopt_get_statistics()
</programlisting>

    <para>The return argument of this function can be found by using the
    interactive help:</para>

    <programlisting>help(res.solver.opt_coll_ipopt_get_statistics)
Get statistics from the last optimization run.
    
Returns::
    
    return_status -- 
        Return status from IPOPT.
            
    nbr_iter -- 
        Number of iterations.
            
    objective -- 
       Final value of objective function.
            
    total_exec_time -- 
        Execution time.
</programlisting>

    <section>
      <title>Examples</title>

      <section xml:id="opt-sec-dae-c-cstr">
        <title>Optimal control</title>

        <para>This tutorial is based on the Hicks-Ray Continuously Stirred
        Tank Reactors (CSTR) system. The model was originally presented in
        [1]. The system has two states, the concentration, c, and the
        temperature, T. The control input to the system is the temperature,
        Tc, of the cooling flow in the reactor jacket. The chemical reaction
        in the reactor is exothermic, and also temperature dependent; high
        temperature results in high reaction rate. The CSTR dynamics is given
        by:</para>

        <informalequation>
          <m:math display="block" overflow="scroll">
            <m:mtable>
              <m:mtr>
                <m:mtd columnalign="right">
                  <m:mover>
                    <m:mi>c</m:mi>

                    <m:mo>.</m:mo>
                  </m:mover>

                  <m:mfenced>
                    <m:mi>t</m:mi>
                  </m:mfenced>
                </m:mtd>

                <m:mtd columnalign="left">
                  <m:mo>=</m:mo>

                  <m:mfrac>
                    <m:mrow>
                      <m:msub>
                        <m:mi>F</m:mi>

                        <m:mn>0</m:mn>
                      </m:msub>

                      <m:mfenced separators="">
                        <m:msub>
                          <m:mi>c</m:mi>

                          <m:mn>0</m:mn>
                        </m:msub>

                        <m:mo>-</m:mo>

                        <m:mi>c</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:mi>t</m:mi>
                        </m:mfenced>
                      </m:mfenced>
                    </m:mrow>

                    <m:mi>V</m:mi>
                  </m:mfrac>

                  <m:mo>-</m:mo>

                  <m:msub>
                    <m:mi>k</m:mi>

                    <m:mn>0</m:mn>
                  </m:msub>

                  <m:mi>c</m:mi>

                  <m:mo>⁡</m:mo>

                  <m:mfenced>
                    <m:mi>t</m:mi>
                  </m:mfenced>

                  <m:msup>
                    <m:mi>e</m:mi>

                    <m:mrow>
                      <m:mo>-</m:mo>

                      <m:mi>EdivR</m:mi>

                      <m:mo>/</m:mo>

                      <m:mi>T</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>
                    </m:mrow>
                  </m:msup>
                </m:mtd>
              </m:mtr>

              <m:mtr>
                <m:mtd columnalign="right">
                  <m:mover>
                    <m:mi>T</m:mi>

                    <m:mo>.</m:mo>
                  </m:mover>

                  <m:mfenced>
                    <m:mi>t</m:mi>
                  </m:mfenced>
                </m:mtd>

                <m:mtd columnalign="left">
                  <m:mo>=</m:mo>

                  <m:mfrac>
                    <m:mrow>
                      <m:msub>
                        <m:mi>F</m:mi>

                        <m:mn>0</m:mn>
                      </m:msub>

                      <m:mfenced separators="">
                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mn>0</m:mn>
                        </m:msub>

                        <m:mo>-</m:mo>

                        <m:mi>T</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:mi>t</m:mi>
                        </m:mfenced>
                      </m:mfenced>
                    </m:mrow>

                    <m:mi>V</m:mi>
                  </m:mfrac>

                  <m:mo>-</m:mo>

                  <m:mfrac>
                    <m:mrow>
                      <m:mrow>
                        <m:mi>d</m:mi>

                        <m:mi>H</m:mi>
                      </m:mrow>

                      <m:msub>
                        <m:mi>k</m:mi>

                        <m:mn>0</m:mn>
                      </m:msub>

                      <m:mi>c</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mrow>
                      <m:mi>ρ</m:mi>

                      <m:msub>
                        <m:mi>C</m:mi>

                        <m:mi>p</m:mi>
                      </m:msub>
                    </m:mrow>
                  </m:mfrac>

                  <m:msup>
                    <m:mi>e</m:mi>

                    <m:mrow>
                      <m:mo>-</m:mo>

                      <m:mi>EdivR</m:mi>

                      <m:mo>/</m:mo>

                      <m:mi>T</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>
                    </m:mrow>
                  </m:msup>

                  <m:mo>+</m:mo>

                  <m:mfrac>
                    <m:mrow>
                      <m:mn>2</m:mn>

                      <m:mi>U</m:mi>
                    </m:mrow>

                    <m:mrow>
                      <m:mi>r</m:mi>

                      <m:mi>ρ</m:mi>

                      <m:msub>
                        <m:mi>C</m:mi>

                        <m:mi>p</m:mi>
                      </m:msub>
                    </m:mrow>
                  </m:mfrac>

                  <m:mfenced separators="">
                    <m:mrow>
                      <m:mi>T</m:mi>

                      <m:mi>c</m:mi>
                    </m:mrow>

                    <m:mfenced>
                      <m:mi>t</m:mi>
                    </m:mfenced>

                    <m:mo>-</m:mo>

                    <m:mi>T</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi>t</m:mi>
                    </m:mfenced>
                  </m:mfenced>
                </m:mtd>
              </m:mtr>
            </m:mtable>

            <m:mspace linebreak="newline"/>
          </m:math>
        </informalequation>

        <para>This tutorial will cover the following topics:</para>

        <itemizedlist>
          <listitem>
            <para>How to solve a DAE initialization problem. The
            initialization model have equations specifying that all
            derivatives should be identically zero, which implies that a
            stationary solution is obtained. Two stationary points,
            corresponding to different inputs, are computed. We call the
            stationary points A and B respectively. Point A corresponds to
            operating conditions where the reactor is cold and the reaction
            rate is low, whereas point B corresponds to a higher temperature
            where the reaction rate is high. For more information about the
            DAE initialization algorithm, see the JMI API
            documentation.</para>
          </listitem>

          <listitem>
            <para>An optimal control problem is solved where the objective is
            to transfer the state of the system from stationary point A to
            point B. The challenge is to ignite the reactor while avoiding
            uncontrolled temperature increase. It is also demonstrated how to
            set parameter and variable values in a model. More information
            about the simultaneous optimization algorithm can be found at
            JModelica.org API documentation.</para>
          </listitem>

          <listitem>
            <para>The optimization result is saved to file and then the
            important variables are plotted.</para>
          </listitem>
        </itemizedlist>

        <para>The Python commands in this tutorial may be copied and pasted
        directely into a Python shell, in some cases with minor modifications.
        Alternatively, you may copy the commands into a text file, e.g.,
        <filename>cstr.py</filename>.</para>

        <para>Start the tutorial by creating a working directory and copy the
        file
        <filename>$JMODELICA_HOME/Python/pyjmi/examples/files/CSTR.mop</filename>
        to your working directory. An on-line version of <link
        xlink:href="https://svn.jmodelica.org/trunk/Python/src/pyjmi/examples/files/CSTR.mop"><filename>CSTR.mop</filename></link>
        is also available (depending on which browser you use, you may have to
        accept the site certificate by clicking through a few steps). If you
        choose to create Python script file, save it to the working
        directory.</para>

        <section>
          <title>Compile and instantiate a model object</title>

          <para>The functions and classes used in the tutorial script need to
          be imported into the Python script. This is done by the following
          Python commands. Copy them and paste them either directly into your
          Python shell or, preferably, into your Python script file.</para>

          <programlisting language="python">import numpy as N
import matplotlib.pyplot as plt

from pymodelica import compile_jmu
from pyjmi import JMUModel
</programlisting>

          <para>Before we can do operations on the model, such as optimizing
          it, the model file must be compiled and the resulting DLL file
          loaded in Python. These steps are described in more detail Section
          4.</para>

          <programlisting language="python"># Compile the stationary initialization model into a JMU
jmu_name = compile_jmu("CSTR.CSTR_Init","CSTR.mop", 
    compiler_options={"enable_variable_scaling":True})

# load the JMU
init_model = JMUModel(jmu_name)
</programlisting>

          <para>Notice that automatic scaling of the model is enabled by
          setting the compiler option
          <literal>enable_variable_scaling</literal> to true. At this point,
          you may open the file <filename>CSTR.mop</filename>, containing the
          CSTR model and the static initialization model used in this section.
          Study the classes <literal>CSTR.CSTR</literal> and
          <literal>CSTR.CSTR_Init</literal> and make sure you understand the
          models. Before proceeding, have a look at the interactive help for
          one of the functions you used:</para>

          <programlisting language="python">help(compile_jmu)
</programlisting>
        </section>

        <section>
          <title>Solve the DAE initialization problem</title>

          <para>In the next step, we would like to specify the first operating
          point, A, by means of a constant input cooling temperature, and then
          solve the initialization problem assuming that all derivatives are
          zero.</para>

          <programlisting language="python"># Set inputs for Stationary point A
Tc_0_A = 250
init_model.set('Tc',Tc_0_A)
    
# Solve the DAE initialization system with Ipopt
init_result = init_model.initialize()

# Store stationary point A
c_0_A = init_result['c'][0]
T_0_A = init_result['T'][0]

# Print some data for stationary point A
print(' *** Stationary point A ***')
print('Tc = %f' % Tc_0_A)
print('c = %f' % c_0_A)
print('T = %f' % T_0_A)
</programlisting>

          <para>Notice how the method <literal>set</literal> is used to set
          the value of the control input. The initialization algorithm is
          invoked by calling the <literal>JMUModel</literal> method
          <literal>initialize</literal>, which returns a result object from
          which the initialization result can be accessed. The
          <literal>initialize</literal> method relies on the algorithm IPOPT
          for computing the solution of the initialization problem. The values
          of the states corresponding to point A can then be extracted from
          the result object. Look carefully at the printouts in the Python
          shell to see a printout of the stationary values. Display the help
          text for the <literal>initialize</literal> method and take a moment
          to look through it. The procedure is now repeated for operating
          point B:</para>

          <programlisting language="python"># Set inputs for Stationary point B
Tc_0_B = 280
init_model.set('Tc',Tc_0_B)
    
# Solve the DAE initialization system with Ipopt
init_result = init_model.initialize()
# Store stationary point B
c_0_B = init_result['c'][0]
T_0_B = init_result['T'][0]

# Print some data for stationary point B
print(' *** Stationary point B ***')
print('Tc = %f' % Tc_0_B)
print('c = %f' % c_0_B)
print('T = %f' % T_0_B)
</programlisting>

          <para>We have now computed two stationary points for the system
          based on constant control inputs. In the next section, these will be
          used to set up an optimal control problem.</para>
        </section>

        <section>
          <title>Solving an optimal control problem</title>

          <para>The optimal control problem we are about to solve is given
          by:</para>

          <informalequation>
            <m:math display="block" overflow="scroll">
              <m:mtable>
                <m:mtr>
                  <m:mtd columnalign="right"/>

                  <m:mtd columnalign="left">
                    <m:msub>
                      <m:mi mathvariant="normal">min</m:mi>

                      <m:mrow>
                        <m:mi>u</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:mi>t</m:mi>
                        </m:mfenced>
                      </m:mrow>
                    </m:msub>

                    <m:munderover>
                      <m:mo>∫</m:mo>

                      <m:mn>0</m:mn>

                      <m:mn>150</m:mn>
                    </m:munderover>

                    <m:msup>
                      <m:mfenced close=")" open="(" separators="">
                        <m:msup>
                          <m:mi>c</m:mi>

                          <m:mrow>
                            <m:mi>r</m:mi>

                            <m:mi>e</m:mi>

                            <m:mi>f</m:mi>
                          </m:mrow>
                        </m:msup>

                        <m:mo>-</m:mo>

                        <m:mi>c</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:mi>t</m:mi>
                        </m:mfenced>
                      </m:mfenced>

                      <m:mn>2</m:mn>
                    </m:msup>

                    <m:mo>+</m:mo>

                    <m:msup>
                      <m:mfenced close=")" open="(" separators="">
                        <m:msup>
                          <m:mi>T</m:mi>

                          <m:mrow>
                            <m:mi>r</m:mi>

                            <m:mi>e</m:mi>

                            <m:mi>f</m:mi>
                          </m:mrow>
                        </m:msup>

                        <m:mo>-</m:mo>

                        <m:mi>T</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:mi>t</m:mi>
                        </m:mfenced>
                      </m:mfenced>

                      <m:mn>2</m:mn>
                    </m:msup>

                    <m:mo>+</m:mo>

                    <m:msup>
                      <m:mfenced close=")" open="(" separators="">
                        <m:msubsup>
                          <m:mi>T</m:mi>

                          <m:mi>c</m:mi>

                          <m:mrow>
                            <m:mi>r</m:mi>

                            <m:mi>e</m:mi>

                            <m:mi>f</m:mi>
                          </m:mrow>
                        </m:msubsup>

                        <m:mo>-</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>c</m:mi>
                        </m:msub>

                        <m:mfenced>
                          <m:mi>t</m:mi>
                        </m:mfenced>
                      </m:mfenced>

                      <m:mn>2</m:mn>
                    </m:msup>

                    <m:mrow>
                      <m:mi>d</m:mi>

                      <m:mi>t</m:mi>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>

                <m:mtr>
                  <m:mtd columnalign="right"/>

                  <m:mtd columnalign="left">
                    <m:mstyle mathvariant="normal">
                      <m:mi>subject</m:mi>

                      <m:mo> </m:mo>

                      <m:mo> </m:mo>

                      <m:mi>to</m:mi>
                    </m:mstyle>
                  </m:mtd>
                </m:mtr>

                <m:mtr>
                  <m:mtd columnalign="right"/>

                  <m:mtd columnalign="left">
                    <m:mn>230</m:mn>

                    <m:mo>≤</m:mo>

                    <m:mi>u</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi>t</m:mi>
                    </m:mfenced>

                    <m:mo>≤</m:mo>

                    <m:mn>370</m:mn>
                  </m:mtd>
                </m:mtr>

                <m:mtr>
                  <m:mtd columnalign="right"/>

                  <m:mtd columnalign="left">
                    <m:mi>T</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi>t</m:mi>
                    </m:mfenced>

                    <m:mo>≤</m:mo>

                    <m:mn>350</m:mn>
                  </m:mtd>
                </m:mtr>
              </m:mtable>

              <m:mspace linebreak="newline"/>
            </m:math>
          </informalequation>

          <para>and is expressed in Optimica format in the class
          <literal>CSTR.CSTR_Opt</literal> in the
          <filename>CSTR.mop</filename> file above. Have a look at this class
          and make sure that you understand how the optimization problem is
          formulated and what the objective is.</para>

          <para>Direct collocation methods often require good initial guesses
          in order to ensure robust convergence. Since initial guesses are
          needed for all discretized variables along the optimization
          interval, simulation provides a convenient mean to generate state
          and derivative profiles given an initial guess for the control
          input(s). It is then convenient to set up a dedicated model for
          computation of initial trajectories. In the model
          <literal>CSTR.CSTR_Init_Optimization</literal> in the
          <filename>CSTR.mop</filename> file, a step input is applied to the
          system in order obtain an initial guess. Notice that the variable
          names in the initialization model must match those in the optimal
          control model. Therefore, also the cost function is included in the
          initialization model.</para>

          <para>First, compile the model and set model parameters:</para>

          <programlisting language="python"># Compile the optimization initialization model
jmu_name = compile_jmu("CSTR.CSTR_Init_Optimization","CSTR.mop")

# Load the model
init_sim_model = JMUModel(jmu_name)

# Set model parameters
init_sim_model.set('cstr.c_init',c_0_A)
init_sim_model.set('cstr.T_init',T_0_A)
init_sim_model.set('c_ref',c_0_B)
init_sim_model.set('T_ref',T_0_B)
init_sim_model.set('Tc_ref',Tc_0_B)
</programlisting>

          <para>Having initialized the model parameters, we can simulate the
          model using the <literal>simulate</literal> function.</para>

          <programlisting language="python">res = init_sim_model.simulate(start_time=0.,final_time=150.)
</programlisting>

          <para>The method <literal>simulate</literal> first computes
          consistent initial conditions and then simulates the model in the
          interval 0 to 150 seconds. Take a moment to read the interactive
          help for the <literal>simulate</literal> method.</para>

          <para>The simulation result object is returned and to retrieve the
          simulation data use Python dictionary access to retrieve the
          variable trajectories.</para>

          <programlisting language="python"># Extract variable profiles
c_init_sim=res['cstr.c']
T_init_sim=res['cstr.T']
Tc_init_sim=res['cstr.Tc']
t_init_sim = res['time']

# Plot the results
plt.figure(1)
plt.clf()
plt.hold(True)
plt.subplot(311)
plt.plot(t_init_sim,c_init_sim)
plt.grid()
plt.ylabel('Concentration')

plt.subplot(312)
plt.plot(t_init_sim,T_init_sim)
plt.grid()
plt.ylabel('Temperature')

plt.subplot(313)
plt.plot(t_init_sim,Tc_init_sim)
plt.grid()
plt.ylabel('Cooling temperature')
plt.xlabel('time')
plt.show()
</programlisting>

          <para>Look at the plots and try to relate the trajectories to the
          optimal control problem. Why is this a good initial guess?</para>

          <para>Once the initial guess is generated, we compile the model
          containing the optimal control problem:</para>

          <programlisting language="python"># Compile model
jmu_name = compile_jmu("CSTR.CSTR_Opt", "CSTR.mop")

# Load model
cstr = JMUModel(jmu_name)
</programlisting>

          <para>We will now initialize the parameters of the model so that
          their values correspond to the optimization objective of
          transferring the system state from operating point A to operating
          point B. Accordingly, we set the parameters representing the initial
          values of the states to point A and the reference values in the cost
          function to point B:</para>

          <programlisting language="python"># Set reference values
cstr.set('Tc_ref',Tc_0_B)
cstr.set('c_ref',c_0_B)
cstr.set('T_ref',T_0_B)

# Set initial values
cstr.set('cstr.c_init',c_0_A)
cstr.set('cstr.T_init',T_0_A)
</programlisting>

          <para>Collocation-based optimization algorithms often require a good
          initial guess in order to achieve fast convergence. Also, if the
          problem is non-convex, initialization is even more critical. Initial
          guesses can be provided in Optimica by the
          <literal>initialGuess</literal> attribute, see the
          <filename>CSTR.mop</filename> file for an example for this. Notice
          that initialization in the case of collocation-based optimization
          methods means initialization of all the control and state profiles
          as a function of time. In some cases, it is sufficient to use
          constant profiles. For this purpose, the
          <literal>initialGuess</literal> attribute works well. In more
          difficult cases, however, it may be necessary to initialize the
          profiles using simulation data, where an initial guess for the
          input(s) has been used to generate the profiles for the dependent
          variables. This approach for initializing the optimization problem
          is used in this tutorial.</para>

          <para>We are now ready to solve the actual optimization problem.
          This is done by invoking the method optimize:</para>

          <programlisting language="python">n_e = 100 # Number of elements 

# Set options
opt_opts = cstr.optimize_options()
opt_opts['n_e'] = n_e
opt_opts['init_traj'] = res.result_data

res = cstr.optimize(options=opt_opts)
</programlisting>

          <para>In this case, we would like to increase the number of finite
          elements in the mesh from 50 to 100. This is done by setting the
          corresponding option and provide it as an argument to the
          <literal>optimize</literal> method. You should see the output of
          Ipopt in the Python shell as the algorithm iterates to find the
          optimal solution. Ipopt should terminate with a message like
          'Optimal solution found' or 'Solved to an acceptable level' in order
          for an optimum to be found. The optimization result object is
          returned and the optimization data are stored in
          <literal>res</literal>.</para>

          <para>We can now retrieve the trajectories of the variables that we
          intend to plot:</para>

          <programlisting language="python"># Extract variable profiles
c_res=res['cstr.c']
T_res=res['cstr.T']
Tc_res=res['cstr.Tc']
time_res = res['time']

c_ref=res['c_ref']
T_ref=res['T_ref']
Tc_ref=res['Tc_ref']
</programlisting>

          <para>Finally, we plot the result using the functions available in
          matplotlib:</para>

          <programlisting language="python"># Plot the result
plt.figure(2)
plt.clf()
plt.hold(True)
plt.subplot(311)
plt.plot(time_res,c_res)
plt.plot([time_res[0],time_res[-1]],[c_ref,c_ref],'--')
plt.grid()
plt.ylabel('Concentration')

plt.subplot(312)
plt.plot(time_res,T_res)
plt.plot([time_res[0],time_res[-1]],[T_ref,T_ref],'--')
plt.grid()
plt.ylabel('Temperature')

plt.subplot(313)
plt.plot(time_res,Tc_res)
plt.plot([time_res[0],time_res[-1]],[Tc_ref,Tc_ref],'--')
plt.grid()
plt.ylabel('Cooling temperature')
plt.xlabel('time')
plt.show()
</programlisting>

          <para>Notice that parameters are returned as scalar values whereas
          variables are returned as vectors and that this must be taken into
          account when plotting. You should now see the plot shown in <xref
          linkend="opt-fig-cstr-opt1"/>.</para>

          <figure xml:id="opt-fig-cstr-opt1">
            <title>Optimal profiles for the CSTR problem.</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="images/cstr.svg" scalefit="1" width="60%"/>
              </imageobject>
            </mediaobject>
          </figure>

          <para>Take a minute to analyze the optimal profiles and to answer
          the following questions:</para>

          <orderedlist>
            <listitem>
              <para>Why is the concentration high in the beginning of the
              interval?</para>
            </listitem>

            <listitem>
              <para>Why is the input cooling temperature high in the beginning
              of the interval?</para>
            </listitem>
          </orderedlist>
        </section>

        <section>
          <title>Verify optimal control solution</title>

          <para>Solving optimal control problems by means of direct
          collocation implies that the differential equation is approximated
          by a discrete time counterpart. The accuracy of the solution is
          dependent on the method of collocation and the number of elements.
          In order to assess the accuracy of the discretization, we may
          simulate the system using a DAE solver using the optimal control
          profile as input. With this approach, the state profiles are
          computed with high accuracy and the result may then be compared with
          the profiles resulting from optimization. Notice that this procedure
          does not verify the optimality of the resulting optimal control
          profiles, but only the accuracy of the discretization of the
          dynamics.</para>

          <para>The procedure for setting up and executing this simulation is
          similar to above:</para>

          <programlisting language="python"># Simulate to verify the optimal solution
# Set up the input trajectory
t = time_res 
u = Tc_res
u_traj = N.transpose(N.vstack((t,u)))

# Compile the Modelica model to a JMU
jmu_name = compile_jmu("CSTR.CSTR", "CSTR.mop")

# Load model
sim_model = JMUModel(jmu_name)

sim_model.set('c_init',c_0_A)
sim_model.set('T_init',T_0_A)
sim_model.set('Tc',u[0])

res = sim_model.simulate(start_time=0.,final_time=150.,
    input=('Tc',u_traj))
</programlisting>

          <para>Finally, we load the simulated data and plot it to compare
          with the optimized trajectories:</para>

          <programlisting language="python"># Extract variable profiles
c_sim=res['c']
T_sim=res['T']
Tc_sim=res['Tc']
time_sim = res['time']

# Plot the results
plt.figure(3)
plt.clf()
plt.hold(True)
plt.subplot(311)
plt.plot(time_res,c_res,'--')
plt.plot(time_sim,c_sim)
plt.legend(('optimized','simulated'))
plt.grid()
plt.ylabel('Concentration')

plt.subplot(312)
plt.plot(time_res,T_res,'--')
plt.plot(time_sim,T_sim)
plt.legend(('optimized','simulated'))
plt.grid()
plt.ylabel('Temperature')

plt.subplot(313)
plt.plot(time_res,Tc_res,'--')
plt.plot(time_sim,Tc_sim)
plt.legend(('optimized','simulated'))
plt.grid()
plt.ylabel('Cooling temperature')
plt.xlabel('time')
plt.show()
</programlisting>

          <para>You should now see the plot shown in <xref
          linkend="opt-fig-cstr-opt2"/>.</para>

          <figure xml:id="opt-fig-cstr-opt2">
            <title>Optimal control profiles and simulated trajectories
            corresponding to the optimal control input.</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="images/cstr_opt_cmp.svg" scalefit="1"
                           width="60%"/>
              </imageobject>
            </mediaobject>
          </figure>

          <para>Discuss why the simulated trajectories differs from the
          optimized counterparts.</para>
        </section>

        <section>
          <title>Exercises</title>

          <para>After completing the tutorial you may continue to modify the
          optimization problem and study the results.</para>

          <orderedlist>
            <listitem>
              <para>Remove the constraint on cstr.T. What is then the maximum
              temperature?</para>
            </listitem>

            <listitem>
              <para>Play around with weights in the cost function. What
              happens if you penalize the control variable with a larger
              weight? Do a parameter sweep for the control variable weight and
              plot the optimal profiles in the same figure.</para>
            </listitem>

            <listitem>
              <para>Add terminal constraints
              ('cstr.T(finalTime)=someParameter') for the states so that they
              are equal to point B at the end of the optimization interval.
              Now reduce the length of the optimization interval. How short
              can you make the interval?</para>
            </listitem>

            <listitem>
              <para>Try varying the number of elements in the mesh and the
              number of collocation points in each interval. 2-10 collocation
              points are supported.</para>
            </listitem>
          </orderedlist>
        </section>

        <section>
          <title>References</title>

          <para>[1] G.A. Hicks and W.H. Ray. Approximation Methods for Optimal
          Control Synthesis. <emphasis>Can. J. Chem. Eng</emphasis>.,
          40:522–529, 1971.</para>

          <para>[2] Bieger, L., A. Cervantes, and A. Wächter (2002): "Advances
          in simultaneous strategies for dynamic optimization."
          <emphasis>Chemical Engineering Science</emphasis>, <emphasis
          role="bold">57</emphasis>, pp. 575-593.</para>
        </section>
      </section>

      <section>
        <title>Minimum time problems</title>

        <para>Minimum time problems are dynamic optimization problems where
        not only the control inputs are optimized, but also the final time.
        Typically, elements of such problems include initial and terminal
        state constraints and an objective function where the transition time
        is minimized. The following example will be used to illustrate how
        minimum time problems are formulated in Optimica. We consider the
        optimization problem:</para>

        <informalequation>
          <m:math display="block" overflow="scroll">
            <m:munder>
              <m:mi>min</m:mi>

              <m:mrow>
                <m:mi>u</m:mi>

                <m:mo>⁡</m:mo>

                <m:mfenced>
                  <m:mi>t</m:mi>
                </m:mfenced>
              </m:mrow>
            </m:munder>

            <m:msub>
              <m:mi>t</m:mi>

              <m:mi>f</m:mi>
            </m:msub>

            <m:mspace linebreak="newline"/>
          </m:math>
        </informalequation>

        <para>subject to the Van der Pol dynamics:</para>

        <informalequation>
          <m:math display="block" overflow="scroll">
            <m:mtable>
              <m:mtr>
                <m:mtd columnalign="right">
                  <m:msub>
                    <m:mover>
                      <m:mi>x</m:mi>

                      <m:mo>.</m:mo>
                    </m:mover>

                    <m:mn>1</m:mn>
                  </m:msub>
                </m:mtd>

                <m:mtd columnalign="left">
                  <m:mo>=</m:mo>

                  <m:mfenced separators="">
                    <m:mn>1</m:mn>

                    <m:mo>-</m:mo>

                    <m:msubsup>
                      <m:mi>x</m:mi>

                      <m:mn>2</m:mn>

                      <m:mn>2</m:mn>
                    </m:msubsup>
                  </m:mfenced>

                  <m:msub>
                    <m:mi>x</m:mi>

                    <m:mn>1</m:mn>
                  </m:msub>

                  <m:mo>-</m:mo>

                  <m:msub>
                    <m:mi>x</m:mi>

                    <m:mn>2</m:mn>
                  </m:msub>

                  <m:mo>+</m:mo>

                  <m:mi>u</m:mi>

                  <m:mi>,</m:mi>

                  <m:mspace width="1em"/>

                  <m:msub>
                    <m:mi>x</m:mi>

                    <m:mn>1</m:mn>
                  </m:msub>

                  <m:mfenced>
                    <m:mn>0</m:mn>
                  </m:mfenced>

                  <m:mo>=</m:mo>

                  <m:mn>0</m:mn>
                </m:mtd>
              </m:mtr>

              <m:mtr>
                <m:mtd columnalign="right">
                  <m:msub>
                    <m:mover>
                      <m:mi>x</m:mi>

                      <m:mo>.</m:mo>
                    </m:mover>

                    <m:mn>2</m:mn>
                  </m:msub>
                </m:mtd>

                <m:mtd columnalign="left">
                  <m:mo>=</m:mo>

                  <m:msub>
                    <m:mi>x</m:mi>

                    <m:mn>1</m:mn>
                  </m:msub>

                  <m:mi>,</m:mi>

                  <m:mspace width="1em"/>

                  <m:msub>
                    <m:mi>x</m:mi>

                    <m:mn>2</m:mn>
                  </m:msub>

                  <m:mfenced>
                    <m:mn>0</m:mn>
                  </m:mfenced>

                  <m:mo>=</m:mo>

                  <m:mn>1</m:mn>
                </m:mtd>
              </m:mtr>
            </m:mtable>

            <m:mspace linebreak="newline"/>
          </m:math>
        </informalequation>

        <para>and the constraints:</para>

        <informalequation>
          <m:math display="block" overflow="scroll">
            <m:mtable>
              <m:mtr>
                <m:mtd columnalign="right">
                  <m:msub>
                    <m:mi>x</m:mi>

                    <m:mn>1</m:mn>
                  </m:msub>

                  <m:mo>⁡</m:mo>

                  <m:mfenced>
                    <m:msub>
                      <m:mi>t</m:mi>

                      <m:mi>f</m:mi>
                    </m:msub>
                  </m:mfenced>
                </m:mtd>

                <m:mtd columnalign="left">
                  <m:mo>=</m:mo>

                  <m:mn>0</m:mn>

                  <m:mi>,</m:mi>

                  <m:mspace width="1em"/>

                  <m:msub>
                    <m:mi>x</m:mi>

                    <m:mn>2</m:mn>
                  </m:msub>

                  <m:mo>⁡</m:mo>

                  <m:mfenced>
                    <m:msub>
                      <m:mi>t</m:mi>

                      <m:mi>f</m:mi>
                    </m:msub>
                  </m:mfenced>

                  <m:mo>=</m:mo>

                  <m:mn>0</m:mn>
                </m:mtd>
              </m:mtr>
            </m:mtable>

            <m:mspace linebreak="newline"/>
          </m:math>
        </informalequation>

        <informalequation>
          <m:math display="block">
            <m:mi>-1 ≤ u(t) ≤ 1</m:mi>
          </m:math>
        </informalequation>

        <para>This problem is encoded in the following Optimica
        specification:</para>

        <programlisting language="optimica">optimization VDP_Opt_Min_Time (objective = finalTime,
                               startTime = 0,
                               finalTime(free=true,min=0.2,initialGuess=1)) 

  // The states
  Real x1(start = 0,fixed=true);
  Real x2(start = 1,fixed=true);

  // The control signal
  input Real u(free=true,min=-1,max=1);

equation
  // Dynamic equations
  der(x1) = (1 - x2^2) * x1 - x2 + u;
  der(x2) = x1;

constraint
  // terminal constraints
  x1(finalTime)=0;
  x2(finalTime)=0;
end VDP_Opt_Min_Time;
</programlisting>

        <para>Notice how the class attribute <literal>finalTime</literal> is
        set to be free in the optimization. The problem is solved by the
        following Python script:</para>

        <programlisting language="python"># Import numerical libraries
import numpy as N
import matplotlib.pyplot as plt

# Import the JModelica.org Python packages
from pymodelica import compile_jmu
from pyjmi import JMUModel

model_name = 'VDP_pack.VDP_Opt_Min_Time'

jmu_name = compile_jmu('VDP_Opt_Min_Time', 'VDP_Opt_Min_Time.mop')
vdp = JMUModel(jmu_name)
res = vdp.optimize()

# Extract variable profiles
x1=res['x1']
x2=res['x2']
u=res['u']
tf=res['finalTime']
t=res['time']

# Plot
plt.figure(1)
plt.clf()
plt.subplot(311)
plt.plot(t,x1)
plt.grid()
plt.ylabel('x1')

plt.subplot(312)
plt.plot(t,x2)
plt.grid()
plt.ylabel('x2')

plt.subplot(313)
plt.plot(t,u)
plt.grid()
plt.ylabel('u')
plt.xlabel('time')
plt.show()
</programlisting>

        <para>The resulting control and state profiles are shown in <xref
        linkend="opt-fig-vdp-min-time"/>. Notice the difference as compared to
        Figure <xref linkend="fig-vdp-opt"/>, where the Van der Pol oscillator
        system is optimized using a quadratic objective function.</para>

        <figure xml:id="opt-fig-vdp-min-time">
          <title>Minimum time profiles for the Van der Pol Oscillator.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/vdp_min_time.svg" scalefit="1"
                         width="60%"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>Parameter optimization</title>

        <para>In this tutorial it will be demonstrated how to solve parameter
        estimation problems. We consider a quadruple tank system depicted in
        <xref linkend="opt-fig-quadtank"/>.</para>

        <figure xml:id="opt-fig-quadtank">
          <title>A schematic picture of the quadruple tank process.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/qt_schematic.png" scalefit="1"
                         width="40%"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The dynamics of the system are given by the differential
        equations:</para>

        <informalequation>
          <m:math display="block" overflow="scroll">
            <m:mtable>
              <m:mtr>
                <m:mtd columnalign="right">
                  <m:msub>
                    <m:mover>
                      <m:mi>x</m:mi>

                      <m:mo>.</m:mo>
                    </m:mover>

                    <m:mn>1</m:mn>
                  </m:msub>
                </m:mtd>

                <m:mtd columnalign="left">
                  <m:mo>=</m:mo>

                  <m:mo>-</m:mo>

                  <m:mfrac>
                    <m:msub>
                      <m:mi>a</m:mi>

                      <m:mn>1</m:mn>
                    </m:msub>

                    <m:msub>
                      <m:mi>A</m:mi>

                      <m:mn>2</m:mn>
                    </m:msub>
                  </m:mfrac>

                  <m:msqrt>
                    <m:mrow>
                      <m:mn>2</m:mn>

                      <m:mi>g</m:mi>
                    </m:mrow>

                    <m:msub>
                      <m:mi>x</m:mi>

                      <m:mn>1</m:mn>
                    </m:msub>
                  </m:msqrt>

                  <m:mo>+</m:mo>

                  <m:mfrac>
                    <m:msub>
                      <m:mi>a</m:mi>

                      <m:mn>3</m:mn>
                    </m:msub>

                    <m:msub>
                      <m:mi>A</m:mi>

                      <m:mn>1</m:mn>
                    </m:msub>
                  </m:mfrac>

                  <m:msqrt>
                    <m:mrow>
                      <m:mn>2</m:mn>

                      <m:mi>g</m:mi>
                    </m:mrow>

                    <m:msub>
                      <m:mi>x</m:mi>

                      <m:mn>3</m:mn>
                    </m:msub>
                  </m:msqrt>

                  <m:mo>+</m:mo>

                  <m:mfrac>
                    <m:mrow>
                      <m:msub>
                        <m:mi>γ</m:mi>

                        <m:mn>1</m:mn>
                      </m:msub>

                      <m:msub>
                        <m:mi>k</m:mi>

                        <m:mn>1</m:mn>
                      </m:msub>
                    </m:mrow>

                    <m:msub>
                      <m:mi>A</m:mi>

                      <m:mn>1</m:mn>
                    </m:msub>
                  </m:mfrac>

                  <m:msub>
                    <m:mi>u</m:mi>

                    <m:mn>1</m:mn>
                  </m:msub>
                </m:mtd>
              </m:mtr>

              <m:mtr>
                <m:mtd columnalign="right">
                  <m:msub>
                    <m:mover>
                      <m:mi>x</m:mi>

                      <m:mo>.</m:mo>
                    </m:mover>

                    <m:mn>2</m:mn>
                  </m:msub>
                </m:mtd>

                <m:mtd columnalign="left">
                  <m:mo>=</m:mo>

                  <m:mo>-</m:mo>

                  <m:mfrac>
                    <m:msub>
                      <m:mi>a</m:mi>

                      <m:mn>2</m:mn>
                    </m:msub>

                    <m:msub>
                      <m:mi>A</m:mi>

                      <m:mn>2</m:mn>
                    </m:msub>
                  </m:mfrac>

                  <m:msqrt>
                    <m:mrow>
                      <m:mn>2</m:mn>

                      <m:mi>g</m:mi>
                    </m:mrow>

                    <m:msub>
                      <m:mi>x</m:mi>

                      <m:mn>2</m:mn>
                    </m:msub>
                  </m:msqrt>

                  <m:mo>+</m:mo>

                  <m:mfrac>
                    <m:msub>
                      <m:mi>a</m:mi>

                      <m:mn>4</m:mn>
                    </m:msub>

                    <m:msub>
                      <m:mi>A</m:mi>

                      <m:mn>2</m:mn>
                    </m:msub>
                  </m:mfrac>

                  <m:msqrt>
                    <m:mrow>
                      <m:mn>2</m:mn>

                      <m:mi>g</m:mi>
                    </m:mrow>

                    <m:msub>
                      <m:mi>x</m:mi>

                      <m:mn>4</m:mn>
                    </m:msub>
                  </m:msqrt>

                  <m:mo>+</m:mo>

                  <m:mfrac>
                    <m:mrow>
                      <m:msub>
                        <m:mi>γ</m:mi>

                        <m:mn>2</m:mn>
                      </m:msub>

                      <m:msub>
                        <m:mi>k</m:mi>

                        <m:mn>2</m:mn>
                      </m:msub>
                    </m:mrow>

                    <m:msub>
                      <m:mi>A</m:mi>

                      <m:mn>2</m:mn>
                    </m:msub>
                  </m:mfrac>

                  <m:msub>
                    <m:mi>u</m:mi>

                    <m:mn>2</m:mn>
                  </m:msub>
                </m:mtd>
              </m:mtr>

              <m:mtr>
                <m:mtd columnalign="right">
                  <m:msub>
                    <m:mover>
                      <m:mi>x</m:mi>

                      <m:mo>.</m:mo>
                    </m:mover>

                    <m:mn>3</m:mn>
                  </m:msub>
                </m:mtd>

                <m:mtd columnalign="left">
                  <m:mo>=</m:mo>

                  <m:mo>-</m:mo>

                  <m:mfrac>
                    <m:msub>
                      <m:mi>a</m:mi>

                      <m:mn>3</m:mn>
                    </m:msub>

                    <m:msub>
                      <m:mi>A</m:mi>

                      <m:mn>3</m:mn>
                    </m:msub>
                  </m:mfrac>

                  <m:msqrt>
                    <m:mrow>
                      <m:mn>2</m:mn>

                      <m:mi>g</m:mi>
                    </m:mrow>

                    <m:msub>
                      <m:mi>x</m:mi>

                      <m:mn>3</m:mn>
                    </m:msub>
                  </m:msqrt>

                  <m:mo>+</m:mo>

                  <m:mfrac>
                    <m:mrow>
                      <m:mfenced separators="">
                        <m:mn>1</m:mn>

                        <m:mo>-</m:mo>

                        <m:msub>
                          <m:mi>γ</m:mi>

                          <m:mn>2</m:mn>
                        </m:msub>
                      </m:mfenced>

                      <m:msub>
                        <m:mi>k</m:mi>

                        <m:mn>2</m:mn>
                      </m:msub>
                    </m:mrow>

                    <m:msub>
                      <m:mi>A</m:mi>

                      <m:mn>3</m:mn>
                    </m:msub>
                  </m:mfrac>

                  <m:msub>
                    <m:mi>u</m:mi>

                    <m:mn>2</m:mn>
                  </m:msub>
                </m:mtd>
              </m:mtr>

              <m:mtr>
                <m:mtd columnalign="right">
                  <m:msub>
                    <m:mover>
                      <m:mi>x</m:mi>

                      <m:mo>.</m:mo>
                    </m:mover>

                    <m:mn>4</m:mn>
                  </m:msub>
                </m:mtd>

                <m:mtd columnalign="left">
                  <m:mo>=</m:mo>

                  <m:mo>-</m:mo>

                  <m:mfrac>
                    <m:msub>
                      <m:mi>a</m:mi>

                      <m:mn>4</m:mn>
                    </m:msub>

                    <m:msub>
                      <m:mi>A</m:mi>

                      <m:mn>4</m:mn>
                    </m:msub>
                  </m:mfrac>

                  <m:msqrt>
                    <m:mrow>
                      <m:mn>2</m:mn>

                      <m:mi>g</m:mi>
                    </m:mrow>

                    <m:msub>
                      <m:mi>x</m:mi>

                      <m:mn>4</m:mn>
                    </m:msub>
                  </m:msqrt>

                  <m:mo>+</m:mo>

                  <m:mfrac>
                    <m:mrow>
                      <m:mfenced separators="">
                        <m:mn>1</m:mn>

                        <m:mo>-</m:mo>

                        <m:msub>
                          <m:mi>γ</m:mi>

                          <m:mn>1</m:mn>
                        </m:msub>
                      </m:mfenced>

                      <m:msub>
                        <m:mi>k</m:mi>

                        <m:mn>1</m:mn>
                      </m:msub>
                    </m:mrow>

                    <m:msub>
                      <m:mi>A</m:mi>

                      <m:mn>4</m:mn>
                    </m:msub>
                  </m:mfrac>

                  <m:msub>
                    <m:mi>u</m:mi>

                    <m:mn>1</m:mn>
                  </m:msub>
                </m:mtd>
              </m:mtr>
            </m:mtable>

            <m:mspace linebreak="newline"/>
          </m:math>
        </informalequation>

        <para>Where the parameter values are given in <xref
        linkend="opt-tab-qtpars"/>.</para>

        <table xml:id="opt-tab-qtpars">
          <title>Parameters for the quadruple tank process.</title>

          <tgroup cols="3">
            <colspec align="left" colname="col–opt" colwidth="1*"/>

            <colspec align="left" colname="col–desc" colwidth="2*"/>

            <colspec align="left" colname="col–def" colwidth="1*"/>

            <thead>
              <row>
                <entry align="center">Parameter name</entry>

                <entry align="center">Value</entry>

                <entry align="center">Unit</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>A<subscript>i</subscript></entry>

                <entry>4.9</entry>

                <entry>cm<superscript>2</superscript></entry>
              </row>

              <row>
                <entry><literal>a<subscript>i</subscript></literal></entry>

                <entry>0.03</entry>

                <entry>cm<superscript>2</superscript></entry>
              </row>

              <row>
                <entry><literal>k<subscript>i</subscript></literal></entry>

                <entry>0.56</entry>

                <entry>cm<superscript>2</superscript>V<superscript>-1</superscript>s<superscript>-1</superscript></entry>
              </row>

              <row>
                <entry><literal>γ<subscript>i</subscript></literal></entry>

                <entry>0.3</entry>

                <entry>Vcm<superscript>-1</superscript></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>The states of the model are the tank water levels x1, x2, x3,
        and x4. The control inputs, u1 and u2, are the flows generated by the
        two pumps.</para>

        <para>The Modelica model for the system is located in <link
        xlink:href="https://svn.jmodelica.org/trunk/Python/src/pyjmi/examples/files/QuadTankPack.mop">QuadTankPack.mop</link>.
        Download the file to your working directory and open it in a text
        editor. Locate the class <literal>QuadTankPack.QuadTank</literal> and
        make sure you understand the model. In particular, notice that all
        model variables and parameters are expressed in SI units.</para>

        <para>Measurement data, available in <link
        xlink:href="https://svn.jmodelica.org/trunk/Python/src/pyjmi/examples/files/qt_par_est_data.mat">qt_par_est_data.mat</link>,
        has been logged in an identification experiment. Download also this
        file to your working directory.</para>

        <para>Open a text file and name it <filename>qt_par_est.py</filename>.
        Then enter the imports:</para>

        <programlisting language="python">from scipy.io.matlab.mio import loadmat
import matplotlib.pyplot as plt
import numpy as N

from pymodelica import compile_jmu
from pyjmi import JMUModel
</programlisting>

        <para>into the file. Next, we enter code to open the data file,
        extract the measurement time series and plot the measurements:</para>

        <programlisting language="python"># Load measurement data from file
data = loadmat('qt_par_est_data.mat',appendmat=False)

# Extract data series
t_meas = data['t'][6000::100,0]-60
y1_meas = data['y1_f'][6000::100,0]/100
y2_meas = data['y2_f'][6000::100,0]/100
y3_meas = data['y3_d'][6000::100,0]/100
y4_meas = data['y4_d'][6000::100,0]/100
u1 = data['u1_d'][6000::100,0]
u2 = data['u2_d'][6000::100,0]    

# Plot measurements and inputs
plt.figure(1)
plt.clf()
plt.subplot(2,2,1)
plt.plot(t_meas,y3_meas)
plt.title('x3')
plt.grid()
plt.subplot(2,2,2)
plt.plot(t_meas,y4_meas)
plt.title('x4')
plt.grid()
plt.subplot(2,2,3)
plt.plot(t_meas,y1_meas)
plt.title('x1')
plt.xlabel('t[s]')
plt.grid()
plt.subplot(2,2,4)
plt.plot(t_meas,y2_meas)
plt.title('x2')
plt.xlabel('t[s]')
plt.grid()
plt.show()

plt.figure(2)
plt.clf()
plt.subplot(2,1,1)
plt.plot(t_meas,u1)
plt.hold(True)
plt.title('u1')
plt.grid()
plt.subplot(2,1,2)
plt.plot(t_meas,u2)
plt.title('u2')
plt.xlabel('t[s]')
plt.hold(True)
plt.grid()
plt.show()
</programlisting>

        <para>You should now see two plots showing the measurement state
        profiles and the control input profiles similar to <xref
        linkend="opt-fig-qt_data"/> and <xref
        linkend="opt-fig-qtinput"/>.</para>

        <figure xml:id="opt-fig-qt_data">
          <title>Measured state profiles.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/qt_x.svg" scalefit="1" width="60%"/>
            </imageobject>
          </mediaobject>
        </figure>

        <figure xml:id="opt-fig-qtinput">
          <title>Control inputs used in the identification experiment.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/qt_u.svg" scalefit="1" width="60%"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>In order to evaluate the accuracy of nominal model parameter
        values, start by simulating the model, assuming that the start values
        of the states are given by the state measurement at the start of the
        experiment. This assumption can be expressed in the model:</para>

        <programlisting language="modelica">model Sim_QuadTank
  QuadTank qt;
  input Real u1 = qt.u1;
  input Real u2 = qt.u2;
initial equation
  qt.x1 = 0.0627;
  qt.x2 = 0.06044;
  qt.x3 = 0.024;
  qt.x4 = 0.023;
end Sim_QuadTank;
</programlisting>

        <para>Notice that initial equations have been added to the model.
        Before the model is simulated, a matrix containing the input
        trajectories is created:</para>

        <programlisting language="python"># Build input trajectory matrix for use in simulation
u = N.transpose(N.vstack((t_meas,u1,u2)))
</programlisting>

        <para>Now, the model can be simulated:</para>

        <programlisting language="python"># compile JMU
jmu_name = compile_jmu('QuadTankPack.Sim_QuadTank','QuadTankPack.mop')

# Load model
model = JMUModel(jmu_name)

# Simulate model response with nominal parameters
res = model.simulate(input=(['u1','u2'],u),start_time=0.,final_time=60)
</programlisting>

        <para>The simulation result can now be extracted:</para>

        <programlisting language="python"># Load simulation result
x1_sim = res['qt.x1']
x2_sim = res['qt.x2']
x3_sim = res['qt.x3']
x4_sim = res['qt.x4']
t_sim  = res['time']
u1_sim = res['u1']
u2_sim = res['u2']
</programlisting>

        <para>and then plotted:</para>

        <programlisting language="python"># Plot simulation result
plt.figure(1)
plt.subplot(2,2,1)
plt.plot(t_sim,x3_sim)
plt.subplot(2,2,2)
plt.plot(t_sim,x4_sim)
plt.subplot(2,2,3)
plt.plot(t_sim,x1_sim)
plt.subplot(2,2,4)
plt.plot(t_sim,x2_sim)
plt.show()

plt.figure(2)
plt.subplot(2,1,1)
plt.plot(t_sim,u1_sim,'r')
plt.subplot(2,1,2)
plt.plot(t_sim,u2_sim,'r')
plt.show()
</programlisting>

        <para><xref linkend="opt-fig-sim-nom"/> shows the result of the
        simulation.</para>

        <figure xml:id="opt-fig-sim-nom">
          <title>Simulation result for the nominal model.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/qt_sim.svg" scalefit="1" width="60%"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Here, the simulated profiles are given by the green curves.
        Clearly, there is a mismatch in the response, especially for the two
        lower tanks. Think about why the model does not match the data, i.e.,
        which parameters may have wrong values.</para>

        <para>The next step towards solving a parameter estimation problem is
        to identify which parameters to tune. Typically, parameters which are
        not known precisely are selected. Also, the selected parameters need
        of course affect the mismatch between model response and data, when
        tuned. In a first attempt, we aim at decreasing the mismatch for the
        two lower tanks, and therefore we select the lower tank outflow areas,
        a1 and a2, as parameters to optimize. The Optimica specification for
        the estimation problem contained in the class
        <literal>QuadTankPack.QuadTank_ParEst</literal>:</para>

        <programlisting language="optimica">optimization QuadTank_ParEst (objective=sum((y1_meas[i] - qt.x1(t_meas[i]))^2 + 
                                            (y2_meas[i] - qt.x2(t_meas[i]))^2 for i in 1:N_meas),
                                             startTime=0,finalTime=60)
    
    // Initial tank levels
  parameter Modelica.SIunits.Length x1_0 = 0.06255;
  parameter Modelica.SIunits.Length x2_0 = 0.06045;
  parameter Modelica.SIunits.Length x3_0 = 0.02395;
  parameter Modelica.SIunits.Length x4_0 = 0.02325;

  QuadTank qt(x1(fixed=true),x1_0=x1_0,
              x2(fixed=true),x2_0=x2_0,
              x3(fixed=true),x3_0=x3_0,
              x4(fixed=true),x4_0=x4_0,
              a1(free=true,initialGuess = 0.03e-4,min=0,max=0.1e-4),
              a2(free=true,initialGuess = 0.03e-4,min=0,max=0.1e-4));

  // Number of measurement points
  parameter Integer N_meas = 61;
  // Vector of measurement times
  parameter Real t_meas[N_meas] = 0:60.0/(N_meas-1):60;
  // Measurement values for x1 
  // Notice that dummy values are entered here:
  // the real measurement values will be set from Python
  parameter Real y1_meas[N_meas] = ones(N_meas);
  // Measurement values for x2 	
  parameter Real y2_meas[N_meas] = ones(N_meas);
  // Input trajectory for u1 
  PRBS1 prbs1;
  // Input trajectory for u2
  PRBS2 prbs2;	
equation
  connect(prbs1.y,qt.u1);
  connect(prbs2.y,qt.u2);
end QuadTank_ParEst;
</programlisting>

        <para>The cost function is here given as a squared sum of the
        difference between the measured profiles for x1 and x2 and the
        corresponding model profiles. Also the, parameters a1 and a2 are set
        to be free, and are given initial guesses as well as bounds. As for
        the measurement data, parameter vectors are declared, but only dummy
        data is provided in the model - the actual data values will be set
        from the Python script. Also, the input profiles are connected to
        signal generators that outputs the same input profiles as those used
        in the experiment. Take some time to look at
        <filename>QuadTankPack.mop</filename> and locate the classes used
        above.</para>

        <para>Before the optimization problem can be solved, the Optimica
        specification needs to be compiled:</para>

        <programlisting language="python"># Compile parameter optimization model
jmu_name = compile_jmu("QuadTankPack.QuadTank_ParEst","QuadTankPack.mop")

# Load the model
qt_par_est = JMUModel(jmu_name)
</programlisting>

        <para>Next, we load the measurement data into the model:</para>

        <programlisting language="python"># Number of measurement points
N_meas = N.size(u1,0)

# Set measurement data into model
for i in range(0,N_meas):
    qt_par_est.set("t_meas["+`i+1`+"]",t_meas[i])
    qt_par_est.set("y1_meas["+`i+1`+"]",y1_meas[i])
    qt_par_est.set("y2_meas["+`i+1`+"]",y2_meas[i])
</programlisting>

        <para>We are now ready to solve the optimization problem:</para>

        <programlisting language="python">n_e = 100 # Numer of element in collocation algorithm

# Get an options object for the optimization algorithm
opt_opts = qt_par_est.optimize_options()
# Set the number of collocation points
opt_opts['n_e'] = n_e

# Solve parameter optimization problem
res = qt_par_est.optimize(options=opt_opts)
</programlisting>

        <para>Now, lets extract the optimal values of the parameters a1 and a2
        and print them to the console:</para>

        <programlisting language="python"># Extract optimal values of parameters
a1_opt = res.final("qt.a1")
a2_opt = res.final("qt.a2")

# Print optimal parameter values
print('a1: ' + str(a1_opt*1e4) + 'cm^2')
print('a2: ' + str(a2_opt*1e4) + 'cm^2')
</programlisting>

        <para>You should get an output similar to:</para>

        <programlisting language="python">a1: 0.0266cm^2
a2: 0.0272cm^2
</programlisting>

        <para>The estimated values are slightly smaller than the nominal
        values - think about why this may be the case. Also note that the
        estimated values do not necessarily correspond to the physically true
        values. Rather, the parameter values are adjusted to compensate for
        all kinds of modeling errors in order to minimize the mismatch between
        model response and measurement data.</para>

        <para>Next we plot the optimized profiles:</para>

        <programlisting language="python"># Load state profiles
x1_opt = res["qt.x1"]
x2_opt = res["qt.x2"]
x3_opt = res["qt.x3"]
x4_opt = res["qt.x4"]
u1_opt = res["qt.u1"]
u2_opt = res["qt.u2"]
t_opt  = res["time"]

# Plot
plt.figure(1)
plt.subplot(2,2,1)
plt.plot(t_opt,x3_opt,'k')
plt.subplot(2,2,2)
plt.plot(t_opt,x4_opt,'k')
plt.subplot(2,2,3)
plt.plot(t_opt,x1_opt,'k')
plt.subplot(2,2,4)
plt.plot(t_opt,x2_opt,'k')
plt.show()
</programlisting>

        <para>You will see the plot shown in <xref
        linkend="opt-fig-par-est1"/>.</para>

        <figure xml:id="opt-fig-par-est1">
          <title>State profiles corresponding to estimated values of a1 and
          a2.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/qt_est1.svg" scalefit="1" width="60%"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The profiles corresponding to the estimated values of a1 and a2
        are shown in black curves. As can be seen, the match between the model
        response and the measurement data has been significantly increased. Is
        the behavior of the model consistent with the estimated parameter
        values?</para>

        <para>Never the less, There is still a mismatch for the upper tanks,
        especially for tank 4. In order to improve the match, a second
        estimation problem may be formulated, where the parameters a1, a2, a3,
        a4 are free optimization variables, and where the squared errors of
        all four tank levels are penalized. Take a minute to locate the class
        <literal>QuadTankPack.QuadTank_ParEst2</literal> and make sure that
        you understand the model. Solve the optimization problem by typing the
        Python code:</para>

        <programlisting language="python"># Compile second parameter estimation model
jmu_name = compile_jmu("QuadTankPack.QuadTank_ParEst2", "QuadTankPack.mop")

# Load model
qt_par_est2 = JMUModel(jmu_name)

# Number of measurement points
N_meas = N.size(u1,0)

# Set measurement data into model
for i in range(0,N_meas):
    qt_par_est2.set("t_meas["+`i+1`+"]",t_meas[i])
    qt_par_est2.set("y1_meas["+`i+1`+"]",y1_meas[i])
    qt_par_est2.set("y2_meas["+`i+1`+"]",y2_meas[i])
    qt_par_est2.set("y3_meas["+`i+1`+"]",y3_meas[i])
    qt_par_est2.set("y4_meas["+`i+1`+"]",y4_meas[i])

# Solve parameter estimation problem
res_opt2 = qt_par_est2.optimize(options=opt_opts)
</programlisting>

        <para>Next, we print the optimal parameter values:</para>

        <programlisting language="python"># Get optimal parameter values
a1_opt2 = res_opt2.final("qt.a1")
a2_opt2 = res_opt2.final("qt.a2")
a3_opt2 = res_opt2.final("qt.a3")
a4_opt2 = res_opt2.final("qt.a4")

# Print optimal parameter values 
print('a1:' + str(a1_opt2*1e4) + 'cm^2')
print('a2:' + str(a2_opt2*1e4) + 'cm^2')
print('a3:' + str(a3_opt2*1e4) + 'cm^2')
print('a4:' + str(a4_opt2*1e4) + 'cm^2')
</programlisting>

        <para>The output in the console should be similar to:</para>

        <programlisting language="python">a1:0.0266cm^2
a2:0.0271cm^2
a3:0.0301cm^2
a4:0.0293cm^2
</programlisting>

        <para>Think about the result - can you explain why the estimated value
        of a4 is slightly smaller than the nominal value? Finally, plot the
        state profiles corresponding to the estimated parameters:</para>

        <programlisting language="python"># Extract state and input profiles
x1_opt2 = res_opt2["qt.x1"]
x2_opt2 = res_opt2["qt.x2"]
x3_opt2 = res_opt2["qt.x3"]
x4_opt2 = res_opt2["qt.x4"]
u1_opt2 = res_opt2["qt.u1"]
u2_opt2 = res_opt2["qt.u2"]
t_opt2  = res_opt2["time"]

# Plot
plt.figure(1)
plt.subplot(2,2,1)
plt.plot(t_opt2,x3_opt2,'r')
plt.subplot(2,2,2)
plt.plot(t_opt2,x4_opt2,'r')
plt.subplot(2,2,3)
plt.plot(t_opt2,x1_opt2,'r')
plt.subplot(2,2,4)
plt.plot(t_opt2,x2_opt2,'r')
plt.show()
</programlisting>

        <para>The resulting plot is shown in <xref
        linkend="opt-fig-par-est2"/>.</para>

        <figure xml:id="opt-fig-par-est2">
          <title>State profiles corresponding to estimated values of a1, a2,
          a3 and a4.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/qt_est2.svg" scalefit="1" width="60%"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The red curves represent the case where a1, a2, a3 and a4 has
        been estimated.</para>

        <para>Take a moment to think about the results. Are there other
        parameters that could have been selected for estimation?</para>

        <para>Having computed the parameter values that fits the data, we
        proceed to compute the standard deviations for the parameter
        estimates. This information is valuable when judging how accurate the
        estimates are. For an introduction to statistical inference in
        parameter estimation problems, see
        <citation>Eng2001</citation>.</para>

        <para>The covariance matrix of the estimated parameter vector is given
        by the expression:</para>

        <informalequation>
          <m:math display="block" overflow="scroll">
            <m:mrow>
              <m:mi>C</m:mi>

              <m:mi>O</m:mi>

              <m:mi>V</m:mi>
            </m:mrow>

            <m:mfenced>
              <m:msup>
                <m:mi>p</m:mi>

                <m:mo>*</m:mo>
              </m:msup>
            </m:mfenced>

            <m:mo>=</m:mo>

            <m:msubsup>
              <m:mover>
                <m:mi>σ</m:mi>

                <m:mo>ˆ</m:mo>
              </m:mover>

              <m:mi>ε</m:mi>

              <m:mn>2</m:mn>
            </m:msubsup>

            <m:msup>
              <m:mfenced close=")" open="(" separators="">
                <m:msup>
                  <m:mi>J</m:mi>

                  <m:mi>T</m:mi>
                </m:msup>

                <m:mi>J</m:mi>
              </m:mfenced>

              <m:mrow>
                <m:mo>-</m:mo>

                <m:mn>1</m:mn>
              </m:mrow>
            </m:msup>

            <m:mspace linebreak="newline"/>
          </m:math>
        </informalequation>

        <para>where <emphasis>J</emphasis> is the Jacobian of the error
        residual and σ is the estimated measurement noise variance. In order
        to compute the residual Jacobian, the sensitivity equations needs to
        be computed.</para>

        <para>The model <literal>QuadTankPack.QuadTank_Sens2</literal> is used
        for the sensitivity simulation. Notice that the
        <literal>free</literal> attribute is used to mark the parameters for
        which sensitivities should be computed:</para>

        <programlisting language="modelica">optimization QuadTank_Sens2 
    
   extends QuadTank (x1(fixed=true),x1_0 = 0.0627,
                     x2(fixed=true),x2_0 = 0.06044,
                     x3(fixed=true),x3_0 = 0.024,
                     x4(fixed=true),x4_0 = 0.023,
                     a1(free=true),
                     a2(free=true),
                     a3(free=true),
                     a4(free=true));

end QuadTank_Sens2;
</programlisting>

        <para>In a first step to simulating the sensitivity equations for the
        model, we compile the model and set the optimal parameter
        values:</para>

        <programlisting language="python"># compile JMU
jmu_name = compile_jmu('QuadTankPack.QuadTank_Sens2',
                       'QuadTankPack.mop')

# Load model
model = JMUModel(jmu_name)

model.set('a1',a1_opt2)
model.set('a2',a2_opt2)
model.set('a3',a3_opt2)
model.set('a4',a4_opt2)
</programlisting>

        <para>Next, we set the <literal>IDA_option</literal>
        <literal>sensitivity</literal> to <literal>true</literal>, and
        simulate the model:</para>

        <programlisting language="python"># Get an options object
sens_opts = model.simulate_options()

# Enable sensitivity computations
sens_opts['IDA_options']['sensitivity'] = True

# Simulate sensitivity equations
sens_res = model.simulate(input=(['u1','u2'],u),start_time=0.,
                          final_time=60, options = sens_opts)
</programlisting>

        <para>Using the results of sensitivity simulation, the Jacobian and
        the residual error vector can be created:</para>

        <programlisting language="python"># Get result trajectories
x1_sens = sens_res['x1']
x2_sens = sens_res['x2']
x3_sens = sens_res['x3']
x4_sens = sens_res['x4']

dx1da1 = sens_res['dx1/da1']
dx1da2 = sens_res['dx1/da2']
dx1da3 = sens_res['dx1/da3']
dx1da4 = sens_res['dx1/da4']

dx2da1 = sens_res['dx2/da1']
dx2da2 = sens_res['dx2/da2']
dx2da3 = sens_res['dx2/da3']
dx2da4 = sens_res['dx2/da4']

dx3da1 = sens_res['dx3/da1']
dx3da2 = sens_res['dx3/da2']
dx3da3 = sens_res['dx3/da3']
dx3da4 = sens_res['dx3/da4']

dx4da1 = sens_res['dx4/da1']
dx4da2 = sens_res['dx4/da2']
dx4da3 = sens_res['dx4/da3']
dx4da4 = sens_res['dx4/da4']
t_sens = sens_res['time']


# Create a trajectory object for interpolation
traj=TrajectoryLinearInterpolation(t_sens,
    N.transpose(N.vstack((x1_sens,x2_sens,x3_sens,x4_sens,
                          dx1da1,dx1da2,dx1da3,dx1da4,
                          dx2da1,dx2da2,dx2da3,dx2da4,
                          dx3da1,dx3da2,dx3da3,dx3da4,
                          dx4da1,dx4da2,dx4da3,dx4da4))))

# Create Jacobian
jac = N.zeros((61*4,4))

# Error vector
err = N.zeros(61*4)

# Extract Jacobian and residual error information
i = 0
for t_p in t_meas:
    vals = traj.eval(t_p)
    for j in range(4):
        for k in range(4):
            jac[i+j,k] = vals[0,4*j+k+4]
        err[i] = vals[0,0] - y1_meas[i/4]
        err[i+1] = vals[0,1] - y2_meas[i/4]
        err[i+2] = vals[0,2] - y3_meas[i/4]
        err[i+3] = vals[0,3] - y4_meas[i/4]
    i = i + 4
</programlisting>

        <para>Notice the convention for how the sensitivity variables are
        named.</para>

        <para>Finally, we compute and print the standard deviations for the
        estimated parameters:</para>

        <programlisting language="python"># Compute estimated variance of measurement noice    
v_err = N.sum(err**2)/(61*4-2)

# Compute J^T*J
A = N.dot(N.transpose(jac),jac)

# Compute parameter covariance matrix
P = v_err*N.linalg.inv(A)

# Compute standard deviations for parameters
sigma_a1 = N.sqrt(P[0,0])
sigma_a2 = N.sqrt(P[1,1])
sigma_a3 = N.sqrt(P[2,2])
sigma_a4 = N.sqrt(P[3,3])

print "a1: " + str(sens_res.final('a1')) + ", standard deviation: " + str(sigma_a1)
print "a2: " + str(sens_res.final('a2')) + ", standard deviation: " + str(sigma_a2)
print "a3: " + str(sens_res.final('a3')) + ", standard deviation: " + str(sigma_a3)
print "a4: " + str(sens_res.final('a4')) + ", standard deviation: " + str(sigma_a4)
</programlisting>

        <para>You should now see the standard deviations for the estimated
        parameters printed.</para>
      </section>
    </section>
  </section>

  <section xml:id="opt-sec-dae-casadi">
    <title>Dynamic optimization of DAEs using direct collocation with
    CasADi</title>

    <section>
      <title>Algorithm overview</title>

      <para>The default algorithm described in <xref
      linkend="opt-sec-dae-jmu"/> is well tested, robust and has been used in
      several large-scale industrial projects. Due to its implementation in C,
      however, its flexibility is limited and extension requires significant
      efforts. Therefore, a new algorithm for optimal control and parameter
      estimation of DAEs based on the same collocation scheme that has proven
      successful in the default algorithm has been initiated. The new
      algorithm is based on the CasADi package for evaluation of first and
      second order derivatives, and for integration with the IPOPT and WORHP
      algorithms. The two main benefits of using CasADi, through its Python
      interface, is increased flexibility and extensibility of the
      implementation improved performance. The goal is for the CasADi-based
      algorithm to replace the C-based algorithm, once it has sufficiently
      matured.</para>

      <para>The direct collocation method can be used to solve dynamic
      optimization problems, including optimal control problems and parameter
      optimization problems. In the collocation method, the dynamic model
      variable profiles are approximated by piecewise polynomials. This method
      of approximating a differential equation corresponds to a fixed step
      implicit Runge-Kutta scheme, where the mesh defines the length of each
      step. Also, the number of collocation points in each element, or step,
      needs to be provided. This number corresponds to the stage order of the
      Runge-Kutta scheme. The selection of mesh is analogous to the choice of
      step length in a one-step algorithm for solving differential equations.
      Accordingly, the mesh needs to be fine-grained enough to ensure
      sufficiently accurate approximation of the differential constraint. For
      an overview of simultaneous optimization algorithms, see [2]. The
      nonlinear programming solvers IPOPT and WORHP can be used to solve the
      nonlinear program resulting from collocation.</para>

      <para>The collocation method requires that the model to be optimized
      does not contain discontinuities such as if equations, when clauses or
      integer variables.</para>

      <para>Optimization models are represented using the class
      <literal>OptimizationProblem</literal>. An object containing all the
      options for the optimization algorithm can be retrieved from the model
      object:</para>

      <programlisting language="python">opts = model.optimize_options()

opts? # View the help text</programlisting>

      <para>After options have been set, the options object can be propagated
      to the <literal>optimize</literal> method:</para>

      <programlisting language="python">res = model.optimize(options=opts)</programlisting>

      <para>The options for the algorithm are shown in <xref
      linkend="opt-tab-casadi-dae-opts"/>. Additional documentation is
      available in the Python class documentation.</para>

      <table xml:id="opt-tab-casadi-dae-opts">
        <title>Options for the CasADi- and collocation-based optimization
        algorithm</title>

        <tgroup cols="3">
          <colspec align="left" colname="col–opt" colwidth="1*"/>

          <colspec align="left" colname="col–desc" colwidth="1*"/>

          <colspec align="left" colname="col–def" colwidth="2*"/>

          <thead>
            <row>
              <entry align="center">Option</entry>

              <entry align="center">Default</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>n_e</literal></entry>

              <entry>50</entry>

              <entry>Number of finite elements.</entry>
            </row>

            <row>
              <entry><literal>hs</literal></entry>

              <entry>None</entry>

              <entry>Element lengths. Possible values: None, iterable of
              floats and "free" None: The element lengths are uniformly
              distributed. iterable of floats: Component i of the iterable
              specifies the length of element i. The lengths must be
              normalized in the sense that the sum of all lengths must be
              equal to 1. "free": The element lengths become optimization
              variables and are optimized according to the algorithm option
              free_element_lengths_data. WARNING: The "free" option is very
              experimental and will not always give desirable results.</entry>
            </row>

            <row>
              <entry><literal>free_element_lengths_data</literal></entry>

              <entry>None</entry>

              <entry>Data used for optimizing the element lengths if they are
              free. Should be None when hs != "free".</entry>
            </row>

            <row>
              <entry><literal>n_cp</literal></entry>

              <entry>3</entry>

              <entry>Number of collocation points in each element.</entry>
            </row>

            <row>
              <entry><literal>discr</literal></entry>

              <entry>'LGR'</entry>

              <entry>Determines the collocation scheme used to discretize the
              problem. Possible values: "LG" and "LGR". "LG": Gauss
              collocation (Legendre-Gauss) "LGR": Radau collocation
              (Legendre-Gauss-Radau).</entry>
            </row>

            <row>
              <entry><literal>expand_to_sx</literal></entry>

              <entry>"NLP"</entry>

              <entry>Whether to expand the CasADi MX graphs to SX graphs.
              Possible values: "NLP", "DAE", "no". "NLP": The entire NLP graph
              is expanded into SX. This will lead to high evaluation speed and
              high memory consumption. "DAE": The DAE, objective and
              constraint graphs for the dynamic optimization problem
              expressions are expanded into SX, but the full NLP graph is an
              MX graph. This will lead to moderate evaluation speed and
              moderate memory consumption. "no": All constructed graphs are MX
              graphs. This will lead to low evaluation speed and low memory
              consumption.</entry>
            </row>

            <row>
              <entry><literal>named_vars</literal></entry>

              <entry>False</entry>

              <entry>If enabled, the solver will create a duplicated set of
              NLP variables which have names corresponding to the
              Modelica/Optimica variable names. Symbolic expressions of the
              NLP consisting of the named variables can then be obtained using
              the get_named_var_expr method of the collocator class. This
              option is only intended for investigative purposes.</entry>
            </row>

            <row>
              <entry><literal>init_traj</literal></entry>

              <entry>None</entry>

              <entry>Variable trajectory data used for initialization of the
              NLP variables.</entry>
            </row>

            <row>
              <entry><literal>variable_scaling</literal></entry>

              <entry>True</entry>

              <entry>Whether to scale the variables according to their nominal
              values or the trajectories provided with the nominal_traj
              option.</entry>
            </row>

            <row>
              <entry><literal>nominal_traj</literal></entry>

              <entry>None</entry>

              <entry>Variable trajectory data used for scaling of the NLP
              variables. This option is only applicable if variable scaling is
              enabled.</entry>
            </row>

            <row>
              <entry><literal>nominal_traj_mode</literal></entry>

              <entry>{"_default_mode": "linear"}</entry>

              <entry>Mode for computing scaling factors based on nominal
              trajectories. Four possible modes: "attribute": Time-invariant,
              linear scaling based on Nominal attribute "linear":
              Time-invariant, linear scaling "affine": Time-invariant, affine
              scaling "time-variant": Time-variant, linear scaling Option is a
              dictionary with variable names as keys and corresponding scaling
              modes as values. For all variables not occuring in the keys of
              the dictionary, the mode specified by the "_default_mode" entry
              will be used, which by default is "linear".</entry>
            </row>

            <row>
              <entry><literal>result_file_name</literal></entry>

              <entry>""</entry>

              <entry>Specifies the name of the file where the result is
              written. Setting this option to an empty string results in a
              default file name that is based on the name of the model
              class.</entry>
            </row>

            <row>
              <entry><literal>write_scaled_result</literal></entry>

              <entry>False</entry>

              <entry>Return the scaled optimization result if set to True,
              otherwise return the unscaled optimization result. This option
              is only applicable when variable_scaling is enabled and is only
              intended for debugging.</entry>
            </row>

            <row>
              <entry><literal>print_condition_numbers</literal></entry>

              <entry>False</entry>

              <entry>Prints the condition numbers of the Jacobian of the
              constraints and of the simplified KKT matrix at the initial and
              optimal points. Note that this is only feasible for very small
              problems.</entry>
            </row>

            <row>
              <entry><literal>result_mode</literal></entry>

              <entry>'collocation_points'</entry>

              <entry>Specifies the output format of the optimization result.
              Possible values: "collocation_points", "element_interpolation"
              and "mesh_points" "collocation_points": The optimization result
              is given at the collocation points as well as the start and
              final time point. "element_interpolation": The values of the
              variable trajectories are calculated by evaluating the
              collocation polynomials. The algorithm option n_eval_points is
              used to specify the evaluation points within each finite
              element. "mesh_points": The optimization result is given at the
              mesh points.</entry>
            </row>

            <row>
              <entry><literal>n_eval_points</literal></entry>

              <entry>20</entry>

              <entry>The number of evaluation points used in each element when
              the algorithm option result_mode is set to
              "element_interpolation". One evaluation point is placed at each
              element end-point (hence the option value must be at least 2)
              and the rest are distributed uniformly.</entry>
            </row>

            <row>
              <entry><literal>blocking_factors</literal></entry>

              <entry>None (not used)</entry>

              <entry>Blocking factors are used to enforce piecewise constant
              inputs. The inputs may only change values at some of the element
              boundaries. The option is either None (disabled), given as an
              instance of
              pyjmi.optimization.casadi_collocation.BlockingFactors or as a
              list of blocking factors. If the options is a list of blocking
              factors, then each element in the list specifies the number of
              collocation elements for which all of the inputs must be
              constant. For example, if blocking_factors == [2, 2, 1], then
              the inputs will attain 3 different values (number of elements in
              the list), and it will change values between collocation element
              number 2 and 3 as well as number 4 and 5. The sum of all
              elements in the list must be the same as the number of
              collocation elements and the length of the list determines the
              number of separate values that the inputs may attain. See the
              documentation of the BlockingFactors class for how to use it. If
              blocking_factors is None, then the usual collocation polynomials
              are instead used to represent the controls.</entry>
            </row>

            <row>
              <entry><literal>quadrature_constraint</literal></entry>

              <entry>True</entry>

              <entry>Whether to use quadrature continuity constraints. This
              option is only applicable when using Gauss collocation. It is
              incompatible with eliminate_der_var set to True. True:
              Quadrature is used to get the values of the states at the mesh
              points. False: The Lagrange basis polynomials for the state
              collocation polynomials are evaluated to get the values of the
              states at the mesh points.</entry>
            </row>

            <row>
              <entry><literal>eliminate_der_var</literal></entry>

              <entry>False</entry>

              <entry>True: The variables representing the derivatives are
              eliminated via the collocation equations and are thus not a part
              of the NLP, with the exception of \dot{x}_{1, 0}, which is not
              eliminated since the collocation equations are not enforced at
              t_0. False: The variables representing the derivatives are kept
              as NLP variables and the collocation equations enter as
              constraints.</entry>
            </row>

            <row>
              <entry><literal>eliminate_cont_var</literal></entry>

              <entry>False</entry>

              <entry>True: Let the same variables represent both the values of
              the states at the start of each element and the end of the
              previous element. False: For Radau collocation, the extra
              variables x_{i, 0}, representing the states at the start of each
              element, are created and then constrained to be equal to the
              corresponding variable at the end of the previous element for
              continuity. For Gauss collocation, the extra variables x_{i,
              n_cp + 1}, representing the states at the end of each element,
              are created and then constrained to be equal to the
              corresponding variable at the start of the succeeding element
              for continuity.</entry>
            </row>

            <row>
              <entry><literal>measurement_data</literal></entry>

              <entry>None</entry>

              <entry>Data used to penalize, constraint or eliminate certain
              variables.</entry>
            </row>

            <row>
              <entry>delayed_feedback</entry>

              <entry>None</entry>

              <entry>If not <literal>None</literal>, should be a
              <literal>dict</literal> with mappings <literal>'delayed_var':
              ('undelayed_var', delay_ne)</literal>. For each key-value pair,
              adds the the constraint that the variable
              <literal>'delayed_var'</literal> equals the value of the
              variable <literal>'undelayed_var'</literal> delayed by
              <literal>delay_ne</literal> elements. The initial part of the
              trajectory for <literal>'delayed_var'</literal> is fixed to its
              initial guess given by the <literal>init_traj</literal> option
              or the <literal>initialGuess</literal> attribute.
              <literal>'delayed_var'</literal> will typically be an input.
              This is an experimental feature and is subject to
              change.</entry>
            </row>

            <row>
              <entry><literal>solver</literal></entry>

              <entry>'IPOPT'</entry>

              <entry>Specifies the nonlinear programming solver to be used.
              Possible choices are 'IPOPT' and 'WORHP'.</entry>
            </row>

            <row>
              <entry><literal>IPOPT_options</literal></entry>

              <entry>IPOPT defaults</entry>

              <entry>IPOPT options for solution of NLP. See IPOPT's
              documentation for available options.</entry>
            </row>

            <row>
              <entry><literal>WORHP_options</literal></entry>

              <entry>WORHP defaults</entry>

              <entry>WORHP options for solution of NLP. See WORHP's
              documentation for available options.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>A few of the options are experimental, so changing default values
      should be done with some care.</para>

      <para>The last options, <literal>IPOPT_options</literal> and
      <literal>WORHP_options</literal>, serve as interface for setting options
      in IPOPT and WORHP. To exemplify the usage of these algorithm options,
      the maximum number of iterations in IPOPT can be set using the following
      syntax:</para>

      <programlisting>opts = model.optimize_options()
opts["IPOPT_options"]["max_iter"] = 10000</programlisting>

      <para>The algorithm is in many ways similar to the JMI algorithm, but
      there are a few key differences. As mentioned before, it offers
      increased performance, which is mainly due to two things. The first is
      that this algorithm constructs automatic differentiation graphs for the
      entire NLP, whereas the JMI algorithm only constructs graphs for
      evaluation of residuals, leading to very fast function evaluations. The
      second is that second-order derivatives are computed using automatic
      differentiation, whereas the JMI algorithm instead uses a quasi-Newton
      method, which affects convergence speed and robustness. This feature can
      be disabled by setting the IPOPT option
      <literal>generate_hessian</literal> to <literal>False</literal>, in
      which case it will use the same quasi-Newton approach as the JMI
      algorithm.</para>

      <para>JModelica.org's CasADi framework does not support simulation and
      initialization of models. It is recommended to use PyFMI for these
      purposes instead.</para>

      <para>Some statistics from the NLP solver can be obtained by issuing the
      command</para>

      <programlisting>res_opt.solver.get_solver_statistics()
</programlisting>

      <para>The return argument of this function can be found by using the
      interactive help:</para>

      <programlisting>help(res.solver.opt_get_solver_statistics)
Get nonlinear programming solver statistics.
    
Returns::
    
    return_status -- 
        Return status from nonlinear programming solver.
            
    nbr_iter -- 
        Number of iterations.
            
    objective -- 
       Final value of objective function.
            
    total_exec_time -- 
        Execution time.</programlisting>
    </section>

    <section>
      <title>Examples</title>

      <section>
        <title>Optimal control</title>

        <para>This tutorial is based on the Hicks-Ray Continuously Stirred
        Tank Reactors (CSTR) system. The model was originally presented in
        [1]. The system has two states, the concentration, c, and the
        temperature, T. The control input to the system is the temperature,
        Tc, of the cooling flow in the reactor jacket. The chemical reaction
        in the reactor is exothermic, and also temperature dependent; high
        temperature results in high reaction rate. The CSTR dynamics are given
        by:</para>

        <informalequation>
          <m:math display="block" overflow="scroll">
            <m:mtable>
              <m:mtr>
                <m:mtd columnalign="right">
                  <m:mover>
                    <m:mi>c</m:mi>

                    <m:mo>.</m:mo>
                  </m:mover>

                  <m:mfenced>
                    <m:mi>t</m:mi>
                  </m:mfenced>
                </m:mtd>

                <m:mtd columnalign="left">
                  <m:mo>=</m:mo>

                  <m:mfrac>
                    <m:mrow>
                      <m:msub>
                        <m:mi>F</m:mi>

                        <m:mn>0</m:mn>
                      </m:msub>

                      <m:mfenced separators="">
                        <m:msub>
                          <m:mi>c</m:mi>

                          <m:mn>0</m:mn>
                        </m:msub>

                        <m:mo>-</m:mo>

                        <m:mi>c</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:mi>t</m:mi>
                        </m:mfenced>
                      </m:mfenced>
                    </m:mrow>

                    <m:mi>V</m:mi>
                  </m:mfrac>

                  <m:mo>-</m:mo>

                  <m:msub>
                    <m:mi>k</m:mi>

                    <m:mn>0</m:mn>
                  </m:msub>

                  <m:mi>c</m:mi>

                  <m:mo>⁡</m:mo>

                  <m:mfenced>
                    <m:mi>t</m:mi>
                  </m:mfenced>

                  <m:msup>
                    <m:mi>e</m:mi>

                    <m:mrow>
                      <m:mo>-</m:mo>

                      <m:mi>EdivR</m:mi>

                      <m:mo>/</m:mo>

                      <m:mi>T</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>
                    </m:mrow>
                  </m:msup>
                </m:mtd>
              </m:mtr>

              <m:mtr>
                <m:mtd columnalign="right">
                  <m:mover>
                    <m:mi>T</m:mi>

                    <m:mo>.</m:mo>
                  </m:mover>

                  <m:mfenced>
                    <m:mi>t</m:mi>
                  </m:mfenced>
                </m:mtd>

                <m:mtd columnalign="left">
                  <m:mo>=</m:mo>

                  <m:mfrac>
                    <m:mrow>
                      <m:msub>
                        <m:mi>F</m:mi>

                        <m:mn>0</m:mn>
                      </m:msub>

                      <m:mfenced separators="">
                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mn>0</m:mn>
                        </m:msub>

                        <m:mo>-</m:mo>

                        <m:mi>T</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:mi>t</m:mi>
                        </m:mfenced>
                      </m:mfenced>
                    </m:mrow>

                    <m:mi>V</m:mi>
                  </m:mfrac>

                  <m:mo>-</m:mo>

                  <m:mfrac>
                    <m:mrow>
                      <m:mrow>
                        <m:mi>d</m:mi>

                        <m:mi>H</m:mi>
                      </m:mrow>

                      <m:msub>
                        <m:mi>k</m:mi>

                        <m:mn>0</m:mn>
                      </m:msub>

                      <m:mi>c</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mrow>
                      <m:mi>ρ</m:mi>

                      <m:msub>
                        <m:mi>C</m:mi>

                        <m:mi>p</m:mi>
                      </m:msub>
                    </m:mrow>
                  </m:mfrac>

                  <m:msup>
                    <m:mi>e</m:mi>

                    <m:mrow>
                      <m:mo>-</m:mo>

                      <m:mi>EdivR</m:mi>

                      <m:mo>/</m:mo>

                      <m:mi>T</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>
                    </m:mrow>
                  </m:msup>

                  <m:mo>+</m:mo>

                  <m:mfrac>
                    <m:mrow>
                      <m:mn>2</m:mn>

                      <m:mi>U</m:mi>
                    </m:mrow>

                    <m:mrow>
                      <m:mi>r</m:mi>

                      <m:mi>ρ</m:mi>

                      <m:msub>
                        <m:mi>C</m:mi>

                        <m:mi>p</m:mi>
                      </m:msub>
                    </m:mrow>
                  </m:mfrac>

                  <m:mfenced separators="">
                    <m:mrow>
                      <m:mi>T</m:mi>

                      <m:mi>c</m:mi>
                    </m:mrow>

                    <m:mfenced>
                      <m:mi>t</m:mi>
                    </m:mfenced>

                    <m:mo>-</m:mo>

                    <m:mi>T</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi>t</m:mi>
                    </m:mfenced>
                  </m:mfenced>
                </m:mtd>
              </m:mtr>
            </m:mtable>

            <m:mspace linebreak="newline"/>
          </m:math>
        </informalequation>

        <para>This tutorial will cover the following topics:</para>

        <itemizedlist>
          <listitem>
            <para>How to solve a DAE initialization problem. The
            initialization model has equations specifying that all derivatives
            should be identically zero, which implies that a stationary
            solution is obtained. Two stationary points, corresponding to
            different inputs, are computed. We call the stationary points A
            and B respectively. Point A corresponds to operating conditions
            where the reactor is cold and the reaction rate is low, whereas
            point B corresponds to a higher temperature where the reaction
            rate is high.</para>
          </listitem>

          <listitem>
            <para>An optimal control problem is solved where the objective is
            to transfer the state of the system from stationary point A to
            point B. The challenge is to ignite the reactor while avoiding
            uncontrolled temperature increases. It is also demonstrated how to
            set parameter and variable values in a model. More information
            about the simultaneous optimization algorithm can be found at
            JModelica.org API documentation.</para>
          </listitem>

          <listitem>
            <para>The optimization result is saved to file and then the
            important variables are plotted.</para>
          </listitem>
        </itemizedlist>

        <para>The Python commands in this tutorial may be copied and pasted
        directly into a Python shell, in some cases with minor modifications.
        Alternatively, you may copy the commands into a text file, e.g.,
        <filename>cstr_casadi.py</filename>.</para>

        <para>Start the tutorial by creating a working directory and copy the
        file
        <filename>$JMODELICA_HOME/Python/pyjmi/examples/files/CSTR.mop</filename>
        to your working directory. An online version of <link
        xlink:href="https://svn.jmodelica.org/trunk/Python/src/pyjmi/examples/files/CSTR.mop"><filename>CSTR.mop</filename></link>
        is also available (depending on which browser you use, you may have to
        accept the site certificate by clicking through a few steps). If you
        choose to create a Python script file, save it to the working
        directory.</para>

        <section>
          <title>Compile and instantiate a model object</title>

          <para>The functions and classes used in the tutorial script need to
          be imported into the Python script. This is done by the following
          Python commands. Copy them and paste them either directly into your
          Python shell or, preferably, into your Python script file.</para>

          <programlisting language="python">import numpy as N
import matplotlib.pyplot as plt

from pymodelica import compile_fmu
from pyfmi import load_fmu
from pyjmi import transfer_optimization_problem
</programlisting>

          <para>To solve the initialization problem and simulate the model, we
          will first compile it as an FMU and load it in Python. These steps
          are described in more detail in Section 4.</para>

          <programlisting language="python"># Compile the stationary initialization model into an FMU
init_fmu = compile_fmu("CSTR.CSTR_Init", "CSTR.mop")
    
# Load the FMU
init_model = load_fmu(init_fmu)
</programlisting>

          <para>At this point, you may open the file
          <filename>CSTR.mop</filename>, containing the CSTR model and the
          static initialization model used in this section. Study the classes
          <literal>CSTR.CSTR</literal> and <literal>CSTR.CSTR_Init</literal>
          and make sure you understand the models. Before proceeding, have a
          look at the interactive help for one of the functions you
          used:</para>

          <programlisting language="python">help(compile_fmu)
</programlisting>
        </section>

        <section>
          <title>Solve the DAE initialization problem</title>

          <para>In the next step, we would like to specify the first operating
          point, A, by means of a constant input cooling temperature, and then
          solve the initialization problem assuming that all derivatives are
          zero.</para>

          <programlisting language="python"># Set input for Stationary point A
Tc_0_A = 250
init_model.set('Tc', Tc_0_A)

# Solve the initialization problem using FMI
init_model.initialize()

# Store stationary point A
[c_0_A, T_0_A] = init_model.get(['c', 'T'])

# Print some data for stationary point A
print(' *** Stationary point A ***')
print('Tc = %f' % Tc_0_A)
print('c = %f' % c_0_A)
print('T = %f' % T_0_A)
</programlisting>

          <para>Notice how the method <literal>set</literal> is used to set
          the value of the control input. The initialization algorithm is
          invoked by calling the method <literal>initialize</literal>, which
          returns a result object from which the initialization result can be
          accessed. The values of the states corresponding to point A can then
          be extracted from the result object. Look carefully at the printouts
          in the Python shell to see a printout of the stationary values.
          Display the help text for the <literal>initialize</literal> method
          and take a moment to look it through. The procedure is now repeated
          for operating point B:</para>

          <programlisting language="python"># Set inputs for Stationary point B
init_model.reset() # reset the FMU so that we can initialize it again
Tc_0_B = 280
init_model.set('Tc', Tc_0_B)

# Solve the initialization problem using FMI
init_model.initialize()

# Store stationary point B
[c_0_B, T_0_B] = init_model.get(['c', 'T'])

# Print some data for stationary point B
print(' *** Stationary point B ***')
print('Tc = %f' % Tc_0_B)
print('c = %f' % c_0_B)
print('T = %f' % T_0_B)
</programlisting>

          <para>We have now computed two stationary points for the system
          based on constant control inputs. In the next section, these will be
          used to set up an optimal control problem.</para>

          <section>
            <title>Solving an optimal control problem</title>

            <para>The optimal control problem we are about to solve is given
            by:</para>

            <informalequation>
              <m:math display="block" overflow="scroll">
                <m:mtable>
                  <m:mtr>
                    <m:mtd columnalign="right"/>

                    <m:mtd columnalign="left">
                      <m:msub>
                        <m:mi mathvariant="normal">min</m:mi>

                        <m:mrow>
                          <m:mi>u</m:mi>

                          <m:mo>⁡</m:mo>

                          <m:mfenced>
                            <m:mi>t</m:mi>
                          </m:mfenced>
                        </m:mrow>
                      </m:msub>

                      <m:munderover>
                        <m:mo>∫</m:mo>

                        <m:mn>0</m:mn>

                        <m:mn>150</m:mn>
                      </m:munderover>

                      <m:msup>
                        <m:mfenced close=")" open="(" separators="">
                          <m:msup>
                            <m:mi>c</m:mi>

                            <m:mrow>
                              <m:mi>r</m:mi>

                              <m:mi>e</m:mi>

                              <m:mi>f</m:mi>
                            </m:mrow>
                          </m:msup>

                          <m:mo>-</m:mo>

                          <m:mi>c</m:mi>

                          <m:mo>⁡</m:mo>

                          <m:mfenced>
                            <m:mi>t</m:mi>
                          </m:mfenced>
                        </m:mfenced>

                        <m:mn>2</m:mn>
                      </m:msup>

                      <m:mo>+</m:mo>

                      <m:msup>
                        <m:mfenced close=")" open="(" separators="">
                          <m:msup>
                            <m:mi>T</m:mi>

                            <m:mrow>
                              <m:mi>r</m:mi>

                              <m:mi>e</m:mi>

                              <m:mi>f</m:mi>
                            </m:mrow>
                          </m:msup>

                          <m:mo>-</m:mo>

                          <m:mi>T</m:mi>

                          <m:mo>⁡</m:mo>

                          <m:mfenced>
                            <m:mi>t</m:mi>
                          </m:mfenced>
                        </m:mfenced>

                        <m:mn>2</m:mn>
                      </m:msup>

                      <m:mo>+</m:mo>

                      <m:msup>
                        <m:mfenced close=")" open="(" separators="">
                          <m:msubsup>
                            <m:mi>T</m:mi>

                            <m:mi>c</m:mi>

                            <m:mrow>
                              <m:mi>r</m:mi>

                              <m:mi>e</m:mi>

                              <m:mi>f</m:mi>
                            </m:mrow>
                          </m:msubsup>

                          <m:mo>-</m:mo>

                          <m:msub>
                            <m:mi>T</m:mi>

                            <m:mi>c</m:mi>
                          </m:msub>

                          <m:mfenced>
                            <m:mi>t</m:mi>
                          </m:mfenced>
                        </m:mfenced>

                        <m:mn>2</m:mn>
                      </m:msup>

                      <m:mrow>
                        <m:mi>d</m:mi>

                        <m:mi>t</m:mi>
                      </m:mrow>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd columnalign="right"/>

                    <m:mtd columnalign="left">
                      <m:mstyle mathvariant="normal">
                        <m:mi>subject</m:mi>

                        <m:mo> </m:mo>

                        <m:mo> </m:mo>

                        <m:mi>to</m:mi>
                      </m:mstyle>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd columnalign="right"/>

                    <m:mtd columnalign="left">
                      <m:mn>230</m:mn>

                      <m:mo>≤</m:mo>

                      <m:mi>u</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>

                      <m:mo>=</m:mo>

                      <m:msub>
                        <m:mi>T</m:mi>

                        <m:mi>c</m:mi>
                      </m:msub>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>

                      <m:mn>≤ 370</m:mn>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd columnalign="right"/>

                    <m:mtd columnalign="left">
                      <m:mi>T</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>

                      <m:mo>≤</m:mo>

                      <m:mn>350</m:mn>
                    </m:mtd>
                  </m:mtr>
                </m:mtable>

                <m:mspace linebreak="newline"/>
              </m:math>
            </informalequation>

            <para>and is expressed in Optimica format in the class
            <literal>CSTR.CSTR_Opt2</literal> in the
            <filename>CSTR.mop</filename> file above. Have a look at this
            class and make sure that you understand how the optimization
            problem is formulated and what the objective is.</para>

            <para>Direct collocation methods often require good initial
            guesses in order to ensure robust convergence. Since initial
            guesses are needed for all discretized variables along the
            optimization interval, simulation provides a convenient means to
            generate state and derivative profiles given an initial guess for
            the control input(s). It is then convenient to set up a dedicated
            model for computation of initial trajectories. In the model
            <literal>CSTR.CSTR_Init_Optimization</literal> in the
            <filename>CSTR.mop</filename> file, a step input is applied to the
            system in order obtain an initial guess. Notice that the variable
            names in the initialization model must match those in the optimal
            control model.</para>

            <para>First, compile the model and set model parameters:</para>

            <programlisting language="python"># Compile the optimization initialization model
init_sim_fmu = compile_fmu("CSTR.CSTR_Init_Optimization", "CSTR.mop")

# Load the model
init_sim_model = load_fmu(init_sim_fmu)

# Set initial and reference values
init_sim_model.set('cstr.c_init', c_0_A)
init_sim_model.set('cstr.T_init', T_0_A)
init_sim_model.set('c_ref', c_0_B)
init_sim_model.set('T_ref', T_0_B)
init_sim_model.set('Tc_ref', Tc_0_B)
</programlisting>

            <para>Having initialized the model parameters, we can simulate the
            model using the <literal>simulate</literal> function.</para>

            <programlisting language="python">init_res = init_sim_model.simulate(start_time=0., final_time=150.)
</programlisting>

            <para>The method <literal>simulate</literal> first computes
            consistent initial conditions and then simulates the model in the
            interval 0 to 150 seconds. Take a moment to read the interactive
            help for the <literal>simulate</literal> method.</para>

            <para>The simulation result object is returned and to retrieve the
            simulation data use Python dictionary access to retrieve the
            variable trajectories.</para>

            <programlisting language="python"># Extract variable profiles
t_init_sim = init_res['time']
c_init_sim = init_res['cstr.c']
T_init_sim = init_res['cstr.T']
Tc_init_sim = init_res['cstr.Tc']

# Plot the initial guess trajectories
plt.close(1)
plt.figure(1)
plt.hold(True)
plt.subplot(3, 1, 1)
plt.plot(t_init_sim, c_init_sim)
plt.grid()
plt.ylabel('Concentration')
plt.title('Initial guess obtained by simulation')

plt.subplot(3, 1, 2)
plt.plot(t_init_sim, T_init_sim)
plt.grid()
plt.ylabel('Temperature')

plt.subplot(3, 1, 3)
plt.plot(t_init_sim, Tc_init_sim)
plt.grid()
plt.ylabel('Cooling temperature')
plt.xlabel('time')
plt.show()
</programlisting>

            <para>Look at the plots and try to relate the trajectories to the
            optimal control problem. Why is this a good initial guess?</para>

            <para>Once the initial guess is generated, we compile the optimal
            control problem:</para>

            <programlisting language="python"># Compile and load optimization problem
op = transfer_optimization_problem("CSTR.CSTR_Opt2", "CSTR.mop")
</programlisting>

            <para>We will now initialize the parameters of the model so that
            their values correspond to the optimization objective of
            transferring the system state from operating point A to operating
            point B. Accordingly, we set the parameters representing the
            initial values of the states to point A and the reference values
            in the cost function to point B:</para>

            <programlisting language="python"># Set reference values
op.set('Tc_ref', Tc_0_B)
op.set('c_ref', float(c_0_B))
op.set('T_ref', float(T_0_B))

# Set initial values
op.set('cstr.c_init', float(c_0_A))
op.set('cstr.T_init', float(T_0_A))
</programlisting>

            <para>Collocation-based optimization algorithms often require a
            good initial guess in order to achieve fast convergence. Also, if
            the problem is non-convex, initialization is even more critical.
            Initial guesses can be provided in Optimica by the
            <literal>initialGuess</literal> attribute, see the
            <filename>CSTR.mop</filename> file for an example for this. Notice
            that initialization in the case of collocation-based optimization
            methods means initialization of all the control and state profiles
            as a function of time. In some cases, it is sufficient to use
            constant profiles. For this purpose, the
            <literal>initialGuess</literal> attribute works well. In more
            difficult cases, however, it may be necessary to initialize the
            profiles using simulation data, where an initial guess for the
            input(s) has been used to generate the profiles for the dependent
            variables. This approach for initializing the optimization problem
            is used in this tutorial.</para>

            <para>We are now ready to solve the actual optimization problem.
            This is done by invoking the method optimize:</para>

            <programlisting language="python"># Set options
opt_opts = op.optimize_options()
opt_opts['n_e'] = 19 # Number of elements
opt_opts['init_traj'] = init_res.result_data
opt_opts['IPOPT_options']['tol'] = 1e-10

# Solve the optimal control problem
res = op.optimize(options=opt_opts)
</programlisting>

            <para>In this case, we would like to increase the number of finite
            elements in the mesh from 50 to 100. This is done by setting the
            corresponding option and provide it as an argument to the
            <literal>optimize</literal> method. We also lower the tolerance of
            IPOPT to get a more accurate result. You should see the output of
            IPOPT in the Python shell as the algorithm iterates to find the
            optimal solution. IPOPT should terminate with a message like
            'Optimal solution found' or 'Solved to acceptable level' in order
            for an optimum to have been found. The optimization result object
            is returned and the optimization data are stored in
            <literal>res</literal>.</para>

            <para>We can now retrieve the trajectories of the variables that
            we intend to plot:</para>

            <programlisting language="python"># Extract variable profiles
c_res = res['cstr.c']
T_res = res['cstr.T']
Tc_res = res['cstr.Tc']
time_res = res['time']
c_ref = res['c_ref']
T_ref = res['T_ref']
Tc_ref = res['Tc_ref']
</programlisting>

            <para>Finally, we plot the result using the functions available in
            matplotlib:</para>

            <programlisting language="python"># Plot the results
plt.close(2)
plt.figure(2)
plt.hold(True)
plt.subplot(3, 1, 1)
plt.plot(time_res, c_res)
plt.plot(time_res, c_ref, '--')
plt.grid()
plt.ylabel('Concentration')
plt.title('Optimized trajectories')

plt.subplot(3, 1, 2)
plt.plot(time_res, T_res)
plt.plot(time_res, T_ref, '--')
plt.grid()
plt.ylabel('Temperature')

plt.subplot(3, 1, 3)
plt.plot(time_res, Tc_res)
plt.plot(time_res, Tc_ref, '--')
plt.grid()
plt.ylabel('Cooling temperature')
plt.xlabel('time')
plt.show()

</programlisting>

            <para>You should now see the plot shown in <xref
            linkend="opt-fig-cstr-casadi-opt1"/>.</para>

            <figure xml:id="opt-fig-cstr-casadi-opt1">
              <title>Optimal profiles for the CSTR problem.</title>

              <mediaobject>
                <imageobject>
                  <imagedata fileref="images/cstr_casadi.svg" scalefit="1"
                             width="60%"/>
                </imageobject>
              </mediaobject>
            </figure>

            <para>Take a minute to analyze the optimal profiles and to answer
            the following questions:</para>

            <orderedlist>
              <listitem>
                <para>Why is the concentration high in the beginning of the
                interval?</para>
              </listitem>

              <listitem>
                <para>Why is the input cooling temperature high in the
                beginning of the interval?</para>
              </listitem>
            </orderedlist>
          </section>
        </section>

        <section>
          <title>Verify optimal control solution</title>

          <para>Solving optimal control problems by means of direct
          collocation implies that the differential equation is approximated
          by a time-discrete counterpart. The accuracy of the solution is
          dependent on the method of collocation and the number of elements.
          In order to assess the accuracy of the discretization, we may
          simulate the system using the optimal control profile as input. With
          this approach, the state profiles are computed with high accuracy
          and the result may then be compared with the profiles resulting from
          optimization. Notice that this procedure does not verify the
          optimality of the resulting optimal control profiles, but only the
          accuracy of the discretization of the dynamics.</para>

          <para>We start by compiling and loading the model used for
          simulation:</para>

          <programlisting># Compile model
sim_fmu = compile_fmu("CSTR.CSTR", file_path)

# Load model
sim_model = load_fmu(sim_fmu)
</programlisting>

          <para>The solution obtained from the optimization are values at a
          finite number of time points, in this case the collocation points.
          With the JMI framework, these values are normally interpolated
          linearly when used for simulation purposes. The CasADi framework
          also supports obtaining all the collocation polynomials for all the
          input variables in the form of a function instead, which can be used
          during simulation for greater accuracy. We obtain it from the result
          object in the following manner.</para>

          <programlisting># Get optimized input
(_, opt_input) = res.solver.get_opt_input()
</programlisting>

          <para>We specify the initial values and simulate using the optimal
          trajectory:</para>

          <programlisting># Set initial values
sim_model.set('c_init', c_0_A)
sim_model.set('T_init', T_0_A)

# Simulate using optimized input
sim_opts = sim_model.simulate_options()
sim_opts['CVode_options']['rtol'] = 1e-6
sim_opts['CVode_options']['atol'] = 1e-8
res = sim_model.simulate(start_time=0., final_time=150.,
                         input=('Tc', opt_input), options=sim_opts)
</programlisting>

          <para>Finally, we load the simulated data and plot it to compare
          with the optimized trajectories:</para>

          <programlisting language="python"># Extract variable profiles
c_sim=res['c']
T_sim=res['T']
Tc_sim=res['Tc']
time_sim = res['time']

# Plot the results
plt.figure(3)
plt.clf()
plt.hold(True)
plt.subplot(311)
plt.plot(time_res,c_res,'--')
plt.plot(time_sim,c_sim)
plt.legend(('optimized','simulated'))
plt.grid()
plt.ylabel('Concentration')

plt.subplot(312)
plt.plot(time_res,T_res,'--')
plt.plot(time_sim,T_sim)
plt.legend(('optimized','simulated'))
plt.grid()
plt.ylabel('Temperature')

plt.subplot(313)
plt.plot(time_res,Tc_res,'--')
plt.plot(time_sim,Tc_sim)
plt.legend(('optimized','simulated'))
plt.grid()
plt.ylabel('Cooling temperature')
plt.xlabel('time')
plt.show()
</programlisting>

          <para>You should now see the plot shown in <xref
          linkend="opt-fig-cstr-casadi-opt2"/>.</para>

          <figure xml:id="opt-fig-cstr-casadi-opt2">
            <title>Optimal control profiles and simulated trajectories
            corresponding to the optimal control input.</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="images/cstr_opt_cmp_casadi.svg"
                           scalefit="1" width="60%"/>
              </imageobject>
            </mediaobject>
          </figure>

          <para>Discuss why the simulated trajectories differ from their
          optimized counterparts.</para>
        </section>

        <section>
          <title>Exercises</title>

          <para>After completing the tutorial you may continue to modify the
          optimization problem and study the results.</para>

          <orderedlist>
            <listitem>
              <para>Remove the constraint on cstr.T. What is then the maximum
              temperature?</para>
            </listitem>

            <listitem>
              <para>Play around with weights in the cost function. What
              happens if you penalize the control variable with a larger
              weight? Do a parameter sweep for the control variable weight and
              plot the optimal profiles in the same figure.</para>
            </listitem>

            <listitem>
              <para>Add terminal constraints
              ('cstr.T(finalTime)=someParameter') for the states so that they
              are equal to point B at the end of the optimization interval.
              Now reduce the length of the optimization interval. How short
              can you make the interval?</para>
            </listitem>

            <listitem>
              <para>Try varying the number of elements in the mesh and the
              number of collocation points in each interval.</para>
            </listitem>
          </orderedlist>
        </section>

        <section>
          <title>References</title>

          <para>[1] G.A. Hicks and W.H. Ray. Approximation Methods for Optimal
          Control Synthesis. <emphasis>Can. J. Chem. Eng</emphasis>.,
          40:522–529, 1971.</para>

          <para>[2] Bieger, L., A. Cervantes, and A. Wächter (2002): "Advances
          in simultaneous strategies for dynamic optimization."
          <emphasis>Chemical Engineering Science</emphasis>, <emphasis
          role="bold">57</emphasis>, pp. 575-593.</para>

          <section>
            <title>Minimum time problems</title>

            <para>Minimum time problems are dynamic optimization problems
            where not only the control inputs are optimized, but also the
            final time. Typically, elements of such problems include initial
            and terminal state constraints and an objective function where the
            transition time is minimized. The following example will be used
            to illustrate how minimum time problems are formulated in
            Optimica. We consider the optimization problem:</para>

            <informalequation>
              <m:math display="block" overflow="scroll">
                <m:munder>
                  <m:mi>min</m:mi>

                  <m:mrow>
                    <m:mi>u</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi>t</m:mi>
                    </m:mfenced>
                  </m:mrow>
                </m:munder>

                <m:msub>
                  <m:mi>t</m:mi>

                  <m:mi>f</m:mi>
                </m:msub>

                <m:mspace linebreak="newline"/>
              </m:math>
            </informalequation>

            <para>subject to the Van der Pol dynamics:</para>

            <informalequation>
              <m:math display="block" overflow="scroll">
                <m:mtable>
                  <m:mtr>
                    <m:mtd columnalign="right">
                      <m:msub>
                        <m:mover>
                          <m:mi>x</m:mi>

                          <m:mo>.</m:mo>
                        </m:mover>

                        <m:mn>1</m:mn>
                      </m:msub>
                    </m:mtd>

                    <m:mtd columnalign="left">
                      <m:mo>=</m:mo>

                      <m:mfenced separators="">
                        <m:mn>1</m:mn>

                        <m:mo>-</m:mo>

                        <m:msubsup>
                          <m:mi>x</m:mi>

                          <m:mn>2</m:mn>

                          <m:mn>2</m:mn>
                        </m:msubsup>
                      </m:mfenced>

                      <m:msub>
                        <m:mi>x</m:mi>

                        <m:mn>1</m:mn>
                      </m:msub>

                      <m:mo>-</m:mo>

                      <m:msub>
                        <m:mi>x</m:mi>

                        <m:mn>2</m:mn>
                      </m:msub>

                      <m:mo>+</m:mo>

                      <m:mi>u</m:mi>

                      <m:mi>,</m:mi>

                      <m:mspace width="1em"/>

                      <m:msub>
                        <m:mi>x</m:mi>

                        <m:mn>1</m:mn>
                      </m:msub>

                      <m:mfenced>
                        <m:mn>0</m:mn>
                      </m:mfenced>

                      <m:mo>=</m:mo>

                      <m:mn>0</m:mn>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd columnalign="right">
                      <m:msub>
                        <m:mover>
                          <m:mi>x</m:mi>

                          <m:mo>.</m:mo>
                        </m:mover>

                        <m:mn>2</m:mn>
                      </m:msub>
                    </m:mtd>

                    <m:mtd columnalign="left">
                      <m:mo>=</m:mo>

                      <m:msub>
                        <m:mi>x</m:mi>

                        <m:mn>1</m:mn>
                      </m:msub>

                      <m:mi>,</m:mi>

                      <m:mspace width="1em"/>

                      <m:msub>
                        <m:mi>x</m:mi>

                        <m:mn>2</m:mn>
                      </m:msub>

                      <m:mfenced>
                        <m:mn>0</m:mn>
                      </m:mfenced>

                      <m:mo>=</m:mo>

                      <m:mn>1</m:mn>
                    </m:mtd>
                  </m:mtr>
                </m:mtable>

                <m:mspace linebreak="newline"/>
              </m:math>
            </informalequation>

            <para>and the constraints:</para>

            <informalequation>
              <m:math display="block" overflow="scroll">
                <m:mtable>
                  <m:mtr>
                    <m:mtd columnalign="right">
                      <m:msub>
                        <m:mi>x</m:mi>

                        <m:mn>1</m:mn>
                      </m:msub>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:msub>
                          <m:mi>t</m:mi>

                          <m:mi>f</m:mi>
                        </m:msub>
                      </m:mfenced>
                    </m:mtd>

                    <m:mtd columnalign="left">
                      <m:mo>=</m:mo>

                      <m:mn>0</m:mn>

                      <m:mi>,</m:mi>

                      <m:mspace width="1em"/>

                      <m:msub>
                        <m:mi>x</m:mi>

                        <m:mn>2</m:mn>
                      </m:msub>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:msub>
                          <m:mi>t</m:mi>

                          <m:mi>f</m:mi>
                        </m:msub>
                      </m:mfenced>

                      <m:mo>=</m:mo>

                      <m:mn>0</m:mn>
                    </m:mtd>
                  </m:mtr>
                </m:mtable>

                <m:mspace linebreak="newline"/>
              </m:math>
            </informalequation>

            <para><informalequation>
                <m:math display="block">
                  <m:mi>-1 ≤ u(t) ≤ 1</m:mi>
                </m:math>
              </informalequation></para>

            <para>This problem is encoded in the following Optimica
            specification:</para>

            <programlisting language="optimica">optimization VDP_Opt_Min_Time (objective = finalTime,
                               startTime = 0,
                               finalTime(free=true,min=0.2,initialGuess=1)) 

  // The states
  Real x1(start = 0,fixed=true);
  Real x2(start = 1,fixed=true);

  // The control signal
  input Real u(free=true,min=-1,max=1);

equation
  // Dynamic equations
  der(x1) = (1 - x2^2) * x1 - x2 + u;
  der(x2) = x1;

constraint
  // terminal constraints
  x1(finalTime)=0;
  x2(finalTime)=0;
end VDP_Opt_Min_Time;
</programlisting>

            <para>Notice how the class attribute <literal>finalTime</literal>
            is set to be free in the optimization. The problem is solved by
            the following Python script:</para>

            <programlisting language="python"># Import numerical libraries
import numpy as N
import matplotlib.pyplot as plt

# Import the JModelica.org Python packages
from pymodelica import compile_fmu
from pyfmi import load_fmu
from pyjmi import transfer_optimization_problem

vdp = transfer_optimization_problem("VDP_Opt_Min_Time", "VDP_Opt_Min_Time.mop")
res = vdp.optimize()

# Extract variable profiles
x1=res['x1']
x2=res['x2']
u=res['u']
t=res['time']

# Plot
plt.figure(1)
plt.clf()
plt.subplot(311)
plt.plot(t,x1)
plt.grid()
plt.ylabel('x1')

plt.subplot(312)
plt.plot(t,x2)
plt.grid()
plt.ylabel('x2')

plt.subplot(313)
plt.plot(t,u,'x-')
plt.grid()
plt.ylabel('u')
plt.xlabel('time')
plt.show()
</programlisting>

            <para>The resulting control and state profiles are shown in <xref
            linkend="opt-fig-vdp-min-time-casadi"/>. Notice the difference as
            compared to Figure <xref linkend="fig-vdp-opt"/>, where the Van
            der Pol oscillator system is optimized using a quadratic objective
            function.</para>

            <figure xml:id="opt-fig-vdp-min-time-casadi">
              <title>Minimum time profiles for the Van der Pol
              Oscillator.</title>

              <mediaobject>
                <imageobject>
                  <imagedata fileref="images/vdp_min_time.svg" scalefit="1"
                             width="60%"/>
                </imageobject>
              </mediaobject>
            </figure>
          </section>

          <section>
            <title>Optimization under delay constraints</title>

            <para>In some applications, it can be useful to solve dynamic
            optimization problems that include time delays in the model.
            Collocation based optimization schemes are well suited to handle
            this kind of models, since the whole state trajectory is available
            at the same time. The direct collocation method using CasADi
            contains an experimental implementation of such delays, which we
            will describe with an example. Please note that the implementation
            of this feature is experimental and subject to change.</para>

            <para>We consider the optimization problem</para>

            <informalequation>
              <m:math display="block">
                <m:mrow>
                  <m:munder>
                    <m:mi>min</m:mi>

                    <m:mi>u(t)</m:mi>
                  </m:munder>

                  <m:mrow>
                    <m:munderover>
                      <m:mo>∫</m:mo>

                      <m:mi>0</m:mi>

                      <m:mi>1</m:mi>
                    </m:munderover>

                    <m:msup>
                      <m:mi>(4x(t)</m:mi>

                      <m:mi>2</m:mi>
                    </m:msup>

                    <m:msubsup>
                      <m:mi> + u(t)</m:mi>

                      <m:mi>1</m:mi>

                      <m:mi>2</m:mi>
                    </m:msubsup>

                    <m:msubsup>
                      <m:mi> + u(t)</m:mi>

                      <m:mi>2</m:mi>

                      <m:mi>2</m:mi>
                    </m:msubsup>

                    <m:mi>) dt</m:mi>
                  </m:mrow>
                </m:mrow>
              </m:math>
            </informalequation>

            <para>subject to the dynamics</para>

            <informalequation>
              <m:math display="block">
                <m:mtable>
                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:mover>
                          <m:mi>x</m:mi>

                          <m:mi>.</m:mi>
                        </m:mover>

                        <m:mi>(t)</m:mi>

                        <m:mo>=</m:mo>

                        <m:msub>
                          <m:mi>u</m:mi>

                          <m:mi>1</m:mi>
                        </m:msub>

                        <m:mi>(t) - </m:mi>

                        <m:mi>2</m:mi>

                        <m:msub>
                          <m:mi>u</m:mi>

                          <m:mi>2</m:mi>
                        </m:msub>

                        <m:mi>(t)</m:mi>
                      </m:mrow>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>u</m:mi>

                          <m:mi>2</m:mi>
                        </m:msub>

                        <m:mi>(t)</m:mi>

                        <m:mo>=</m:mo>

                        <m:msub>
                          <m:mi>u</m:mi>

                          <m:mi>1</m:mi>
                        </m:msub>

                        <m:mi>(t - </m:mi>

                        <m:msub>
                          <m:mi>t</m:mi>

                          <m:mi>delay</m:mi>
                        </m:msub>

                        <m:mi>)</m:mi>
                      </m:mrow>
                    </m:mtd>
                  </m:mtr>
                </m:mtable>
              </m:math>
            </informalequation>

            <para>and the boundary conditions</para>

            <informalequation>
              <m:math display="block">
                <m:mtable>
                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:mi>x(0)</m:mi>

                        <m:mo>=</m:mo>

                        <m:mi>1</m:mi>
                      </m:mrow>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:mi>x(1)</m:mi>

                        <m:mo>=</m:mo>

                        <m:mi>0</m:mi>
                      </m:mrow>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>u</m:mi>

                          <m:mi>2</m:mi>
                        </m:msub>

                        <m:mi>(t)</m:mi>

                        <m:mo>=</m:mo>

                        <m:mi>0.25, t &lt; </m:mi>

                        <m:msub>
                          <m:mi>t</m:mi>

                          <m:mi>delay</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>
                  </m:mtr>
                </m:mtable>
              </m:math>
            </informalequation>

            <para>The effect of positive <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>u</m:mi>

                    <m:mi>1</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation> is initially to increase <inlineequation>
                <m:math display="inline">
                  <m:mi>x</m:mi>
                </m:math>
              </inlineequation>, but after a time delay of time
            <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>t</m:mi>

                    <m:mi>delay</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation>, it comes back with twice the effect in the
            negative direction through <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>u</m:mi>

                    <m:mi>2</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation>.</para>

            <para>We model everything except the delay constraint in the
            Optimica specification</para>

            <programlisting>optimization DelayTest(startTime = 0, finalTime = 1,
                       objectiveIntegrand = 4*x^2 + u1^2 + u2^2)
    input Real u1, u2;
    Real x(start = 1, fixed=true);
equation
    der(x) = u1 - 2*u2;
constraint
    x(finalTime) = 0;
end DelayTest;
</programlisting>

            <para>The problem is then solved in the following python script.
            Notice how delay constraint is added using the
            <literal>delayed_feedback</literal> option, and the initial part
            of <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>u</m:mi>

                    <m:mi>2</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation> is set using the
            <literal>initialGuess</literal> attribute:</para>

            <programlisting># Import numerical libraries
import numpy as np
import matplotlib.pyplot as plt

# Import JModelica.org Python packages
from pyjmi import transfer_optimization_problem

n_e = 20
delay_n_e = 5
horizon = 1.0
delay = horizon*delay_n_e/n_e

# Compile and load optimization problem
opt = transfer_optimization_problem("DelayTest", "DelayedFeedbackOpt.mop")

# Set value for u2(t) when t &lt; delay
opt.getVariable('u2').setAttribute('initialGuess', 0.25)

# Set algorithm options
opts = opt.optimize_options()
opts['n_e'] = n_e
# Set delayed feedback from u1 to u2
opts['delayed_feedback'] = {'u2': ('u1', delay_n_e)}

# Optimize
res = opt.optimize(options=opts)

# Extract variable profiles
x_res = res['x']
u1_res = res['u1']
u2_res = res['u2']
time_res = res['time']

# Plot results
plt.plot(time_res, x_res, time_res, u1_res, time_res, u2_res)
plt.hold(True)
plt.plot(time_res+delay, u1_res, '--')
plt.hold(False)
plt.legend(('x', 'u1', 'u2', 'delay(u1)'))
plt.show()
</programlisting>

            <para>The resulting control and state profiles are shown in <xref
            linkend="opt-fig-delayed-feedback"/>. Notice that <inlineequation>
                <m:math display="inline">
                  <m:mi>x</m:mi>
                </m:math>
              </inlineequation> grows initially since <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>u</m:mi>

                    <m:mi>1</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation> is set positive to exploit the greater control
            gain that appears delayed through <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>u</m:mi>

                    <m:mi>2</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation>. At time <inlineequation>
                <m:math display="inline">
                  <m:mi>1 - </m:mi>

                  <m:msub>
                    <m:mi>t</m:mi>

                    <m:mi>delay</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation>, the delayed value of <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>u</m:mi>

                    <m:mi>1</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation> ceases to influence <inlineequation>
                <m:math display="inline">
                  <m:mi>x</m:mi>
                </m:math>
              </inlineequation> within the horizon, and <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>u</m:mi>

                    <m:mi>1</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation> immediately switches sign to drive down
            <inlineequation>
                <m:math display="inline">
                  <m:mi>x</m:mi>
                </m:math>
              </inlineequation> to its final value <inlineequation>
                <m:math display="inline">
                  <m:mi>x(1) = 0</m:mi>
                </m:math>
              </inlineequation>.</para>

            <figure xml:id="opt-fig-delayed-feedback">
              <title>Optimization result for delayed feedback example.</title>

              <mediaobject>
                <imageobject>
                  <imagedata fileref="images/delayed_feedback_opt.svg"
                             scalefit="1" width="60%"/>
                </imageobject>
              </mediaobject>
            </figure>
          </section>
        </section>
      </section>
    </section>
  </section>

  <section xml:id="opt_sec_pseudo-spectral">
    <title>Optimization of ODEs using Pseduo-Spectral methods</title>

    <para>The automatic differentiation tool CasADi is connected to IPOPT. The
    collocation algorithms are the Gauss Pseudospectral-, the Legendre
    Pseudospectral- and the Radau Pseudospectral-method. These methods can be
    used either as a local method or a global method where in the local case
    the time horizon is discretized into elements and each element is
    approximated with a polynomial. In the global case, a polynomial is used
    over the complete time horizon. For a mathematic overview of the methods,
    see the Python API documentation for the class
    <literal>PseudoSpectral</literal>.</para>

    <para>This section relies on a model format called FMUX, and the Python
    class <literal>CasadiModel</literal>. These are supported in
    JModelica.org, but no longer used for the main CasADi-based optimization
    tool chain. For more information about the FMUX format and the
    <literal>CasadiModel</literal> class, see the JModelica.org-1.12 User
    Guide, available from <link
    xlink:href="http://jmodelica.org/page/236">http://jmodelica.org/page/236</link>.</para>

    <para>The implementation resides in the module
    <literal>casadi_interface</literal> and contains a model class
    <literal>CasadiModel</literal>. A compiler method for creating models
    compliant with <literal>CasadiModel</literal> resides in
    <literal>pymodelica</literal>, <literal>compile_fmux</literal>. Usage of
    the methods is consistent with the work flow for optimization of
    <literal>JMUModels</literal>. Shown below is a Python code example
    describing how to invoke the optimization method.</para>

    <programlisting language="python">from pymodelica import compile_fmux
from pyjmi import CasadiModel

casadi_name = compile_fmux("MyModel", "MyModels.mop")
model = CasadiModel(casadi_name)

res = model.optimize(algorithm="CasadiPseudoSpectral")

#Plot...
</programlisting>

    <para>As can be seen from the above code example the real difference from
    the native optimization method is that here we use a different model class
    and a different compilation class, except from that, it can be used in
    similar fashion.</para>

    <section>
      <title>Options</title>

      <para>Options can be viewed and set via the options dictionary which can
      then be passed to the optimize call. The option dictionary can be
      retrieved with the below code example where <literal>model</literal> is
      a <literal>CasadiModel</literal> instance. It is also shown how to use
      the interactive help.</para>

      <programlisting language="python">opts = model.optimize_options(algorithm="CasadiPseudoSpectralAlg")

opts? #View the help text</programlisting>

      <para>To provide the options to the optimize call, use the options
      attribute.</para>

      <programlisting language="python">res = model.optimize(algorithm="CasadiPseudoSpectralAlg", options=opts)</programlisting>

      <para>In <xref linkend="opt-tab-pseudo-opts"/> the options for the
      PseudoSpectral methods are shown.<table xml:id="opt-tab-pseudo-opts">
          <title>Options for the Pseudospectral optimization
          algorithms.</title>

          <tgroup cols="3">
            <colspec align="left" colname="col–opt" colwidth="1*"/>

            <colspec align="left" colname="col–desc" colwidth="1*"/>

            <colspec align="left" colname="col–def" colwidth="2*"/>

            <thead>
              <row>
                <entry align="center">Option</entry>

                <entry align="center">Default</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>n_e</literal></entry>

                <entry>1</entry>

                <entry>Number of elements of the finite element mesh.</entry>
              </row>

              <row>
                <entry><literal>n_cp</literal></entry>

                <entry>20</entry>

                <entry>Number of collocation points in each element. Values
                between 1 and 80 are supported.</entry>
              </row>

              <row>
                <entry><literal>discr</literal></entry>

                <entry>"LG"</entry>

                <entry>Determines the discretization of the problem. Can be
                either "LG" (Legendre-Gauss), LGR (Legendre-Gauss-Radau), LGL
                (Legendre-Gauss-Lobatto).</entry>
              </row>

              <row>
                <entry><literal>link_options</literal></entry>

                <entry>[] (not used)</entry>

                <entry>This option allows users to specify states that are
                allowed to be discontinuous between phases (elements) and to
                connect the transition with a model parameter. Example,
                [(1,"x1","dx1")], this allowes the variable x1 to be
                discontinuous between phase 1 and 2 with the parameter dx1.
                The generating constraint becomes, x1_N^1 - x1_0^2 - dx1 = 0.
                There is no limit that the same parameter can be used in
                multiple transition such as, [(1,"x1","dx1"), (1,"x2","dx1"),
                (2,"x1","dx1")]</entry>
              </row>

              <row>
                <entry>phase_options</entry>

                <entry>None (not used)</entry>

                <entry>This options allows users to connect parameters to
                phase boundaries (time). Example, in a three phase problem the
                parameters t1 and t2 can be specified to be the boundaries of
                the phases such as, ["t1", "t2"], the option free_phases have
                also be set to true. Default: None</entry>
              </row>

              <row>
                <entry>free_phases</entry>

                <entry>False</entry>

                <entry>Specifies if the location of the phases should be
                allowed to be changed by the optimizer. Default: False</entry>
              </row>

              <row>
                <entry><literal>init_traj</literal></entry>

                <entry>None (i.e. not used, set this argument to activate
                initialization)</entry>

                <entry>Variable trajectory data used for initialization of the
                optimization problem. The data is represented by an object of
                the type
                <literal>pyjmi.common.io.ResultDymolaTextual.</literal></entry>
              </row>

              <row>
                <entry><literal>result_file_name</literal></entry>

                <entry>Empty string (default generated file name will be
                used)</entry>

                <entry>Specifies the name of the file where the optimization
                result is written. Setting this option to an empty string
                results in a default file name that is based on the name of
                the optimization class.</entry>
              </row>

              <row>
                <entry><literal>result_format</literal></entry>

                <entry>'txt'</entry>

                <entry>Specifies in which format to write the result.
                Currently only textual mode is supported.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>Options that need a little more attention are the
      <literal>free_phase</literal>s, <literal>link_options</literal> and
      <literal>phase_options</literal>. These options allows a user to setup a
      problem involving discontinuities. As an example, say that in a model a
      state is allowed to be changed discontinuous at an arbitrary time point,
      <literal>tp</literal>, with the parameter <literal>dv</literal>. See
      <xref linkend="opt-fig-disc"/>.</para>

      <figure xml:id="opt-fig-disc">
        <title>Handling of discontinuities.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/phase.png"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>In this case we set up the solver to use two elements (phases) and
      at the phase boundary we impose an extra constraint that our state in
      phase one plus the discontinuity should be equal to our state in phase
      two.</para>

      <programlisting language="python">opts = model.optimize_options(algorithm="CasadiPseudoSpectralAlg")

opts["n_e"]=2 #Two elements
opts["link_options"] = [(1,"v","dv")]   # The parameter dv should be connected
                                        # between phase 1 and 2 to variable v
opts["phase_options"] = ["t1"]          # The parameter t1 connects phase 1 and 2
opts["free_phases"] = True              # The phase boundary is allowed to be changed.
</programlisting>

      <para>Note that the parameters <literal>dv</literal> and
      <literal>t1</literal> should be defined in the model and should be set
      to free.</para>
    </section>

    <section>
      <title>Examples</title>

      <para>In the following subsections it will be shown how to use the
      PseudoSpectral methods on <literal>Optimica</literal> models.</para>

      <section>
        <title>Van der Pol oscillator</title>

        <para>This example shows the well known Van der Pol (VDP) oscillator
        being optimized as an optimal control problem. The formulation is
        somewhat different than in previous example of the VDP problem, as
        here there is no extra <literal>cost</literal> state, instead the cost
        function have been directly defined in the Lagrange term
        (objectiveIntegrand). There is also no bounds on <literal>u</literal>.
        Below, the <literal>Optimica</literal> for the example is
        shown.</para>

        <programlisting language="optimica">optimization VDP_Opt (objectiveIntegrand = (x1^2 + x2^2 + u^2),
                         startTime = 0,
                         finalTime = 20)

    // State start values
    parameter Real x1_0 = 0;
    parameter Real x2_0 = 1;

    // The states
    Real x1(start = x1_0, fixed=true);
    Real x2(start = x2_0, fixed=true);

    // The control signal
    input Real u;

  equation
    der(x1) = (1 - x2^2) * x1 - x2 + u;
    der(x2) = x1;
  end VDP_Opt;</programlisting>

        <para>To compile and load the VDP model into JModelica.org we first
        import the necessary Python modules. Then we call the compiler method
        and we load it into our model class. Finally the optimization is
        performed by a call to the optimize method. An extra note in this
        example is that we change the number of collocation points from the
        default 20 to 40 via the options dictionary.</para>

        <programlisting language="python">from pymodelica import compile_fmux
from pyjmi import CasadiModel

casadi_name = compile_fmux("VDP_Opt", "VDP.mop")
model = CasadiModel(casadi_name)

# Get the options dictionary
opts = model.optimize_options(algorithm="CasadiPseudoSpectralAlg")
opts["n_cp"] = 40 # Number of collocation points

res = model.optimize(algorithm="CasadiPseudoSpectralAlg", options=opts)

#Plot...</programlisting>

        <para>The result can then be used to visualize the result and a
        resulting figure is shown in <xref
        linkend="opt-fig-vdp-casadi"/>.</para>

        <figure xml:id="opt-fig-vdp-casadi">
          <title>The Van der Pol oscillator optimized using Gauss
          PseudoSpectral method.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/vdp_casadi.svg" scalefit="1"
                         width="60%"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>Hohmann Transfer</title>

        <para>This example will show how to use the pseudo-spectral method for
        solving a problem of altitude change of a satellite orbiting earth.
        The problem have a well known solution called a Hohmann Transfer from
        the German scientist Walter Hohmann. The solution consists of two
        rocket burns, one for leaving the current orbit and one when the final
        orbit have been reached, both perpendicular to the radial component in
        a rotation coordinating system. The magnitude of the rocket burns can
        also be calculated theoretically.</para>

        <para>We will solve this problem using the gauss pseudo-spectral
        method with two phases. The phases will be connected in such a way
        that the velocities are allowed to be discontinuous, see <xref
        linkend="opt-fig-disc"/> . The magnitude of the discontinuity will
        correspond to the first rocket burn. The second rocket burn are
        connected as constraints at the final time.</para>

        <para>We start by setting up our model of a planar two-body system
        where the bodies are the earth and the satellite. We also scale the
        problem with the orbital time and the radius of the earth.</para>

        <programlisting language="modelica">model Orbital
  //"State variables"
  Real x(fixed=true,start=x0);
  Real y(fixed=true,start=y0);
  Real vx(fixed=true,start=vx0);
  Real vy(fixed=true,start=vy0);
  
  //"Initial values"
  parameter Real x0=rStart;
  parameter Real y0=0;
  parameter Real vx0=0;
  parameter Real vy0=vStart;
  
  //"Constants"
  constant Real G=6.67384e-11 "Gravitational Constant";
  constant Real M=5.9742e24 "Earth Mass";
  constant Real R=6.371e6 "Earth Radii";
  
  //"Parameters"
  parameter Real my=G*M/R^3*T^2;
  parameter Real T=5400; //Orbital time of rStart

  parameter Real rFinal = rStart*2 "Radii of final orbit";
  parameter Real rStart = (R+300e3)/R "Radii of start orbit";
  parameter Real vStart = 7730/R*T "Velocity of start orbit";
  
equation //Equation of motion of a planar two-body problem
  der(x)=vx;
  der(y)=vy;
  der(vx)=-x*my/(x^2+y^2)^(3/2);
  der(vy)=-y*my/(x^2+y^2)^(3/2);
end Orbital;</programlisting>

        <para>Our starting orbit is 300 km above the earths surface and our
        target orbit is 6971 km.</para>

        <para>Next, we set up our optimization problem.</para>

        <programlisting language="optimica">optimization HohmannTransfer(objective=(dx1^2+dy1^2)^0.5+(dx2^2+dy2^2)^0.5, startTime=0, finalTime(free=true,min=0.5,max=10,initialGuess=0.8))
  extends Orbital;

  //"Rocket burns"
  parameter Real dx1(free=true,min=-2,max=2,start=0.05);
  parameter Real dy1(free=true,min=-2,max=2,start=0.05);
  parameter Real dx2(free=true,min=-2,max=2,start=0.05);
  parameter Real dy2(free=true,min=-2,max=2,start=0.05);
  
  //"Time for firing the first rockets"
  parameter Real t1(free=true,min=0.001,max=0.01, start=0.005);

constraint
  (x(finalTime)^2+y(finalTime)^2)^0.5=rFinal; //"Final position constraint"
  (vx(finalTime)+dx2)^2+(vy(finalTime)+dy2)^2=my/rFinal; //"Final velocity"
  x(finalTime)*(vx(finalTime)+dx2)+y(finalTime)*(vy(finalTime)+dy2)=0; //"Final Radial velocity component"
end HohmannTransfer;</programlisting>

        <para>As can be seen from the above the code, our objective is to
        minimize the rocket burns (d1 and d2) with the final time unknown. The
        constraints are set on the final position (circular) and on the final
        velocities so that we are actually staying in the target orbit. There
        is also a parameter t1 set to be free which will be connected to the
        problem via Python and will be used to specify the time of the first
        rocket burn. From the problem, one can also see that dx1 and dy1 are
        not included in the problem, except for the objective. They will be
        connected via Python and determine the velocity changes between phase
        1 and phase 2. Note that in the following scripts the models have been
        stored as <literal>Hohmann.mop</literal> .</para>

        <para>We start our script by importing the necessary modules and
        methods for compiling the two different models and also for loading
        the compiled models into the JModelica.org framework. Note that it is
        necessary to disable the compiler option
        <literal>normalize_minimum_time_problems</literal> when solving
        problems with free start or final time using this algorithm.</para>

        <programlisting language="python">import numpy as N
import matplotlib.pyplot as plt

from pymodelica import compile_fmu
from pyfmi import load_fmu

from pymodelica import compile_fmux
from pyjmi import CasadiModel

jmu_name  = compile_fmu("Orbital","Hohmann.mop")
comp_opts = {"normalize_minimum_time_problems": False}
fmux_name = compile_fmux("HohmannTransfer", "Hohmann.mop", compiler_options=comp_opts)
</programlisting>

        <para>Next, the optimization model needs to be loaded and options
        specified.</para>

        <programlisting language="python"># Optimization
model = CasadiModel(fmux_name)
    
opts = model.optimize_options(algorithm="CasadiPseudoSpectralAlg")

opts["n_cp"] = 40                                      # Number of collocation points
opts["n_e"] = 2                                        # Number of phases
opts["free_phases"] = True                             # The phase boundary is allowed to be changed in time
opts["phase_options"] = ["t1"]                         # The phase boundary is connected to variable t1
opts["link_options"] = [(1,"vy","dy1"),(1,"vx","dx1")] # Allow for discontinuities between phase 1 and 2 for vy and vx.
                                                       # The discontinuities are connected by dy1 and dx1</programlisting>

        <para>In the above code we have loaded our optimization model
        <literal>fmux_name</literal> into a class,
        <literal>CasadiModel</literal>. Our options dictionary is retrieved by
        calling the optimization options method with our method of choice as
        input, <literal>CasadiPseudoSpectral</literal>. We then specify the
        number of collocation points in each phase and also the number of
        phases. The next options are a bit more interesting. The option
        <literal>free_phases</literal> specifies that the boundary between
        phase 1 and phase 2 are allowed to be changed by the optimizer and the
        <literal>phase_options</literal> specifies that the boundary should be
        connected to the parameter <literal>t1</literal> in the model where we
        also have specified constraints on the parameter. Finally we connect
        the first rocket burn (dx1 and dy1) to the corresponding variables, dx
        and dy, allowing them to be changed on the phase boundary.</para>

        <para>Now we are ready to optimize our problem.</para>

        <programlisting language="python"># Optimize
res_opt = model.optimize(algorithm="CasadiPseudoSpectralAlg",options=opts)
    
# Get results
dx1,dy1,dx2,dy2 = res_opt.final("dx1"), res_opt.final("dy1"), res_opt.final("dx2"), res_opt.final("dy2")
r1,r2,my        = res_opt.final("rStart"), res_opt.final("rFinal"), res_opt.final("my")
tf,t1           = res_opt.final("time"), res_opt.final("t1")</programlisting>

        <para>The above code performs the optimization and also retrieves the
        values used to verify the solution.</para>

        <para>To verify the solution we perform simulations using the
        resulting rocket burns and even simulate further in time to verify
        that we are staying in the targeted orbit.</para>

        <programlisting language="python"># Verify solution by simulation
model = load_fmu(fmu_name)
    
# Simulation of Phase 1
res = model.simulate(final_time=t1,options={'ncp':100,'solver':"CVode"})

x_phase_1,y_phase_1 = res["x"], res["y"]
    
# Simulation of Phase 2
model.set("vx",dx1+res["vx"][-1])
model.set("vy",dy1+res["vy"][-1])

res = model.simulate(start_time=t1,final_time=tf,options={'ncp':100,'solver':"CVode","initialize":False})

x_phase_2,y_phase_2 = res["x"], res["y"]

# Simulation of Phase 3 (verify that we are still in orbit)
model.set("vx",dx2+res["vx"][-1])
model.set("vy",dy2+res["vy"][-1])

res = model.simulate(start_time=tf,final_time=tf*2,options={'ncp':100,'solver':"CVode","initialize":False})

x_phase_3,y_phase_3 = res["x"], res["y"]</programlisting>

        <para>In the above simulation code we used the model compiled in the
        beginning of the script ,<literal>"Orbital"</literal> and then
        performed three simulations. One for the first phase, one for the
        second phase and finally an extra simulation for verification. In
        between the simulations we added the calculated rocket burns to the
        velocities and also retrieved the result.</para>

        <para>Next, we set up the figure where we plot the the initial and
        target orbit together with the earth and the satellite trajectory. We
        also plot the rocket burns.</para>

        <programlisting language="python"># Plot Earth
r = 1.0
xE = r*N.cos(N.linspace(0,2*N.pi,200))
yE = r*N.sin(N.linspace(0,2*N.pi,200))
plt.plot(xE,yE,label="Earth")

# Plot Orbits
r = res.final("rStart")
xS = r*N.cos(N.linspace(0,2*N.pi,200))
yS = r*N.sin(N.linspace(0,2*N.pi,200))
plt.plot(xS,yS,label="Low Orbit")

r = res.final("rFinal")
xSE = r*N.cos(N.linspace(0,2*N.pi,200))
ySE = r*N.sin(N.linspace(0,2*N.pi,200))
plt.plot(xSE,ySE,label="High Orbit")
        
# Plot Satellite trajectory
x_sim=N.hstack((N.hstack((x_phase_1,x_phase_2)),x_phase_3))
y_sim=N.hstack((N.hstack((y_phase_1,y_phase_2)),y_phase_3))

plt.plot(x_sim,y_sim,"-",label="Satellite")
        
# Plot Rocket Burns
plt.arrow(x_phase_1[-1],y_phase_1[-1],0.5*dx1,0.5*dy1, width=0.01,label="dv1")
plt.arrow(x_phase_2[-1],y_phase_2[-1],0.5*dx2,0.5*dy2, width=0.01,label="dv2")
        
plt.legend()
plt.show()</programlisting>

        <para>In <xref linkend="fig-opt-satellite-final"/> the result is
        visualized. The arrows represents the rocket burns.</para>

        <figure xml:id="fig-opt-satellite-final">
          <title>Hohmann Transfer</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/satellite_final.png" scalefit="1"
                         width="60%"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <section>
      <title>Limitations</title>

      <para>Current limitations for the PseudoSpectral methods include,</para>

      <itemizedlist>
        <listitem>
          <para>Final time or start time cannot be explicitly in the cost
          function. Although states of final time /start time can be
          used.</para>
        </listitem>

        <listitem>
          <para>No path constraints. However variable bounds can be
          used.</para>
        </listitem>

        <listitem>
          <para>Only explicit ordinary differential equations.</para>
        </listitem>

        <listitem>
          <para>Still under development and not extensively tested, consider
          using <literal>JMUModel.optimize</literal> as a first choice.</para>
        </listitem>

        <listitem>
          <para>No support for scaling.</para>
        </listitem>

        <listitem>
          <para>Parameters cannot be set after compilation.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Derivative-Free Model Calibration of FMUs</title>

    <para><figure xml:id="opt-fig-furuta">
        <title>The Furuta pendulum.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/furuta-image.png" scale="50"/>
          </imageobject>
        </mediaobject>
      </figure>This tutorial demonstrates how to solve a model calibration
    problem using an algorithm that can be applied to Functional Mock-up
    Units. The model to be calibrated is the Furuta pendulum shown in <xref
    linkend="opt-fig-furuta"/>. The Furuta pendulum consists of an arm
    rotating in the horizontal plane and a pendulum which is free to rotate in
    the vertical plane. The construction has two degrees of freedom, the angle
    of the arm, <inlineequation>
        <m:math display="inline">
          <m:mi>φ</m:mi>
        </m:math>
      </inlineequation>, and the angle of the pendulum, <inlineequation>
        <m:math display="inline">
          <m:mi>θ</m:mi>
        </m:math>
      </inlineequation>. Copy the file
    <filename>$JMODELICA_HOME/Python/pyjmi/examples/files/FMUs/Furuta.fmu</filename>
    to your working directory. <emphasis role="bold">Note that this the
    Furuta.fmu file is currently only supported on Windows.</emphasis>
    Measurement data for <inlineequation>
        <m:math display="inline">
          <m:mi>φ</m:mi>
        </m:math>
      </inlineequation> and <inlineequation>
        <m:math display="inline">
          <m:mi>θ</m:mi>
        </m:math>
      </inlineequation> is available in the file
    <filename>$JMODELICA_HOME/Python/pyjmi/examples/files/FurutaData.mat</filename>.
    Copy this file to your working directory as well. These measurements will
    be used for the calibration. Open a text file, name it
    <filename>furuta_par_est.py</filename> and enter the following
    imports:</para>

    <programlisting language="python">from scipy.io.matlab.mio import loadmat
import matplotlib.pyplot as plt
import numpy as N
from pyfmi import load_fmu
from pyjmi.optimization import dfo
</programlisting>

    <para>Then, enter code for opening the data file and extracting the
    measurement time series:</para>

    <programlisting language="python"># Load measurement data from file
data = loadmat('FurutaData.mat',appendmat=False)
# Extract data series
t_meas = data['time'][:,0]
phi_meas = data['phi'][:,0]
theta_meas = data['theta'][:,0]
</programlisting>

    <para>Now, plot the measurements:</para>

    <programlisting language="python"># Plot measurements
plt.figure (1)
plt.clf()
plt.subplot(2,1,1)
plt.plot(t_meas,theta_meas,label='Measurements')
plt.title('theta [rad]')
plt.legend(loc=1)
plt.grid ()
plt.subplot(2,1,2)
plt.plot(t_meas,phi_meas,label='Measurements')
plt.title('phi [rad]')
plt.legend(loc=1)
plt.grid ()
plt.show ()
</programlisting>

    <para>This code should generate <xref linkend="opt-fig-furuta-meas"/>
    showing the measurements of <inlineequation>
        <m:math display="inline">
          <m:mi>θ</m:mi>
        </m:math>
      </inlineequation> and <inlineequation>
        <m:math display="inline">
          <m:mi>φ</m:mi>
        </m:math>
      </inlineequation>.</para>

    <figure xml:id="opt-fig-furuta-meas">
      <title>Measurements of <inlineequation>
          <m:math display="inline">
            <m:mi>θ</m:mi>
          </m:math>
        </inlineequation> and <inlineequation>
          <m:math display="inline">
            <m:mi>φ</m:mi>
          </m:math>
        </inlineequation> for the Furuta pendulum.</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/furuta_meas.svg" scalefit="1" width="60%"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>To investigate the accuracy of the nominal parameter values in the
    model, we shall now simulate the model:</para>

    <programlisting language="python"># Load model
model = load_fmu("Furuta.fmu")
# Simulate model response with nominal parameters
res = model.simulate(start_time=0.,final_time=40)
# Load simulation result
phi_sim = res['armJoint.phi']
theta_sim = res['pendulumJoint.phi']
t_sim = res['time']
</programlisting>

    <para>Then, we plot the simulation result:</para>

    <programlisting language="python"># Plot simulation result
plt.figure (1)
plt.subplot(2,1,1)
plt.plot(t_sim,theta_sim,'--',label='Simulation nominal parameters')
plt.legend(loc=1)
plt.subplot(2,1,2)
plt.plot(t_sim,phi_sim,'--',label='Simulation nominal parameters')
plt.xlabel('t [s]')
plt.legend(loc=1)
plt.show ()
</programlisting>

    <para><xref linkend="opt-fig-furuta-meas-nomsim"/> shows the simulation
    result together with the measurements.</para>

    <figure xml:id="opt-fig-furuta-meas-nomsim">
      <title>Measurements and model simulation result for <inlineequation>
          <m:math display="inline">
            <m:mi>φ</m:mi>
          </m:math>
        </inlineequation> and <inlineequation>
          <m:math display="inline">
            <m:mi>θ</m:mi>
          </m:math>
        </inlineequation> when using nominal parameter values in the Furuta
      pendulum model.</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/furuta_meas_nomsim.svg" scalefit="1"
                     width="60%"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>As can be seen, the simulation result does not quite agree with the
    measurements. We shall now attempt to calibrate the model by estimating
    the two following model parameters:</para>

    <itemizedlist>
      <listitem>
        <para><inlineequation>
            <m:math display="inline">
              <m:msub>
                <m:mi>c</m:mi>

                <m:mi>arm</m:mi>
              </m:msub>
            </m:math>
          </inlineequation>: arm friction coefficient (nominal value
        0.012)</para>
      </listitem>

      <listitem>
        <para><inlineequation>
            <m:math display="inline">
              <m:msub>
                <m:mi>c</m:mi>

                <m:mi>pend</m:mi>
              </m:msub>
            </m:math>
          </inlineequation>: pendulum friction coefficient (nominal value
        0.002)</para>
      </listitem>
    </itemizedlist>

    <para>The calibration will be performed using the Nelder-Mead simplex
    optimization algorithm. The objective function, i.e. the function to be
    minimized, is defined as:</para>

    <para><inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/furuta-cost.png" scale="30"/>
        </imageobject>
      </inlinemediaobject></para>

    <para>where <inlineequation>
        <m:math display="inline">
          <m:msub>
            <m:mi>t</m:mi>

            <m:mi>i</m:mi>
          </m:msub>
        </m:math>
      </inlineequation>, i = 1,2,...,M, are the measurement time points and
    <inlineequation>
        <m:math display="inline">
          <m:msup>
            <m:mrow>
              <m:mo>[</m:mo>

              <m:mtable>
                <m:mtr>
                  <m:mtd>
                    <m:msub>
                      <m:mi>c</m:mi>

                      <m:mi>arm</m:mi>
                    </m:msub>
                  </m:mtd>

                  <m:mtd>
                    <m:msub>
                      <m:mi>c</m:mi>

                      <m:mi>pend</m:mi>
                    </m:msub>
                  </m:mtd>
                </m:mtr>
              </m:mtable>

              <m:mo>]</m:mo>
            </m:mrow>

            <m:mi>T</m:mi>
          </m:msup>
        </m:math>
      </inlineequation> is the parameter vector. <inlineequation>
        <m:math display="inline">
          <m:msup>
            <m:mi>φ</m:mi>

            <m:mi>meas</m:mi>
          </m:msup>
        </m:math>
      </inlineequation> and <inlineequation>
        <m:math display="inline">
          <m:msup>
            <m:mi>θ</m:mi>

            <m:mi>meas</m:mi>
          </m:msup>
        </m:math>
      </inlineequation> are the measurements of <inlineequation>
        <m:math display="inline">
          <m:mi>φ</m:mi>
        </m:math>
      </inlineequation> and <inlineequation>
        <m:math display="inline">
          <m:mi>θ</m:mi>
        </m:math>
      </inlineequation>, respectively, and <inlineequation>
        <m:math display="inline">
          <m:msup>
            <m:mi>φ</m:mi>

            <m:mi>sim</m:mi>
          </m:msup>
        </m:math>
      </inlineequation> and <inlineequation>
        <m:math display="inline">
          <m:msup>
            <m:mi>θ</m:mi>

            <m:mi>sim</m:mi>
          </m:msup>
        </m:math>
      </inlineequation> are the corresponding simulation results. Now, add
    code defining a starting point for the algorithm (use the nominal
    parameter values) as well as lower and upper bounds for the
    parameters:<programlisting language="python"># Choose starting point
x0 = N.array([0.012,0.002])*1e3
# Choose lower and upper bounds (optional)
lb = N.zeros (2)
ub = (x0 + 1e-2)*1e3
</programlisting>Note that the values are scaled with a factor <inlineequation>
        <m:math display="inline">
          <m:msup>
            <m:mi>10</m:mi>

            <m:mi>3</m:mi>
          </m:msup>
        </m:math>
      </inlineequation>. This is done to get a more appropriate variable size
    for the algorithm to work with. After the optimization is done, the
    obtained result is scaled back again. In this calibration problem, we
    shall use multiprocessing, i.e., parallel execution of multiple processes.
    All objective function evaluations in the optimization algorithm will be
    performed in separate processes in order to save memory and time. To be
    able to do this we need to define the objective function in a separate
    Python file and provide the optimization algorithm with the file name.
    Open a new text file, name it <filename>furuta_cost.py</filename> and
    enter the following imports:</para>

    <programlisting language="python">from pyfmi import load_fmu
from pyjmi.optimization import dfo
from scipy.io.matlab.mio import loadmat
import numpy as N
</programlisting>

    <para>Then, enter code for opening the data file and extracting the
    measurement time series:</para>

    <programlisting language="python"># Load measurement data from file
data = loadmat('FurutaData.mat',appendmat=False)
# Extract data series
t_meas = data['time'][:,0]
phi_meas = data['phi'][:,0]
theta_meas = data['theta'][:,0]
</programlisting>

    <para>Next, define the objective function, it is important that the
    objective function has the same name as the file it is defined in (except
    for .py):</para>

    <programlisting language="python"># Define the objective function
def furuta_cost(x):
    # Scale down the inputs x since they are scaled up
    # versions of the parameters (x = 1e3*[param1,param2])
    armFrictionCoefficient = x[0]/1e3
    pendulumFrictionCoefficient = x[1]/1e3
    # Load model
    model = load_fmu('../Furuta.fmu')
    # Set new parameter values into the model
    model.set('armFriction',armFrictionCoefficient)
    model.set('pendulumFriction',pendulumFrictionCoefficient)
    # Simulate model response with new parameter values
    res = model.simulate(start_time=0.,final_time=40)
    # Load simulation result
    phi_sim = res['armJoint.phi']
    theta_sim = res['pendulumJoint.phi']
    t_sim = res['time']
    # Evaluate the objective function
    y_meas = N.vstack((phi_meas ,theta_meas))
    y_sim = N.vstack((phi_sim,theta_sim))
    obj = dfo.quad_err(t_meas,y_meas,t_sim,y_sim)  
    return obj
</programlisting>

    <para>This function will later be evaluated in temporary sub-directories
    to your working directory which is why the string '../' is added to the
    FMU name, it means that the FMU is located in the parent directory. The
    Python function <literal>dfo.quad_err</literal> evaluates the objective
    function. Now we can finally perform the actual calibration. Solve the
    optimization problem by calling the Python function
    <literal>dfo.fmin</literal> in the file named
    <filename>furuta_par_est.py</filename>:</para>

    <programlisting language="python"># Solve the problem using the Nelder-Mead simplex algorithm
x_opt,f_opt,nbr_iters,nbr_fevals,solve_time = dfo.fmin("furuta_cost.py",
xstart=x0,lb=lb,ub=ub,alg=1,nbr_cores=4,x_tol=1e-3,f_tol=1e-2)
</programlisting>

    <para>The input argument <literal>alg</literal> specifies which algorithm
    to be used, <literal>alg=1</literal> means that the Nelder-Mead simplex
    algorithm is used. The number of processor cores
    (<literal>nbr_cores</literal>) on the computer used must also be provided
    when multiprocessing is applied. Now print the optimal parameter values
    and the optimal function value:</para>

    <programlisting language="python"># Optimal point (don't forget to scale down)
[armFrictionCoefficient_opt ,pendulumFrictionCoefficient_opt] = x_opt/1e3
# Print optimal parameter values and optimal function value
print 'Optimal parameter values:'
print 'arm friction coeff = ' + str(armFrictionCoefficient_opt)
print 'pendulum friction coeff = ' + str(pendulumFrictionCoefficient_opt)
print 'Optimal function value: ' + str(f_opt)
</programlisting>

    <para>This should give something like the following printout:</para>

    <programlisting>Optimal parameter values:
arm friction coeff = 0.00997223923413
pendulum friction coeff = 0.000994473020199
Optimal function value: 1.09943830585
</programlisting>

    <para>Then, we shall set the optimized parameter values into the model and
    simulate it:</para>

    <programlisting language="python"># Load model
model = load_fmu("Furuta.fmu")
# Set optimal parameter values into the model
model.set('armFriction',armFrictionCoefficient_opt)
model.set('pendulumFriction',pendulumFrictionCoefficient_opt)
# Simulate model response with optimal parameter values
res = model.simulate(start_time=0.,final_time=40)
# Load simulation result
phi_opt = res['armJoint.phi']
theta_opt = res['pendulumJoint.phi']
t_opt = res['time']
</programlisting>

    <para>And finally, we plot the simulation result:</para>

    <programlisting language="python"># Plot simulation result
plt.figure (1)
plt.subplot(2,1,1)
plt.plot(t_opt,theta_opt,'-.',linewidth=3,
label='Simulation optimal parameters')
plt.legend(loc=1)
plt.subplot(2,1,2)
plt.plot(t_opt,phi_opt,'-.',linewidth=3,
label='Simulation optimal parameters')
plt.legend(loc=1)
plt.show ()
</programlisting>

    <para>This should generate the <xref linkend="opt-fig-furuta-opt"/>. As
    can be seen, the agreement between the measurements and the simulation
    result has improved considerably. The model has been successfully
    calibrated.</para>

    <figure xml:id="opt-fig-furuta-opt">
      <title>Measurements and model simulation results for <inlineequation>
          <m:math display="inline">
            <m:mi>φ</m:mi>
          </m:math>
        </inlineequation> and <inlineequation>
          <m:math display="inline">
            <m:mi>θ</m:mi>
          </m:math>
        </inlineequation> with nominal and optimal parameters in the model of
      the Furuta pendulum.</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/furuta_optsim_dashed.svg" scalefit="1"
                     width="60%"/>
        </imageobject>
      </mediaobject>
    </figure>
  </section>
</chapter>
