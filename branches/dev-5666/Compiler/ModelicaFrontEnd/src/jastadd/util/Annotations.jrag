/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.NoSuchElementException;

import org.jmodelica.util.collections.ChainedIterator;
import org.jmodelica.util.collections.FilteredIterator;
import org.jmodelica.util.Criteria;

aspect AnnotationAPI {
	/**
	 * Interface for Expression which can be interpreted as some form of Access.
	 */
	public interface AccessLikeExp {}  
	CommonAccessExp implements AccessLikeExp;

    /**
     * Get the annotation node for this AST node's annotation, if any.
     * 
     * This should be overridden for all nodes that can have annotations and need a 
     * non-default evaluator.
     */
    syn AnnotationNode ASTNode.annotation() = annotation(AnnotationNode.DEFAULT_EVALUATOR);

    /**
     * Get the annotation node for this AST node's annotation, if any.
     * 
     * This should be overridden for all nodes that can have annotations.
     */
    syn AnnotationNode ASTNode.annotation(SrcExpEvaluator eval) = AnnotationNode.NO_ANNOTATION;

    /**
     * Get the annotation node for a sub-node of this AST node's annotation, if any.
     * 
     * Path is interpreted as a "/"-separated list of names of nested annotations.
     * 
     * Example:
     * <code>annotation(A(B(C = "foo")));</code>
     * Here the annotation given by the path <code>"A/B/C"</code> has the value <code>"foo"</code>.
     */
    syn AnnotationNode ASTNode.annotation(String path) = annotation().forPath(path);
    
    syn AnnotationNode ASTNode.annotationOfChild(Opt n, SrcExpEvaluator eval) = 
            (n.getNumChild() > 0) ? n.getChild(0).annotation(eval) : createNullAnnotationNode(eval);

    eq SrcComment.annotation(SrcExpEvaluator eval)         = annotationOfChild(getSrcAnnotationOpt(), eval);
    eq SrcParseAnnotation.annotation(SrcExpEvaluator eval) = getSrcClassModification().annotationNode(eval);
    eq SrcModification.annotation(SrcExpEvaluator eval)    = annotationNode(eval);

    eq SrcExternalClause.annotation(SrcExpEvaluator eval) = annotationOfChild(getSrcAnnotationOpt(), eval);
    eq InstExternal.annotation(SrcExpEvaluator eval)      = getSrcExternalClause().annotation(eval);

    eq SrcFullClassDecl.annotation(SrcExpEvaluator eval)           = annotationOfChild(getSrcAnnotationOpt(), eval);
    eq InstClassDecl.annotation(SrcExpEvaluator eval)              = getSrcClassDecl().annotation(eval);
    eq SrcShortClassDecl.annotation(SrcExpEvaluator eval)          = getSrcExtendsClauseShortClass().annotation(eval);
    eq SrcLibNode.annotation(SrcExpEvaluator eval)                 = myClass().annotation(eval);
    eq SrcExtendsClauseShortClass.annotation(SrcExpEvaluator eval) = getSrcComment().annotation(eval);

    eq SrcAbstractEquation.annotation(SrcExpEvaluator eval) = getSrcComment().annotation(eval);

    eq SrcComponentDecl.annotation(SrcExpEvaluator eval)  = getSrcComment().annotation(eval);
    eq InstComponentDecl.annotation(SrcExpEvaluator eval) = getSrcComponentDecl().annotation(eval);

    public class FFunctionDecl     implements FAttributeListAnnotationNode.FAttributeList {}
    public class FVariable         implements FAttributeListAnnotationNode.FAttributeList {}
    public class FAbstractEquation implements FAttributeListAnnotationNode.FAttributeList {}
    public class FClass            implements FAttributeListAnnotationNode.FAttributeList {}
    public class FAttribute        implements FAttributeListAnnotationNode.FAttributeList {}
    
    eq FFunctionDecl.annotation(SrcExpEvaluator eval)     = new FAttributeListAnnotationNode(this, eval);
    eq FVariable.annotation(SrcExpEvaluator eval)         = new FAttributeListAnnotationNode(this, eval);
    eq FAbstractEquation.annotation(SrcExpEvaluator eval) = new FAttributeListAnnotationNode(this, eval);
    eq FClass.annotation(SrcExpEvaluator eval)            = new FAttributeListAnnotationNode(this, eval);

    eq InstExternal.annotation() = annotation(annotationExpEvaluator());
    eq InstNode    .annotation() = annotation(annotationExpEvaluator());

    syn SrcExpEvaluator InstExternal     .annotationExpEvaluator() = parentExpEvaluator();
    syn SrcExpEvaluator InstNode         .annotationExpEvaluator() = parentExpEvaluator();
    eq                  InstFullClassDecl.annotationExpEvaluator() = this;

    inh SrcExpEvaluator InstExternal.parentExpEvaluator();
    inh SrcExpEvaluator InstNode    .parentExpEvaluator();
    eq InstNode.getChild().parentExpEvaluator() = this;

    /**
     * Evaluate exp in the scope of this node.
     */
    public CValue InstNode.ceval(SrcExp exp) {
        return looseExp(exp).ceval();
    }

    /**
     * If exp is an access, try to look it up as a class in the scope of this node, 
     * otherwise return null.
     */
    public InstLookupResult<InstClassDecl> InstNode.lookupInstClass(SrcExp exp) {
        return looseExp(exp).lookupInstClassIfAccess();
    }

    /**
     * If this is an access, try to look it up as a class, otherwise return null.
     */
    syn InstLookupResult<InstClassDecl> FExp.lookupInstClassIfAccess();
    eq FExp         .lookupInstClassIfAccess() = null;
    eq InstAccessExp.lookupInstClassIfAccess() = asInstAccess().lookupInstClassIfAccess();
    
    syn InstLookupResult<InstClassDecl> InstAccess.lookupInstClassIfAccess();
    eq InstAccess     .lookupInstClassIfAccess() = myInstLookupClass();
    eq InstClassAccess.lookupInstClassIfAccess() = myInstLookup();
    eq InstDot        .lookupInstClassIfAccess() = getLastInstAccess().lookupInstClassIfAccess();

    /**
     * If exp is an access, try to look it up as a component in the scope of this node, 
     * otherwise return null.
     */
    public InstLookupResult<InstComponentDecl> InstNode.lookupInstComponent(SrcExp exp) {
        return looseExp(exp).lookupInstComponentIfAccess();
    }

    /**
     * If this is an access, try to look it up as a component, otherwise return null.
     */
    syn InstLookupResult<InstComponentDecl> FExp.lookupInstComponentIfAccess();
    eq FExp         .lookupInstComponentIfAccess() = null;
    eq InstAccessExp.lookupInstComponentIfAccess() = asInstAccess().lookupInstComponentIfAccess();
    
    syn InstLookupResult<InstComponentDecl> InstAccess.lookupInstComponentIfAccess();
    eq InstAccess         .lookupInstComponentIfAccess() = myInstLookupComponent();
    eq InstComponentAccess.lookupInstComponentIfAccess() = myInstLookup();
    eq InstDot            .lookupInstComponentIfAccess() = 
        getLastInstAccess().lookupInstComponentIfAccess();


    syn lazy List<FExp> InstNode.getLooseExpList() = new List<FExp>(new FNoExp());

    eq InstReplacingFullClassDecl       .getLooseExp().lookupInstClass(String name) = 
        getInstClassRedeclare().lookupInstClass(name);
    eq InstReplacingShortClassDecl      .getLooseExp().lookupInstClass(String name) = 
        getInstClassRedeclare().lookupInstClass(name);
    eq InstReplacingSimpleShortClassDecl.getLooseExp().lookupInstClass(String name) = 
        getInstClassRedeclare().lookupInstClass(name);

    private Map<SrcExp,Integer> InstNode.looseExpMap = null;

    /**
     * Instantiates exp and inserts it into tree in the scope of this node, unless already done.
     */
    public FExp InstNode.looseExp(SrcExp exp) {
        if (looseExpMap == null) {
            looseExpMap = new HashMap<>();
        }
        List<FExp> list = getLooseExps();
        int i;
        if (looseExpMap.containsKey(exp)) {
            i = looseExpMap.get(exp);
        } else {
            i = list.getNumChild();
            looseExpMap.put(exp, i);
            FExp instExp = exp.instantiate();
            list.add(instExp);
        }
        return list.getChild(i);
    }

    syn AnnotationNode InstNode.classAnnotation() = myInstClass().annotation();

    /**
     * Experimental! Retreives the annotation representing the modifications.
     */

    syn AnnotationNode SrcElement.modificationAnnotation()       = AnnotationNode.NO_ANNOTATION;
    syn AnnotationNode SrcComponentDecl.modificationAnnotation() = 
        annotationOfChild(getSrcModificationOpt(),      AnnotationNode.DEFAULT_EVALUATOR);
    eq SrcExtendsClause.modificationAnnotation()                 = 
        annotationOfChild(getSrcClassModificationOpt(), AnnotationNode.DEFAULT_EVALUATOR);

    syn AnnotationNode ASTNode         .createNullAnnotationNode(SrcExpEvaluator eval) = 
        AnnotationNode.NO_ANNOTATION;
    eq                 SrcComment      .createNullAnnotationNode(SrcExpEvaluator eval) = 
        new CommentAnnotationNode(this, eval);
    eq                 SrcFullClassDecl.createNullAnnotationNode(SrcExpEvaluator eval) = 
        new FullClassDeclAnnotationNode(this, eval);

    /**
     * Get the annotation node that represents this node when used as an annotation, if 
     * applicable.
     */
    syn      AnnotationNode ASTNode         .annotationNode(SrcExpEvaluator eval);
    syn lazy AnnotationNode SrcModification .annotationNode(SrcExpEvaluator eval);
    syn lazy AnnotationNode SrcExp          .annotationNode(SrcExpEvaluator eval);
    syn lazy AnnotationNode SrcNamedArgument.annotationNode(SrcExpEvaluator eval);
    eq ASTNode                 .annotationNode(SrcExpEvaluator eval) = createNullAnnotationNode(eval);
    eq SrcModification         .annotationNode(SrcExpEvaluator eval) = createNullAnnotationNode(eval);
    eq SrcClassModification    .annotationNode(SrcExpEvaluator eval) = 
        new ClassModAnnotationNode    (this, eval);
    eq SrcValueModification    .annotationNode(SrcExpEvaluator eval) = 
        new ValueModAnnotationNode    (this, eval);
    eq SrcCompleteModification .annotationNode(SrcExpEvaluator eval) = 
        new CompleteModAnnotationNode (this, eval);
    eq SrcComponentModification.annotationNode(SrcExpEvaluator eval) = 
        new ComponentModAnnotationNode(this, eval);
    eq SrcExp                  .annotationNode(SrcExpEvaluator eval) = 
        new EAnnotationNode           (this, eval);
    eq SrcFunctionCall         .annotationNode(SrcExpEvaluator eval) = 
        new FCAnnotationNode          (this, eval);
    eq SrcNamedArgument        .annotationNode(SrcExpEvaluator eval) = 
        new NAAnnotationNode          (this, eval);
    eq FAttribute              .annotationNode(SrcExpEvaluator eval) = 
        new FAttributeAnnotationNode  (this, eval);

    /**
     * Proxy object for evaluating an expression from the source tree.
     */
    public interface SrcExpEvaluator {
        public CValue ceval(SrcExp exp);
        public InstLookupResult<InstClassDecl>     lookupInstClass(SrcExp exp);
        public InstLookupResult<InstComponentDecl> lookupInstComponent(SrcExp exp);
    }

    InstNode implements SrcExpEvaluator;

    /**
     * Describes a node in the tree formed by an annotation.
     */
    public abstract class AnnotationNode implements Iterable<AnnotationNode> {


    	
    	
		/**
		 * Returns the value for a node that represents a list of strings.
		 */
		public ArrayList<String> stringList() {
			return null;
		}

        /**
         * Represents an annotation that does not exist.
         */
        public static final AnnotationNode NO_ANNOTATION = new NullAnnotationNode();

        /**
         * Proxy object for evaluating simple expressions in the source tree.
         */
        public static final SrcExpEvaluator DEFAULT_EVALUATOR = new SrcExpEvaluator() {
            public CValue ceval(SrcExp exp) {
                return exp.ceval();
            }

            public InstLookupResult<InstClassDecl> lookupInstClass(SrcExp exp) {
                return null;
            }

            public InstLookupResult<InstComponentDecl> lookupInstComponent(SrcExp exp) {
                return null;
            }
        };

        /**
         * Finds an annotation node at the given path below this one.
         */
        public final AnnotationNode forPath(String path) {
            return forPath(path.split("/"), 0);
        }

        /**
         * Finds all annotation nodes of the given name that are direct children to this one.
         */
        public final Iterable<AnnotationNode> allFor(final String name) {
            return new Iterable<AnnotationNode>() {
                public Iterator<AnnotationNode> iterator() {
                    return iteratorFor(name);
                };
            };
        }

        /**
         * Iterates over all annotation nodes of the given name that are direct children to this one.
         */
        public Iterator<AnnotationNode> iteratorFor(final String name) {
            Criteria<AnnotationNode> crit = new Criteria<AnnotationNode>() {
                public boolean test(AnnotationNode elem) {
                    return name.equals(elem.name());
                }
            };
            return new FilteredIterator<AnnotationNode>(iterator(), crit);
        }

        /**
         * Creates a new empty annotation node, that if written to adds a new child 
         * of this annotation.
         * 
         * Can be used even if there is already a child with that name, 
         * then the new node will be beside the existing node.
         */
        public AnnotationNode emptyNode(String name) {
            return new AssignableNullAnnotationNode(this, name);
        }

        /**
         * Internal definition of {@link #forPath(String)}.
         * 
         * @param path   the path elements to find
         * @param i      the first index in <code>path</code> to use
         */
        private final AnnotationNode forPath(String[] path, int i) {
            if (i >= path.length)
                return this;
            AnnotationNode node = lookup(path[i]);
            if (node == null)
                node = emptyNode(path[i]);
            return node.forPath(path, i + 1);
        }

        /**
         * Finds an create annotation node at the given path below this one.
         */
        public final AnnotationNode createForPath(String path) {
            return createForPath(path.split("/"), 0);
        }

        /**
         * Internal definition of {@link #forPath(String)}.
         * 
         * @param path   the path elements to find
         * @param i      the first index in <code>path</code> to use
         */
        private final AnnotationNode createForPath(String[] path, int i) {
            if (i >= path.length)
                return this;
            AnnotationNode node = lookup(path[i]);
            if (node == null)
                node = addNode(path[i]);
            return node.createForPath(path, i + 1);
        }

		/**
		 * Check if this annotation node represents a value node.
		 */
		public boolean isValue() {
			return false;
		}
		
		/**
		 * Checks if this annotation node represents an existing annotation.
		 */
		public boolean exists() {
			return true;
		}
		
		/**
		 * Get the name associated with this annotation node, if any.
		 * 
		 * In general, any node reachable with a call to forPath() will have a name.
		 * 
		 * @return the name or <code>null</code>, if no name is available
		 */
		public String name() {
			return null;
		}

        /**
         * Iterate over this node's child annotation nodes.
         */
        public final Iterator<AnnotationNode> iterator() {
            Iterator<AnnotationNode> attrIt = attributeIterator();
            Iterator<AnnotationNode> valueIt = valueIterator();
            if (attrIt != NullAnnotationNode.EMPTY_ITERATOR && valueIt != NullAnnotationNode.EMPTY_ITERATOR)
                return new ChainedIterator<AnnotationNode>(attrIt, valueIt);
            else if (attrIt != NullAnnotationNode.EMPTY_ITERATOR)
                return attrIt;
            else
                return valueIt;
        }

        /**
         * Iterate over this node's child annotation nodes that are declared in
         * an attribute looking way.
         */
        public Iterator<AnnotationNode> attributeIterator() {
            return NullAnnotationNode.EMPTY_ITERATOR;
        }

        /**
         * Iterate over this node's child annotation nodes that are declared in
         * a asignment looking way.
         */
        public Iterator<AnnotationNode> valueIterator() {
            return NullAnnotationNode.EMPTY_ITERATOR;
        }

        /**
         * For a value modification, return toString() of the rhs, for any other 
         * modification, return null.
         */
        public String valueToString() {
            return null;
        }

        /**
         * Calculates and returns the evaluated value of this annotation
         * node (if possible).
         */
        public CValue ceval() {
            return CValue.UNKNOWN;
        }

        /**
         * Returns the value for a node that represents a string value.
         */
        public final String string() {
            try {
                return ceval().stringValue();
            } catch (ConstantEvaluationException e) {
                return null;
            }
        }

        /**
         * Check if this node represents a string value.
         */
        public final boolean isStringValue() {
            try {
                CValue val = ceval();
                return val.isString() && val.isScalar();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Check if this node represents a value modification that is an access.
         */
        public boolean isAccess() {
            return false;
        }

        /**
         * If this annotation was accessed from the instance tree, and this represents a 
         * value that is an access, try to look up that access as a class, and return the 
         * resulting lookup result.
         * 
         * If the requirements are not fulfilled (i.e. instance tree access), this returns null.
         */
        public InstLookupResult<InstClassDecl> lookupInstClass() {
            return null;
        }

        /**
         * If this annotation was accessed from the instance tree, and this represents a 
         * value that is an access, try to look up that access as a component, and return the 
         * resulting lookup result.
         * 
         * If the requirements are not fulfilled (i.e. instance tree access), this returns null.
         */
        public InstLookupResult<InstComponentDecl> lookupInstComponent() {
            return null;
        }

        /**
         * Returns the value for a node that represents a string value, interpreted as 
         * a path of an URI (with protocol file or modelica). A simple path is also 
         * supported, and is interpreted relative to the top containing package, or if 
         * that does not exist, relative to the directory containing the current file.
         */
        public String path() {
            return URIResolver.DEFAULT.resolveInPackage(ast(), string());
        }

        /**
         * Returns the value for a node that represents a list of strings.
         */
        public final String[] stringVector() {
            try {
                CValue val = ceval();
                if (val.isString() && val.isVector()) {
                    return val.stringVector();
                }
            } catch (ConstantEvaluationException e) {}
            return null;
        }

        /**
         * Check if this node represents a list of strings.
         */
        public final boolean isStringVector() {
            try {
                CValue val = ceval();
                return val.isString() && val.isVector();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the value for a node that represents a list of strings, 
         * or a single string value.
         */
        public final String[] asStringVector() {
            if (isStringVector())
                return stringVector();
            else if (isStringValue())
                return new String[] { string() };
            else
                return null;
        }

        /**
         * Returns the value for a node that represents an integer value.
         */
        public final int integer() {
            try {
                CValue val = ceval();
                if (val.hasIntValue()) {
                    return val.intValue();
                }
            } catch (ConstantEvaluationException e) {}
            return 0;
        }

        /**
         * Check if this node represents an integer value.
         */
        public final boolean isIntegerValue() {
            try {
                CValue val = ceval();
                return val.isInteger() && val.isScalar();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the value for a node that represents a real value.
         */
        public final double real() {
            try {
                CValue val = ceval();
                if (val.hasRealValue()) {
                    return val.realValue();
                }
            } catch (ConstantEvaluationException e) {}
            return 0.0;
        }

        /**
         * Check if this node represents a real value.
         */
        public final boolean isRealValue() {
            try {
                CValue val = ceval();
                return val.isReal() && val.isScalar();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the value for a node that represents a vector of real values.
         */
        public final double[] realVector() {
            try {
                CValue val = ceval();
                if (val.isReal() && val.isVector()) {
                    return val.realVector();
                }
            } catch (ConstantEvaluationException e) {}
            return null;
        }

        /**
         * Check if this node represents a vector of real values.
         */
        public final boolean isRealVectorValue() {
            try {
                CValue val = ceval();
                return val.isReal() && val.isVector();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the value for a node that represents a matrix of real values.
         */
        public final double[][] realMatrix() {
            try {
                CValue val = ceval();
                if (val.isReal() && val.isMatrix()) {
                    return val.realMatrix();
                }
            } catch (ConstantEvaluationException e) {}
            return null;
        }

        /**
         * Check if this node represents a matrix of real values.
         */
        public final boolean isRealMatrixValue() {
            try {
                CValue val = ceval();
                return val.isReal() && val.isMatrix();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the value for a node that represents a boolean value.
         */
        public final boolean bool() {
            try {
                CValue val = ceval();
                if (val.hasBooleanValue()) {
                    return val.booleanValue();
                }
            } catch (ConstantEvaluationException e) {}
            return false;
        }

        /**
         * Check if this node represents a boolean value.
         */
        public final boolean isBoolValue() {
            try {
                CValue val = ceval();
                return val.isBoolean() && val.isScalar();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the ast node that this annotation node is connected to.
         */
        protected abstract ASTNode ast();

        /**
         * Returns the exp node that this annotation node is connected to (if possible).
         */
        public SrcExp exp() {
            return null;
        }

        /**
         * Returns the FExp node that this annotation node is connected to (if possible).
         */
        public FExp fExp() {
            return null;
        }

        /**
         * Returns true if the each keyword is set
         * @return true if each is set
         */
        public boolean isEach() {
            return false;
        }

        /**
         * Returns true if the final keyword is set
         * @return true if final is set
         */
        public boolean isFinal() {
            return false;
        }

        /**
         * Returns true if the final keyword is set
         * @return true if final is set
         */
        public int level() {
            return 0;
        }

        /**
         * Returns the vendor specific node for jmodelica. forPath("__Modelon") is done.
         */
        public AnnotationNode vendorNode() {
            return forPath("__Modelon");
        }

        /**
         * Returns the vendor specific node for jmodelica. forPath("__Modelon") is done.
         */
        public AnnotationNode createVendorNode() {
            return createForPath("__Modelon");
        }

        /**
         * Return the string representation of the AST node that this annotation node is connected to.
         */
        public String toString() {
            return (ast() != null) ? ast().toString() : "(no annotation)"; 
        }

        /**
         * Lookup the annotation node with the name <code>name</code> in this
         * annotation node.
         * Default implementation return NO_ANNOTATION node. Sub classes should
         * implement propper behaviour.
         * 
         * An AssignableNullAnnotationNode is created by calling functions if
         * null is returned.
         * 
         * @param name Name of the node.
         * @return An annotation node representation of the node.
         */
        protected AnnotationNode lookup(String name) {
            return NO_ANNOTATION;
        }

        /**
         * Set the expression <code>exp</code> of the node if possible.
         * 
         * @param exp Expresion to set.
         */
        public void setValue(SrcExp exp) {
            throw new AnnotationEditException("Set value is not supported on this type of annotation node (" + getClass().getSimpleName() + ")");
        }

        /**
         * Set the flat expression <code>exp</code> of the node if possible.
         * 
         * @param exp Flat expresion to set.
         */
        public void setValue(FExp exp) {
            throw new AnnotationEditException("Set value is not supported on this type of annotation node (" + getClass().getSimpleName() + ")");
        }

        /**
         * Adds a node with the name <code>name</code> to this node if possible.
         * 
         * @param name Name of the new node.
         * @return An annotation node representation of the new node.
         */
        public AnnotationNode addNode(String name) {
            throw new AnnotationEditException("Add node is not supported on this type of annotation node (" + getClass().getSimpleName() + ")");
        }

        /**
         * Sets the each value for the node (if possible).
         * 
         * @param eachValue New each value that should be set
         */
        public void setEach(boolean eachValue) {
            throw new AnnotationEditException("Set each is not supported on this type of annotation node (" + getClass().getSimpleName() + ")");
        }

        /**
         * Sets the final value for the node (if possible).
         * 
         * @param finalValue New final value that should be set
         */
        public void setFinal(boolean finalValue) {
            throw new AnnotationEditException("Set final is not supported on this type of annotation node (" + getClass().getSimpleName() + ")");
        }

        /**
         * Sets the level for the node (if possible).
         * 
         * @param level New level that should be set
         */
        public void setLevel(int level) {
            throw new AnnotationEditException("Set level is not supported on this type of annotation node (" + getClass().getSimpleName() + ")");
        }

        /**
         * Iterates over the annotation nodes representing the nodes in the list.
         */
        protected static class AnnotationIterator implements Iterator<AnnotationNode> {
            private Iterator<? extends ASTNode> it;
            private AnnotationNode next;
            private SrcExpEvaluator eval;

            public AnnotationIterator(Iterator<? extends ASTNode> it, SrcExpEvaluator eval) {
                this.it = it;
                this.eval = eval;
                update();
            }

            public AnnotationIterator(Iterable<? extends ASTNode> list, SrcExpEvaluator eval) {
                this(list.iterator(), eval);
            }
            
            public boolean hasNext() {
                return next.exists();
            }
            
            public AnnotationNode next() {
                if (!hasNext())
                    throw new NoSuchElementException();
                AnnotationNode res = next;
                update();
                return res;
            }
            
            public void remove() {
                throw new UnsupportedOperationException();
            }
            
            private void update() {
                next = NO_ANNOTATION;
                while (it.hasNext() && !next.exists()) 
                    next = it.next().annotationNode(eval);
            }
        }

		/**
		 * Represents a non-existing annotation.
		 */
		private static class NullAnnotationNode extends AnnotationNode {
			private static final Iterator<AnnotationNode> EMPTY_ITERATOR = 
				new ArrayList<AnnotationNode>().iterator();
			
			public boolean exists() {
				return false;
			}
			
			public String path() {
				return null;
			}

			protected ASTNode ast() {
				return null;
			}
			
        }
    }

    /**
     * Representation a non-existing annotation but with the possibility to add content.
     */
    public final class AssignableNullAnnotationNode extends AnnotationNode {

        private final AnnotationNode parent;
        protected AnnotationNode realNode;
        private final String name;

        /**
         * Creates an instance form a parent annotation node <code>parent</code> and
         * the path name <code>name</code> of this instance. 
         */
        public AssignableNullAnnotationNode(AnnotationNode parent, String name) {
            this.parent = parent;
            this.name = name;
        }

        @Override
        public boolean exists() {
            return realNode != null;
        }

        public AnnotationNode realNode() {
            if (realNode != null)
                return realNode;
            realNode = parent.createForPath(name);
            return realNode;
        }

        @Override
        public CValue ceval() {
            if (exists())
                return realNode().ceval();
            else
                return super.ceval();
        }

        @Override
        public String valueToString() {
            if (exists())
                return realNode().valueToString();
            else
                return super.valueToString();
        }

        @Override
        public boolean isAccess() {
            if (exists())
                return realNode().isAccess();
            else
                return super.isAccess();
        }

        @Override
        public InstLookupResult<InstClassDecl> lookupInstClass() {
            if (exists())
                return realNode().lookupInstClass();
            else
                return super.lookupInstClass();
        }

        public InstLookupResult<InstComponentDecl> lookupInstComponent() {
            if (exists())
                return realNode().lookupInstComponent();
            else
                return super.lookupInstComponent();
        }

        @Override
        public SrcExp exp() {
            if (exists())
                return realNode().exp();
            else
                return super.exp();
        }

        @Override
        public FExp fExp() {
            if (exists())
                return realNode().fExp();
            else
                return super.fExp();
        }

        @Override
        public boolean isEach() {
            if (exists())
                return realNode().isEach();
            else
                return super.isEach();
        }

        @Override
        public boolean isFinal() {
            if (exists())
                return realNode().isFinal();
            else
                return super.isFinal();
        }

        @Override
        public int level() {
            if (exists())
                return realNode().level();
            else
                return super.level();
        }
        
        @Override
        public final void setValue(FExp exp) {
            if (exp != null || exists())
                realNode().setValue(exp);
        }
        
        @Override
        protected AnnotationNode lookup(String path) {
            return realNode == null ? null : realNode.lookup(path);
        }

        @Override
        public AnnotationNode addNode(String path) {
            return realNode().addNode(path);
        }

        @Override
        protected ASTNode ast() {
            return realNode == null ? null : realNode.ast();
        }

        @Override
        public void setEach(boolean eachValue) {
            if (eachValue || exists())
                realNode().setEach(eachValue);
        }

        @Override
        public void setFinal(boolean finalValue) {
            if (finalValue || exists())
                realNode().setFinal(finalValue);
        }

        @Override
        public void setLevel(int level) {
            if (level != 0 || exists())
                realNode().setLevel(level);
        }
    }

    /**
     * Node for representing common entry nodes. These nodes usually only
     * support lookup of sub nodes.
     */
    public abstract class RootAnnotationNode extends AnnotationNode {
    }

    /**
     * A null annotation node for a comment, it adds the possibility to add annotation.
     */
    public class CommentAnnotationNode extends RootAnnotationNode {
        
        private SrcComment comment;
        private SrcExpEvaluator eval;
        /**
         * Constructs an instance with the comment <code>comment</code>.
         */
        public CommentAnnotationNode(SrcComment comment, SrcExpEvaluator eval) {
        	this.eval = eval;
            this.comment = comment;
        }
        
        @Override
        protected AnnotationNode lookup(String path) {
            if (comment.hasSrcAnnotation()) {
                return comment.getSrcAnnotation().annotationNode(eval).lookup(path);
            } else {
                return null;
            }
        }

        @Override
        public AnnotationNode addNode(String path) {
            if (!comment.hasSrcAnnotation()) {
                SrcClassModification cm = new SrcClassModification();
                comment.setSrcAnnotation(new SrcParseAnnotation(cm));
            }
            return comment.getSrcAnnotation().annotationNode(eval).addNode(path);
        }

        @Override
        protected ASTNode ast() {
            return comment;
        }
    
    }
    
    /**
     * A null annotation node for a SrcFullClassDecl, it adds the possibility to add annotation.
     */
    public class FullClassDeclAnnotationNode extends RootAnnotationNode {
 
        private SrcFullClassDecl fullClassDecl;
        private SrcExpEvaluator eval;
        
        /**
         * Constructs an instance with the SrcFullClassDecl <code>fullClassDecl</code>.
         */  
        public FullClassDeclAnnotationNode(SrcFullClassDecl fullClassDecl) {
            this.fullClassDecl = fullClassDecl;
        }
        
        /**
         * Constructs an instance with the SrcFullClassDecl <code>fullClassDecl</code> with 
         * evaluation support.
         */  
        public FullClassDeclAnnotationNode(SrcFullClassDecl fullClassDecl, SrcExpEvaluator eval) {
        	this.fullClassDecl = fullClassDecl;
        	this.eval = eval;
        }

        @Override
        protected ASTNode ast() {
            return fullClassDecl;
        }

        @Override
        protected AnnotationNode lookup(String path) {
            if (fullClassDecl.hasSrcAnnotation()) {
                return fullClassDecl.getSrcAnnotation().annotationNode(eval).lookup(path);
            } else {
                return null;
            }
        }

        @Override
        public AnnotationNode addNode(String path) {
            if (!fullClassDecl.hasSrcAnnotation()) {
                SrcClassModification cm = new SrcClassModification();
                fullClassDecl.setSrcAnnotation(new SrcParseAnnotation(cm));
            }
            return fullClassDecl.getSrcAnnotation().annotationNode(eval).addNode(path);
        }
    }
	/**
	 * Represents an annotation that is represented in the source tree by a SrcClassModification.
	 */
    public class ClassModAnnotationNode extends AnnotationNode {

        private SrcClassModification mod;
        public SrcExpEvaluator eval;

        public ClassModAnnotationNode(SrcClassModification cm, SrcExpEvaluator eval) {
            this.eval = eval;
            mod = cm;
        }

        public Iterator<AnnotationNode> attributeIterator() {
            return new AnnotationIterator(mod.getSrcArguments(), eval);
        }

        public String name() {
            return mod.parentAnnotationName();
        }
        
        public SrcClassModification ast() {
            return mod;
        }

        @Override
        protected AnnotationNode lookup(String path) {
            for (SrcArgument arg : mod.getSrcArguments()) 
                if (arg.matches(path))
                    return arg.annotationNode(eval);
            return null;
        }

        @Override
        public AnnotationNode addNode(String path) {
            SrcComponentModification cm = new SrcComponentModification(new SrcNamedAccess(path), new SrcCompleteModification(new SrcClassModification()));
            mod.addSrcArgument(cm);
            return cm.annotationNode(eval);
        }

    }


    /**
     * Represents an annotation that is represented in the source tree by a SrcFunctionCall.
     */
    public class FCAnnotationNode extends AnnotationNode {

        private SrcFunctionCall call;
        private SrcExpEvaluator eval;

        public FCAnnotationNode(SrcFunctionCall fc, SrcExpEvaluator eval) {
            call = fc;
            this.eval = eval;
        }

        public Iterator<AnnotationNode> attributeIterator() {
            return new AnnotationIterator(new ChainedIterator(
                    call.getSrcFunctionArguments().getSrcExps().iterator(), 
                    call.getSrcFunctionArguments().getSrcNamedArguments().iterator()), eval);
        }
		
		public String name() {
			return call.getName().name();
		}

		protected ASTNode ast() {
			return call;
		}

        @Override
        protected AnnotationNode lookup(String path) {
            for (SrcNamedArgument arg : call.getSrcFunctionArguments().getSrcNamedArguments()) 
                if (arg.matches(path)) 
                    return arg.annotationNode(eval);
            return null;
        }
	}
	
	public abstract class ExpAnnotationNode extends AnnotationNode {
		
		public abstract SrcExp exp();
		protected abstract void setSrcExp(SrcExp exp);
		public SrcExpEvaluator eval;
		
		public ExpAnnotationNode(SrcExpEvaluator eval) {
        	this.eval = eval;
		}
		
		public boolean isValue() {
			if (exp() == null)
				return super.isValue();
			else
				return !exp().isAnnotationExp();
		}

        public Iterator<AnnotationNode> valueIterator() {
            return exp() == null || isValue() 
                    ? super.valueIterator() 
                    : new AnnotationIterator(exp().annotationList(), eval);
        }
		
		@Override
		protected abstract ASTNode ast();
		
		@Override
		public void setValue(SrcExp exp) {
			setSrcExp(exp);
		}

        @Override
        public CValue ceval() {
            try {
                return exp() == null ? super.ceval() : eval.ceval(exp());
            } catch (ConstantEvaluationException e) {
                return CValue.UNKNOWN;
            }
        }

        @Override
        public String valueToString() {
            return exp().toString();
        }

        @Override
        public final boolean isAccess() {
            return exp() != null && exp().isAccess();
        }

        @Override
        public InstLookupResult<InstClassDecl> lookupInstClass() {
            return exp() == null ? super.lookupInstClass() : eval.lookupInstClass(exp());
        }

        public InstLookupResult<InstComponentDecl> lookupInstComponent() {
            return exp() == null ? super.lookupInstComponent() : eval.lookupInstComponent(exp());
        }

        public ArrayList<String> stringList() {
			if (exp() == null)
				return super.stringList();
			else
				return exp().avalueStringList();
		}

	}
	
	/**
	 * Represents an annotation that is represented in the source tree by a SrcValueModification.
	 */
	public class ValueModAnnotationNode extends ExpAnnotationNode {
		
		private SrcValueModification mod;
		
		public ValueModAnnotationNode(SrcValueModification vm, SrcExpEvaluator eval) {
			super(eval);
			mod = vm;
		}
		
		public SrcExp exp() {
			return mod.getSrcExp();
		}
		
		protected void setSrcExp(SrcExp exp) {
			mod.setSrcExp(exp);
		}
		
		@Override
		protected ASTNode ast() {
			return mod;
		}
		
		public String name() {
			return mod.parentAnnotationName();
		}
	}
	
	/**
	 * Represents an annotation that is represented in the source tree by a SrcComponentModification.
	 */
	public class ComponentModAnnotationNode extends ExpAnnotationNode {
		
		private SrcComponentModification mod;
		
		public ComponentModAnnotationNode(SrcComponentModification mod, SrcExpEvaluator eval) {
			super(eval);
			this.mod = mod;
		}
		
		@Override
		public SrcExp exp() {
			if (mod.hasSrcModification() && mod.getSrcModification().annotationNode(eval) instanceof ExpAnnotationNode)
				return ((ExpAnnotationNode) mod.getSrcModification().annotationNode(eval)).exp();
			else
				return null;
		}
		
		@Override
		protected void setSrcExp(SrcExp exp) {
			if (mod.hasSrcModification())
				mod.getSrcModification().annotationNode(eval).setValue(exp);
			else
			    throw new UnsupportedOperationException();
		}
		
		@Override
		protected ASTNode ast() {
			return mod;
		}
		
		@Override
		public String name() {
			return mod.getName().name();
		}
		
		@Override
		public boolean isValue() {
			if (mod.hasSrcModification())
				return mod.getSrcModification().annotationNode(eval).isValue();
			else
				return false;
		}
		
		@Override
		public Iterator<AnnotationNode> attributeIterator() {
			if (mod.hasSrcModification())
				return mod.getSrcModification().annotationNode(eval).attributeIterator();
			else
				return super.attributeIterator();
		}

		@Override
		protected AnnotationNode lookup(String path) {
		    if (mod.hasSrcModification())
		        return mod.getSrcModification().annotationNode(eval).lookup(path);
		    else
				return NO_ANNOTATION;
		}
		
		@Override
		public boolean isEach() {
		    return mod.getEach();
		}
		
		@Override
		public boolean isFinal() {
		    return mod.getFinal();
		}
		
	}
	
	/**
	 * Represents an annotation that is represented in the source tree by a SrcCompleteModification.
	 */
	public class CompleteModAnnotationNode extends ExpAnnotationNode {
		
		private SrcCompleteModification mod;
		
		public CompleteModAnnotationNode(SrcCompleteModification mod, SrcExpEvaluator eval) {
			super(eval);
			this.mod = mod;
		}
		
		@Override
		public SrcExp exp() {
			if (mod.hasSrcValueModification())
				return mod.getSrcValueModification().getSrcExp();
			else
				return null;
		}
		
		@Override
		protected void setSrcExp(SrcExp exp) {
			if (mod.hasSrcValueModification())
				mod.getSrcValueModification().annotationNode(eval).setValue(exp);
			else
				mod.setSrcValueModification(new SrcValueModification(exp));
		}
		
		@Override
		protected ASTNode ast() {
			return mod;
		}
		
		@Override
		public String name() {
			return mod.parentAnnotationName();
		} 
		
		@Override
		public boolean isValue() {
			if (mod.hasSrcValueModification())
				return mod.getSrcValueModification().annotationNode(eval).isValue();
			else
				return false;
		}
		
        @Override
        public Iterator<AnnotationNode> attributeIterator() {
            return mod.getSrcClassModification().annotationNode(eval).iterator();
        }

        @Override
        protected AnnotationNode lookup(String path) {
            return mod.getSrcClassModification().annotationNode(eval).lookup(path);
        }

        @Override
        public AnnotationNode addNode(String path) {
            return mod.getSrcClassModification().annotationNode(eval).addNode(path);
        }
		
	}
	
	/**
	 * Represents an annotation that is represented in the source tree by a SrcNamedArgument.
	 */
	public class NAAnnotationNode extends ExpAnnotationNode {
		
		private SrcNamedArgument arg;
		
		public NAAnnotationNode(SrcNamedArgument na, SrcExpEvaluator eval) {
			super(eval);
			arg = na;
		}
		
		public SrcExp exp() {
			return arg.getSrcExp();
		}
		
		protected void setSrcExp(SrcExp exp) {
			arg.setSrcExp(exp);
		}
		
		@Override
		protected ASTNode ast() {
			return arg;
		}
		
		public String name() {
			return arg.getName().name();
		}
		
	}
	
	/**
	 * Represents an annotation that is represented in the source tree by an SrcExp.
	 */
	public class EAnnotationNode extends ExpAnnotationNode {
		
		private SrcExp e;
		
		public EAnnotationNode(SrcExp exp, SrcExpEvaluator eval) {
			super(eval);
			e = exp;
		}
		
		public SrcExp exp() {
			return e;
		}
		
		protected void setSrcExp(SrcExp exp) {
			e = exp; // TODO: This is probably wrong!
		}
		
		@Override
		protected ASTNode ast() {
			return e;
		}
		
	}
	
    public abstract class FExpAnnotationNode extends AnnotationNode {
        
        @Override
        public abstract FExp fExp();
        
        @Override
        public boolean isValue() {
            if (exp() == null)
                return super.isValue();
            else
                return !exp().isAnnotationExp();
        }

        @Override
        public Iterator<AnnotationNode> valueIterator() {
            return fExp() == null || isValue() 
                    ? super.valueIterator() 
                    : new AnnotationIterator(fExp().annotationList(), AnnotationNode.DEFAULT_EVALUATOR);
        }

        @Override
        public CValue ceval() {
            try {
                return fExp() == null ? super.ceval() : fExp().ceval();
            } catch (ConstantEvaluationException e) {
                return CValue.UNKNOWN;
            }
        }

        @Override
        public boolean isAccess() {
            FExp e = fExp();
            return e instanceof AccessLikeExp;
        }

        public String valueToString() {
            FExp e = fExp();
            return (e == null) ? null : e.toString();
        }

    }

    public class FAttributeAnnotationNode extends FExpAnnotationNode {
        
        private final FAttribute attr;
        private SrcExpEvaluator eval;
        
        public FAttributeAnnotationNode(FAttribute attr, SrcExpEvaluator eval) {
            this.attr = attr;
            this.eval = eval;
        }

        
        @Override
        public FExp fExp() {
            return attr.hasValue() ? attr.getValue() : null;
        }
        
        @Override
        public CValue ceval() {
            return attr.hasValue() ? attr.getValue().ceval() : super.ceval();
        }

        @Override
        protected ASTNode ast() {
            return attr;
        }

        @Override
        public boolean isEach() {
            return attr.hasFEach();
        }

        @Override
        public boolean isFinal() {
            return attr.hasFFinal();
        }

        @Override
        public int level() {
            return attr.getLevel();
        }

        @Override
        public Iterator<AnnotationNode> attributeIterator() {
            return attr.getNumFAttribute() > 0 
                    ? new AnnotationIterator(attr.getFAttributes(), eval) 
                    : super.attributeIterator();
        }

        @Override
        protected AnnotationNode lookup(String path) {
            for (FAttribute attr : this.attr.getFAttributes())
                if (attr.matches(path))
                    return attr.annotationNode(eval);
            return null;
        }

        @Override
        public AnnotationNode addNode(String path) {
            FAttribute attr = new FAnnotationAttribute(path);
            this.attr.addFAttribute(attr);
            return new FAttributeAnnotationNode(attr, eval);
        }

        @Override
        public void setValue(FExp exp) {
            if (exp == null)
                attr.setValueOpt(new Opt<FExp>());
            else
                attr.setValue(exp);
        }
        
        @Override
        public void setEach(boolean eachValue) {
            if (eachValue)
                attr.setFEach(new FEach());
            else
                attr.setFEachOpt(new Opt<FEach>());
        }

        @Override
        public void setLevel(int level) {
            attr.setLevel(level);
        }

        @Override
        public String name() {
            return attr.getName().name();
        }
    }

    public class FAttributeListAnnotationNode extends AnnotationNode {
        
        public interface FAttributeList {
            public void addFAttribute(FAttribute attribute);
            public List<FAttribute> getFAttributeList();
            public int getNumFAttribute();
        }
        
        private final FAttributeList attrs;
        private final SrcExpEvaluator eval;
        
        public FAttributeListAnnotationNode(FAttributeList attrs, SrcExpEvaluator eval) {
            this.attrs = attrs;
            this.eval = eval;
        }
        
        @Override
        protected ASTNode ast() {
            return attrs.getFAttributeList();
        }

        @Override
        public Iterator<AnnotationNode> attributeIterator() {
            return attrs.getNumFAttribute() > 0 
                    ? new AnnotationIterator(attrs.getFAttributeList(), eval) 
                    : super.attributeIterator();
        }

        @Override
        protected AnnotationNode lookup(String path) {
            for (FAttribute attr : attrs.getFAttributeList())
                if (attr.matches(path)) 
                    return attr.annotationNode(eval);
            return null;
        }

        @Override
        public AnnotationNode addNode(String path) {
            FAttribute attr = new FAnnotationAttribute(path);
            attrs.addFAttribute(attr);
            return new FAttributeAnnotationNode(attr, eval);
        }
    }
    
	/**
	 * A runtime exception that is thrown when an action fail while trying
	 * to alter an annotation node and it's underlying structure.
	 */
	public class AnnotationEditException extends RuntimeException {
		
		/**
		 * Constructs an instance from a string <code>s</code>.
		 * 
		 * @param s A string explaining the exception
		 */
		public AnnotationEditException(String s) {
			super(s);
		}
		
		/**
		 * Constructs an instance from a string <code>s</code> and exception
		 * <code>e</code>.
		 * 
		 * @param s A string explaining the exception
		 * @param e An exception that caused this exception
		 */
		public AnnotationEditException(String s, Exception e) {
			super(s, e);
		}
	}
	
	syn boolean SrcArgument.matches(String str) = false;
	eq SrcNamedModification.matches(String str) = getName().name().equals(str);
	
	syn boolean SrcNamedArgument.matches(String str) = getName().name().equals(str);
	
	
	syn boolean SrcExp.isFunctionCall() = false;
	eq SrcFunctionCall.isFunctionCall() = true;
	
	syn boolean SrcExp.isAnnotationExp()     = false;
	eq SrcFunctionCall.isAnnotationExp()     = true;
	eq SrcArrayConstructor.isAnnotationExp() = 
		getSrcFunctionArguments().getNumSrcExp() > 0;
		
    syn boolean FExp.isAnnotationExp() = false;
    eq FFunctionCall.isAnnotationExp() = true;
    eq FArray.isAnnotationExp()        = getNumFExp() > 0;

	syn Iterable<? extends ASTNode> SrcExp.annotationList() = new ArrayList<ASTNode>(0);
	eq SrcArrayConstructor.annotationList()                 = getSrcFunctionArguments().getSrcExps();
	eq SrcFunctionCall.annotationList()                     = Collections.singletonList(this);
	
    syn Iterable<? extends ASTNode> FExp.annotationList() = new ArrayList<ASTNode>(0);
    eq FArray.annotationList()                            = getFExps();
    eq FFunctionCall.annotationList()                     = getArgs();
    
    syn String SrcExp.avalueString()  = null;
	eq SrcStringLitExp.avalueString() = unEscape();
	eq SrcAccessExp.avalueString()    = getSrcAccess().name();
    
    syn ArrayList<String> SrcExp.avalueStringList() = null;
	eq SrcArrayConstructor.avalueStringList() {
		ArrayList<String> l = new ArrayList<String>(getSrcFunctionArguments().getNumSrcExp());
		for (SrcExp e : getSrcFunctionArguments().getSrcExps())
			l.add(e.avalueString());
		return l.contains(null) ? null : l;
	}
    
}

