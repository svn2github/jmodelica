aspect CanonizeEquations {
	public class FClass {
        /**
         * Perform canonization on equations if it is activated.
         */
        public class canonizeEquationsIfSet extends Transformation {
            public canonizeEquationsIfSet() {
                super("canonize_equations");
            }
            
            public void perform() {
                canonizeEquations();
            }
        }
        
        public canonizeEquationsIfSet canonizeEquations = new canonizeEquationsIfSet();
    }
    
    syn boolean FDivExp.isDivExp() = true;
    syn boolean FExp.isDivExp() = false;
    
    syn boolean FMulExp.isMulExp() = true;
    syn boolean FExp.isMulExp() = false;
    
    syn boolean FBinExp.isBinExp() = true;
    syn boolean FExp.isBinExp() = false;
    
    syn boolean FAddExp.isAddExp() = true;
    syn boolean FExp.isAddExp() = false;
    
    syn boolean FSubExp.isSubExp() = true;
    syn boolean FExp.isSubExp() = false;
    
    syn boolean FExp.isFExp() = true;
    syn boolean ASTNode.isFExp() = false;
    
    syn boolean FExp.isLeftChildOfMul() { 
        if (parentFExp() == null) {
            return false;
        }
        return parentFExp().lookupLeft(this);
    }
    
    syn boolean FExp.lookupLeft(FExp child) { 
        if (parentFExp() == null) {
            return false;
        }
        return parentFExp().lookupLeft(this);
    }
    
    syn boolean FMulExp.lookupLeft(FExp child) {
        return child == getChild(0);
    }
    
    
    /*
    syn boolean FExp.isLeftChild() {
        if (parentFExp() == null) {
            return false;
        } else if (parentFExp().getChild(0).isFExp()) {
            if (parentFExp().getChild(0) == this) {
                return true;
            }
        }
        return false;
    }
    syn ASTNode.isLeftChild() = false;
    
    syn boolean FExp.isRightChild() {
        if (parentFExp() == null) {
            return false;
        } else if (parentFExp().getChild(1).isFExp()) {
            if (parentFExp().getChild(1) == this) {
                return true;
            }
        }
        return false;
    }
    syn ASTNode.isLeftChild() = false;
    */
    
    /**
     * Transforms equations to canonical form.
     */
    public class FClass {
        private FExp denominator = null;
        private boolean continueUp = false;
        
        public void canonizeEquations() {
	    	for (FAbstractEquation equation: getFAbstractEquations()) {
	    	    if (!equation.isFEquation())  // Avoids erroneous class casting.
	    	      continue;
	    	      
	    	    FEquation feq  = (FEquation) equation;
	            FExp leftExp = feq.getLeft();
	            FExp rightExp = feq.getRight();
	            
	    	    // Step 1. Move all expressions to RHS.
	    	    moveToRHS(feq, leftExp, rightExp);
	    	    
	    	    // Step 2: Remove all DivExp.
	    	    rightExp = feq.getRight();
	    	    elimDiv(rightExp, feq);
	    	    
	    	    // Step 3: Expand parentheses.
	    	    // TODO: not implemented
	    	    expandParentheses(rightExp, feq);
	    	    
	        	// Step 4: ...
	        	
	        	//dumpTree("");
	        	System.out.print("\n\n");
            }
        }
    
	    /*
	     * Move LHS of equation to RHS. 
	     */
	    public void moveToRHS(FEquation feq, FExp leftExp, FExp rightExp) {
	        //System.out.println("Do moveToRHS():\n" + feq.toString());
	        // Set LHS to 0.
	        feq.setLeft(new FIntegerLitExp(0));
	        
	        // Subtract LHS from RHS.
	        feq.setRight(new FSubExp(rightExp, leftExp));
	        //System.out.println("Done moveToRHS():\n" + feq.toString());
	    }
    
	    /*
	     * Eliminate all DivExp.
	     */
	    public void elimDiv(FExp fexp, FEquation feq) {
	        //System.out.println("Do elimDiv():\n" + feq.toString());
	        
	        // Only perform algorithm if RHS starts with a FBinExpr 
	        if (!fexp.isBinExp()) {
	           return;
	        }
	        
	        // If RHS is a FDivExp, we only have to replace it with its
	        // numerator.
	        if (fexp.isDivExp()) {
	           if (fexp.getChild(0).isFExp()) {
	               feq.setRight((FExp) fexp.getChild(0));
	           }
	           //System.out.println("Done elimDiv():\n" + feq.toString());
	           return;
	        }
	        
	        boolean foundDiv = false;
	        do {
	            foundDiv = divToMul(fexp, fexp);
	            continueUp = false;
	        } while (foundDiv);
	        
	        //System.out.println("Done elimDiv():\n" + feq.toString());
	    }
    
	    /*
	     * This method calls itself recursively to find the FDivExp at the bottom of
	     * the tree first.
	     * TODO: Not optimized atm. The algorithm is traversing the whole tree everytime this method is called.
	     *       This could be improved by tracking which paths we have already found and removed an FDivExp.
	     */
	    public boolean divToMul(FExp fexp, FExp rootParent) {
	        boolean foundDivLeft = false;
	        boolean foundDivRight = false;
	        boolean foundDiv = false;
	        FExp leftChild = null;
            FExp rightChild = null;
	        
	        // Retrieve children.
	        if (fexp.getChild(0).isFExp()) {
	            leftChild = (FExp) fexp.getChild(0);       // FExp has getLeft/getRight
	        }
	        if (fexp.getChild(1).isFExp()) {
	            rightChild = (FExp) fexp.getChild(1);
	        }
	    
	        // Recursive call if a child is a FBinExp (then we know its not a leaf).
	        if (leftChild.isBinExp()) {
	            foundDivLeft = divToMul(leftChild, rootParent);
	        }
	        if (rightChild.isBinExp() && !foundDivLeft) {
	            foundDivRight = divToMul(rightChild, rootParent);
	        }
	        
	        foundDiv = foundDivLeft || foundDivRight;
	        
	        // Remove bottom FDivExp and insert FMulExps at correct places.
            if (!foundDiv && fexp.isDivExp() && fexp != rootParent) {
                foundDiv = true;
                continueUp = true;
                denominator = rightChild;
                if (fexp.parentFExp().getChild(0) == fexp) {
                    fexp.parentFExp().setChild(leftChild, 0);
                } else {
                    fexp.parentFExp().setChild(leftChild, 1);
                }
            } else if (continueUp && (fexp.isAddExp() || fexp.isSubExp())) {
                if (foundDivLeft) {
                    fexp.setChild(new FMulExp(rightChild, denominator), 1);
                } else {
                    fexp.setChild(new FMulExp(leftChild, denominator), 0);
                }
            } else if (continueUp && foundDivRight && fexp.isDivExp()) {
                continueUp = false;
                fexp.setChild(new FMulExp(leftChild, denominator), 0);
            }
	        
	        return foundDiv;
	    }
    
	    /**
	     * Expand all parenteses.
         * TODO: implement method.
	     */
	    public void expandParentheses(FExp fexp, FEquation feq) {
	        System.out.println("Do expandParentheses():\n" + feq.toString());
	        boolean notDone = true;
	        // Only perform algorithm if RHS starts with a FBinExpr 
            if (!fexp.isBinExp()) {
               return;
            }
             	       
	        expandNext(fexp, fexp, feq);
	        
	        
	        System.out.println("Done expandParentheses():\n" + feq.toString());
	    }
	    
	    public boolean expandNext(FExp fexp, FExp rootParent, FEquation feq) {
	        boolean notDone = false;
	        boolean addFactors = false;
	        FExp leftChild = null;
            FExp rightChild = null;
            FExp mulParent = null;
            FExp mulExp = null;
            ArrayList<FExp> leftPosFactors = new ArrayList();
            ArrayList<FExp> rightPosFactors = new ArrayList();
            ArrayList<FExp> leftNegFactors = new ArrayList();
            ArrayList<FExp> rightNegFactors = new ArrayList();
            
            Stack<FExp> stack = new Stack();
            stack.push(fexp);
            
            while (!stack.isEmpty()) {
                FExp nextExp = stack.pop();
                // Retrieve children.
                if (nextExp.getChild(0).isFExp()) {
                    leftChild = (FExp) nextExp.getChild(0);
                }
                if (nextExp.getChild(1).isFExp()) {
                    rightChild = (FExp) nextExp.getChild(1);
                }
                
                // If this is a mulExp then we start adding factors to the factor lists
                if (nextExp.isMulExp()) {
                    addFactors = true;
                    mulExp = nextExp;
                    if (nextExp != rootParent) {
                        mulParent = rootParent;
                    }
                }
                
                // Check children to see if we have a subtree with mulExp.
                // If so, we step down into it and fix its structure before 
                // adding it to the factor lists.
                if (leftChild.isMulExp()) {
                    expandNext(leftChild, nextExp, feq);
                }
                if (rightChild.isMulExp()) {
                    expandNext(rightChild, nextExp, feq);
                }
                
                // If a child is an add- or subExp, we add them to the stack and continue down
                if (leftChild.isAddExp() || leftChild.isSubExp()) {
                    stack.push(leftChild);
                }
                
                if (rightChild.isAddExp() || rightChild.isSubExp()) {
                    stack.push(rightChild);
                }
                
                // If a child is either a mulExp or one of the non binExps, we add them their
                // corresponding factor list.
                if (addFactors && (!leftChild.isBinExp() || leftChild.isMulExp())) {
                    if (leftChild.isLeftChildOfMul()) {
                        leftPosFactors.add(leftChild);
                    } else {
                        rightPosFactors.add(leftChild);
                    }
                }
                if (addFactors && (!rightChild.isBinExp() || rightChild.isMulExp())) {
                    if (rightChild.isLeftChildOfMul()) {
                        if (nextExp.isSubExp()) {
                            leftNegFactors.add(rightChild);
                        } else {
                            leftPosFactors.add(rightChild);
                        }
                    } else {
                        if (nextExp.isSubExp()) {
                            rightNegFactors.add(rightChild);
                        } else {
                            rightPosFactors.add(rightChild);
                        }
                    }
                }
            }
            
            FExp newExp = buildNewExp(leftPosFactors, leftNegFactors, rightPosFactors, rightNegFactors);
            
            
            return notDone;
	    }
	    
	    private FExp buildNewExp(ArrayList<FExp> lp, ArrayList<FExp> ln, ArrayList<FExp> rp, ArrayList<FExp> rn) {
	        ArrayList<FAddExp> adds = new ArrayList();
	        ArrayList<FSubExp> subs = new ArrayList();
	        ArrayList<FMulExp> pMuls = new ArrayList();
	        ArrayList<FMulExp> nMuls = new ArrayList();
            int size = 0:
            FExp newExp = null;
            
            for (FExp lpExp : lp) {
                for (FExp rpExp : rp) {
                    pMuls.add(new FMulExp(lpExp, rpExp));
                }
                for (FExp rnExp : rn) {
                    nMuls.add(new FMulExp(lpExp, rnExp));
                }
            }
            for (FExp lnExp : ln) {
                for (FExp rpExp : rp) {
                    nMuls.add(new FMulExp(lnExp, rpExp));
                }
                for (FExp rnExp : rn) {
                    pMuls.add(new FMulExp(lnExp, rnExp));
                }
            }
            
            size = pMuls.size() + nMuls.size();
	        
	        // Slutade h√§r......
	        int i = 1;
	        for (FMulExp pmExp : pMuls) {
	           if (i == 1) {
	               newExp = new FAddExp(pmExp, null);
	           } else if (i == 2) {
                   newExp.getChild(1) = 
	           } else if (i%2 != 0) {
	               
	           } else {
	               
	           }
	           i++;
	        }
	        
	        
	        return newExp;
	    }
	}
}