
/*
Copyright (C) 2009-2017 Modelon AB

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect CCodeGenFunctionPartial {

    /**
     * \brief Generates forward declarations for FPCL and FPCR functions used
     * by partial function calls.
     */
    public void FFunctionDecl.genHeadersPartial_C(CodeStream str, String indent) {
        prettyPrintHeadFPCL_C(str, indent);
        str.println(";");
        prettyPrintHeadFPCR_C(str, indent);
        str.println(";");
    }

    /**
     * \brief Generates FP and OUT structs used by partial function calls.
     */
    public void FFunctionDecl.genStructsPartial_C(CodeStream str, String indent) {
        CodePrinter p = ASTNode.printer_C;
        String fp  = funcNameUnderscore(C_SUFFIX_FP);
        String out = funcNameUnderscore(C_SUFFIX_FPOUT);
        String next = p.indent(indent);
        
        beginStruct_C(str, indent, out);
        str.formatln("%sint n;", next);
        for (FFunctionVariable ffv : myOutputs()) {
            str.formatln("%s%s %s;", next, ffv.type().type_C(), ffv.name_C());
        }
        endStruct_C(str, indent);
        
        beginStruct_C(str, indent, fp);
        str.formatln("%s%s (*fpcl)(%s*, %s*, ...);", next, getDeclaredType_C(), fp, out);
        str.formatln("%s%s* (*fpcr)(%s*, %s*, ...);", next, fp, fp, fp);
        for (FFunctionVariable ffv : myInputs()) {
            String name = ffv.name_C();
            str.formatln("%s%s %s;", next, ffv.type().type_C(), name);
            str.formatln("%sint %s_s;", next, name);
        }
        endStruct_C(str, indent);
    }

    /**
     * \brief Generate first line of struct declaration name_ with typedef to name
     */
    public static void FFunctionDecl.beginStruct_C(CodeStream str, String indent, String name) {
        str.formatln("%stypedef struct %s_ %s;", indent, name, name);
        str.formatln("%sstruct %s_ {", indent, name);
    }

    /**
     * \brief Generate last line of struct declaration
     */
    public static void FFunctionDecl.endStruct_C(CodeStream str, String indent) {
        str.formatln("%s};", indent);
    }

    /**
     * \brief Generate declaration for varargs
     */
    public void FFunctionDecl.genVarArgsDecl(CodeStream str, String indent) {
        str.print(indent);
        str.println("va_list argp;");
    }

    /**
     * \brief Generate initialization for varargs
     */
    public void FFunctionDecl.genVarArgsOpen(CodeStream str, String indent, String last) {
        str.print(indent);
        str.print("va_start(argp, ");
        str.print(last);
        str.println(");");
    }

    /**
     * \brief Generate use for varargs
     */
    public void FFunctionDecl.genVarArgsRead(CodeStream str, String indent, String dest, String type) {
        str.print(indent);
        str.print(dest);
        str.print(" = ");
        genVarArgsRead(str, type);
        str.println(";");
    }

    /**
     * \brief Generate use for varargs
     */
    public void FFunctionDecl.genVarArgsRead(CodeStream str, String type) {
        str.print("va_arg(argp, ");
        str.print(type);
        str.print(")");
    }

    /**
     * \brief Generate closing for varargs
     */
    public void FFunctionDecl.genVarArgsClose(CodeStream str, String indent) {
        str.print(indent);
        str.println("va_end(argp);");
    }

    /**
     * \brief Generate header for FPCL function.
     */
    public void FFunctionDecl.prettyPrintHeadFPCL_C(CodeStream str, String indent) {
        str.format("%s%s %s(%s* fp_in, %s* out, ...)", indent, getDeclaredType_C(),funcNameUnderscore(C_SUFFIX_FPCL),
                funcNameUnderscore(C_SUFFIX_FP), funcNameUnderscore(C_SUFFIX_FPOUT));
    }

    /**
     * \brief Generate header for FPCR function.
     */
    public void FFunctionDecl.prettyPrintHeadFPCR_C(CodeStream str, String indent) {
        String fp = funcNameUnderscore(C_SUFFIX_FP);
        str.format("%s%s* %s(%s* fp_in, %s* fp_out, ...)", indent, fp, funcNameUnderscore(C_SUFFIX_FPCR), fp, fp);
    }

    /**
     * \brief Generates FPCL and FPCR functions used by partial function calls.
     */
    public void FFunctionDecl.prettyPrintPartial_C(CodeStream str, String indent) {
        int i;
        CodePrinter p = ASTNode.printer_C;
        String next = p.indent(indent);
        String next2 = p.indent(next);
        String next3 = p.indent(next2);
        String fp = funcNameUnderscore(C_SUFFIX_FP);
        ArrayList<FFunctionVariable> inputs  = myInputs();
        ArrayList<FFunctionVariable> outputs = myOutputs();
        int n = inputs.size() + outputs.size();
        String[] names = new String[n];
        for (i = 0; i < n; i++) {
            names[i] = "tmp_" + (i+1); 
        }
        
        // FPCL
        prettyPrintHeadFPCL_C(str, indent);
        str.print(" {\n");
        
        i = 0;
        for (FFunctionVariable ffv : inputs) {
            str.formatln("%s%s %s;", next, ffv.type_C(), names[i++]);
        }
        for (FFunctionVariable ffv : outputs) {
            str.formatln("%s%s %s;", next, ffv.type_C(), names[i++]);
        }
        
        genVarArgsDecl(str, next);
        genVarArgsOpen(str, next, "out");
        i = 0;
        for (FFunctionVariable ffv : inputs) {
              str.formatln("%sif (fp_in->%s_s) {", next, ffv.name_C());
              str.formatln("%s%s = fp_in->%s;", next2, names[i], ffv.name_C());
              str.formatln("%s} else {", next);
              genVarArgsRead(str, next2, names[i], ffv.type_C());
              str.formatln("%s}", next);
              i++;
        }
        genVarArgsClose(str, next);
        
        str.format("%s%s(", next, funcNameUnderscore("def"));
        String prefix = "";
        i = 0;
        for (FFunctionVariable ffv : inputs) {
            str.print(prefix);
            str.print(names[i++]);
            prefix = ", ";
        }
        for (FFunctionVariable ffv : outputs) {
            str.print(prefix);
            str.print("&");
            str.print(names[i++]);
        }
        str.println(");");
        
        str.formatln("%sif (out != NULL) {",next);
        i = 0;
        for (FFunctionVariable ffv : outputs) {
              str.formatln("%sif (out->n > %d) {", next2, i);
              str.formatln("%sout->%s = %s;", next3, ffv.name_C(), names[i + inputs.size()]);
              str.formatln("%s}", next2);
              i++;
        }
        str.formatln("%s}",next);
        if (outputs.size() > 0)
            str.formatln("%sreturn %s;", next, names[inputs.size()]);
        str.format("%s}\n\n", indent);
        
        
        // FPCR
        prettyPrintHeadFPCR_C(str, indent);
        str.print(" {\n");
        genVarArgsDecl(str, next);
        str.formatln("%sif (fp_out == NULL) {", next);
        str.formatln("%sfp_out = malloc(sizeof(%s));", next2, fp);
        str.formatln("%s}", next);
        
        str.formatln("%sfp_out->fpcl = &%s;", next, funcNameUnderscore(C_SUFFIX_FPCL));
        str.formatln("%sfp_out->fpcr = &%s;", next, funcNameUnderscore(C_SUFFIX_FPCR));
        
        str.formatln("%sif (fp_in == NULL) {", next);
        for (FFunctionVariable ffv : inputs) {
            str.formatln("%sfp_out->%s_s = 0;", next2, ffv.name_C());
        }
        str.formatln("%s} else {", next);
        for (FFunctionVariable ffv : inputs) {
            String name = ffv.name_C();
            str.formatln("%sfp_out->%s_s = fp_in->%s_s;", next2, name, name);
            str.formatln("%sfp_out->%s = fp_in->%s;", next2, name, name);
        }
        str.formatln("%s}", next);
        
        genVarArgsOpen(str, next, "fp_out");
        for (FFunctionVariable ffv : inputs) {
            String name = ffv.name_C();
            str.format("%sif (!fp_out->%s_s && ", next, name);
            genVarArgsRead(str, "int");
            str.println(") {");
            str.formatln("%sfp_out->%s_s = 1;", next2, name);
            genVarArgsRead(str, next2, "fp_out->" + name, ffv.type_C());
            str.formatln("%s}", next);
        }
        genVarArgsClose(str, next);
        
        str.formatln("%sreturn fp_out;", next);
        str.format("%s}\n\n", indent);
    }

    @Override
    public void FFunctionVariable.prettyPrintCall_C(CodePrinter p, CodeStream str, String indent, FFunctionCall call) {
        boolean exp = call.functionCallIsExp();
        String out = "NULL";
        if (!exp) {
            out = call.tempName_C();
            str.formatln("%s%s.n = %s;", indent, out, call.myLefts().size());
            out = "&" +out;
            str.print(indent);
        }
        str.format("%s->fpcl(%s, %s", name_C(), name_C(), out);
        String sep = ", ";
        for (FExp arg : call.getArgs()) {
            str.format("%s(%s)(", sep, arg.type().type_C());
            arg.genTempArg(p.ExecStep, str, indent);
            str.print(")");
        }
        str.print(")");
        if (!exp)
            str.print(";\n");
        if (!exp) {
            int tot = myOutputs().size();
            int lefts = call.myLefts().size();
            for (int i = 0; i < tot; i++) {
                if (i < lefts) {
                    String n = call.myLefts().get(i).prettyPrint_C(indent);
                    str.formatln("%s%s = %s.%s;", indent, n, call.tempName_C(), n);
                }
            }
        }
    }

    @Override
    public void FPartialFunctionCall.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        boolean exp = functionCallIsExp();
        FCallable fc = myFCallable();
        String previous = "NULL";
        String result   = "NULL";
        if (fc.isPartialFunction()) {
            previous = ((FFunctionVariable) fc).name_C();
        } else {
            result = "&" + tempName_C();
        }
        if (fc.isPartialFunction()) {
            str.print(previous);
            str.print("->fpcr");
        } else {
            str.print(fc.funcNameUnderscore(C_SUFFIX_FPCR));
        }
        str.print("(");
        str.print(previous);
        str.print(", ");
        str.print(result);
        
        /* Print "0" for the inputs we don't set, and "1, value" for those we do set */
        Iterator<FIdUse> it = getArgNames().iterator();
        Iterator<FFunctionVariable> it2 = fc.myInputs().iterator();
        for (FExp arg : getArgs()) {
            String name = it.next().name();
            while (!it2.next().name().equals(name)) {
                str.print(", 0");
            }
            str.print(", 1");
            
            str.print(", ");
            str.format("(%s)(", arg.type().type_C());
            arg.genTempArg(p.ExecStep, str, indent);
            str.print(")");
        }
        while (it2.hasNext()) {
            str.print(", 0");
            it2.next();
        }
        
        str.print(")");
    }
}