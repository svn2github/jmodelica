/*
    Copyright (C) 2009-2014 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

%goal source_root;
%goal exp;

%header {:
 package $PARSER_PACKAGE$;
 import $AST_PACKAGE$.*;
 import org.jmodelica.util.formattedPrint.FormattingInfo;
 import org.jmodelica.util.Problem;
 import java.io.*;
 import java.util.Collection;
 import java.util.Map;
:};

%embed {:

	/**
	 * Error reporting class that creates an error message and delegates reporting the 
	 * message to a subclass.
	 */
	public abstract static class Report extends Parser.Events {

		/**
		 * Report an error with error message <code>msg</code>.
		 */
		protected abstract void report(Problem P);

		/**
		 * Creates an error message for when <code>token</code> is found unexpectedly. 
		 * Passes the error message to {@link #report(String)}.
		 * @param token		the unexpected symbol.
		 */
		public void syntaxError(Symbol token) {
			
			StringBuilder s = new StringBuilder();
			//s.append("Syntax error at line "+ Symbol.getLine(token.getStart()) + ", column " + Symbol.getColumn(token.getStart()) + "\n");
			if (token.value != null) {
				s.append("   Unexpected token: \"" + token.value + "\"");
			} else if (token.getId()<Terminals.NAMES.length)
				s.append("  Unexpected token: " + Terminals.NAMES[token.getId()]);
			else 
				s.append("  *** Syntactic error");
			Problem p = new Problem("", s.toString(), Problem.Severity.ERROR, Problem.Kind.SYNTACTIC, Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()));
			
			report(p);
		}

		/**
		 * Creates an error message for when the scanner throws an exception.
		 * Passes the error message to {@link #report(String)}.
		 * @param e		the exception.
		 */
		public void scannerError(Scanner.Exception e) {
			/*
			StringBuilder s = new StringBuilder(e.getMessage());
			s.append(" at line ");
			s.append(e.line);
			s.append(", column ");
			s.append(e.column);
			*/
			Problem p = new Problem("", e.getMessage(), Problem.Severity.ERROR, Problem.Kind.LEXICAL, e.line, e.column);
			
			report(p);
		}
		
	}
	
	/**
	 * Error reporting class that throws a {@link CompilerException} on an error.
	 * Uses error message created by {@link Report}.
	 */
	public class AbortingReport extends Report {

		/**
		 * Throws a <code>ParserException</code> with <code>msg</code> as the message.
		 */
		@Override
		protected void report(Problem p) {
		  throw new ParserException(p);
		}
		
		
	}
	
	/**
	 * Error reporting class that collects error messages for later retrieval.
	 * Uses error message created by {@link Report}.
	 */
	public static class CollectingReport extends Report {

		private ArrayList<Problem> errors = new ArrayList<Problem>();

		/**
		 * Adds error message <code>msg</code> to list.
		 */ 
		@Override
		protected void report(Problem p) {
			errors.add(p);			
		}
		
		/**
		 * Get the list of errors. Returns a reference to the internal list, not a copy.
		 * @return a {@link java.util.Collection} with the reported error messages.
		 */
		public Collection<Problem> getErrors() {
			return errors;
		}
		
		/**
		 * Reset the list of errors.
		 */
		public void resetErrors() {
			errors = new ArrayList<Problem>();
		}
		
		/**
		 * Checks if any errors has been reported.
		 * @return <code>true</code> if the list contains any errors.
		 */
		public boolean hasErrors() {
			return !errors.isEmpty();
		}

	}

	{ report = new AbortingReport(); }  // As default, throw exception on errors.
	
	/**
	 * Set the error reporting class to use.
	 * @param report	a subclass of {@link Parser.Events} to use for reporting errors.
	 */
	public void setReport(Parser.Events report) {
		this.report = report;
	}
	
	public Parser.Events getReport() {
		return report;
	}
	
	private int[] lineBreakMap;
	
	public void setLineBreakMap(int[] map) {
	    lineBreakMap = map;
	}

	private FormattingInfo formatting;
	
	public void setFormattingInfo(FormattingInfo formatting) {
		this.formatting = formatting;
	}

:};
 
SourceRoot source_root
    = /* nothing */ {: 
        SourceRoot sr = new SourceRoot(new Program(new List()));
        return sr; 
      :}
   | program {: 
       SourceRoot sr = new SourceRoot(program); 
       return sr; 
   :};

Program program
    = stored_definition   {: 
        return new Program(new List().add(stored_definition)); 
    :};
  
StoredDefinition stored_definition
    = within? base_class_decl_list {:
        StoredDefinition def = new StoredDefinition(within, base_class_decl_list);
        def.setLineBreakMap(lineBreakMap);
        def.setFormatting(formatting);
    	return def; 
    :}
    | error {: 
        return new BadDefinition(); 
    :};

Within within
    = WITHIN parse_access? SEMICOLON {: 
        return new Within(parse_access); 
    :};
  
List base_class_decl_list  
    = base_class_decl SEMICOLON {: 
        return new List().add(base_class_decl); 
    :}
    | base_class_decl_list base_class_decl SEMICOLON {: 
        base_class_decl_list.add(base_class_decl);
        return base_class_decl_list; 
    :};

BaseClassDecl base_class_decl 
    =               
    encapsulated? 
    partial? 
    restriction  
    id_decl.start 
    string_comment? 
    composition 
    annotation_sc?
    end_decl   {:   
        return new PN_FullClassDecl(
            start,
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            string_comment,
            composition,
            annotation_sc,
            end_decl); 
    :}
    |
    encapsulated? 
    partial? 
    restriction  
    id_decl.class_name EQUALS
    type_prefix_flow?
    type_prefix_variability?
    type_prefix_input_output?
    class_access /*name*/
    array_subscripts?
    class_modification?
    comment {:
        return new PN_ShortClassDecl(
            class_name, 
            new UnknownVisibilityType(),
            encapsulated, 
            partial, 
            restriction, 
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            type_prefix_flow, 
            type_prefix_variability, 
            type_prefix_input_output, 
            class_access,
            array_subscripts, 
            class_modification, 
            comment); 
    :}
    |
    encapsulated? 
    partial? 
    restriction 
    EXTENDS 
    id_decl.start 
    class_modification?
    string_comment? 
    composition 
    annotation_sc?
    end_decl {:
        return new PN_ExtendClassDecl(
            start,
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            string_comment,
            composition,
            annotation_sc,
            end_decl, 
            class_modification); 
  :}  
   |
    encapsulated? 
    partial? 
    restriction  
    id_decl.enum_name EQUALS
    ENUMERATION LPAREN enum_specification RPAREN
    comment {:
    return new PN_EnumDecl(
            enum_name,
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            ENUMERATION,
            enum_specification,
            comment); 
    
    :}
  | error {: 
      return new BadClassDecl();
  :};

EnumSpecification enum_specification =
  COLON {: return new EnumUnspecified(); :}
  | enum_literal_list {: return new EnumLiteralList(enum_literal_list); :}
  ;
  
List enum_literal_list =
  enum_literal                          {: return new List().add(enum_literal); :}
  | enum_literal_list COMMA enum_literal    {: enum_literal_list.add(enum_literal); 
                                       return enum_literal_list; :}
  ;

EnumLiteral enum_literal = 
  id_decl comment {: return new EnumLiteral(id_decl,comment); :}
  ;

Partial partial = 
  PARTIAL {: return new Partial(); :}
  ;

Encapsulated encapsulated = 
  ENCAPSULATED {: return new Encapsulated(); :}
  ;

TypePrefix type_prefix_variability = 
   DISCRETE         {: return new Discrete(); :}
  | PARAMETER       {: return new Parameter(); :}
  | CONSTANT        {: return new Constant(); :}
  ;
  
TypePrefix type_prefix_input_output = 
    INPUT           {: return new Input(); :}
  | OUTPUT          {: return new Output(); :}
  ;


Restriction restriction = 
  CLASS                    {: return new MClass(); :}
  | MODEL                  {: return new Model(); :}
  | BLOCK                  {: return new Block(); :}
  | CONNECTOR              {: return new Connector(); :}
  | EXPANDABLE CONNECTOR   {: return new ExpandableConnector(); :}
  | TYPE                   {: return new MType(); :}
  | PACKAGE                {: return new MPackage(); :}
  | FUNCTION               {: return new Function(); :}
  | RECORD                 {: return new Record(); :}  
  | OPERATOR RECORD        {: return new OperatorRecord(); :}  
  | OPERATOR FUNCTION      {: return new OperatorFunction(); :}
  | OPERATOR               {: return new Operator(); :}
  ;

Final final_ = 
  FINAL {: return new Final(); :}
  ;
  
Inner inner = 
  INNER {: return new Inner(); :}
  ;
  
 Outer outer = 
  OUTER {: return new Outer(); :}
  ;
   
Replaceable replaceable = 
  REPLACEABLE  {: return new Replaceable(); :}
  ;
    
Redeclare redeclare = 
  REDECLARE  {: return new Redeclare(); :}
  ;  
  
Each each =
  EACH  {: return new Each(); :}
  ;  

    
Composition composition = 
  composition_clauses  external_clause?
               {: return new Composition(composition_clauses,external_clause); :}
  | elements composition_clauses external_clause?
               {: composition_clauses.insertChild(new PublicElementList(elements), 0);
                  return new Composition(composition_clauses, external_clause); :}                             
  ;


List composition_clauses = 
             {: return new List(); :}
  | composition_clause {: return new List().add(composition_clause); :}
  | composition_clauses composition_clause {: return composition_clauses.add(composition_clause); :}
  ;


List elements
    = element {:
        return new List().add(element); 
    :} 
    | elements element {: 
        return elements.add(element);
    :};

Clause composition_clause =  
   PUBLIC                    {: return new PublicElementList(new List()); :}
   | PROTECTED               {: return new ProtectedElementList(new List()); :}
   | PUBLIC elements         {: return new PublicElementList(elements); :}
   | PROTECTED elements      {: return new ProtectedElementList(elements); :}
   | equation_clause         {: return equation_clause; :}
   | algorithm               {: return algorithm; :}
   ;
   
ExternalClause external_clause =
	EXTERNAL
	external_language?
	external_function_call?
	annotation.a1?
	SEMICOLON   {:  return new ExternalClause(external_language, external_function_call, a1); :}
	;

	
ExternalLanguage external_language =
	STRING.s {: return new ExternalLanguage(s); :}
	;	
	
Annotation annotation_sc =
	annotation SEMICOLON {: return annotation; :}
   	;

ExternalFunctionCall external_function_call =
	parse_access EQUALS id_decl LPAREN arg_list RPAREN  
	            {: return new ExternalFunctionCall(new Opt(parse_access), id_decl, arg_list); :}
  | id_decl LPAREN arg_list RPAREN  
                {: return new ExternalFunctionCall(new Opt(), id_decl, arg_list); :}
  ;   	 	
   	  	

	
Element element 
    = 
    redeclare? 
    final_? 
    inner? 
    outer? 
    base_class_decl SEMICOLON {: 
        base_class_decl.setRedeclareOpt(redeclare);
        base_class_decl.setFinalOpt(final_);   
        base_class_decl.setInnerOpt(inner);
        base_class_decl.setOuterOpt(outer);
        return base_class_decl;
    :}
    |
    redeclare? 
    final_? 
    inner? 
    outer? 
    replaceable
    base_class_decl
    constraining_clause? 
    comment SEMICOLON {: 
        base_class_decl.setRedeclareOpt(redeclare);
        base_class_decl.setFinalOpt(final_);   
        base_class_decl.setInnerOpt(inner);
        base_class_decl.setOuterOpt(outer);
        base_class_decl.setReplaceableOpt(new Opt(replaceable));
        base_class_decl.setConstrainingClauseOpt(constraining_clause);
        base_class_decl.setConstrainingClauseComment(comment);
        return base_class_decl;  
    :}  
    | extends_clause SEMICOLON {: 
        return extends_clause;
    :}
    | import_clause SEMICOLON {: 
        return import_clause;
    :}
    |
    redeclare? 
    final_? 
    inner? 
    outer? 
    type_prefix_flow? 
    type_prefix_variability? 
    type_prefix_input_output? 
    class_access/*name*/ 
    array_subscripts? 
    component_list 
    SEMICOLON {:
        return new PN_ComponentClause(
            redeclare,
            final_,
            inner,
            outer,
            new Opt(),
            type_prefix_flow,
            type_prefix_variability,
            type_prefix_input_output,
            class_access,
            array_subscripts,
            component_list,
            new Opt(),
            new Comment(new Opt(), new Opt()));
  :}
  | redeclare? 
    final_? 
    inner? 
    outer? 
    replaceable 
    type_prefix_flow? 
    type_prefix_variability? 
    type_prefix_input_output? 
    class_access/*name*/ 
    array_subscripts? 
    component_list 
    constraining_clause? 
    comment 
    SEMICOLON {: 
        return new PN_ComponentClause(
            redeclare,
            final_,
            inner,
            outer,
            new Opt(replaceable),
            type_prefix_flow,
            type_prefix_variability,
            type_prefix_input_output,
            class_access,
            array_subscripts,
            component_list,
            constraining_clause,comment); 
  :}
  | error SEMICOLON						  {: return new BadElement(); :}
  ;
  
ConstrainingClause constraining_clause = 
  CONSTRAINEDBY class_access/*name*/ class_modification?{: return new ConstrainingClause(class_access,class_modification); :}
  ;
  
PN_ExtendsClause extends_clause = 
   EXTENDS  class_access/*name*/ class_modification? annotation?    {: return new PN_ExtendsClause(class_access,class_modification,annotation); :}
  ;

ImportClause import_clause = 
  IMPORT 
  qualified_import_access 
  comment {: return new ImportClauseQualified(qualified_import_access,comment); :}
  | IMPORT 
  unqualified_import_access
  comment {: return new ImportClauseUnqualified(unqualified_import_access,comment); :}
  | IMPORT 
  id_decl.alias 
  EQUALS 
  qualified_import_access 
  comment {: return new ImportClauseRename(qualified_import_access,comment,alias); :}
  ;




ArraySubscripts array_subscripts = 
  LBRACK subscript_list RBRACK {: return new ArraySubscripts(subscript_list); :}
  ;
  
List subscript_list =
  subscript               {: return new List().add(subscript); :}
  | subscript_list COMMA subscript {: subscript_list.add(subscript);
                                      return subscript_list; :}
  ;
  
Subscript subscript =
  COLON                 {: return new ColonSubscript(); :}
  | exp                 {: return new ExpSubscript(exp); :}                                                                           
  ;


List component_list = 
  pn_component_decl                    {: return new List().add(pn_component_decl); :}
  | component_list COMMA pn_component_decl           {: component_list.add(pn_component_decl);
                                                      return component_list; :}
  ;
  
PN_ComponentDecl pn_component_decl = 
  id_decl.comp_name array_subscripts? modification? conditional_attribute? comment                   {: return new PN_ComponentDecl(comp_name,array_subscripts,modification,conditional_attribute,comment); :} 
  ;
  
ConditionalAttribute conditional_attribute = 
  IF exp {: return new ConditionalAttribute(exp); :}
  ;  
  
TypePrefix type_prefix_flow = 
    FLOW     {: return new Flow(); :}
  | STREAM   {: return new Stream(); :}
  ;
  
EquationClause equation_clause =
  EQUATION abstract_equation*  {:  return new EquationClause(abstract_equation); :}
  | INITIAL_EQUATION abstract_equation*  {:  //System.out.println("equation_clause"); 
  					     for (int i=0;i<abstract_equation.getNumChild();i++)
  					     	((AbstractEquation)abstract_equation.getChild(i)).setAbstractEquationModifier(new Initial()); 
  					     return new InitialEquationClause(abstract_equation); :}
  ;  

Algorithm algorithm =
  ALGORITHM statement_list            {: return new Algorithm(new Opt(), statement_list); :}
  | INITIAL_ALGORITHM statement_list  {: return new Algorithm(new Opt(new Initial()), 
                                                              statement_list); :}
  ;  

/*
List abstract_equation_list =
                                  {: return new List(); :}
  |abstract_equation                           {: return new List().add(abstract_equation); :}
  | abstract_equation_list abstract_equation  {: abstract_equation_list.add(abstract_equation); 
                                                 return abstract_equation_list; :}
  ;  
*/

List statement_list =
                              {: return new List(); :}
  | statement                 {: return new List().add(statement); :}
  | statement_list statement  {: statement_list.add(statement); 
                                 return statement_list; :}
  ;  

Modification modification =
  complete_modification               {: return complete_modification; :}
  |value_modification               {: return value_modification; :}
//  |assign_modification                 {: return assign_modification; :}  
  ;
  

CompleteModification complete_modification =
  class_modification value_modification?  {: return new CompleteModification(class_modification,value_modification); :}
  ;
  
ValueModification value_modification =
  EQUALS exp  {: return new ValueModification(exp); :}
  | COLON EQUALS exp  {: return new ValueModification(exp); :}
  ;

/*  
AssignModification assign_modification =
  COLON EQUALS exp  {: return new AssignModification(exp); :}
  ;  
  */
  
ClassModification class_modification = 
    LPAREN RPAREN {: return new ClassModification(); :}
  | LPAREN argument_list RPAREN {: return new ClassModification(argument_list); :}
  ;

List argument_list =
    argument                          {: return new List().add(argument); :}
  | argument_list COMMA argument    {: argument_list.add(argument); 
                                       return argument_list; :}
  ;

Argument argument = 
  each? 
  final_? 
  parse_access 
  modification? 
  string_comment? {: return new ComponentModification(each, 
                                                    final_,
                                                    parse_access,
                                                    modification,
                                                    string_comment); :}
  |each? 
   final_? 
   replaceable 
   base_class_decl 
   constraining_clause? {:  ClassAccess pa = new ClassAccess(base_class_decl.getName().getID());
   							pa.setLocationNoTree(base_class_decl.getName());
   							base_class_decl.setConstrainingClauseOpt(constraining_clause);
   							base_class_decl.setReplaceable(replaceable);
   							ClassRedeclare cdr = new ClassRedeclare(each,
                                                         final_,
                                                         pa,
                                                         base_class_decl); 
                            return cdr; :} 
  |each? 
   final_? 
   replaceable 
   type_prefix_flow?
   type_prefix_variability? 
   type_prefix_input_output? 
   class_access 
   id_decl.comp_name 
   array_subscripts? 
   modification? 
   comment
   constraining_clause? 
   {: 			ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
   				pa.setLocationNoTree(comp_name);
       			PN_ComponentDecl cd = new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment);
       			cd.setLocationNoTree(comp_name, comment);
   				PN_ComponentRedeclare cdr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(new Replaceable()),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(cd),
                                                               constraining_clause,
                                                               new Comment(new Opt(),new Opt()))); 
                                         return cdr; :}
  |REDECLARE 
   each? 
   final_?  
   base_class_decl {: ClassAccess pa = new ClassAccess(base_class_decl.getName().getID());
                      pa.setLocationNoTree(base_class_decl.getName());       
                      base_class_decl.setRedeclare(new Redeclare());
                      ClassRedeclare cdr = new ClassRedeclare(each,
                                                              final_,
                                                              pa,
                                                              base_class_decl);
                      return cdr; :}
  |REDECLARE
   each? 
   final_? 
   type_prefix_flow?
   type_prefix_variability? 
   type_prefix_input_output? 
   class_access 
   id_decl.comp_name 
   array_subscripts? 
   modification? 
   comment
   {: ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
   				pa.setLocationNoTree(comp_name, array_subscripts);
           		PN_ComponentDecl cd = new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment);
       			cd.setLocationNoTree(comp_name, comment);
   				PN_ComponentRedeclare cdr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(cd),
                                                               new Opt(),
                                                               new Comment(new Opt(),new Opt()))); 
                 return cdr; :}
                                                 
  |REDECLARE
   each? 
   final_? 
   replaceable 
   base_class_decl 
   constraining_clause? {:  base_class_decl.setConstrainingClauseOpt(constraining_clause);
                            base_class_decl.setReplaceable(replaceable);
                            base_class_decl.setRedeclare(new Redeclare());
                            ClassAccess ca = new ClassAccess(base_class_decl.getName().getID());
                            ca.setLocationNoTree(base_class_decl.getName());
                             return new  ClassRedeclare(each,
                                                         final_,
                                                         ca,
                                                         base_class_decl); :} 
  |REDECLARE
   each? 
   final_? 
   replaceable 
   type_prefix_flow?
   type_prefix_variability? 
   type_prefix_input_output? 
   class_access 
   id_decl.comp_name 
   array_subscripts? 
   modification? 
   comment
   constraining_clause? 
   {:  ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
       pa.setLocationNoTree(comp_name);
       PN_ComponentDecl cd = new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment);
       cd.setLocationNoTree(comp_name, comment);
       PN_ComponentRedeclare cr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(new Replaceable()),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(cd),
                                                               constraining_clause,
                                                               new Comment(new Opt(),new Opt()))); 
        return cr;                                                       
                                                               :}
   | error				{: return new BadArgument(); :}                                              
   ;

Annotation annotation = 
  ANNOTATION class_modification    {: return new ParseAnnotation(class_modification); :}
  ;  
   
   
AbstractEquation abstract_equation =
  exp.left EQUALS exp.right comment SEMICOLON
                                      {: return new Equation(new Opt(),comment,left,right); :}
  | if_equation SEMICOLON             {: return if_equation; :}
  | for_clause_e SEMICOLON            {: return for_clause_e; :}
  | when_equation SEMICOLON           {: return when_equation; :}
  | CONNECT LPAREN parse_access.a COMMA parse_access.b RPAREN comment SEMICOLON
                                      {: return new ConnectClause(new Opt(), comment,a,b); :}
  | LPAREN function_call_left_list RPAREN EQUALS function_call comment SEMICOLON
                                      {: return new FunctionCallEquation(new Opt(),comment,function_call_left_list,function_call); :}
  | function_call comment SEMICOLON   {: return new FunctionCallEquation(new Opt(),comment,new List(),function_call); :}
  ;

List function_call_left_list =
    function_call_left.a COMMA function_call_left.b   {: return new List().add(a).add(b); :}
  | function_call_left_list COMMA function_call_left  {: return function_call_left_list.add(function_call_left); :}
  ;

FunctionCallLeft function_call_left =
                   {: return new FunctionCallLeft(new Opt()); :}
  | parse_access   {: return new FunctionCallLeft(new Opt(parse_access)); :}
  ;

ForClauseE for_clause_e =
  FOR for_indices LOOP
  abstract_equation*
  END_FOR comment   {: return new ForClauseE(new Opt(), comment, for_indices,abstract_equation); :}
  ;


List for_indices = 
  for_index        {: return new List().add(for_index); :}
  | for_indices COMMA for_index {: for_indices.add(for_index);
                                     return for_indices; :}
  ;
  
ForIndex for_index = 
  id_decl for_in_exp? {: ForIndex f = new ForIndex(new ForIndexDecl(new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(new Parameter()),
                                                              new Opt(),
                                                              new ParseAccess("Integer",new Opt()),
                                                              new Opt(),
                                                              new PublicVisibilityType(),
                                                              id_decl,
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Comment(new Opt(),new Opt()),
                                                              new Opt(),
                                                              new Comment(new Opt(),new Opt())),
                                                   for_in_exp); 
                          f.setLocationNoTree(id_decl, for_in_exp); 
                          return f; :}
  ;

Exp for_in_exp =
  IN exp.e {: return e; :}
  ;

WhenEquation when_equation =
  WHEN exp.test THEN
  abstract_equation*
  else_when_equation?
  END_WHEN comment     {: return new WhenEquation(new Opt(), 
                                                  comment, 
                                                  abstract_equation,
                                                  test, 
                                                  else_when_equation); 
                       :}
  ;  

WhenEquation else_when_equation =
  ELSEWHEN exp.test THEN
  abstract_equation* 
  else_when_equation?     {: return new WhenEquation(new Opt(), 
                                                     new Comment(), 
                                                     abstract_equation, 
                                                     test, 
                                                     else_when_equation); 
                          :}
  ;

IfEquation if_equation =
  IF exp.test THEN
  abstract_equation*
  else_if_equation?
  END_IF comment      {: return new IfEquation(new Opt(), 
                                               comment, 
                                               abstract_equation, 
                                               test, 
                                               else_if_equation); 
                      :}
  ;  

IfWhenElseEquation else_if_equation =
    ELSEIF exp.test THEN
    abstract_equation* 
    else_if_equation?        {: return new IfEquation(new Opt(), 
                                                      new Comment(), 
                                                      abstract_equation, 
                                                      test, 
                                                      else_if_equation); 
                             :}
  | ELSE abstract_equation*  {: return new ElseEquation(new Opt(), 
                                                        new Comment(), 
                                                        abstract_equation); 
                             :}
  ;


Statement statement =
  parse_access.left ASSIGN exp.right comment SEMICOLON                  
                                     {: return new AssignStmt(comment, left, right); :}
  | function_call_stmt SEMICOLON     {: return function_call_stmt; :}
  | BREAK comment SEMICOLON          {: return new BreakStmt(comment); :} 
  | RETURN comment SEMICOLON         {: return new ReturnStmt(comment); :}
  | if_stmt SEMICOLON                {: return if_stmt; :}
  | when_stmt SEMICOLON              {: return when_stmt; :}
  | for_stmt SEMICOLON               {: return for_stmt; :}
  | while_stmt SEMICOLON             {: return while_stmt; :}
  | error                            {: return new BadStatement(); :}
  ;
  
FunctionCallStmt function_call_stmt =
    LPAREN function_call_stmt_left_list RPAREN ASSIGN function_call comment  
                           {: return new FunctionCallStmt(comment, function_call_stmt_left_list, function_call); :}
  | function_call comment  {: return new FunctionCallStmt(comment, new List(), function_call); :}
  ;

List function_call_stmt_left_list =
    function_call_stmt_left   {: return new List().add(function_call_stmt_left); :}
  | function_call_stmt_left_list COMMA function_call_stmt_left  {: return function_call_stmt_left_list.add(function_call_stmt_left); :}
  ;

FunctionCallLeft function_call_stmt_left =
                   {: return new FunctionCallLeft(new Opt()); :}
  | parse_access   {: return new FunctionCallLeft(new Opt(parse_access)); :}
  ;

IfStmt if_stmt =
    IF if_clause_list else_stmts END_IF comment {: return new IfStmt(comment, if_clause_list, new Opt(else_stmts)); :}
  | IF if_clause_list END_IF comment {: return new IfStmt(comment, if_clause_list, new Opt()); :}
  ;  

List if_clause_list =
    if_clause                        {: return new List().add(if_clause); :}
  | if_clause_list ELSEIF if_clause  {: return if_clause_list.add(if_clause); :}
  ;

IfClause if_clause =
  exp THEN statement_list  {: return new IfClause(exp, statement_list); :}
  ;

ElseClause else_stmts =
  ELSE statement_list  {: return new ElseClause(statement_list); :}
  ;

WhenStmt when_stmt =
  WHEN when_clause_list END_WHEN comment {: return new WhenStmt(comment, when_clause_list); :}
  ;  

List when_clause_list =
    when_clause                            {: return new List().add(when_clause); :}
  | when_clause_list ELSEWHEN when_clause  {: return when_clause_list.add(when_clause); :}
  ;

WhenClause when_clause =
  exp THEN statement_list  {: return new WhenClause(exp, statement_list); :}
  ;

ForStmt for_stmt =
  FOR for_indices LOOP for_stmt_list END_FOR comment  
                         {: return new ForStmt(comment, for_indices, for_stmt_list); :}
  ;
  
ForStmtList for_stmt_list =
  statement_list {: return new ForStmtList(statement_list); :}
  ;

WhileStmt while_stmt = 
  WHILE exp LOOP statement_list END_WHILE comment  {: return new WhileStmt(comment, exp, statement_list); :}
  ;
  
Exp exp =
  simple_expression {: return simple_expression; :}
  | if_exp           {: return if_exp; :}
  ;

IfExp if_exp =
  IF exp.ifexp THEN exp.thenexp else_if_exp 
  		{: return new IfExp(ifexp, thenexp, else_if_exp); :}
  ;  

Exp else_if_exp =
   ELSEIF exp.ifexp THEN exp.thenexp else_if_exp 
		{: return new IfExp(ifexp, thenexp, else_if_exp); :}
 | ELSE exp   {: return exp; :}
  ;

Exp simple_expression = 
    log_exp 
        {: return log_exp; :}
  | log_exp.l1 COLON log_exp.l2
        {: RangeExp r = new RangeExp();
           r.addExp(l1);
           r.addExp(l2);
           return r; :}
  | log_exp.l1 COLON log_exp.l2 COLON log_exp.l3
        {: RangeExp r = new RangeExp();
           r.addExp(l1);
           r.addExp(l2);
           r.addExp(l3);
           return r; :}
  ;

Exp log_exp = 
  log_exp.a OR log_exp.b {: return new OrExp(a,b); :}  
  | log_exp.a AND log_exp.b {: return new AndExp(a,b); :}  
  | NOT relation.a {: return new NotExp(a); :}  
  | relation {: return relation; :}
;

Exp relation =
  artm_exp.a LT artm_exp.b {: return new LtExp(a,b); :}
  | artm_exp.a LEQ artm_exp.b {: return new LeqExp(a,b); :}
  | artm_exp.a GT artm_exp.b {: return new GtExp(a,b); :}
  | artm_exp.a GEQ artm_exp.b {: return new GeqExp(a,b); :}
  | artm_exp.a EQ artm_exp.b {: return new EqExp(a,b); :}
  | artm_exp.a NEQ artm_exp.b {: return new NeqExp(a,b); :}
  | artm_exp.a {: return a; :}	
  ;
  
  
  Exp artm_exp =
   additive_exp {: return additive_exp; :}
   ;

  Exp additive_exp =
     multiplicative_exp.e    {: return e; :}
   | additive_exp.e1 PLUS multiplicative_exp.e2      {: return new AddExp(e1, e2); :}
   | additive_exp.e1 MINUS multiplicative_exp.e2     {: return new SubExp(e1, e2); :}
   | additive_exp.e1 DOTPLUS multiplicative_exp.e2   {: return new DotAddExp(e1, e2); :}
   | additive_exp.e1 DOTMINUS multiplicative_exp.e2  {: return new DotSubExp(e1, e2); :}
   ;

  Exp multiplicative_exp =
     unary_exp.e                                     {: return e; :}
   | multiplicative_exp.e1 MULT unary_exp.e2     {: return new MulExp(e1, e2); :}
   | multiplicative_exp.e1 DIV unary_exp.e2      {: return new DivExp(e1, e2); :}
   | multiplicative_exp.e1 DOTMULT unary_exp.e2  {: return new DotMulExp(e1, e2); :}
   | multiplicative_exp.e1 DOTDIV unary_exp.e2   {: return new DotDivExp(e1, e2); :} 
   ;


Exp unary_exp =
   pow_exp          {: return pow_exp; :}
   | MINUS unary_exp       {: return new NegExp(unary_exp); :}
   | PLUS unary_exp        {: return unary_exp; :}
   ;

Exp pow_exp =
    primary {:return primary; :}
    | primary.a POW primary.e    {: return new PowExp(a,e); :}
    | primary.a DOTPOW primary.e {: return new DotPowExp(a,e); :}
    ;

Exp primary =        
   UNSIGNED_NUMBER.n    {: return new RealLitExp(n); :}
  | UNSIGNED_INTEGER.n    {: return new IntegerLitExp(n); :}
  | TRUE                {: return new BooleanLitExpTrue(); :}
  | FALSE                {: return new BooleanLitExpFalse(); :}
  | STRING.s               {: return new StringLitExp(s); :}
  | access_expression   {: return access_expression; :}
  | der_expression      {: return der_expression; :}
  | LPAREN exp.a RPAREN {: formatting.addParenthesis(LPAREN, RPAREN);
						   return a; :}
  | function_call        {: return function_call; :}
  | LBRACK matrix RBRACK {: return matrix; :}
  | LBRACE function_arguments RBRACE {: return new ArrayConstructor(function_arguments); :}
  | TIME                {: return new TimeExp(); :}
  | END                 {: return new EndExp(); :} 
  ;
 
 FunctionCall function_call =
    parse_access LPAREN function_arguments? RPAREN 
                                      {: return new FunctionCall(parse_access, function_arguments); :}
  ;  
  
 PartialFunctionCall partial_function_call =
    FUNCTION parse_access LPAREN function_arguments? RPAREN 
                                      {: return new PartialFunctionCall(parse_access, function_arguments); :}
  ;  
  
FunctionArguments function_arguments =
    exp FOR for_indices               {: List arg_list_f = new List().add(new IterExp(exp, for_indices));
                                         return new FunctionArguments(arg_list_f, new List()); :} 
  | arg_list_p                        {: return new FunctionArguments(arg_list_p, new List()); :}  
  | arg_list_p COMMA named_arguments  {: return new FunctionArguments(arg_list_p, named_arguments); :}
  | named_arguments                   {: return new FunctionArguments(new List(), named_arguments); :}
  ;
  
List named_arguments =
    named_argument                       {: return new List().add(named_argument); :}
  | named_arguments COMMA named_argument {: return named_arguments.add(named_argument); :}
  ;
  
Exp function_argument_exp =
 exp                               {: return exp; :}
 | partial_function_call          {: return partial_function_call; :}  
 ;
  
NamedArgument named_argument =
  named_argument_id EQUALS function_argument_exp {: return new NamedArgument(named_argument_id,function_argument_exp); :}
  ;

Access named_argument_id = 
  ID.id {: return new ParseAccess(id, new Opt()); :}
  ;

Matrix matrix = 
    matrix_row                   {: return new Matrix(new List().add(matrix_row)); :}
  | matrix SEMICOLON matrix_row  {: matrix.addRow(matrix_row); 
                                    return matrix; :}      
  ;  
  
MatrixRow matrix_row = 
    exp                   {: return new MatrixRow(new List().add(exp)); :}
  | matrix_row COMMA exp  {: matrix_row.addExp(exp); 
                             return matrix_row; :}
  ; 
  
List arg_list = 
                        {: return new List(); :}
  | exp                 {: return new List().add(exp); :}
  | arg_list COMMA exp  {: arg_list.add(exp); 
                           return arg_list; :}
  ;
  
List arg_list_p = 
  function_argument_exp                   {: return new List().add(function_argument_exp); :}
  | arg_list_p COMMA function_argument_exp  {: return arg_list_p.add(function_argument_exp); :}
  ;
  
Comment comment = 
  string_comment?  annotation?     {: return new Comment(string_comment,annotation); :}
  ;
  
StringComment string_comment =
  STRING.s      {: return new StringComment(s); :}
  | string_comment PLUS STRING.s {: string_comment.setComment(string_comment.getComment().concat(s));
                                    return string_comment; :}
  
  ;
 
 IdDecl id_decl = 
   ID.id   {: return new IdDecl(id); :}
 ;

 AccessExp access_expression =
   parse_access {: return new AccessExp(parse_access); :}
 ;

 DerExp der_expression = 
   DER LPAREN exp RPAREN  {: return new DerExp(exp); :}
 ;

 Access parse_access = 
   parse_access_loc        {: return parse_access_loc; :}
 | DOT first_class_access  {: return new GlobalAccess(first_class_access); :}
 ;
 
 Access parse_access_loc = 
   parse_access_single   {: return parse_access_single; :}
 | parse_access_single DOT parse_access_loc 
   			             {: return new PN_Dot(parse_access_single, parse_access_loc); :}
 ;
 
 Access first_class_access =
   class_access_single  {: return class_access_single; :}
 | class_access_single DOT parse_access_loc  
 						{: return new PN_Dot(class_access_single, parse_access_loc); :}
 ;
 
 ParseAccess parse_access_single = 
   ID.id  array_subscripts? {: return new ParseAccess(id, array_subscripts); :}
 ;   
 
 ParseAccess parse_access_single_simple = 
   ID.id  {: return new ParseAccess(id, new Opt()); :}
 ;      

   
 Access qualified_import_access = 
   qualified_import_access_loc      {: return qualified_import_access_loc; :}
 | DOT qualified_import_access_loc  {: return new GlobalAccess(qualified_import_access_loc); :}
 ;
 
 Access qualified_import_access_loc = 
   qualified_import_access_rec
            {: return qualified_import_access_rec; :}
 | class_access_single
            {: return class_access_single; :}
 ;
 
 Access qualified_import_access_rec = 
   class_access_single DOT parse_access_single_simple  
   			{: return new PN_Dot(class_access_single, parse_access_single_simple); :}
 | class_access_single DOT qualified_import_access_rec 
   			{: return new PN_Dot(class_access_single, qualified_import_access_rec); :}
 ;

 
 Access unqualified_import_access =
   class_access DOTMULT   {: return class_access; :}
 ;
 
 
 Access class_access = 
   class_access_loc      {: return class_access_loc; :}
 | DOT class_access_loc  {: return new GlobalAccess(class_access_loc); :}
 ;
 
 Access class_access_loc = 
   class_access_single                      {: return class_access_single; :}
 | class_access_single DOT class_access_loc {: return new PN_Dot(class_access_single, class_access_loc); :}
 ;    
  
 ClassAccess class_access_single = 
   ID.id  {: return new ClassAccess(id); :}
 ;
   
 EndDecl end_decl =
   END_ID {: String value = (String) END_ID.value;
             String id = value.substring(3, value.length()).trim();
             return new EndDecl(id); :}
 ;