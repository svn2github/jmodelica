/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.PrintStream;
import java.util.ArrayDeque;
import java.util.Collections;
import java.util.Deque;
import java.util.Iterator;

aspect DiagnosticsGeneration {

/**
 * A class for generating 
 */
public class DiagnosticsGenerator {

	private String modelName;
	private String modelNameUnderscore;
	private String diagnosticsDirString;
	
	private String rawFlattenedModelFileName;
	private String transformedModelFileName;	
	private String errorsFileName;
	private String bltFileName;	
	private String bltTableFileName;	
	private String aliasFileName;		
	private String connectionsFileName;		
    private String indexFileName;			
    private String ivFileName;			

	private String rawFlattenedModelAbsFileName;
	private String transformedModelAbsFileName;	
	private String errorsAbsFileName;
	private String bltAbsFileName;	
	private String bltTableAbsFileName;	
	private String aliasAbsFileName;		
	private String connectionsAbsFileName;		
    private String indexAbsFileName;		
    private String ivAbsFileName;
    
    private DiagnosticsFile rawFlattenedModel;
	
	private int numErrors = -1;
	private int numComplianceErrors = -1;
	private int numWarnings = -1;
	
	private Collection<Problem> problems = new TreeSet<Problem>();

	/**
	 * Default constructor for the Diagnostics generator.
	 *
	 * The diagnostics generator generates a number of HTML files containing
	 * diagnostics for the compilation of a model.
	 */	
	private String html_header ="<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n" +   
								"<html>\n" + 
								"<head>\n" + 
								"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n" +
								"<title>Model diagnosis</title>\n" + 
								"</head>\n" + 
								"<body style=\"background-color: rgb(255, 255, 255);\">\n";
	
	private String html_tail = "</body>\n </html>\n";
	
	private String indexDiagnostics;
	
	public DiagnosticsGenerator(String modelName) {
		this.modelName = modelName;
		this.modelNameUnderscore = modelName.replace('.','_');
		// Create directory containing the diagnostics files	
		File currDir = new File(".");
		String currDirString = currDir.getAbsolutePath().substring(0,currDir.getAbsolutePath().length()-2);
		File diagnosticsDir = new File(currDirString,this.modelNameUnderscore + "_html_diagnostics");
		boolean success = diagnosticsDir.mkdir();
		diagnosticsDirString = diagnosticsDir.getAbsolutePath();
		
		rawFlattenedModel = new RawFlatModelFile();
		
		DiagnosticsFile[] files = new DiagnosticsFile[] {
				rawFlattenedModel
		};
		
		for (DiagnosticsFile file : files)
			file.clear();
		
//		this.rawFlattenedModelFileName = this.modelNameUnderscore + "_raw.html";
		this.transformedModelFileName = this.modelNameUnderscore + "_transformed.html";
		this.errorsFileName = this.modelNameUnderscore + "_errors.html";
		this.bltFileName = this.modelNameUnderscore + "_blt.html";
		this.bltTableFileName = this.modelNameUnderscore + "_bltTable.html";
		this.aliasFileName = this.modelNameUnderscore + "_alias.html";
		this.connectionsFileName = this.modelNameUnderscore + "_connections.html";
		this.ivFileName = this.modelNameUnderscore + "_iv.html";
		this.indexFileName = "index.html";
		
		indexDiagnostics = "<h2>" + modelName + "</h2>\n{problemsString}\n";
		
//		this.rawFlattenedModelAbsFileName = (new File(diagnosticsDirString,this.rawFlattenedModelFileName)).getAbsolutePath();
		this.transformedModelAbsFileName = (new File(diagnosticsDirString,this.transformedModelFileName)).getAbsolutePath();
		this.errorsAbsFileName = (new File(diagnosticsDirString,this.errorsFileName)).getAbsolutePath();
		this.bltAbsFileName = (new File(diagnosticsDirString,this.bltFileName)).getAbsolutePath();
		this.bltTableAbsFileName = (new File(diagnosticsDirString,this.bltTableFileName)).getAbsolutePath();
		this.aliasAbsFileName = (new File(diagnosticsDirString,this.aliasFileName)).getAbsolutePath();
		this.connectionsAbsFileName = (new File(diagnosticsDirString,this.connectionsFileName)).getAbsolutePath();
		this.ivAbsFileName = (new File(diagnosticsDirString,this.ivFileName)).getAbsolutePath();
		this.indexAbsFileName = (new File(diagnosticsDirString,this.indexFileName)).getAbsolutePath();
		
		// Clear old files
		PrintStream out;
		try {
//			out = new PrintStream(rawFlattenedModelAbsFileName,"UTF-8");
//			out.close();
			out = new PrintStream(transformedModelAbsFileName,"UTF-8");
			out.close();
			out = new PrintStream(errorsAbsFileName,"UTF-8");
			out.close();
			out = new PrintStream(bltAbsFileName,"UTF-8");
			out.close();
			out = new PrintStream(bltTableAbsFileName,"UTF-8");
			out.close();
			out = new PrintStream(aliasAbsFileName,"UTF-8");
			out.close();
			out = new PrintStream(connectionsAbsFileName,"UTF-8");
			out.close();
			out = new PrintStream(ivAbsFileName,"UTF-8");
			out.close();
			out = new PrintStream(indexAbsFileName,"UTF-8");
			out.close();
		} catch(FileNotFoundException e) {
		} catch(UnsupportedEncodingException e) {		
		} 
	}

    /**
     *  Write a file containing the raw flattened model.
     */
	public void writeRawFlattenedModel(FClass fc) {
		rawFlattenedModel.write(fc);
	}
	
	public class RawFlatModelFile extends DiagnosticsFile {
		
		public RawFlatModelFile() {
			super("Flattened model", "raw", false);
		}
		
		protected void writeContents(FClass fc, CodeStream out) {
			// Dump model to file
			out.print("<pre>\n");
			fc.prettyPrint(out, "");
			out.print("</pre>\n");
		}
		
	}

    /**
     *  Write a file containing the transformed scalarized model..
     */	
	public void writeTransformedFlattenedModel(FClass fc) {
		// Dump model to file
		try {
		    CodeStream out;
			out = new CodeStream(new PrintStream(transformedModelAbsFileName,"UTF-8"));
			out.print(html_header);
			out.print("<pre>\n");
			fc.prettyPrint(out, "");
			out.print("</pre>\n");	
			out.print(html_tail);
		   	out.close();
		} catch(FileNotFoundException e) {
		} catch(UnsupportedEncodingException e) {		
		} 
	}

    /**
     *  Write a file containing BLT information
     */	
	public void writeBLTFile(FClass fc) {
		// Dump model to file
		try {
		    CodeStream out;
			out = new CodeStream(new PrintStream(bltAbsFileName,"UTF-8"));
			out.print(html_header);
			if (fc.root().options.getBooleanOption("equation_sorting")) {
				out.print("<h2>BLT for initialization system </h2>\n");
				for (AbstractEquationBlock eb : fc.getDAEInitBLT()) {
					out.print("<pre>\n");
					eb.prettyPrint(out);
					out.print("</pre>\n");
				}
				out.print("<h2>BLT for DAE system </h2>\n");
				out.print("<h3> ODE blocks </h3>\n");	
				// Loop over all derivatives
				for (AbstractEquationBlock eb : fc.getDAEStructuredBLT().getOdeBlocks()) {
					out.print("<pre>\n");
					eb.prettyPrint(out);
					out.print("</pre>\n");
				}
				out.print("<h3> Real output blocks </h3>\n");
				for (AbstractEquationBlock eb : fc.getDAEStructuredBLT().getRealOutputBlocks()) {
					out.print("<pre>\n");
					eb.prettyPrint(out);
					out.print("</pre>\n");
				}
				out.print("<h3> Integer and boolean output blocks </h3>\n");	
				for (AbstractEquationBlock eb : fc.getDAEStructuredBLT().getIntegerBooleanOutputBlocks()) {
					out.print("<pre>\n");
					eb.prettyPrint(out);
					out.print("</pre>\n");
				}
				out.print("<h3> Other output blocks </h3>\n");
				for (AbstractEquationBlock eb : fc.getDAEStructuredBLT().getOtherBlocks()) {
					out.print("<pre>\n");
					eb.prettyPrint(out);
					out.print("</pre>\n");
				}		
			}
			out.print("</pre>\n");	
			out.print(html_tail);
		   	out.close();
		} catch(FileNotFoundException e) {
		} catch(UnsupportedEncodingException e) {
		}
		writeIVFile(fc);
	}
	
	public void writeIVFile(FClass fc) {
		// Dump model to file
		try {
		    PrintStream out;
			out = new PrintStream(ivAbsFileName, "UTF-8");
			out.print(html_header);
			if (fc.root().options.getBooleanOption("equation_sorting")) {
				out.print("<h2>Alias sets of iteration variables:</h2>\n");
				out.print("<pre>\n");
				Set<FVariable> vars = new HashSet<FVariable>();
				for (AbstractEquationBlock eb : fc.getDAEStructuredBLT())
					if (eb instanceof TornEquationBlock)
						vars.addAll(eb.unsolvedVariables());
				for (AliasManager.AliasSet as : fc.getAliasManager().getAliasSets())
					if (vars.contains(as.getIterationVariable().getFVariable()))
						out.println(as.toStringWithStart());
				out.print("</pre>\n");
			}
			out.print(html_tail);
		   	out.close();
		} catch(FileNotFoundException e) {
		} catch(UnsupportedEncodingException e) {
		}
	}

    /**
     *  Write a file containing the alias elimination information
     */	
	public void writeAliasFile(FClass fc) {
		// Dump model to file
		try {
		    PrintStream out;
			out = new PrintStream(aliasAbsFileName,"UTF-8");
			out.print(html_header);
			out.print("<h2>Alias sets: " + modelName + "</h2>\n"); 
			out.print("<pre>\n");
			out.print(fc.aliasDiagnostics());
			out.print("</pre>\n");	
			out.print(html_tail);
		   	out.close();
		} catch(FileNotFoundException e) {
		} catch(UnsupportedEncodingException e) {		
		} 
	}

    /**
     *  Write a file containing the alias elimination information
     */	
	public void writeConnectionsFile(FClass fc) {
		try {
		    PrintStream out;
			out = new PrintStream(connectionsAbsFileName,"UTF-8");
			out.print(html_header);
			out.print("<h2>Connection sets: " + modelName + "</h2>\n"); 
			out.print("<pre>\n");
			out.print(fc.getConnectionSetManager().printConnectionSets());
			out.print("</pre>\n");	
			out.print(html_tail);
		   	out.close();
		} catch(FileNotFoundException e) {
		} catch(UnsupportedEncodingException e) {		
		} 
	}
	
	/**
     *  Write a file containing the problems in the model.
     */
	public void writeProblems(Collection<Problem> newProblems) {
		// Add the problems to our set of problems
		problems.addAll(newProblems);
		// Print problems
		try {
			PrintStream out;
			out = new PrintStream(errorsAbsFileName,"UTF-8");
			out.print(html_header);
			out.print("<h2>Problems: " + modelName + "</h2>\n"); 
			out.print("<pre>\n");
			StringBuffer errs = new StringBuffer();
			StringBuffer compErrs = new StringBuffer();
			StringBuffer warns = new StringBuffer();
			numErrors = 0;
			numComplianceErrors = 0;
			numWarnings = 0;
			for (Problem p : problems) {
				if (p.severity() == Problem.Severity.ERROR && 
				    p.kind() != Problem.Kind.COMPLIANCE) {
					errs.append(p.toString() + "\n");
					numErrors++; 
				} else if (p.severity() == Problem.Severity.ERROR &&
				           p.kind() == Problem.Kind.COMPLIANCE) {
					compErrs.append(p.toString() + "\n");
					numComplianceErrors++;
				} else if (p.severity() == Problem.Severity.WARNING) {
					warns.append(p.toString() + "\n");
					numWarnings++;
				}
			}
			out.print(errs.toString());
			out.print(compErrs.toString());
			out.print(warns.toString());
			out.print("</pre>\n");	
			out.print(html_tail);
			out.close();
			
			// Update the index file.
			writeIndexFile();
		} catch(FileNotFoundException e) {
		} catch(UnsupportedEncodingException e) {
		} 
	}
	
	private String modelDiagnosticsBeforeTransform;
	
	public void setModelDiagnosticsBeforeTransform(String s) {
		modelDiagnosticsBeforeTransform = s;
	}
	
	
	/**
     *  Write index.html.
     */
	public void writeDiagnostics(FClass fc) {
		
		produceIndexDiagnostics(fc);
		writeIndexFile();
		
		// Create BLT diagnostics file (if equation_sorting is true)
		writeBLTFile(fc);
				
		// Create BLT table diagnostics file (if equation_sorting is true)
		writeBLTTableFile(fc);
				
		// Create connection set information file
		writeConnectionsFile(fc);
				
		// Create a file for alias information
		writeAliasFile(fc);
	}
	
	private void produceIndexDiagnostics(FClass fc) {
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		CodeStream out = new CodeStream(os);
		out.println("<h2>" + modelName + "</h2>");
		out.println("{problemsString}"); 
		
		out.println("<h3>Model before transformation</h3>");
		out.println("<p><pre>");
		// Diagnostics about model sizes
		out.print(modelDiagnosticsBeforeTransform);
		out.println("</pre></p>");
		rawFlattenedModel.writeLink(out);
//		out.println("<p><a href=\"" + rawFlattenedModelFileName + "\">Flattened model</a></p>"); 
		out.println("<p><a href=\"" + connectionsFileName + "\">Connection sets</a></p>"); 
		
		
		out.println("<h3>Model after transformation</h3>");
		out.println("<p><pre>");
		// Diagnostics about model sizes
		out.print(fc.modelDiagnostics());
		out.println("</pre></p>");	
		// Model name and links to the flattened models
		out.println("<p><a href=\"" + transformedModelFileName + "\">Transformed model</a></p>"); 
		out.println("<p><a href=\"" + aliasFileName + "\"> Alias sets</a> (" + fc.aliasDiagnosticsShort()  + ")</p>"); 
		out.println("<p><a href=\"" + bltFileName + "\">BLT diagnostics</a><br />"); 
		out.println("<a href=\"" + bltTableFileName + "\">BLT diagnostics table</a></p>"); 
		
        if (fc.root().options.getBooleanOption("equation_sorting")) {
            ArrayList<Integer> unsolvedDAEInitBlockSizes =
                fc.getDAEInitBLT().unsolvedBlockSizes(); 
            out.print("<p>Number of unsolved equation blocks in DAE initialization system: " + 
                      unsolvedDAEInitBlockSizes.size() + ": {");   
            int ind = 0;
            for (Integer bs : unsolvedDAEInitBlockSizes) {
                out.print(bs.toString());
                if (ind<unsolvedDAEInitBlockSizes.size()-1) {
                    out.print(",");
                }   
                ind++;
            }
            out.println("}<br />");
            if (!fc.onlyInitBLT()) {
                ArrayList<Integer> unsolvedDAEBlockSizes =
                        fc.getDAEBLT().unsolvedBlockSizes(); 
                out.print("Number of unsolved equation blocks in DAE system: " + 
                        unsolvedDAEBlockSizes.size() + ": {");   
                ind = 0;
                for (Integer bs : unsolvedDAEBlockSizes) {
                    out.print(bs.toString());
                    if (ind<unsolvedDAEBlockSizes.size()-1) {
                        out.print(",");
                    }   
                    ind++;
                }
                out.println("}");
            }
            out.println("</p>");
            if (EquationBlockFactory.canTear(fc.root().options)) {
                unsolvedDAEInitBlockSizes = fc.getDAEInitBLT().unsolvedBlockIterationSizes();
                out.print("<p>Number of unsolved equation blocks in DAE initialization system after tearing: " + 
                          unsolvedDAEInitBlockSizes.size() + ": {");   
                ind = 0;
                for (Integer bs : unsolvedDAEInitBlockSizes) {
                    out.print(bs.toString());
                    if (ind<unsolvedDAEInitBlockSizes.size()-1) {
                        out.print(",");
                    }   
                    ind++;
                }
                out.println("}<br />");
                if (!fc.onlyInitBLT()) {
                    ArrayList<Integer> unsolvedDAEBlockSizes = fc.getDAEBLT().unsolvedBlockIterationSizes();
                    out.print("Number of unsolved equation blocks in DAE system after tearing: " + 
                              unsolvedDAEBlockSizes.size() + ": {");
                    ind = 0;
                    for (Integer bs : unsolvedDAEBlockSizes) {
                        out.print(bs.toString());
                        if (ind<unsolvedDAEBlockSizes.size()-1) {
                            out.print(",");
                        }   
                        ind++;
                    }
                    out.print("}");
                }
                out.println("</p>");
            }
        }
		indexDiagnostics = os.toString();
	}
	
	public void writeIndexFile() {
		// Create index.html containing:
		
		try {
			PrintStream out;
			out = new PrintStream(indexAbsFileName,"UTF-8");
			out.print(html_header);
			out.print(indexDiagnostics.replaceFirst("\\{problemsString\\}", "<p><a href=\"" + errorsFileName + "\"> Problems:</a><br />\n" +
					"  " + numErrors + " errors, " + numComplianceErrors + " compliance errors, " + numWarnings + " warnings</p>"));
			out.print(html_tail);
		   	out.close();
		} catch(FileNotFoundException e) {
		} catch(UnsupportedEncodingException e) {		
		} 
		
	}

    /**
     *  Finalize the generation.
     */
    public void finalize() {}

    private static String BLT_style = "\n" +
            "<style type=\"text/css\">" + 
            "div.blt {\n" +
            "    position:relative;\n" +
            "    margin-left:200px;\n" +
            "    margin-top:200px;\n" +
            "    border:1px solid black;\n" +
            "    font-family:sans-serif;\n" +
            "    font-size:10px;\n" +
            "}\n" +
            "div.block {\n" +
            "    position:absolute;\n" +
            "    box-sizing:border-box;\n" +
            "    border:1px solid black;\n" +
            "}\n" +
            "div.incidence {\n" +
            "    position:absolute;\n" +
            "    cursor:pointer;\n" +
            "}\n" +
            "div.incidence div{\n" +
            "    width:" + AbstractEquationBlock.DIAGNOSTICS_CELL_SIZE + "px;\n" +
            "    height:" + AbstractEquationBlock.DIAGNOSTICS_CELL_SIZE + "px;\n" +
            "    overflow:hidden;\n" +
            "    display:table-cell;\n" +
            "    text-align:center;\n" +
            "    vertical-align:middle;\n" +
            "}\n" +
            "div.equation {\n" +
            "    position:absolute;\n" +
            "    left:-200px;\n" +
            "    width:200px;\n" +
            "    box-sizing:border-box;\n" +
            "    height:" + (AbstractEquationBlock.DIAGNOSTICS_CELL_SIZE + 1) + "px;\n" +
            "    border-top:1px solid black;\n" +
            "    border-bottom:1px solid black;\n" +
            "    overflow:hidden;\n" +
            "    white-space:nowrap;\n" +
            "}\n" +
            "div.variable {\n" +
            "    position:absolute;\n" +
            "    top:-109px;\n" +
            "    box-sizing:border-box;\n" +
            "    height:" + (AbstractEquationBlock.DIAGNOSTICS_CELL_SIZE + 1) + "px;\n" +
            "    width:200px;\n" +
            "    border-top:1px solid black;\n" +
            "    border-bottom:1px solid black;\n" +
            "    overflow:hidden;\n" +
            "    white-space:nowrap;\n" +
            "    transform:rotate(270deg);\n" +
            "    -ms-transform:rotate(270deg);\n" +
            "    -webkit-transform:rotate(270deg);\n" +
            "    -moz-transform:rotate(270deg);\n" +
            "}\n" +
            "table.incidenceMatrix {\n" +
            "    border-collapse:collapse;\n" +
            "}\n" +
            "\n" +
            "th.var {\n" +
            "    border-right:1px solid black;\n" +
            "    border-left:1px solid black;\n" +
            "}\n" +
            "\n" +
            "div.var {\n" +
            "    width:30px;\n" +
            "    overflow:hidden;\n" +
            "    white-space:nowrap;\n" +
            "}\n" +
            "\n" +
            "th.eqn {\n" +
            "    text-align:right;\n" +
            "    border-top:1px solid black;\n" +
            "    border-bottom:1px solid black;\n" +
            "}\n" +
            "\n" +
            "div.eqn {\n" +
            "    max-width:200px;\n" +
            "    overflow:hidden;\n" +
            "    white-space:nowrap;\n" +
            "}\n" +
            "\n" +
            "table.incidenceMatrix td {\n" +
            "text-align:center;\n" +
            "height:30px;\n" +
            "}\n" +
            "\n" +
            "div#rowHighlight,\n" +
            "div#colHighlight {\n" +
            "    position:absolute;\n" +
            "    z-index:1000;\n" +
            "    background:#999;\n" +
            "    opacity: 0.3;\n" +
            "}\n" +
            "\n" +
            "div#rowLockHighlight,\n" +
            "div#colLockHighlight {\n" +
            "    position:absolute;\n" +
            "    z-index:900;\n" +
            "    background:#999;\n" +
            "    opacity: 0.3;\n" +
            "}\n" +
            "\n" +
            "</style>\n" +
            "<script tyle=\"text/javascript\">\n" +
            "\n" +
            "var currentHightlight = null;\n" +
            "var currentLockHightlight = null;\n" +
            "\n" +
            "function hightlight(incidence) {\n" +
            "    var row = document.getElementById('rowHighlight');\n" +
            "    var col = document.getElementById('colHighlight');\n" +
            "    var blt = incidence.parentElement;\n" +
            "    setHighlight(incidence, blt, row, col)\n" +
            "}\n" +
            "function unhighlight(incidence) {\n" +
            "    var row = document.getElementById('rowHighlight');\n" +
            "    row.style.display = 'none';\n" +
            "    var col = document.getElementById('colHighlight');\n" +
            "    col.style.display = 'none';\n" +
            "}\n" +
            "\n" +
            "function lockHighlight(incidence) {\n" +
            "    var row = document.getElementById('rowLockHighlight');\n" +
            "    var col = document.getElementById('colLockHighlight');\n" +
            "    var blt = incidence.parentElement;\n" +
            "    setHighlight(incidence, blt, row, col)\n" +
            "}\n" +
            "\n" +
            "function setHighlight(incidence, blt, row, col) {\n" +
            "    row.style.width = blt.offsetWidth + 'px';\n" +
            "    row.style.height = (incidence.offsetHeight + 1)+ 'px';\n" +
            "    row.style.top = (offsetTop(incidence) + 1) + 'px';\n" +
            "    row.style.left = offsetLeft(blt) + 'px';\n" +
            "    row.style.display = 'block';\n" +
            "    col.style.width = (incidence.offsetWidth + 1) + 'px';\n" +
            "    col.style.height = blt.offsetHeight + 'px';\n" +
            "    col.style.top = offsetTop(blt) + 'px';\n" +
            "    col.style.left = (offsetLeft(incidence) + 1) + 'px';\n" +
            "    col.style.display = 'block';\n" +
            "}\n" +
            "\n" +
            "function offsetTop(obj) {\n" +
            "    var res = 0;\n" +
            "    while (obj != null) {\n" +
            "        res += obj.offsetTop;\n" +
            "        obj = obj.offsetParent;\n" +
            "    }\n" +
            "    return res;\n" +
            "}\n" +
            "function offsetLeft(obj) {\n" +
            "    var res = 0;\n" +
            "    while (obj != null) {\n" +
            "        res += obj.offsetLeft;\n" +
            "        obj = obj.offsetParent;\n" +
            "    }\n" +
            "    return res;\n" +
            "}\n" +
            "</script>\n";

    public void writeBLTTableFile(FClass fc) {
        try {
            CodeStream out = new CodeStream(new PrintStream(bltTableAbsFileName, "UTF-8"));
            out.print(html_header.replaceFirst("</head>", BLT_style + "</head>"));
            if (fc.root().options.getBooleanOption("equation_sorting")) {
                out.println("<div id=\"rowHighlight\" style=\"display:none;\"></div>");
                out.println("<div id=\"colHighlight\" style=\"display:none;\"></div>");
                out.println("<div id=\"rowLockHighlight\" style=\"display:none;\"></div>");
                out.println("<div id=\"colLockHighlight\" style=\"display:none;\"></div>");

                out.println("<h1>BLT for Init DAE System</h1>");
                fc.getDAEInitBLT().diagnostics_generateBLTTable(out, true);

                if (!fc.onlyInitBLT()) {
                    out.println("<h1>BLT for DAE System</h1>");
                    fc.getDAEBLT().diagnostics_generateBLTTable(out, false);
                }
            }
            out.print(html_tail);
            out.close();
        } catch(FileNotFoundException e) {
        } catch(UnsupportedEncodingException e) {
        }
    }

	public abstract class DiagnosticsFile {
		
		protected String title;
		protected String fileName;
		protected File path;
		protected boolean addTitle;
		
		protected DiagnosticsFile(String title, String suffix, boolean addTitle) {
			this(title, String.format("%s_%s.html", modelNameUnderscore, suffix));
			this.addTitle = addTitle;
		}
		
		protected DiagnosticsFile(String title, String fileName) {
			this.title = title;
			this.fileName = fileName;
			path = new File(diagnosticsDirString, fileName).getAbsoluteFile();
			addTitle = false;
		}
		
		public void write(FClass fc) {
		    CodeStream out = null;
			try {
				out = new CodeStream(new PrintStream(path, "UTF-8"));
				out.print(html_header);
				if (addTitle) {
					if (title != null)
						out.format("<h2>%s: %s</h2>\n", title, modelName);
					else
						out.format("<h2>%s</h2>\n", modelName);
				}
				writeContents(fc, out);
				out.print(html_tail);
			} catch(FileNotFoundException e) {
			} catch(UnsupportedEncodingException e) {		
			} finally {
				if (out != null)
					out.close();
			}
		}
		
		public void clear() {
			PrintStream out;
			try {
				out = new PrintStream(path, "UTF-8");
				out.close();
			} catch(FileNotFoundException e) {
			} catch(UnsupportedEncodingException e) {		
			} 
		}
		
		public void writeLink(CodeStream out) {
			writeLink(out, "");
		}
		
		public void writeLink(CodeStream out, String suffix) {
			out.format("<p><a href=\"%s\">%s</a>%s</p>\n", fileName, title, suffix);
		}
		
		protected abstract void writeContents(FClass fc, CodeStream out);
		
	}
	
    protected static class TableManager {
        private int xPos = 0;
        private int yPos = 0;
        private String blockPrefix;

        protected TableManager(String blockPrefix) {
            this.blockPrefix = blockPrefix;
        }

        public String getBlockPrefix() {
            return blockPrefix;
        }

        public void newRow() {
            yPos++;
            xPos = 0;
        }

        public int getYPos() {
            return yPos;
        }

        public void newCol() {
            xPos++;
        }

        public int getXPos() {
            return xPos;
        }
    }
}

public void BLT.diagnostics_generateBLTTable(CodeStream out, boolean isInit) {
    Deque<FVariable> orderList = new ArrayDeque<FVariable>();
    for (AbstractEquationBlock aeb : this) {
        orderList.addAll(aeb.allVariables());
    }
    FVariable[] order = orderList.toArray(new FVariable[orderList.size()]);

    DiagnosticsGenerator.TableManager tm = new DiagnosticsGenerator.TableManager(isInit ? "block_init_" : "block_");

    out.formatln("<div class=\"blt\" style=\"width:%dpx;height:%dpx;\">", order.length * AbstractEquationBlock.DIAGNOSTICS_CELL_SIZE + 1, order.length * AbstractEquationBlock.DIAGNOSTICS_CELL_SIZE + 1);
    for (int i = 0; i < order.length; i++) {
        FVariable fv = order[i];
        out.formatln("    <div class=\"variable\" style=\"left:%dpx\" title=\"%s\">%s</div>", (i - 6) * AbstractEquationBlock.DIAGNOSTICS_CELL_SIZE - 2, ASTNode.escapeHTML(fv.name()), ASTNode.escapeHTML(fv.name()));
    }

    for (AbstractEquationBlock aeb : this) {
        aeb.diagnostics_generateBLTTable_block(order, out, tm);
    }

    out.println("</div>");
}

protected abstract String AbstractEquationBlock.diagnostics_generateBLTTable_color();
protected String TornEquationBlock.diagnostics_generateBLTTable_color() {
    return "#F0CCCC";
}

protected String SimpleEquationBlock.diagnostics_generateBLTTable_color() {
    return "#CCF0CC";
}

protected String AlgorithmBlock.diagnostics_generateBLTTable_color() {
    return "#CCF0CC";
}
	
protected String EquationBlock.diagnostics_generateBLTTable_color() {
    return "#CCCCF0";
}
	
protected Map<FVariable, Integer> AbstractEquationBlock.EMPTY_VAR_FILTER = Collections.emptyMap();

public static final int AbstractEquationBlock.DIAGNOSTICS_CELL_SIZE = 15;

public void AbstractEquationBlock.diagnostics_generateBLTTable_block(FVariable[] order, CodeStream out, DiagnosticsGenerator.TableManager tm) {
    int numReal = realVariables().size();
    int numNonReal = nonRealVariables().size();
    int start = tm.getYPos() * DIAGNOSTICS_CELL_SIZE;
    int sizeReal = numReal * DIAGNOSTICS_CELL_SIZE + 1;
    int sizeNonReal = (numReal + numNonReal) * DIAGNOSTICS_CELL_SIZE + 1;
    if (numNonReal > 0)
        out.formatln("    <div class=\"block\" style=\"background:#F0E7CC;left:%dpx;top:%dpx;width:%dpx;height:%dpx;\"></div>", start, start, sizeNonReal, sizeNonReal);
    if (numReal > 0)
        out.formatln("    <div class=\"block\" style=\"background:%s;left:%dpx;top:%dpx;width:%dpx;height:%dpx;\"></div>", diagnostics_generateBLTTable_color(), start, start, sizeReal, sizeReal);
    diagnostics_generateBLTTable_rows(order, out, tm, false, -1, EMPTY_VAR_FILTER);
}

public void AbstractEquationBlock.diagnostics_generateBLTTable_rows(FVariable[] order, CodeStream out, DiagnosticsGenerator.TableManager tm, boolean inTearBlock, int size, Map<FVariable, Integer> varFilter) {
    for (FAbstractEquation equation : allEquations()) {
        if (varFilter == EMPTY_VAR_FILTER)
            size = equation.numScalarEquations();
        String equationStr = ASTNode.escapeHTML(equation);
        for (int i = 0; i < size; i++) {
            out.formatln("    <div class=\"equation\" style=\"top:%dpx;\" title=\"%s\">%s</div>", tm.getYPos() * DIAGNOSTICS_CELL_SIZE, equationStr, equationStr);
            for (FVariable var : order) {
                Integer pos = varFilter.get(var);
                boolean contains = (equation.variables().contains(var) 
                        || equation.discretePreVariables().contains(var)
                        || equation.nonFixedParameters().contains(var))
                        && (pos == null || pos == i);
                if (contains)
                    out.formatln("    <div class=\"incidence\" style=\"left:%dpx;top:%dpx;z-index:10000;\" title=\"%s&#13;&#13;%s\" onmouseover=\"hightlight(this);\" onmouseout=\"unhighlight(this);\" onclick=\"lockHighlight(this);\"><div>%s</div></div>", tm.getXPos() * DIAGNOSTICS_CELL_SIZE, tm.getYPos() * DIAGNOSTICS_CELL_SIZE, ASTNode.escapeHTML(var.name()), equationStr, diagnostics_generateBLTTable_solvabilitySymbol(equation.isSolved(var.name(), inTearBlock)));
                tm.newCol();
            }
            tm.newRow();
        }
    }
}

private String AbstractEquationBlock.diagnostics_generateBLTTable_solvabilitySymbol(Solvability s) {
    switch (s) {
    case ANALYTICALLY_SOLVABLE:
        return "O";
    case NUMERICALLY_SOLVABLE:
        return "@";
    case UNSOLVABLE:
        return "X";
    }
    throw new IllegalArgumentException("Unsupported solvability type " + s);
}

public void TornEquationBlock.diagnostics_generateBLTTable_rows(FVariable[] order, CodeStream out, DiagnosticsGenerator.TableManager tm, boolean inTearBlock, int size, Map<FVariable, Integer> varFilter) {
    int numSolved = realVariables().size() - localUnsolvedVariables().size();
    int solvedStart = tm.getYPos() * DIAGNOSTICS_CELL_SIZE;
    int solvedSize = numSolved * DIAGNOSTICS_CELL_SIZE + 1;
    int unsolvedStart = (tm.getYPos() + numSolved) * DIAGNOSTICS_CELL_SIZE;
    int unsolvedSize = localUnsolvedVariables().size() * DIAGNOSTICS_CELL_SIZE + 1;
    int numNonReal = localNonRealVariables().size();
    if (inTearBlock)
        out.formatln("    <div class=\"block\" style=\"background:#F0C7C7;left:%dpx;top:%dpx;width:%dpx;height:%dpx;\"></div>", solvedStart, solvedStart, solvedSize + unsolvedSize - 1, solvedSize + unsolvedSize - 1);
    out.formatln("    <div class=\"block\" style=\"background:#F0E4E4;left:%dpx;top:%dpx;width:%dpx;height:%dpx;\"></div>", solvedStart, solvedStart, solvedSize, solvedSize);
    out.formatln("    <div class=\"block\" style=\"background:#F0C0C0;left:%dpx;top:%dpx;width:%dpx;height:%dpx;\"></div>", unsolvedStart, unsolvedStart, unsolvedSize, unsolvedSize);
    java.util.List<AbstractEquationBlock> blocks = new ArrayList<AbstractEquationBlock>();
    blocks.addAll(solvedRealBlocks());
    blocks.addAll(unsolvedBlocks());
    blocks.addAll(localNonRealBlocks());
    for (AbstractEquationBlock seb : blocks) {
        seb.diagnostics_generateBLTTable_rows(order, out, tm, true, size, varFilter);
    }
}

public void FunctionCallEquationBlock.diagnostics_generateBLTTable_rows(FVariable[] order, CodeStream out, DiagnosticsGenerator.TableManager tm, boolean inTearBlock, int size, Map<FVariable, Integer> varFilter) {
    varFilter = new HashMap<FVariable, Integer>();
    int index = 0;
    for (FVariable var : equation().referencedFVariablesInLHS()) {
        varFilter.put(var, -1);
    }
    for (FVariable var : activeVars) {
        varFilter.put(var, index);
        index++;
    }
    for (FVariable var : equation().referencedFVariablesInRHS()) {
        varFilter.remove(var);
    }
    super.diagnostics_generateBLTTable_rows(order, out, tm, inTearBlock, activeVars.size(), varFilter);
}

public void AlgorithmBlock.diagnostics_generateBLTTable_rows(FVariable[] order, CodeStream out, DiagnosticsGenerator.TableManager tm, boolean inTearBlock, int size, Map<FVariable, Integer> varFilter) {
    varFilter = new HashMap<FVariable, Integer>();
    int index = 0;
    for (FVariable var : equation().referencedFVariablesInLHS()) {
        varFilter.put(var, -1);
    }
    for (FVariable var : activeVars) {
        varFilter.put(var, index);
        index++;
    }
    for (FVariable var : equation().referencedFVariablesInRHS()) {
        varFilter.remove(var);
    }
    super.diagnostics_generateBLTTable_rows(order, out, tm, inTearBlock, activeVars.size(), varFilter);
}

public void AbstractEquationBlock.diagnostics_generateBLTTable_row(FVariable[] order, CodeStream out, DiagnosticsGenerator.TableManager tm, boolean inTearBlock, FAbstractEquation equation, Map<FVariable, Integer> varMap) {
}

protected static String ASTNode.escapeHTML(Object o) {
    return escapeHTML(o.toString());
}

protected static String ASTNode.escapeHTML(String str) {
    str = str.replace("&", "&amp;");
    str = str.replace("\"", "&quot;");
    str = str.replace("\'", "&039;");
    str = str.replace("<", "&lt;");
    str = str.replace(">", "&gt;");
    return str;
}

}