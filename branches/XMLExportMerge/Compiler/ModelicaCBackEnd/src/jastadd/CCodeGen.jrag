/*
Copyright (C) 2009 Modelon AB
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.io.PrintStream;
import java.io.ByteArrayOutputStream;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import java.util.Collections;
import java.util.Stack;

import org.jmodelica.util.Enumerator;
import org.jmodelica.util.streams.CStringCodeStream;

aspect CCodeGen {

    public abstract class CodePrinter extends Printer {
        
        /**
         * A list of code generator providers. Each provider in this list is
         * called in the constructor of CodePrinter.
         */
        private static Collection<CodeGeneratorProvider> providers = null;
        
        /**
         * Adds a CodeGeneratorProvider to the list of providers.
         */
        private <T extends CodeGeneratorProvider> T addProvider(T provider) {
            if (providers == null)
                providers = new PriorityQueue<CodeGeneratorProvider>();
            providers.add(provider);
            return provider;
        }
        
        /**
         * Returns the list of CodeGeneratorProvider providers.
         */
        public Collection<CodeGeneratorProvider> getProviders() {
            if (providers == null)
                return Collections.emptyList();
            else
                return providers;
        }
        
        private final boolean inInitialSystem;

        public CodePrinter(boolean inInitialSystem) {
            super("    ");
            for (CodeGeneratorProvider provider : getProviders())
                provider.provide(this);
            this.inInitialSystem = inInitialSystem;
        }
        
        /**
         * Abstract base class for code generator providers. Features that
         * needs to affect the code gen process should extend this object and
         * add it to the list of providers.
         */
        private abstract static class CodeGeneratorProvider implements Comparable<CodeGeneratorProvider> {
            private final int priority;
            
            /**
             * Constructs a new provider.
             * The argument priority controls the order of wich providers are
             * called. Providers are called in ascending order.
             * 
             * @param priority Denotes the priority of this provider.
             */
            private CodeGeneratorProvider(int priority) {
                this.priority = priority;
            }
            
            @Override
            public int compareTo(CodeGeneratorProvider other) {
                return Integer.valueOf(priority).compareTo(Integer.valueOf(other.priority));
            }
            
            /**
             * Abstract method that should be implemented by sub classes.
             * The provider is then free to modify the CodePrinter object
             * and redefine code generators.
             */
            public abstract void provide(CodePrinter p);
        }
        

        @Override
        public abstract void print(ASTNode node, CodeStream str, String indent);

        public abstract void printVarDecls(ASTNode node, CodeStream str, String indent);

        public abstract void printPreSteps(ASTNode node, CodeStream str, String indent);
        
        public abstract void printPostSteps(ASTNode node, CodeStream str, String indent);

        public boolean insideBlock() {
            return false;
        }
        
        public final CodePrinter initialSystemPrinter() {
            if (inInitialSystem())
                return this;
            else
                return getInitialSystemPrinter();
        }
        
        protected abstract CodePrinter getInitialSystemPrinter();
        
        public boolean inInitialSystem() {
            return inInitialSystem;
        }

        @Override
        public String op(FBinExp e) { return e.op_C(); }

        public abstract TypePrinter_C createDeclPrinter(CodeStream str);
        public abstract TypePrinter_C createInitPrinter(CodeStream str);
    }
    
    public class CPrettyPrinter extends CodePrinter {

        private static CPrettyPrinter INITIAL_SYSTEM_PRINTER = new CPrettyPrinter(true);

        public CPrettyPrinter() {
            this(false);
        }

        protected CPrettyPrinter(boolean inInitialSystem) {
            super(inInitialSystem);
        }

        @Override
        protected CodePrinter getInitialSystemPrinter() {
            return INITIAL_SYSTEM_PRINTER;
        }

        @Override
        public void print(ASTNode node, CodeStream str, String indent) { 
            node.prettyPrint_C(this, str, indent); 
        }

        @Override
        public void printVarDecls(ASTNode node, CodeStream str, String indent) {
            node.genVarDecls_C(this, str, indent);
        }

        @Override
        public void printPreSteps(ASTNode node, CodeStream str, String indent) {
            node.genTempVars_C(this, str, indent);
        }
        
        @Override
        public void printPostSteps(ASTNode node, CodeStream str, String indent) {
            node.genTempFree_C(this, str, indent);
        }

        public TypePrinter_C createDeclPrinter(CodeStream str) {
            return new DeclPrinter_C(this, str);
        }
        
        public TypePrinter_C createInitPrinter(CodeStream str) {
            return new InitPrinter_C(this, str);
        }
    }
	
    /**
     * Just like CPrettyPrinter but it is used inside of blocks
     */
    public class CBlockPrettyPrinter extends CPrettyPrinter {

        private static CBlockPrettyPrinter INITIAL_SYSTEM_PRINTER = new CBlockPrettyPrinter(true);

        public CBlockPrettyPrinter() {
            this(false);
        }

        private CBlockPrettyPrinter(boolean inInitialSystem) {
            super(inInitialSystem);
        }

        @Override
        protected CodePrinter getInitialSystemPrinter() {
            return INITIAL_SYSTEM_PRINTER;
        }

        @Override
        public boolean insideBlock() {
            return true; 
        }

    }
    
    static CPrettyPrinter ASTNode.printer_C = new CPrettyPrinter();
    static CPrettyPrinter ASTNode.blockPrinter_C = new CBlockPrettyPrinter();
	
	public String ASTNode.prettyPrint_C(String indent) {
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		CodeStream str = new CodeStream(os);
		prettyPrint_C(str,indent);
		return os.toString();
	}

	public void ASTNode.prettyPrint_C(CodeStream str, String indent) {
 		prettyPrint_C(printer_C, str, indent);
	}

	public void ASTNode.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
 		prettyPrint(p, str, indent);
	}
	
	public void FDotPowExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		int exponent = 100;
		if (getRight().variability().constantVariability() && getRight().type().isInteger()) 
			exponent = getRight().ceval().intValue();
		if (exponent < 10 && exponent > -10) {
			str.print("(");
			String op = (exponent > 0) ? " * " : " / ";
			exponent = Math.abs(exponent);
			str.print("1.0");
			for (int i = 0; i < exponent; i++) {
				str.print(op);
				str.print("(");
				p.print(getLeft(), str, indent); 
				str.print(")");
			}
			str.print(")");
		} else {
			str.print("pow(");
			p.print(getLeft(),str,indent); 
			str.print(",");
			p.print(getRight(),str,indent);
			str.print(")");
		}
	}
	
	public void FMinMaxExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("jmi_" + builtInName() + "(");
		p.print(getX(), str, indent); 
		str.print(", ");
		p.print(getY(), str, indent);
		str.print(")");
	}
	
	public void FAbstractDerExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (root().options.getBooleanOption("enable_variable_scaling") && !inFunction()) {
			str.print("(");
			str.print(myFV().name_C());
			str.print("*sf(");
			str.print(myFV().valueReference());
			str.print("))");
		} else {
			str.print(myFV().name_C());
		}
	}

    public void FPreExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        FAbstractVariable fv = myFV();
        if (fv.isUnknown()) {
            fv = myNonPreFV();
            if (!fv.isContinuous())
                throw new UnsupportedOperationException();
        }
        str.print(fv.preName_C());
    }
	
	public void FSampleExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("jmi_sample(jmi,");
		p.print(getOffset(),str,"");
		str.print(",");
		p.print(getInterval(),str,"");
		str.print(")");
	}
	
	public void FTimeExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("_time");
	}
	
	public void FEnumIntegerExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print('(');
		p.print(getFExp(), str, indent);
		str.print(')');
	}
	
	public void FEnumLitExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (inIfCondition()) 
			str.print("AD_WRAP_LITERAL(");
		str.print(ceval().intValue());
		if (inIfCondition()) 
			str.print(")");
	}
	
	public void FIdUseExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (isArray() && keepAsArray()) {
			str.print(getFIdUse().toString_C(p));
		} else {
			if (type().isReal() && !inFunction() && 
					root().options.getBooleanOption("enable_variable_scaling")) {
				str.print("(");
				p.print(getFIdUse(), str, indent);
				str.print("*sf(");
				str.print(myFV().valueReference());
				str.print("))");
			} else {
				p.print(getFIdUse(), str, indent);
			}
		}
	}
	
	inh boolean FIdUse.isAssignUse();
	eq InstNode.getChild().isAssignUse()          = false;
	eq FClass.getChild().isAssignUse()            = false;
	eq FFunctionCallLeft.getChild().isAssignUse() = true;
	eq FAssignStmt.getLeft().isAssignUse()        = true;
	eq FAssignStmt.getRight().isAssignUse()       = false;
	
	syn String FIdUse.name_C() = toString_C(printer_C);
	
	syn String FIdUse.toString_C(CodePrinter p) {
		String type = myFV().funcArrayType(isAssignUse());
		if (myFV().inRecord() && inFunction()) 
			return getFQName().genRecordUse_C(p, myRecordFV(), type);
		else
			return myFV().genUse_C(p, getFQName().getFArraySubscripts(), type);
	}
	
	public void FIdUse.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print(toString_C(p));
	}
	
	public String FAbstractVariable.genUse_C(CodePrinter p, FArraySubscripts fas, String type) {
		return name_C();
	}
	
	public String FFunctionArray.genUse_C(CodePrinter p, FArraySubscripts fas, String type) {
		if (fas == null)
			return name_C();
		else
			return fas.genFunctionArrayUse_C(p, name_C(), type);
	}
	
	public String FArraySubscripts.genFunctionArrayUse_C(CodePrinter p, String name, String type) {
		ByteArrayOutputStream os = new ByteArrayOutputStream();	
		CodeStream str = new CodeStream(os);
		str.print("jmi_array_");
		str.print(type);
		str.print("_");
		str.print(getNumFSubscript());
		str.print("(");
		str.print(name);
		str.print(", ");
		getFSubscripts().prettyPrintWithSep(p, str, "", ", ");
		str.print(")");
		return os.toString();
	}
	
	public String FQName.genRecordUse_C(CodePrinter p, FAbstractVariable fv, String type) {
		throw new UnsupportedOperationException();
	}	
	
	public String FQNameFull.genRecordUse_C(CodePrinter p, FAbstractVariable fv, String type) {
		FQNamePart part = getFQNamePart(0);
		FArraySubscripts fas = part.hasFArraySubscripts() ? part.getFArraySubscripts() : null;
		String res = fv.genUse_C(p, fas, C_ARRAY_RECORD);
		for (int i = 1, n = getNumFQNamePart(); i < n; i++) {
			part = getFQNamePart(i);
			res = res + "->" + part.getName();
			if (part.hasFArraySubscripts()) {
				String curType = (n - i > 1 ? C_ARRAY_RECORD : type);
				res = part.getFArraySubscripts().genFunctionArrayUse_C(p, res, curType);
			}
		}
		return res;
	}	
	
    public void FFunctionCall.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        if (isStringExp()) {
            str.print(tempName_C());
        } else {
            prettyPrintCall_C(p, str, indent);
        }
    }
    
    public void FFunctionCall.prettyPrintCall_C(CodePrinter p, CodeStream str, String indent) {
        myFCallable().prettyPrintCall_C(p, str, indent, this);
    }
    
    public interface FCallable {
        /**
         * \brief Generate a call to this callable.
         */
        public void prettyPrintCall_C(CodePrinter p, CodeStream str, String indent, FFunctionCall call);
    }
    
    @Override
    public void FFunctionDecl.prettyPrintCall_C(CodePrinter p, CodeStream str, String indent, FFunctionCall call) {
        boolean exp = call.functionCallIsExp();
        if (!exp)
            str.print(indent);
        str.print(funcNameUnderscore(exp ? C_SUFFIX_EXP : C_SUFFIX_DEF));
        str.print("(");
        String sep = "";
        for (FExp arg : call.getArgs()) {
            str.print(sep);
            arg.genArgument_C(p, str, indent);
            sep = ", ";
        }
        if (!exp) {
            int tot = myOutputs().size();
            int lefts = call.myLefts().size();
            for (int i = 0; i < tot; i++) {
                str.print(sep);
                if (i < lefts)
                    call.myLefts().get(i).genArgument_C(str);
                else
                    str.print("NULL");
                sep = ", ";
            }
        }
        str.print(")");
        if (!exp)
            str.print(";\n");
    }
    
    @Override
    public void FFunctionVariable.prettyPrintCall_C(CodePrinter p, CodeStream str, String indent, FFunctionCall call) {
        boolean exp = call.functionCallIsExp();
        String out = "NULL";
        if (!exp) {
            out = call.tempName_C();
            str.formatln("%s%s.n = %s;", indent, out, call.myLefts().size());
            out = "&" +out;
            str.print(indent);
        }
        str.format("%s->fpcl(%s, %s", name_C(), name_C(), out);
        String sep = ", ";
        for (FExp arg : call.getArgs()) {
            str.format("%s(%s)(", sep, arg.type().type_C());
            arg.genArgument_C(p, str, indent);
            str.print(")");
        }
        str.print(")");
        if (!exp)
            str.print(";\n");
        if (!exp) {
            int tot = myOutputs().size();
            int lefts = call.myLefts().size();
            for (int i = 0; i < tot; i++) {
                if (i < lefts) {
                    String n = call.myLefts().get(i).prettyPrint_C(indent);
                    str.formatln("%s%s = %s.%s;", indent, n, call.tempName_C(), n);
                }
            }
        }
    }
    
    @Override
    public void FPartialFunctionCall.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        boolean exp = functionCallIsExp();
        FCallable fc = myFCallable();
        String previous = "NULL";
        String result   = "NULL";
        if (fc.isPartialFunction()) {
            previous = ((FFunctionVariable) fc).name_C();
        } else {
            result = "&" + tempName_C();
        }
        if (fc.isPartialFunction()) {
            str.print(previous);
            str.print("->fpcr");
        } else {
            str.print(fc.funcNameUnderscore(C_SUFFIX_FPCR));
        }
        str.print("(");
        str.print(previous);
        str.print(", ");
        str.print(result);
        
        /* Print "0" for the inputs we don't set, and "1, value" for those we do set */
        Iterator<FIdUse> it = getArgNames().iterator();
        Iterator<FFunctionVariable> it2 = fc.myInputs().iterator();
        for (FExp arg : getArgs()) {
            String name = it.next().name();
            while (!it2.next().name().equals(name)) {
                str.print(", 0");
            }
            str.print(", 1");
            
            str.print(", ");
            str.format("(%s)(", arg.type().type_C());
            arg.genArgument_C(p, str, indent);
            str.print(")");
        }
        while (it2.hasNext()) {
            str.print(", 0");
            it2.next();
        }
        
        str.print(")");
    }
	
	public String FunctionReturnDefinition.getDeclaredType_C() {
		if (outputs.size() > 0) 
			return outputs.get(0).type_C();
		else
			return "void";
	}
	
	public void FunctionReturnDefinition.printReturnForExp_C(CodeStream str, String indent) {
		str.print(indent);
		str.print("return");
		if (outputs.size() > 0) { 
			str.print(" ");
			str.print(outputs.get(0).name_C());
		}
		str.print(";\n");
	}
	
	public void FunctionReturnDefinition.printDeclarationForExp_C(CodePrinter p, CodeStream str, String indent) {
		if (outputs.size() > 0) 
			outputs.get(0).genVarDecls_C(p, str, indent);
	}
	
	public void FunctionReturnDefinition.printReturnWrite_C(CodeStream str, String indent) {
		for (FFunctionVariable v : outputs) 
			v.printReturnWrite_C(str, indent);
	}
	
	
	private void FFunctionDecl.prettyPrintHead_C(CodePrinter p, CodeStream str, String indent, 
			String type, String suffix, boolean returnArgs) {
		str.print(indent);
		str.print(type);
		str.print(" ");
		str.print(funcNameUnderscore(suffix));
		str.print("(");
		String sep = "";
		for (FFunctionVariable v : myInputs()) {
			str.print(sep);
			v.printArgument_C(str);
			sep = ", ";
		}
		if (returnArgs) {
			for (FFunctionVariable v : myOutputs()) {
				str.print(sep);
				v.printReturnArgument_C(str);
				sep = ", ";
			}
		}
		str.print(")");
	}
	
	private void FFunctionDecl.prettyPrintWrappedCall_C(CodeStream str, String indent) {
		if (!shouldPrintFuncDecl_C())
			return;
		str.print(indent);
		str.print(funcNameUnderscore(C_SUFFIX_DEF));
		str.print("(");
		String sep = "";
		for (FFunctionVariable v : myInputs()) {
			str.print(sep);
			str.print(v.name_C());
			sep = ", ";
		}
		if (myOutputs().size() > 0) {
			str.print(sep);
			str.print("&");
			str.print(myOutputs().get(0).name_C());
			for (int i = myOutputs().size() - 1; i > 0; i--)
				str.print(", NULL");
		}
		str.print(");\n");
	}
	
	public void FFunctionDecl.genHeader_C(CodeStream str, String indent) {
		if (!shouldPrintFuncDecl_C())
			return;
		prettyPrintHead_C(printer_C, str, indent, "void", C_SUFFIX_DEF, true);
		str.print(";\n");
    	if (generateExpFunction()) {
    		String type = returnDefinition().getDeclaredType_C();
			prettyPrintHead_C(printer_C, str, indent, type, C_SUFFIX_EXP, false);
			str.print(";\n");
    	}
	}
	
    /**
     * \brief Generates forward declarations for FPCL and FPCR functions used
     * by partial function calls.
     */
    public void FFunctionDecl.genHeadersPartial_C(CodeStream str, String indent) {
        prettyPrintHeadFPCL_C(str, indent);
        str.println(";");
        prettyPrintHeadFPCR_C(str, indent);
        str.println(";");
    }
    
    /**
     * \brief Generates FP and OUT structs used by partial function calls.
     */
    public void FFunctionDecl.genStructsPartial_C(CodeStream str, String indent) {
        CodePrinter p = ASTNode.printer_C;
        String fp  = funcNameUnderscore(C_SUFFIX_FP);
        String out = funcNameUnderscore(C_SUFFIX_FPOUT);
        String next = p.indent(indent);
        
        beginStruct_C(str, indent, out);
        str.formatln("%sint n;", next);
        for (FFunctionVariable ffv : myOutputs()) {
            str.formatln("%s%s %s;", next, ffv.type().type_C(), ffv.name_C());
        }
        endStruct_C(str, indent);
        
        beginStruct_C(str, indent, fp);
        str.formatln("%s%s (*fpcl)(%s*, %s*, ...);", next, returnDefinition().getDeclaredType_C(), fp, out);
        str.formatln("%s%s* (*fpcr)(%s*, %s*, ...);", next, fp, fp, fp);
        for (FFunctionVariable ffv : myInputs()) {
            String name = ffv.name_C();
            str.formatln("%s%s %s;", next, ffv.type().type_C(), name);
            str.formatln("%sint %s_s;", next, name);
        }
        endStruct_C(str, indent);
    }
    
    /**
     * \brief Generate first line of struct declaration name_ with typedef to name
     */
    public void FFunctionDecl.beginStruct_C(CodeStream str, String indent, String name) {
        str.formatln("%stypedef struct %s_ %s;", indent, name, name);
        str.formatln("%sstruct %s_ {", indent, name);
    }
    
    /**
     * \brief Generate last line of struct declaration
     */
    public void FFunctionDecl.endStruct_C(CodeStream str, String indent) {
        str.formatln("%s};", indent);
    }
    
    /**
     * \brief Generate declaration for varargs
     */
    public void FFunctionDecl.genVarArgsDecl(CodeStream str, String indent) {
        str.print(indent);
        str.println("va_list argp;");
    }
    
    /**
     * \brief Generate initialization for varargs
     */
    public void FFunctionDecl.genVarArgsOpen(CodeStream str, String indent, String last) {
        str.print(indent);
        str.print("va_start(argp, ");
        str.print(last);
        str.println(");");
    }
    
    /**
     * \brief Generate use for varargs
     */
    public void FFunctionDecl.genVarArgsRead(CodeStream str, String indent, String dest, String type) {
        str.print(indent);
        str.print(dest);
        str.print(" = ");
        genVarArgsRead(str, type);
        str.println(";");
    }
    
    /**
     * \brief Generate use for varargs
     */
    public void FFunctionDecl.genVarArgsRead(CodeStream str, String type) {
        str.print("va_arg(argp, ");
        str.print(type);
        str.print(")");
    }
    
    /**
     * \brief Generate closing for varargs
     */
    public void FFunctionDecl.genVarArgsClose(CodeStream str, String indent) {
        str.print(indent);
        str.println("va_end(argp);");
    }
    
    /**
     * \brief Generate header for FPCL function.
     */
    public void FFunctionDecl.prettyPrintHeadFPCL_C(CodeStream str, String indent) {
        str.format("%s%s %s(%s* fp_in, %s* out, ...)", indent, returnDefinition().getDeclaredType_C(), funcNameUnderscore(C_SUFFIX_FPCL), funcNameUnderscore(C_SUFFIX_FP), funcNameUnderscore(C_SUFFIX_FPOUT));
    }
    
    /**
     * \brief Generate header for FPCR function.
     */
    public void FFunctionDecl.prettyPrintHeadFPCR_C(CodeStream str, String indent) {
        String fp = funcNameUnderscore(C_SUFFIX_FP);
        str.format("%s%s* %s(%s* fp_in, %s* fp_out, ...)", indent, fp, funcNameUnderscore(C_SUFFIX_FPCR), fp, fp);
    }
	
	/**
	 * Helper method that checks wether the functiondecl should be printed.
	 */
	syn boolean FFunctionDecl.shouldPrintFuncDecl_C() = functionIsUsed();
	
	public void FFunctionDecl.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (!shouldPrintFuncDecl_C())
			return;
		String next = p.indent(indent);
		// Print definition
		prettyPrintHead_C(p, str, indent, "void", C_SUFFIX_DEF, true);
		str.print(" {\n");
		// TODO: Check if there are any dynamic declarations first
		str.print(next + "JMI_DYNAMIC_INIT()\n");
		genVarDecls_C(p, str, p.indent(indent));
        for (FFunctionVariable ffv : myNonInputs()) {
            if (!ffv.hasInitArrayStmt) {
                p.print(ffv, str, next);
            }
        }
    	p.print(getFAlgorithm(), str, next);
    	str.print(indent);
    	str.print("}\n\n");
    	
    	// Print wrapper for expressions
    	if (generateExpFunction()) {
	    	String type = returnDefinition().getDeclaredType_C();
			prettyPrintHead_C(p, str, indent, type, C_SUFFIX_EXP, false);
			str.print(" {\n");
			returnDefinition().printDeclarationForExp_C(p, str, next);
			prettyPrintWrappedCall_C(str, next);
			returnDefinition().printReturnForExp_C(str, next);
	    	str.print(indent);
	    	str.print("}\n\n");
    	}
	}
	
    /**
     * \brief Generates FPCL and FPCR functions used by partial function calls.
     */
    public void FFunctionDecl.prettyPrintPartial_C(CodeStream str, String indent) {
        int i;
        CodePrinter p = ASTNode.printer_C;
        String next = p.indent(indent);
        String next2 = p.indent(next);
        String next3 = p.indent(next2);
        String fp = funcNameUnderscore(C_SUFFIX_FP);
        ArrayList<FFunctionVariable> inputs  = myInputs();
        ArrayList<FFunctionVariable> outputs = myOutputs();
        int n = inputs.size() + outputs.size();
        String[] names = new String[n];
        for (i = 0; i < n; i++) {
            names[i] = "tmp_" + (i+1); 
        }
        
        // FPCL
        prettyPrintHeadFPCL_C(str, indent);
        str.print(" {\n");
        
        i = 0;
        for (FFunctionVariable ffv : inputs) {
            str.formatln("%s%s %s;", next, ffv.type_C(), names[i++]);
        }
        for (FFunctionVariable ffv : outputs) {
            str.formatln("%s%s %s;", next, ffv.type_C(), names[i++]);
        }
        
        genVarArgsDecl(str, next);
        genVarArgsOpen(str, next, "out");
        i = 0;
        for (FFunctionVariable ffv : inputs) {
              str.formatln("%sif (fp_in->%s_s) {", next, ffv.name_C());
              str.formatln("%s%s = fp_in->%s;", next2, names[i], ffv.name_C());
              str.formatln("%s} else {", next);
              genVarArgsRead(str, next2, names[i], ffv.type_C());
              str.formatln("%s}", next);
              i++;
        }
        genVarArgsClose(str, next);
        
        str.format("%s%s(", next, funcNameUnderscore("def"));
        String prefix = "";
        i = 0;
        for (FFunctionVariable ffv : inputs) {
            str.print(prefix);
            str.print(names[i++]);
            prefix = ", ";
        }
        for (FFunctionVariable ffv : outputs) {
            str.print(prefix);
            str.print("&");
            str.print(names[i++]);
        }
        str.println(");");
        
        str.formatln("%sif (out != NULL) {",next);
        i = 0;
        for (FFunctionVariable ffv : outputs) {
              str.formatln("%sif (out->n > %d) {", next2, i);
              str.formatln("%sout->%s = %s;", next3, ffv.name_C(), names[i + inputs.size()]);
              str.formatln("%s}", next2);
              i++;
        }
        str.formatln("%s}",next);
        if (outputs.size() > 0)
            str.formatln("%sreturn %s;", next, names[inputs.size()]);
        str.format("%s}\n\n", indent);
        
        
        // FPCR
        prettyPrintHeadFPCR_C(str, indent);
        str.print(" {\n");
        genVarArgsDecl(str, next);
        str.formatln("%sif (fp_out == NULL) {", next);
        str.formatln("%sfp_out = malloc(sizeof(%s));", next2, fp);
        str.formatln("%s}", next);
        
        str.formatln("%sfp_out->fpcl = &%s;", next, funcNameUnderscore(C_SUFFIX_FPCL));
        str.formatln("%sfp_out->fpcr = &%s;", next, funcNameUnderscore(C_SUFFIX_FPCR));
        
        str.formatln("%sif (fp_in == NULL) {", next);
        for (FFunctionVariable ffv : inputs) {
            str.formatln("%sfp_out->%s_s = 0;", next2, ffv.name_C());
        }
        str.formatln("%s} else {", next);
        for (FFunctionVariable ffv : inputs) {
            String name = ffv.name_C();
            str.formatln("%sfp_out->%s_s = fp_in->%s_s;", next2, name, name);
            str.formatln("%sfp_out->%s = fp_in->%s;", next2, name, name);
        }
        str.formatln("%s}", next);
        
        genVarArgsOpen(str, next, "fp_out");
        for (FFunctionVariable ffv : inputs) {
            String name = ffv.name_C();
            str.format("%sif (!fp_out->%s_s && ", next, name);
            genVarArgsRead(str, "int");
            str.println(") {");
            str.formatln("%sfp_out->%s_s = 1;", next2, name);
            genVarArgsRead(str, next2, "fp_out->" + name, ffv.type_C());
            str.formatln("%s}", next);
        }
        genVarArgsClose(str, next);
        
        str.formatln("%sreturn fp_out;", next);
        str.format("%s}\n\n", indent);
    }
	
	/**
	 * Check if we need to generate a wrapper for expressions for this function.
	 */
	syn boolean FFunctionDecl.generateExpFunction() = hasOutputs() && !isComposite();
	
	syn String FRecordDecl.name_C()      = getFQName().lastActualPartName() + "_" + 
										       recordIndex() + "_" + C_SUFFIX_RECORD;
	syn String FRecordDecl.nameArray_C() = name_C() + C_SUFFIX_ARRAY;
	
	// TODO: Handle arrays of records and arrays in records
	public void FRecordDecl.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		// Record type (struct)
		str.print(indent);
		str.print("typedef struct _");
		str.print(name_C());
		str.print(" {\n");
		String next = p.indent(indent);
		for (FVariable fv : getFVariables())
			fv.printInRecord_C(p, str, next);
        if (getNumFVariable() == 0)
            // always generate default field so that C struct is not empty
            str.print(next + "char dummy;\n");
		str.print(indent);
		str.print("} ");
		str.print(name_C());
		str.print(";\n");
		
		// Array record type
		str.print(indent);
		str.print("JMI_ARRAY_TYPE(");
		str.print(name_C());
		str.print(", ");
		str.print(nameArray_C());
		str.print(")\n\n");
	}
	
	public void FVariable.printInRecord_C(CodePrinter p, CodeStream str, String indent) {
		str.print(indent);
		str.print(type_C());
		str.print(" ");
		str.print(nameUnderscore());
		str.print(";\n");
	}
	
	public void FExternalObjectVariable.printObjectDecl(CodeStream str, String indent) {
		str.print(indent);
		str.print(type_C());
		str.print(" ");
		str.print(name_C());
		str.print(";\n");
	}
	
	// Suffixes that are used with variables in JMI: size, var, arr, rec
	public static final String ASTNode.C_SUFFIX_DEF      = "def";
	public static final String ASTNode.C_SUFFIX_EXP      = "exp";
	public static final String ASTNode.C_SUFFIX_RECORD   = "r";
	public static final String ASTNode.C_SUFFIX_ENUM     = "e";
	public static final String ASTNode.C_SUFFIX_INDEX    = "i";
	public static final String ASTNode.C_SUFFIX_VARIABLE = "v";
	public static final String ASTNode.C_SUFFIX_ARRAY    = "a";
	public static final String ASTNode.C_SUFFIX_RETURN   = "o";
	public static final String ASTNode.C_SUFFIX_NULL     = "n";

	public static final String ASTNode.C_ARRAY_RECORD    = "rec";
	public static final String ASTNode.C_ARRAY_REFERENCE = "ref";
	public static final String ASTNode.C_ARRAY_VALUE     = "val";
    
    // Suffixes used with functional arguments
    public static final String ASTNode.C_SUFFIX_FP       = "fp";
    public static final String ASTNode.C_SUFFIX_FPCL     = "fpcl";
    public static final String ASTNode.C_SUFFIX_FPCR     = "fpcr";
    public static final String ASTNode.C_SUFFIX_FPOUT    = "fpout";
    
	syn String FAbstractVariable.funcArrayType(boolean assign) = 
		isRecord() ? C_ARRAY_RECORD : (assign ? C_ARRAY_REFERENCE : C_ARRAY_VALUE);
    
    syn String FType.arrayAccess(int nd, String name, String ind) {
        return String.format("jmi_array_%s_%d(%s, %s)", isRecord() ? C_ARRAY_RECORD : C_ARRAY_REFERENCE, 
                nd, name, ind);
    }

	syn lazy String FAbstractVariable.name_C() = null;
	eq FVariable.name_C()           = isForIndex() ? 
										name_C(null, variableIndex() + C_SUFFIX_INDEX) : 
										name_C(""); 
	eq FPreRealVariable.name_C()    = preName_C();
	eq FPreBooleanVariable.name_C() = preName_C();
	eq FPreIntegerVariable.name_C() = preName_C();
	eq FPreStringVariable.name_C()  = preName_C();
	eq FPreEnumVariable.name_C()    = preName_C();

	eq FFunctionVariable.name_C()   = name_C(null, C_SUFFIX_VARIABLE);
	eq FFunctionArray.name_C()      = name_C(null, C_SUFFIX_ARRAY);
	
	syn String FAbstractVariable.preName_C() = null; 
	eq FVariable.preName_C() = name_C("pre");
	
	protected String FVariable.name_C(String prefix) {
		return name_C(prefix, Integer.toString(variableIndex()));
	}
	
	protected String FAbstractVariable.name_C(String prefix, String suffix) {
		StringBuilder buf = new StringBuilder();
		if (prefix != null) {
			buf.append(prefix);
			buf.append('_');
		}
		buf.append(nameUnderscore());
		buf.append('_');
		buf.append(suffix);
		return buf.toString();
	}
	
	syn String FFunctionVariable.nameReturn_C() = 
		isRecord() ? name_C() : name_C(null, C_SUFFIX_RETURN);
	syn String FFunctionArray.nameReturn_C()    = name_C();
	
	syn String FAbstractVariable.type_C() = type().type_C();
	syn String FFunctionCallLeft.type_C() = type().type_C();
	
	
    syn String FFunctionVariable.typeReturn_C() = isRecord() ? type_C() : (type_C() + "*");
    eq FFunctionArray.typeReturn_C()            = type_C();
    
    
    syn String FType.type_C() = isArray() ? arrayType_C() : scalarType_C();
    
    syn String FType.scalarType_C()         = nameScalar_C();
    eq FRecordType.scalarType_C()           = nameScalar_C() + "*";
    
    syn String FType.arrayType_C()          = nameArray_C() + "*";

    
    syn String FType.typeExternal_C() = isArray() ? arrayExternalType_C() : scalarExternalType_C();
    
    syn String FType.scalarExternalType_C() = nameScalarExt_C();
    eq FRecordType.scalarExternalType_C()   = nameScalarExt_C() + "*";
    
    syn String FType.arrayExternalType_C()  = nameArrayExt_C() + "*";
    
    syn String FType.nameScalar_C(boolean external) = external ? nameScalarExt_C() : nameScalar_C();
    syn String FType.nameArray_C(boolean external)  = external ? nameArrayExt_C() : nameArray_C();
    
    syn String FType.nameScalar_C()       = "jmi_ad_var_t";
    eq FRecordType.nameScalar_C()         = myFRecordDecl().name_C();
    eq FStringType.nameScalar_C()         = "jmi_string_t";
    eq FExternalObjectType.nameScalar_C() = "jmi_extobj_t";
    eq FFunctionType.nameScalar_C() = myFFunctionDecl().funcNameUnderscore(C_SUFFIX_FP) + "*";
    
    syn String FType.nameArray_C()        = "jmi_array_t";
    eq FRecordType.nameArray_C()          = myFRecordDecl().nameArray_C();
    eq FStringType.nameArray_C()          = "jmi_string_array_t";
    eq FExternalObjectType.nameArray_C()  = "jmi_extobj_array_t";
    
    syn String FType.nameScalarExt_C()    = nameScalar_C();
    eq FIntegerType.nameScalarExt_C()     = "jmi_int_t";
    eq FBooleanType.nameScalarExt_C()     = "jmi_int_t";
    eq FEnumType.nameScalarExt_C()        = "jmi_int_t";
    
    syn String FType.nameArrayExt_C()     = nameArray_C();
    eq FIntegerType.nameArrayExt_C()      = "jmi_int_array_t";
    eq FBooleanType.nameArrayExt_C()      = "jmi_int_array_t";
    eq FEnumType.nameArrayExt_C()         = "jmi_int_array_t";
    
    
    /* Corresponding external c representation */
    syn String FExp.argType_C(boolean ref) = type().argType_C(ref);
    
    syn String FType.argType_C(boolean ref)        = argTypeBase_C() + (ref ? "*" : "");
    eq FExternalObjectType.argType_C(boolean ref)  = argTypeBase_C();
    eq FStringType.argType_C(boolean ref)          = argTypeBase_C();
    
    syn String FType.argTypeBase_C()        = type_C();
    eq FPrimitiveType.argTypeBase_C()       = "double";
    eq FIntegerType.argTypeBase_C()         = "int";
    eq FBooleanType.argTypeBase_C()         = "int";
    eq FEnumType.argTypeBase_C()            = "int";
    eq FExternalObjectType.argTypeBase_C()  = "void*";
    eq FStringType.argTypeBase_C()          = "char*";
    
	
	public void FFunctionVariable.printReturnArgument_C(CodeStream str) {
		str.print(typeReturn_C());
		str.print(" ");
		str.print(nameReturn_C());
	}
	
	public void FFunctionVariable.printReturnWrite_C(CodeStream str, String indent) {
		if (!isRecord()) {
			getType().printReturn_C(str, indent, nameReturn_C(), name_C(), true);
		}
	}
	
	public void FFunctionArray.printReturnWrite_C(CodeStream str, String indent) {}
	
	public void FFunctionVariable.printArgument_C(CodeStream str) {
		str.print(type_C());
		str.print(" ");
		str.print(name_C());
	}
	
	private FExp FFunctionVariable.dummyFExp = null;
	
	public void FFunctionVariable.setDummyExp() {
		if (dummyFExp == null) 
			dummyFExp = new FNoExp();
		setBindingExp(dummyFExp);
	}
	
	public void FFunctionVariable.resetDummyExp() {
		if (dummyFExp != null)
			setBindingExpOpt(new Opt());
	}
    
    public void FFunctionVariable.print(TypePrinter_C tp, String name, String indent) {
        tp.print(this, name, indent);
    }
	
    public void FFunctionVariable.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        if (isComposite()) {
            if (isOutput()) {
                prettyPrintInitOutput_C(p, str, indent, name_C());
            } else {
                print(p.createInitPrinter(str), name_C(), indent);
            }
        }
    }
    
    public void FFunctionVariable.prettyPrintInitOutput_C(CodePrinter p, CodeStream str, String indent, String name) {
        String next = p.indent(indent);
        String iniName = name + C_SUFFIX_NULL;
        str.print(indent + "if (" + name + " == NULL) {\n");
        print(p.createInitPrinter(str), iniName, next);
        str.print(next + name + " = " + iniName + ";\n");
        str.print(indent + "}\n");
    }
	
    public final void FType.printDecl_C(CodePrinter p, CodeStream str, String indent, String name, FExp src) {
        TypePrinter_C tp = p.createDeclPrinter(str);
        tp.reset(name, src, size().isUnknown(), false, indent);
        print(tp);
    }
    
    public final void FType.printExternDecl_C(CodePrinter p, CodeStream str, String indent, String name, FExp src) {
        TypePrinter_C tp = p.createDeclPrinter(str);
        tp.reset(name, src, size().isUnknown(), true, indent);
        print(tp);
    }
    
    public void FType.printInit_C(CodePrinter p, CodeStream str, String indent, String name, FExp src) {
        TypePrinter_C tp = p.createInitPrinter(str);
        tp.reset(name, src, size().isUnknown(), false, indent);
        print(tp);
    }
    
    public void FType.printExternInit_C(CodePrinter p, CodeStream str, String indent, String name, FExp src) {
        TypePrinter_C tp = p.createInitPrinter(str);
        tp.reset(name, src, size().isUnknown(), true, indent);
        print(tp);
    }
    
    public void FType.print(TypePrinter_C p)               { p.print(this); }
    public void FRecordType.print(TypePrinter_C p)         { p.print(this); }
    public void FExternalObjectType.print(TypePrinter_C p) { p.print(this); }
    
    public abstract class TypePrinter_C {
        protected CodePrinter p;
        protected CodeStream str;
        protected FExp src;
        protected boolean external = false;
        protected boolean subDecls = false; // Used in CAD
        
        private Stack<Level> levels   = new Stack<Level>();
        
        public TypePrinter_C(CodePrinter p, CodeStream str) {
            this.p = p;
            this.str = str;
        }
        
        public TypePrinter_C(CodePrinter p, CodeStream str, String indent, String name, FExp src, boolean dynamic, boolean external) {
            this(p, str);
            reset(name, src, dynamic, external, indent);
        }
        
        public void reset(String name, FExp src, boolean dynamic, boolean external, String indent) {
            this.src = src;
            levels = new Stack<Level>();
            levels.push(new Level(name, indent, dynamic));
            this.external = external;
        }
        
        public void setSubDecls(boolean subDecls) { this.subDecls = subDecls; }
        
        protected String name()     { return levels.peek().name; }
        protected String indent()   { return levels.peek().indent; }
        protected boolean dynamic() { return levels.peek().dynamic; }
        
        protected class Level {
            String name;
            String indent;
            boolean dynamic;
            public Level(String name, String indent, boolean dynamic) {
                this.name    = name;
                this.indent  = indent;
                this.dynamic = dynamic;
            }
        }
        
        protected void pushLevel(String name, boolean indent, boolean dynamic) {
            levels.push(new Level(name, indent ? p.indent(indent()) : indent(), dynamic || dynamic()));
        }
        
        protected void popLevel() {
            levels.pop();
        }
        
        
        protected String dynStr(FType type) {
            // Note: The "REAL" part here is only relevant in JMU/cppad
            return (dynamic() ? "DYNA" : "STAT") + (type.isReal() ? "REAL" : "");
        }
        
        public void print(FFunctionVariable fv, String name, String indent) {
            // This is a rather ugly hack, but we temporarily need an FExp that is in the tree
            if (!fv.hasBindingExp()) {
                fv.setDummyExp();
            }
            reset(name, fv.getBindingExp(), fv.size().isUnknown(), false, indent);
            fv.type().print(this);
            fv.resetDummyExp();
        }
        
        public void print(FType type) {
            if (type.isArray()) {
                printArray(type);
            } else {
                printScalar(type);
            }
        }
        
        public void print(FRecordType type) {
            printComposite(type);
        }
        
        public void print(FExternalObjectType type) {
            print((FType) type);
        }
        
        public void printComposite(FType type) {
            print(type);
            if (type.isArray()) {
                if (dynamic()) {
                    printDynArray(type);
                } else {
                    for (Index i : type.indices()) {
                        pushLevel(type.arrayAccess(type.ndims(), name(), i.toUnclosedString()), false, false);
                        printComps(type);
                        popLevel();
                    }
                }
            } else {
                printComps(type);
            }
        }
        
        protected void printComps(FType type) {
            if (type.isRecord()) {
                printComps((FRecordType) type);
            }
        }
        
        protected void printComps(FRecordType type) {
            for (FRecordComponentType comp : type.getComponents()) {
                if (comp.getFType().isComposite()) {
                    String compName = name() + "->" + comp.getName();
                    String tempName = dynamic() ? compName : acquireTemp(compName);
                    pushLevel(tempName, false, comp.getFType().size().isUnknown());
                    comp.getFType().print(this);
                    popLevel();
                    if (!dynamic())
                        tempWriteBack(compName, tempName);
                }
            }
        }
        
        protected void printComps(FExternalObjectType type) {
            int i = 0;
            String name = acquireTemp(name());
            for (FExp arg : type.myConstructorStmt().myConstructorArgs()) {
                pushLevel(name + "_arg" + i, false, arg.size().isUnknown());
                FType t = arg.type();
                boolean b = t.parent == null;
                if (b) {
                    // This needs to be done since some exps does
                    // not parent their calculated type
                    t.setParent(type);
                }
                t.print(this);
                if (b) {
                    t.setParent(null);
                }
                popLevel();
                i++;
            }
        }
        
        protected void printScalar(FType type) {}
        abstract protected void printArray(FType type);
        abstract protected void printDynArray(FType type);
        abstract protected String acquireTemp(String name);
        protected void tempWriteBack(String compName, String tempName) {}
        
        protected void printSizesAsArgs(FType type) {
            printNumElements(type);
            str.print(", ");
            str.print(type.ndims());
            printDimensions(type);
        }
        protected void printNumElements(FType type) {
            if (external && dynamic())
                type.size().printNumElements_C(p, str, indent(), src.myCodeGenContext().alias(src.prettyPrint_C("")));
            else
                type.size().printNumElements_C(p, str, indent(), src);
        }
        protected void printDimensions(FType type) {
            str.print(", ");
            if (external && dynamic())
                type.size().printDimensions_C(p, str, indent(), src.myCodeGenContext().alias(src.prettyPrint_C("")));
            else
                type.size().printDimensions_C(p, str, indent(), src);
        }
    }
    
    public class DeclPrinter_C extends TypePrinter_C {
        protected boolean print = true;
        public DeclPrinter_C(CodePrinter p, CodeStream str) {
            super(p, str);
        }
        protected String acquireTemp(String key) {
            String tmp = src.nextTempName_C();
            src.recordChildTempNames().put(key, tmp);
            return tmp;
        }
        protected void printScalar(FType type) {
            if (print) {
                type.printScalarDecl_C(str, indent(), external, name());
            }
        }
        protected void printArray(FType type) {
            if (print) {
                str.format("%sJMI_ARR(%s, %s, %s, %s, ", indent(), dynStr(type),
                        type.nameScalar_C(external), type.nameArray_C(external), name());
                printSizesAsArgs(type);
                str.println(")");
            }
        }
        protected void printNumElements(FType type) {
            if (dynamic())
                str.print("-1");
            else
                super.printNumElements(type);
        }
        protected void printDimensions(FType type) {
            
        }
        protected void printDynArray(FType type) {
            String ind    = acquireTemp(name());
            String maxind = ind + "_max";
            print = true;
            pushLevel(ind, false, false);
            type.fRealScalarType().print(this);
            popLevel();
            pushLevel(maxind, false, false);
            type.fRealScalarType().print(this);
            popLevel();
            print = type.isExternalObject();
            pushLevel(type.arrayAccess(1, name(), ind), false, true);
            printComps(type);
            popLevel();
            print = true;
        }
    }
    
    public class InitPrinter_C extends TypePrinter_C {
        public InitPrinter_C(CodePrinter p, CodeStream str) {
            super(p, str);
        }
        protected String acquireTemp(String key) {
            return src.recordChildTempNames().get(key);
        }
        protected void printArray(FType type) {
            str.format("%sJMI_ARRAY_INIT_%d(%s, %s, %s, %s, ", indent(), type.ndims(), dynStr(type),
                    type.nameScalar_C(external), type.nameArray_C(external), name());
            printSizesAsArgs(type);
            str.println(")");
        }
        protected void printDynArray(FType type) {
            String ind    = acquireTemp(name());
            String maxind = ind + "_max";
            str.print(indent() + maxind + " = ");
            printNumElements(type);
            str.println(" + 1;");
            str.formatln("%sfor (%s = 1; %s < %s; %s++) {", indent(), ind, ind, maxind, ind);
            pushLevel(type.arrayAccess(1, name(), ind), true, true);
            printComps(type);
            popLevel();
            str.println(indent() + "}");
        }
        protected void tempWriteBack(String compName, String tempName) {
            str.formatln("%s%s = %s;", indent(), compName, tempName);
        }
    }
    
	
	private Map<String,String> FExp.recordChildTempNameMap = null;
	
	public Map<String,String> FExp.recordChildTempNames() {
		if (recordChildTempNameMap == null)
			recordChildTempNameMap = new HashMap<String,String>();
		return recordChildTempNameMap;
	}

	public void Size.printNumElements_C(CodePrinter p, CodeStream str, String indent, ASTNode src) {
		str.print(numElements());
	}

    @Override
    public void MutableSize.printNumElements_C(CodePrinter p, CodeStream str, String indent, ASTNode src) {
        evaluate();
        int known = 1;
        boolean printed = false;
        boolean calced = false;
        for (int i = 0; i < size.length; i++) {
            // TODO: this will fail if hasValue(i) == false
            if (size[i] == UNKNOWN) {
                FExp exp = exps[i];
                exp.parent = src;
                if (printed)
                    str.print(" * ");
                boolean addParenthesis = exp.addParenthesis(FExp.PRECEDENCE_MULTIPLICATIVE);
                if (addParenthesis)
                    str.print("(");
                p.print(exp, str, indent);
                if (addParenthesis)
                    str.print(")");
                printed = true;
            } else {
                calced = true;
                known *= size[i];
            }
        }
        
        if (calced) {
            if (printed)
                str.print(" * ");
            str.print(known);
        }
	}
	
    public void Size.printDimensions_C(CodePrinter p, CodeStream str, String indent, ASTNode src) {
        str.print(toUnclosedString());
    }

	@Override
	public void MutableSize.printDimensions_C(CodePrinter p, CodeStream str, String indent, ASTNode src) {
		if (isUnknown()) {
			for (int i = 0; i < size.length; i++) {
				if (i > 0)
					str.print(", ");
				if (exps[i] == null) {
					str.print(size[i]);
				} else {
                    FExp exp = exps[i];
                    exp.parent = src;
					exp.prettyPrint_C(p, str, indent); // TODO: This is a hack to get CAD gen to work!
				}
			}
		} else {
			super.printDimensions_C(p, str, indent, src);
		}
	}
	
    public void Size.printNumElements_C(CodePrinter p, CodeStream str, String indent, String name) {
        printDimsWithSep_C(p, str, indent, name, " * ");
    }
    public void Size.printDimensions_C(CodePrinter p, CodeStream str, String indent, String name) {
        printDimsWithSep_C(p, str, indent, name, ", ");
    }
    private void Size.printDimsWithSep_C(CodePrinter p, CodeStream str, String indent, String name, String sep) {
        printSize_C(p, str, indent, name, 0);
        for (int i = 1; i < ndims(); i++) {
            str.print(sep);
            printSize_C(p, str, indent, name, i);
        }
    }
    public void Size.printSize_C(CodePrinter p, CodeStream str, String indent, String name, int dim) {
        str.print("jmi_array_size(");
        str.print(name);
        str.print(", ");
        str.print(dim);
        str.print(")");
    }
    public void Size.printSize_C(CodePrinter p, CodeStream str, String indent, FExp e, int dim) {
        str.print("jmi_array_size(");
        p.print(e, str, indent);
        str.print(", ");
        str.print(dim);
        str.print(")");
    }
    
    public void Size.genVarDecls_C(CodePrinter p, CodeStream str, String indent, FExp src) {}

    @Override
    public void MutableSize.genVarDecls_C(CodePrinter p, CodeStream str, String indent, FExp src) {
        if (isUnknown()) {
            for (int i = 0; i < size.length; i++) {
                if (exps[i] != null) {
                    FExp exp = src.dynamicFExp(exps[i]);
                    p.printVarDecls(exp, str, indent); // TODO: This is a hack to get CAD gen to work!
                }
            }
        } else {
            super.genVarDecls_C(p, str, indent, src);
        }
    }

	
    public void Size.genTempVars_C(CodePrinter p, CodeStream str, String indent, FExp src) {}

    @Override
    public void MutableSize.genTempVars_C(CodePrinter p, CodeStream str, String indent, FExp src) {
        if (isUnknown()) {
            for (int i = 0; i < size.length; i++) {
                if (exps[i] != null) {
                    FExp exp = src.dynamicFExp(exps[i]);
                    p.printPreSteps(exp, str, indent); // TODO: This is a hack to get CAD gen to work!
                }
            }
        } else {
            super.genTempVars_C(p, str, indent, src);
        }
    }
    
    public void Size.genTempFree_C(CodePrinter p, CodeStream str, String indent, FExp src) {}

    @Override
    public void MutableSize.genTempFree_C(CodePrinter p, CodeStream str, String indent, FExp src) {
        if (isUnknown()) {
            for (int i = 0; i < size.length; i++) {
                if (exps[i] != null) {
                    FExp exp = src.dynamicFExp(exps[i]);
                    p.printPostSteps(exp, str, indent); // TODO: This is a hack to get CAD gen to work!
                }
            }
        } else {
            super.genTempFree_C(p, str, indent, src);
        }
    }
	
	public void ASTNode.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
		for (ASTNode node : this)
			node.genVarDecls_C(p, str, indent);
	}
	
    @Override
    public void FAbstractEquation.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        ASTNode attributeList = getFAttributeList();
        for (ASTNode node : this)
            if (node != attributeList)
                node.genVarDecls_C(p, str, indent);
    }

    public void FAlgorithm.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        super.genVarDecls_C(p, str, indent);
        if (!inFunction()) {
            boolean first = true;
            String switchTemp = this.tempName_C();
            for (FIdUseExp use : uniqueFIdUseExpsInLHS()) {
                if (first) {
                    first = false;
                    use.type().printDecl_C(printer_C, str, indent, switchTemp, null);
                }
              use.type().printDecl_C(printer_C, str, indent, use.tempName_C(), use);
            }
        }
    }
	
	public void FFunctionVariable.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
		if (!isInput()) {
			String suffix = (isOutput() && isComposite()) ? C_SUFFIX_NULL : "";
			print(p.createDeclPrinter(str), name_C() + suffix, indent);
		}
	}
	
	public void FExp.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
		if (isArray() && !size().isUnknown())
			getArray().genVarDecls_C(p, str, indent);
		else
			super.genVarDecls_C(p, str, indent);
	}
	
    public void FLoadResource.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        str.formatln("%schar %s[JMI_PATH_MAX];", indent, tempName_C());
    }
	
	public void FFunctionCall.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        p.printVarDecls(getArgs(), str, indent);
        if (!functionCallIsExp() && myFCallable().isPartialFunction() && !isPartialFunctionCall()) {
            str.formatln("%s%s %s;", indent, myFCallable().actualFFunctionDecl().funcNameUnderscore(C_SUFFIX_FPOUT), tempName_C());
        }
		for (FExp arg : getArgs()) 
			arg.genTempInputDecl_C(p, str, indent);
        if (isStringExp()) {
            type().printScalarDecl_C(str, indent, false, tempName_C());
        }
    }
    
    syn boolean FFunctionCall.isStringExp() = functionCallIsExp() && type().isString();
    
    public void FPartialFunctionCall.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        super.genVarDecls_C(p, str, indent);
        String fp = myFCallable().actualFFunctionDecl().funcNameUnderscore(C_SUFFIX_FP);
        if (myFCallable().isPartialFunction()) {
            fp = fp + "*";
        }
        str.formatln("%s%s %s;", indent, fp, tempName_C());
    }
    
    public void FFunctionCallLeft.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        if (hasFExp() && getFExp().replaceWithTemp(true)) {
            getFExp().type().printDecl_C(p, str, indent, name_C(), getFExp());
        }
    }
    
    public void FFunctionCallLeft.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        if (hasFExp() && getFExp().replaceWithTemp(false)) {
            getFExp().type().printInit_C(p, str, indent, getFExp().tempName_C(), getFExp());
        }
    }
    
    public void FFunctionCallLeft.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        if (hasFExp() && type().isString()) {
            getFExp().type().printFree_C(str, indent, false, getFExp().tempName_C());
        }
    }
    
    syn boolean FExp.replaceWithTemp(boolean str)      = !keepAsArray() || str && type().isString();
    eq FFillExp.replaceWithTemp(boolean str)           = true;
    eq FArray.replaceWithTemp(boolean str)             = true;
    eq FRecordConstructor.replaceWithTemp(boolean str) = true;
    
    
	
	public void FExp.genTempInputDecl_C(CodePrinter p, CodeStream str, String indent) {
		if (isComposite() && !keepAsArray()) 
			type().printDecl_C(p, str, indent, tempName_C(), this);
	}

	
	public void FExternalStmt.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
		FExternalLanguage lang = getFExternalLanguage();
		lang.genVarDecls_C(p, str, indent, this);
		lang.genFuncDecl(p, str, indent, this);
	}
	
    /**
     * Generates temporaries for an argument to an external function when necessary.
     */
    public void FExternalLanguage.genVarDecls_C(CodePrinter p, CodeStream str, String indent, FExternalStmt stmt) {
        for (FExp arg: stmt.getArgs()) {
            if (extShouldArgConvert(arg))
                arg.type().printExternDecl_C(p, str, indent, arg.tempName_C(), arg);
        }
    }
    
    /**
     *  Does this external function argument need any conversion?
     *  Boolean        => int
     *  Integer        => int
     *  Fortran matrix => transpose
     */
    syn boolean FExternalLanguage.extShouldArgConvert(FExp arg) = false;
    eq FCExternalLanguage.extShouldArgConvert(FExp arg)         = arg.extShouldArgConvert(false);
    eq FFortran77ExternalLanguage.extShouldArgConvert(FExp arg) = arg.extShouldArgConvert(true);
    
    syn boolean FExp.extShouldArgConvert(boolean fortran) = false;
    eq FLitExp.extShouldArgConvert(boolean fortran)       = fortran;
    eq FIdUseExp.extShouldArgConvert(boolean fortran)     =
            type().isInteger() || type().isBoolean() || type().isEnum() ||
            (fortran && type().isReal() && ndims() > 1);
	
	
	public void FAlgorithm.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (!inFunction()) {
			// Print initialization stmts for variables which might not be set before use
			Set<FVariable> defSet = defSet();
			for (FVariable fv : referencedFVariablesInLHS()) {
				if (!defSet.contains(fv)) {
					FStatement.printAssignStmt_C(str, indent, fv.name_C(), fv.algorithmInit_C());
				}
			}
		}
		// Print the algorithm
		p.print(getFStatements(), str, indent);
	}
	
	public String FVariable.algorithmInit_C() {
		if (isDiscrete()) {
			return myPreVariable().name_C();
		} else if (isParameter() && hasBindingExp()) {
			return getBindingExp().prettyPrint_C("");
		} else {
			FExp e = startAttributeExp();
			return (e == null) ? "0.0" : e.prettyPrint("");
		}
	}
	
	public void FInitArrayStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        p.print((FFunctionVariable) getFIdUseExp().myFV(), str, indent);
	}
	
	public void FFunctionCallStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (!getCall().isIgnored()) {
			p.printPreSteps(this, str, indent);
			p.print(getCall(), str, indent);
			for (FFunctionCallLeft l : getLefts()) {
				l.genWriteBackAssignment_C(str, indent, null);
			}
            p.printPostSteps(this, str, indent);
		}
	}
	
	public void FFunctionCallEquation.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (!getCall().isIgnored()) {
			p.printPreSteps(this, str, indent);
			p.print(getCall(), str, indent);
            p.printPostSteps(this, str, indent);
		}
	}
	
	   
    public void FIfEquation.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        genIfStart_C(p, str, indent);
        for (FAbstractEquation equation : getFAbstractEquations())
            p.print(equation, str, p.indent(indent));
        if (hasElse()) {
            p.print(getElse(), str,indent);
        }
        genIfEnd_C(p, str, indent);
    }
    
    public void FElseEquation.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        genIfStart_C(p, str, indent);
        for (FAbstractEquation equation : getFAbstractEquations())
            p.print(equation, str, p.indent(indent));
    }

	public void FAssignStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		p.printPreSteps(this, str, indent);
        getLeft().type().printAssign_C(p, str, indent, getLeft(), getRight());
        p.printPostSteps(this, str, indent);
	}
	
	public void FReturnStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		returnDefinition().printReturnWrite_C(str, indent);
		// TODO: Check if there are any dynamic declarations first
		str.print(indent + "JMI_DYNAMIC_FREE()\n");
		str.print(indent + "return;\n");
	}
	
	public void FBreakStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print(indent + "break;\n");
	}
	
	public void FIfWhenStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		for (FIfWhenClause clause : getFIfWhenClauses())
			p.printPreSteps(clause.getTest(), str, indent);
		str.print(indent);
		getFIfWhenClauses().prettyPrintWithSep(p, str, indent, indent + "} else ");
		prettyPrintElse_C(p, str, indent);
		str.print(indent);
		str.print("}\n");
        for (FIfWhenClause clause : getFIfWhenClauses())
            p.printPostSteps(clause.getTest(), str, indent);
	}
	
	protected void FIfWhenStmt.prettyPrintElse_C(CodePrinter p, CodeStream str, String indent) {}
	
	protected void FIfStmt.prettyPrintElse_C(CodePrinter p, CodeStream str, String indent) {
		if (getNumElseStmt() > 0) {
			str.print(indent);
			str.print("} else {\n");
			p.print(getElseStmts(), str, p.indent(indent));
		}
	}
	
	public void FIfWhenClause.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("if (");
		p.print(getTest(), str, indent);
		str.print(") {\n");
		p.print(getFStatements(), str, p.indent(indent));
	}
	
	public void FWhileStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		p.printPreSteps(getTest(), str, indent);
		str.print(indent);
		str.print("while (");
		p.print(getTest(), str, "");
		str.print(") {\n");
		p.print(getWhileStmts(), str, p.indent(indent));
		str.print(indent);
		str.print("}\n");
        p.printPostSteps(getTest(), str, indent);
	}
	
	public void FForStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		p.printPreSteps(getIndex(), str, indent);
		getIndex().printForArrayInit_C(p, str, indent);
		str.print(indent);
		str.print("for (");
		p.print(getIndex(), str, indent);
		str.print(") {\n");
		getIndex().printForArrayNext_C(p, str, p.indent(indent));
		p.print(getForStmts(), str, p.indent(indent));
		str.print(indent);		
		str.print("}\n");
        p.printPostSteps(getIndex(), str, indent);
	}
	
	public void FForIndex.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
		super.genVarDecls_C(p, str, indent);
		String name = getFVariable().name_C();
		str.format("%sjmi_ad_var_t %s;\n", indent, name);
		if (needsForArray()) {
			str.format("%sint %si;\n", indent, name);
			str.format("%sjmi_ad_var_t %sa[%d];\n", indent, name, getFExp().size().numElements());
		} else {
			str.format("%sjmi_ad_var_t %se;\n", indent, name);
		}
	}
	
	public void FForIndex.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		getFExp().printForIndex_C(p, str, indent, getFVariable().name_C());
	}
	
	public void FForIndex.printForArrayInit_C(CodePrinter p, CodeStream str, String indent) {
		if (needsForArray()) {
			int i = 0;
			for (FExp e : getFExp().getArray().iterable()) {
				str.format("%s%sa[%d] = ", indent, getFVariable().name_C(), i++);
				p.print(e, str, indent);
				str.print(";\n");
			}
		} else {
			str.format("%s%se = ", indent, getFVariable().name_C());
			getFExp().printForEnd_C(p, str, indent);
			str.print(";\n");
		}
	}
	
	public void FForIndex.printForArrayNext_C(CodePrinter p, CodeStream str, String indent) {
		if (needsForArray()) {
			String name = getFVariable().name_C();
			str.print(indent);
			str.print(name);
			str.print(" = ");
			str.print(name);
			str.print("a[");
			str.print(name);
			str.print("i];\n");
		}
	}
	
	syn boolean FForIndex.needsForArray() = hasFExp() && getFExp().needsForArray();
	syn boolean FExp.needsForArray()      = true;
	eq FRangeExp.needsForArray()          = false;
	
	public void FExp.printForEnd_C(CodePrinter p, CodeStream str, String indent) {
		throw new UnsupportedOperationException(
				"Must override printForEnd_C() if needsForArray() returns false");
	}
	
	public void FRangeExp.printForEnd_C(CodePrinter p, CodeStream str, String indent) {
		p.print(getFExp(hasStep() ? 2 : 1), str, indent);
		str.print(" + ");
		printForStep_C(p, str, indent);
		str.print(" / 2.0");
	}

    public void FRangeExp.printForIndex_C(CodePrinter p, CodeStream str, String indent, String name) {
        str.format("%s = ", name);
        p.print(getFExp(0), str, indent);
        if (hasStep() && !getFExp(1).variability().knownParameterOrLess()) {
            str.format("; %s * ", name);
            p.print(getFExp(1), str, indent);
            str.format(" < %se * ", name);
            p.print(getFExp(1), str, indent);
            str.format("; %s += ", name);
        } else {
            String cmp = (hasStep() && getFExp(1).ceval().isNegative()) ? ">" : "<";
            str.format("; %s %s %se; %s += ", name, cmp, name, name);
        }
        printForStep_C(p, str, indent);
    }

	protected void FRangeExp.printForStep_C(CodePrinter p, CodeStream str, String indent) {
		if (hasStep()) 
			p.print(getFExp(1), str, indent);
		else
			str.print("1");
	}
	
	public void FExp.printForIndex_C(CodePrinter p, CodeStream str, String indent, String name) {
		str.print(name);
		str.print("i = 0; ");
		str.print(name);
		str.print("i < ");
		str.print(size().numElements());
		str.print("; ");
		str.print(name);
		str.print("i++");
	}
	
	public void FSizeExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        size().printSize_C(p, str, indent, getFExp(), dimension());
	}
	
	public void FUnknownSizeExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        size().printSize_C(p, str, indent, getVariable().name_C(), getDim());
	}
	
	public void FTerminate.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print(indent);
		str.print("jmi_flag_termination(jmi, ");
		p.print(getFExp(), str, indent);
		str.print(");\n");
	}
	
	@Override
	public void FAssert.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print(indent);
		str.print("if (");
		p.print(getTest(), str, indent);
		str.print(" == JMI_FALSE) {\n");
		p.printVarDecls(getMsg(), str, p.indent(indent));
		p.printPreSteps(getMsg(), str, p.indent(indent));
		str.print(p.indent(indent));
		str.print("jmi_assert_failed(");
		p.print(getMsg(), str, indent);
		boolean warning = hasLevel() && getLevel().ceval().intValue() == 2;
		str.format(", JMI_ASSERT_%s);\n", warning ? "WARNING" : "ERROR");
		p.printPostSteps(getMsg(), str, p.indent(indent));
		str.print(indent);
		str.print("}\n");
	}
	
    @Override
    public void FAssert.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        p.printVarDecls(getTest(), str, indent);
    }
    
    @Override
    public void FAssert.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        p.printPreSteps(getTest(), str, indent);
    }
    
    @Override
    public void FAssert.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        p.printPostSteps(getTest(), str, indent);
    }
    
    public void FReinit.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        str.format("%sjmi_ad_var_t %s;\n", indent, tempName_C());
    }
    
    public void FReinit.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        str.format("%s%s = ", indent, tempName_C());
        p.print(getFExp(), str, indent);
        str.print(";\n");
    }
    
    public void FReinit.genReinitWritebacks_C(CodePrinter p, CodeStream str, String indent) {
        str.print(indent);
        p.print(getVar(), str, indent);
        str.format(" = %s;\n", tempName_C());
        str.format("%sjmi->reinit_triggered = 1;\n", indent);
    }
    public void FAbstractFunctionCall.genReinitWritebacks_C(CodePrinter p, CodeStream str, String indent) {}
    
    public void FAbstractEquation.genReinitWritebacks_C(CodePrinter p, CodeStream str, String indent) {}
    
    public void FFunctionCallEquation.genReinitWritebacks_C(CodePrinter p, CodeStream str, String indent) {
        getCall().genReinitWritebacks_C(p, str, indent);
    }
    
    public void FIfWhenElseEquation.genReinitWritebacks_C(CodePrinter p, CodeStream str, String indent) {
        if (containsReinit()) {
            genIfStart_C(p, str, indent);
            String nextInd = p.indent(indent);
            for (FAbstractEquation e : getFAbstractEquations())
                e.genReinitWritebacks_C(p, str, nextInd);
        }
    }
    
    public void FIfWhenEquation.genReinitWritebacks_C(CodePrinter p, CodeStream str, String indent) {
        if (containsReinit()) {
            super.genReinitWritebacks_C(p, str, indent);
            if (hasElse() && getElse().containsReinit())
                getElse().genReinitWritebacks_C(p, str, indent);
            genIfEnd_C(p, str, indent);
        }
    }
    
    public void AbstractEquationBlock.genReinitWritebacks_C(CodePrinter p, String indent, CodeStream str) {}
    
    public void MetaEquationBlock.genReinitWritebacks_C(CodePrinter p, String indent, CodeStream str) {
        equation().genReinitWritebacks_C(p, str, indent);
    }
    
    public void FunctionCallEquationBlock.genReinitWritebacks_C(CodePrinter p, CodeStream str, String indent) {
        equation().genReinitWritebacks_C(p, str, indent);
    }
    
    syn boolean ASTNode.containsReinit() {
        for (ASTNode n : this)
            if (n.containsReinit())
                return true;
        return false;
    }
    eq FExp.containsReinit()    = false;
    eq FReinit.containsReinit() = true;
	
	syn String FBinExp.op_C() = op();
	eq FDotAddExp.op_C() = " + ";
	eq FDotSubExp.op_C() = " - ";
	eq FDotMulExp.op_C() = " * ";
	eq FDotDivExp.op_C() = " / ";

	public void FDotDivExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (inFunction()) {
			str.format("jmi_divide_function(\"%s\", ", containingFFunctionDecl().name());
		} else {
			str.print("jmi_divide_equation(jmi, ");
		}
        p.print(getLeft(),str,indent);
        str.print(","); 
        p.print(getRight(),str,indent);
        str.print(",\""); 
        CStringCodeStream tstr = new CStringCodeStream(str);
        prettyPrint(tstr, "");
        tstr.close();
        str.print("\")");
	}
	
    public void FStringLitExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        str.print('"');
        str.print(string_C());
        str.print('"');
    }
    
    public void FStringAddExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        str.print(tempName_C());
    }
    
    public void FStringAddExp.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        super.genVarDecls_C(p, str, indent);
        genTopStringDecl(p, str, indent);
    }
    
    public void FStringAddExp.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        super.genTempVars_C(p, str, indent);
        genTopStringInit(p, str, indent);
    }
    
    public void FStringAddExp.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        super.genTempFree_C(p, str, indent);
        genTopStringFree(p, str, indent);
    }
    
    
    public void FStringExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        str.print(tempName_C());
    }
    
    public void FStringExp.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        super.genVarDecls_C(p, str, indent);
        genTopStringDecl(p, str, indent);
    }
    
    public void FStringExp.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        super.genTempVars_C(p, str, indent);
        genTopStringInit(p, str, indent);
    }
    
    public void FStringExp.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        super.genTempFree_C(p, str, indent);
        genTopStringFree(p, str, indent);
    }
    
    
    public void FExp.genTopStringDecl(CodePrinter p, CodeStream str, String indent) {
        if (isTopStringOp()) {
            boolean k = isKnownStringLength();
            str.format("%sJMI_DEF_%s(%s", indent, k ? "STR_STAT" : "STR_DYNA", tempName_C());
            if (k) {
                str.format(", %d", maxStringLength_C());
            }
            str.println(")");
        }
    }
    
    public void FExp.genTopStringInit(CodePrinter p, CodeStream str, String indent) {
        if (isTopStringOp()) {
            boolean k = isKnownStringLength();
            str.format("%sJMI_INI_%s(%s", indent, k ? "STR_STAT" : "STR_DYNA", tempName_C());
            if (!k) {
                str.print(", ");
                genMaxStringLength_C(p, str, indent);
            }
            str.println(")");
            genStringExpWrite_C(p, str, indent, tempName_C());
        }
    }
    
    public void FExp.genTopStringFree(CodePrinter p, CodeStream str, String indent) {
        if (isTopStringOp() && !isKnownStringLength()) {
            type().printFree_C(str, indent, false, tempName_C());
        }
    }
    
    
    public void FExp.genStringExpWrite_C(CodePrinter p, CodeStream str, String indent, String dest) {
        str.format("%ssnprintf(JMI_STR_END(%s), JMI_STR_LEFT(%s), ", indent, dest, dest);
        genStringFormat_C(p, str, indent);
        str.print(", ");
        genStringParts_C(p, str, indent);
        str.println(");");
    }
    
    public void FStringAddExp.genStringExpWrite_C(CodePrinter p, CodeStream str, String indent, String dest) {
        getLeft().genStringExpWrite_C(p, str, indent, dest);
        getRight().genStringExpWrite_C(p, str, indent, dest);
    }
    
    
    public void FExp.genMaxStringLength_C(CodePrinter p, CodeStream str, String indent) {
        str.print("JMI_LEN(");
        p.print(this, str, indent);
        str.print(")");
    }
    
    public void FStringLitExp.genMaxStringLength_C(CodePrinter p, CodeStream str, String indent) {
        str.print(maxStringLength_C());
    }
    
    public void FStringAddExp.genMaxStringLength_C(CodePrinter p, CodeStream str, String indent) {
        getLeft().genMaxStringLength_C(p, str, indent);
        str.print(" + ");
        getRight().genMaxStringLength_C(p, str, indent);
    }
    
    public void FStringExp.genMaxStringLength_C(CodePrinter p, CodeStream str, String indent) {
        if (hasFormat()) {
            str.print(getValue().type().maxNumericStringLength_C(DEFAULT_PRECISION));
        } else {
            if (hasMinimumLength()) {
                str.print("jmi_max(");
            }
            str.print(getValue().type().maxStringLength_C(0));
            if (getValue().type().isReal()) {
                str.print(" + ");
                if (hasSignificantDigits()) {
                    p.print(getSignificantDigits(), str, indent);
                } else {
                    str.print(significantDigits());
                }
            }
            if (hasMinimumLength()) {
                str.print(", ");
                p.print(getMinimumLength(), str, indent);
                str.print(")");
            }
        }
    }
    
    
    public void FExp.genStringFormat_C(CodePrinter p, CodeStream str, String indent) {
        str.print("\"");
        if (type().isString())
            str.print("%s");
        else
            throw new IllegalArgumentException("Trying to use expression '" + toString() + "' in string type expression!");
        str.print("\"");
    }
    
    public void FStringExp.genStringFormat_C(CodePrinter p, CodeStream str, String indent) {
        if (hasFormat()) {
            p.print(getFormat(), str, indent);
        } else {
            if (hasLeftJustified()) {
                str.print("COND_EXP_EQ(");
                p.print(getLeftJustified(), str, indent);
                str.print(", JMI_TRUE, ");
            }
            
            genStringFormat_C(str, true);
            
            if (hasLeftJustified()) {
                str.print(", ");
                genStringFormat_C(str, false);
                str.print(")");
            }
            
            if (hasMinimumLength()) {
                str.print(", (int) ");
                p.print(getMinimumLength(), str, indent);
            }
            
            if (getValue().type().isReal()) {
                str.print(", (int) ");
                if (hasSignificantDigits()) {
                    p.print(getSignificantDigits(), str, indent);
                } else {
                    str.print(significantDigits());
                }
            }
        }
    }
    
    public void FStringExp.genStringFormat_C(CodeStream str, boolean justifyLeft) {
        str.print("\"%");
        if (justifyLeft)
            str.print("-");
        if (hasMinimumLength())
            str.print("*");
        if (getValue().type().isReal())
            str.print(".*");
        str.print(getValue().type().formatSpecifier());
        str.print("\"");
    }
    
    

	public void FExp.genStringParts_C(CodePrinter p, CodeStream str, String indent) {
		FType t = type();
		if (t.isEnum()) {
			str.print(t.enumNames_C());
			str.print("[(int) ");
			p.print(this, str, indent);
			str.print("]");
		} else if (t.isBoolean()) {
			str.print("COND_EXP_EQ(");
			p.print(this, str, indent);
			str.print(", JMI_TRUE, \"true\", \"false\")");
		} else {
			if (t.isInteger())
				str.print("(int) ");
			p.print(this, str, indent);
		}
	}
	
    public void FStringExp.genStringParts_C(CodePrinter p, CodeStream str, String indent) {
        getValue().genStringParts_C(p, str, indent);
    }
	
	/**
	 * Check if this string concatenation or String operator is the top node in an expression consisting of 
	 * one or more string concatenations, i.e. returns true if parent is not an FStringAddExp.
	 */
	inh boolean FExp.isTopStringOp();
	eq FStringAddExp.getChild().isTopStringOp() = false;
	eq BaseNode.getChild().isTopStringOp()      = true;
	
	/**
	 * The value of this string, encoded as UTF-8.
	 * 
	 * All line breaks are encoded as LF.
	 */
	syn lazy byte[] FStringLitExp.stringUtf8() = getString().replaceAll("\r\n|\r", "\n").getBytes(UTF8);
	
	/**
	 * The C representation of this string literal.
	 */
	syn String FStringLitExp.string_C() {
	    // TODO: Use CStringCodeStream instead?
	    StringBuffer buf = new StringBuffer();
	    for (byte c : stringUtf8()) {
	        if (c == '\n') {
                buf.append("\\n");
            } else if (c > 31 && c < 127) {
                buf.append((char) c);
	        } else if (c != 0) {
	            int c2 = (c < 0) ? 256 + c : c;
	            buf.append((c2 < 16) ? "\\x0" : "\\x");
	            buf.append(Integer.toHexString(c2));
	        }
	    }
	    return buf.toString();
	}
	
    syn boolean FExp.isKnownStringLength() = variability().knownParameterOrLess();
    eq FFunctionCall.isKnownStringLength() = false;
    eq FStringAddExp.isKnownStringLength() = getLeft().isKnownStringLength() && getRight().isKnownStringLength();
    eq FStringExp.isKnownStringLength() = (!hasSignificantDigits() || getSignificantDigits().variability().knownParameterOrLess())
            && (!hasMinimumLength() || getMinimumLength().variability().knownParameterOrLess());
    
	/**
	 * The maximum length string the representation of the value of this expression can have in C.
	 */
	syn int FExp.maxStringLength_C() { 
		if (type().isString())
			return MAX_STRING_LENGTH_C;
		else
			throw new IllegalArgumentException("Trying to use expression '" + toString() + "' in string type expression!");
	}
	syn lazy int FStringAddExp.maxStringLength_C() = Math.min(getLeft().maxStringLength_C() + getRight().maxStringLength_C(), MAX_STRING_LENGTH_C);
	eq FStringLitExp.maxStringLength_C()           = stringUtf8().length;
	eq FStringExp.maxStringLength_C()              =
	        hasFormat() ? type().maxNumericStringLength_C(significantDigits()) :
	        Math.max(getValue().type().maxStringLength_C(significantDigits()), minimumLength());
	
	/**
	 * The maximum length string representations of values of this type can have in C.
	 */
	syn int FType.maxStringLength_C(int precision) {
		throw new UnsupportedOperationException();
	}
	eq FRealType.maxStringLength_C(int precision)    = 7 + precision;
	eq FIntegerType.maxStringLength_C(int precision) = 10;
	eq FBooleanType.maxStringLength_C(int precision) = 5;
	eq FEnumType.maxStringLength_C(int precision) {
		int res = 0;
		for (FEnumLiteralType lit : getFEnumLiteralTypes())
			res = Math.max(res, lit.getName().length());
		return res;
	}
	
	syn int FType.maxNumericStringLength_C(int precision) {
	    return 10 + precision;
	}
	
	public static final int FExp.MAX_STRING_LENGTH_C = 16 * 1024 - 1;
	
	public void FEnumDecl.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.format("%schar* %s[] = { \"\"", indent, name_C());
		for (FEnumLiteral el : ((FEnumLiteralList) getFEnumSpecification()).getFEnumLiterals())
			str.format(", \"%s\"", el.name());
		str.print(" };\n");
	}

	
	syn String FType.enumNames_C() = null;
	eq FEnumType.enumNames_C()     = myFEnumDecl().name_C();
	
	syn String FEnumDecl.name_C() = getName().getFQName().lastActualPartName() + "_" + enumIndex() + "_" + C_SUFFIX_ENUM;

	
	public void FIfExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("COND_EXP_EQ(");
		p.print(getIfExp(), str, indent);
		str.print(", JMI_TRUE, ");
		p.print(getThenExp(),str,indent);
		str.print(", ");
		p.print(getElseExp(),str,indent);
		str.print(")");
	}
	
	public void FAbsExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("jmi_abs(");
		p.print(getFExp(), str, indent);
		str.print(")");
	}
	
	public void FSignExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("jmi_sign(");
		p.print(getFExp(), str, indent);
		str.print(")");
	}

	public void FNoEventExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print('(');
		p.print(getFExp(), str, indent);
		str.print(')');
	}

	public void FSmoothExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print('(');
		p.print(getFExp(), str, indent);
		str.print(')');
	}
	
    public void FLoadResource.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        str.print(tempName_C());
    }

	public void FInitialExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("_atInitial");
	}

	public void FTerminalExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("JMI_FALSE");
	}
	
	public void FDivFuncExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("((long)");
		if (inFunction()) {
			str.format("jmi_divide_function(\"%s\", ", containingFFunctionDecl().name());
		} else {
			str.print("jmi_divide_equation(jmi, ");
		}
		p.print(getX(),str,indent);
		str.print(","); 
		p.print(getY(),str,indent);
		str.print(","); 
		str.print("\""+prettyPrint("")+"\")");
		str.print(")");
	}

    public void FDelayExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        getFExp().prettyPrint_C(p, str, indent);
    }


	public void FCeilFuncExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("ceil(");
		p.print(getX(), str, indent);
		str.print(")");
	}
	
	public void FHomotopyExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("(");
		p.print(getActual(), str, indent);
		str.print(")");
	}
	
	public void FFloorFuncExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("floor(");
		p.print(getX(), str, indent);
		str.print(")");
	}
	
	public void FSemiLinearExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		throw new UnsupportedOperationException("Untransformed semiLinear() expression");
	}
	
	syn String FBoolBinExp.macro_C();
	eq FEqExp.macro_C()  = "COND_EXP_EQ";
	eq FNeqExp.macro_C() = "COND_EXP_EQ";
	eq FLtExp.macro_C()  = "COND_EXP_LT";
	eq FLeqExp.macro_C() = "COND_EXP_LE";
	eq FGtExp.macro_C()  = "COND_EXP_GT";
	eq FGeqExp.macro_C() = "COND_EXP_GE";
	eq FAndExp.macro_C() = "LOG_EXP_AND";
	eq FOrExp.macro_C()  = "LOG_EXP_OR";
	
	syn boolean FRelExp.relIsInverted_C() = false;
	eq FNeqExp.relIsInverted_C() = true;
	
    @Override
	public void FRelExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (cevalType().isString()) {
			str.print("strcmp(");
			p.print(getLeft(), str, indent);
			str.print(", ");
			p.print(getRight(), str, indent);
			str.print(")");
			str.print(op_C());
			str.print("0");
		} else if (!generatesEvent(p.inInitialSystem())) {
			str.print(macro_C()+"(");
			p.print(getLeft(), str, indent);
			str.print(", ");
			p.print(getRight(), str, indent);
			str.print(relIsInverted_C() ? ", JMI_FALSE, JMI_TRUE)" : ", JMI_TRUE, JMI_FALSE)");
		} else {
		    printSwitchMacro_C(p, str, indent);
		}
	}
	
    private void FRelExp.printSwitchMacro_C(CodePrinter p, CodeStream str, String indent) {
        int index = relExpInEquationsIndex();
        if (index >= 0) {
            str.format("_sw(%d)", index);
            return;
        }
        index = relExpInInitialEquationsIndex();
        if (index >= 0) {
            str.format("_sw_init(%d)", index);
            return;
        }
        throw new UnsupportedOperationException("Unable to generate switch macro for relational operator, not in list of switches!");
    }

    syn String FRelExp.op_C() = op();
    eq FNeqExp.op_C() = " != ";

    @Override
    public void FRelExp.genTempVars_C(CodePrinter p, CodeStream str, String outerIndent) {
        super.genTempVars_C(p, str, outerIndent);
        if (root().options.getBooleanOption("generate_dae"))
            return;
        if (generatesEvent(p.inInitialSystem())) {
            if (p.insideBlock())
                str.formatln("%sif (evaluation_mode & JMI_BLOCK_EVALUATE_NON_REALS) {", outerIndent);
            else
                str.formatln("%sif (jmi->atInitial || jmi->atEvent) {", outerIndent);
            String indent = p.indent(outerIndent);
            str.print(indent);
            printSwitchMacro_C(p, str, indent);
            str.print(" = jmi_turn_switch(");
            printIndicator_C(p, str, indent);
            str.print(", ");
            printSwitchMacro_C(p, str, indent);
            str.format(", jmi->events_epsilon, ");
            genRelExpKind(str);
            str.formatln(");");
            str.formatln("%s}", outerIndent);
        }
    }


	public void FLogBinExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print(macro_C());
		str.print("(");
		p.print(getLeft(), str, indent);
		str.print(", ");
		p.print(getRight(), str, indent);
		str.print(")");
	}
	
	public void FNotExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("LOG_EXP_NOT(");
		p.print(getFExp(), str, indent);
		str.print(")");
	}
	
	public void FRealLitExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		boolean wrap = inIfCondition();
		if (wrap) 
			str.print("AD_WRAP_LITERAL(");
		str.print(getValue());
		if (wrap) 
			str.print(")");
	}

	public void FIntegerLitExp.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		boolean wrap = inIfCondition() || inFunctionArg();
		if (wrap) 
			str.print("AD_WRAP_LITERAL(");
		str.print(getValue());
		if (wrap) 
			str.print(")");
	}
	
	inh boolean FIntegerLitExp.inFunctionArg();
	eq FAbstractFunctionCall.getChild().inFunctionArg() = true;
	eq FArraySubscripts.getChild().inFunctionArg()      = false;
	eq FAbstractVariable.getChild().inFunctionArg()     = false;
	eq FAbstractEquation.getChild().inFunctionArg()     = false;
	eq Root.getChild().inFunctionArg()                  = false;
	
	public void FBooleanLitExpTrue.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("JMI_TRUE");
	}
	
	public void FBooleanLitExpFalse.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("JMI_FALSE");
	}
	
	public void FExternalStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {		
		// Generate temp arrays for all array inputs and outputs
		// and transpose array for if array is input (Fortran 77 only)
		getFExternalLanguage().prepExternalArg(p, str, indent, this, false);
		
		str.print(indent);
		// return variable?
		if(hasReturnVar()) {
            str.print(getCodeGenContext().alias(getReturnVar().name_C()));
            str.print(" = ");
		}
		
		// print function call
		getFExternalLanguage().genFuncCall(p, str, indent, this);
		
		// If there are any output arrays, transpose these before returning (Fortran 77 only)
		getFExternalLanguage().prepExternalArg(p, str, indent, this, true);
	}
			
	public class MatrixOp {
		
		private String function;
		
        public MatrixOp(FType type, FExternalLanguage lang, boolean writeback) {
            boolean isFortran = lang instanceof FFortran77ExternalLanguage;
            this.function = String.format("jmi_%smatrix_%s_%s%s", 
                    isFortran ? "" : "copy_",
                    writeback ? "from" : "to",
                    isFortran ? "fortran_" : "",
                    type.isReal() ? "real" : "int");
        }
		
		public void genMatrixOp(CodePrinter p, CodeStream str, String indent, String arr, String src, String dest) {
			str.print(indent + function + "(");
			str.print(arr + ", ");
			str.print(src + "->var");
			str.print(", " + dest + "->var");
			str.print(");\n");				
		}
	}
	
    public void FExternalLanguage.prepExternalArg(CodePrinter p, CodeStream str, String indent, FExternalStmt stmt, boolean writeback){
        for (FExp arg : stmt.getArgs())
            if (extShouldArgConvert(arg))
                arg.prepExternalArg(p, str, indent, this, writeback);
    }
    
    public void FExp.prepExternalArg(CodePrinter p, CodeStream str, String indent, FExternalLanguage lang, boolean writeback) {
        String tempName = tempName_C();
        String src = myCodeGenContext().alias(prettyPrint_C(indent));
        useTempVar = true;
        if (isArray()) {
            MatrixOp op = new MatrixOp(type(), lang, writeback);
            if (writeback)
                op.genMatrixOp(p, str, indent, src, tempName, src);
            else
                op.genMatrixOp(p, str, indent, src, src, tempName);
        } else {
            if (writeback)
                str.formatln("%s%s = %s;", indent, src, tempName);
            else
                type().printAssignExt_C(p, str, indent, tempName, src);
        }
    }
    
    public void FIdUseExp.prepExternalArg(CodePrinter p, CodeStream str, String indent, FExternalLanguage lang, boolean writeback) {
        if (!writeback || myCommonVarDecl().isOutput()) {
            if (isArray() && !writeback)
                type().printExternInit_C(p, str, indent, tempName_C(), this);
            super.prepExternalArg(p, str, indent, lang, writeback);
        }
    }
    
    public void FLitExp.prepExternalArg(CodePrinter p, CodeStream str, String indent, FExternalLanguage lang, boolean writeback) {
        if (!writeback)
            super.prepExternalArg(p, str, indent, lang, writeback);
    }
	
	public void FExternalLanguage.genFuncCall(CodePrinter p, CodeStream str, String indent, FExternalStmt stmt) {}
	
	public void FCExternalLanguage.genFuncCall(CodePrinter p, CodeStream str, String indent, FExternalStmt stmt) {
		str.print(stmt.getName()+"(");
		String prefix = "";
		for (FExp arg : stmt.getArgs()) {
			str.print(prefix);
			arg.genExternalCFuncArgs(p, str, indent);
			prefix = ", ";
		}
		str.print(");\n");
	}
	
	public void FFortran77ExternalLanguage.genFuncCall(CodePrinter p, CodeStream str, String indent, FExternalStmt stmt) {
		str.print(stmt.getName()+"_(");
		String prefix = "";
		for (FExp arg : stmt.getArgs()) {
			str.print(prefix);
			arg.genExternalFortranFuncArgs(p, str, indent);
			prefix = ", ";
		}
		str.print(");\n");		
	}
	
	public void FExp.genExternalFortranFuncArgs(CodePrinter p, CodeStream str, String indent) {
        if (!isArray() && !type().isString()) {
			str.print("&");
		}
        if (useTempVar) {
			str.print(tempName_C());
        } else {
            str.print(myCodeGenContext().alias(prettyPrint_C(indent)));
        }
		if (isArray()) {
			str.print("->var");
		}
	}
	
	public void FExp.genExternalCFuncArgs(CodePrinter p, CodeStream str, String indent) {
        p.print(this, str, indent);
	}
	
	public void FIdUseExp.genExternalCFuncArgs(CodePrinter p, CodeStream str, String indent) {
		if (myCommonVarDecl().isOutput() && !isArray())
			str.print("&");
        if (useTempVar) {
            str.print(tempName_C());
        } else {
            str.print(myCodeGenContext().alias(prettyPrint_C(indent)));
        }
		if (isArray()) {
			str.print("->var");
		}	
	}
	
    public void FSizeExp.genExternalCFuncArgs(CodePrinter p, CodeStream str, String indent) {
        str.print(myCodeGenContext().alias(prettyPrint_C(indent)));
    }
	
	public void FExternalLanguage.genFuncDecl(CodePrinter p, CodeStream str, String indent, FExternalStmt stmt) {}
	
	public void FFortran77ExternalLanguage.genFuncDecl(CodePrinter p, CodeStream str, String indent, FExternalStmt stmt) {
		str.print(indent);
		str.print("extern ");
		if (stmt.hasReturnVar()) {
            str.print(stmt.getReturnVar().type().argType_C(false));
		} else {
            str.print("void");
		}
        str.print(" ");

		str.print(stmt.getName()+"_(");
		
		String prefix = "";
		for (FExp arg : stmt.getArgs()) {
			str.print(prefix);
            str.print(arg.argType_C(true));
			prefix = ", ";
		}
		str.print(");\n");
	}
	
	public void ASTNode.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
		for (ASTNode node : this)
			p.printPreSteps(node, str, indent);
	}
	
    public void ASTNode.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        for (ASTNode node : this)
            p.printPostSteps(node, str, indent);
    }

    @Override
    public void FAbstractEquation.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        ASTNode attributeList = getFAttributeList();
        for (ASTNode node : this)
            if (node != attributeList)
                p.printPreSteps(node, str, indent);
    }
    
    @Override
    public void FAbstractEquation.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        ASTNode attributeList = getFAttributeList();
        for (ASTNode node : this)
            if (node != attributeList)
                p.printPostSteps(node, str, indent);
    }

	public void FExp.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
		if (isArray() && !size().isUnknown())
			p.printPreSteps(getArray(), str, indent);
		else
			super.genTempVars_C(p, str, indent);
	}
	
    public void FExp.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        if (isArray() && !size().isUnknown())
            p.printPostSteps(getArray(), str, indent);
        else
            super.genTempFree_C(p, str, indent);
    }
	
    public void FLoadResource.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        str.formatln("%sjmi_load_resource(jmi, %s, \"/%s\");", indent, tempName_C(), resourceName());
    }
	
	public void FFunctionCall.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
		p.printPreSteps(getArgs(), str, indent);
		for (FExp arg : getArgs()) 
			arg.genTempInput_C(p, str, indent);
        if (isStringExp()) {
            str.print(indent);
            str.print(tempName_C());
            str.print(" = ");
            myFCallable().prettyPrintCall_C(p, str, indent, this);
            str.println(";");
        }
	}
	
    public void FFunctionCall.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        p.printPostSteps(getArgs(), str, indent);
        if (isStringExp()) {
            type().printFree_C(str, indent, false, tempName_C());
        }
    }
    
	
    syn lazy String FExp.tempName_C()       = nextTempName_C();
    syn lazy String FAlgorithm.tempName_C() = nextTempName_C();
    
    syn String FExp.nextTempName_C()       = myCodeGenContext().nextTempName_C();
    syn String FAlgorithm.nextTempName_C() = myCodeGenContext().nextTempName_C();
    
    public class CodeGenContext {
        private int nextTempNbr_C = 1;
        
        public String nextTempName_C() {
            return "tmp_" + nextTempNbr_C++;
        }
        public void setAlias(String key, String val) {
            throw new UnsupportedOperationException();
        }
        public String alias(String key) {
            return key;
        }
        public CodeGenContext createProxy() {
            return new CodeGenContextProxy(this);
        }
        private class CodeGenContextProxy extends CodeGenContext {
            private CodeGenContext redirect;
            private Map<String,String> aliases = new HashMap<String,String>();
            public CodeGenContextProxy(CodeGenContext redirect) {
                this.redirect = redirect;
            }
            public String nextTempName_C() {
                return redirect.nextTempName_C();
            }
            public void setAlias(String key, String val) {
                aliases.put(key,val);
            }
            public String alias(String key) {
                return aliases.get(key);
            }
        }
    }
    private CodeGenContext FClass.codeGenContext = new CodeGenContext();
    private CodeGenContext FFunctionDecl.codeGenContext = new CodeGenContext();
    private CodeGenContext FExternalStmt.codeGenContext = null;
    public void FExternalStmt.setCodeGenContext(CodeGenContext cgc) { codeGenContext = cgc; }
    public CodeGenContext FExternalStmt.getCodeGenContext() { return codeGenContext == null ? myCodeGenContext() : codeGenContext; }
    
    inh CodeGenContext FExp.myCodeGenContext();
    inh CodeGenContext FAlgorithm.myCodeGenContext();
    inh CodeGenContext FExternalStmt.myCodeGenContext();
    eq Root.getChild().myCodeGenContext() = null;
    eq FClass.getChild().myCodeGenContext() = codeGenContext;
    eq FFunctionDecl.getChild().myCodeGenContext() = codeGenContext;
    eq FExternalStmt.getChild().myCodeGenContext() = getCodeGenContext();
    
    
	public void FExp.genTempInput_C(CodePrinter p, CodeStream str, String indent) {
		if (isComposite() && !keepAsArray()) {
			String name = tempName_C();
			type().printInit_C(p, str, indent, name, this);
			type().genTempInputAssigns_C(p, str, indent, name, this);
		}
	}
    
    public void FPartialFunctionCall.genTempInput_C(CodePrinter p, CodeStream str, String indent) {
        if (myFCallable().isPartialFunction()) {
            type().genTempInputAssigns_C(p, str, indent, tempName_C(), this);
            str.formatln("%sJMI_DYNAMIC_ADD(%s)", indent, tempName_C());
        }
    }
	
	public void FType.genTempInputAssigns_C(
			CodePrinter p, CodeStream str, String indent, String name, FExp exp) {
		if (isArray()) {
			String type = isRecord() ? C_ARRAY_RECORD : C_ARRAY_REFERENCE;
			String pre = "jmi_array_" + type + "_" + ndims() + "(" + name + ", ";
			Array arr = exp.getArray();
			for (Index i : arr.indices()) {
				String cellName = pre + i.toUnclosedString() + ")";
				genTempInputCellAssigns_C(p, str, indent, cellName, arr.get(i));
			}
		} else {
			genTempInputCellAssigns_C(p, str, indent, name, exp);
		}
	}
	
	public void FType.genTempInputCellAssigns_C(
			CodePrinter p, CodeStream str, String indent, String name, FExp exp) {
		str.print(indent + name + " = ");
		p.print(exp, str, indent);
		str.print(";\n");
	}
	
	public void FRecordType.genTempInputCellAssigns_C(
			CodePrinter p, CodeStream str, String indent, String name, FExp exp) {
		for (FRecordComponentType comp : getComponents()) {
			String compName = name + "->" + comp.getName();
			FExp compExp = exp.extractRecordComponentExp(comp.getName());
			comp.getFType().genTempInputAssigns_C(p, str, indent, compName, compExp);
		}
	}
	
	// TODO: maybe this should be moved to front-end
	public FExp FExp.extractRecordComponentExp(String name) {
		throw new UnsupportedOperationException(getClass().getSimpleName() + " shouldn't have record type.");
	}
	
	public FExp FIdUseExp.extractRecordComponentExp(String name) {
		FQName fqn = getFIdUse().getFQName().copyAndAppend(name);
		return dynamicFExp(new FIdUseExp(fqn));
	}
	
    public FExp FRecordConstructor.extractRecordComponentExp(String name) {
        return myArgFExp(name);
    }
    
    
    public void AbstractEquationBlock.genBlockResidualFunction_C(CodePrinter p, CodeStream str, String outerIndent, boolean inInitial) {
        if (getLabel() == null)
            return;
        for (AbstractEquationBlock subBlock : genBlockResidualFunction_subBlocks_C())
            subBlock.genBlockResidualFunction_C(p, str, outerIndent, inInitial);
        
        Map<FVariable,String> solverArrayMap = new LinkedHashMap<FVariable,String>();
        int i = 0;
        for (FVariable fv : localUnsolvedVariables()) 
            solverArrayMap.put(fv, "x[" + (i++) + "]");
        
        String indent = p.indent(outerIndent);
        String nextIndent = p.indent(indent);
        str.format("%sstatic int dae_%sblock_%d(jmi_t* jmi, jmi_real_t* x, jmi_real_t* residual, int evaluation_mode) {\n", 
                outerIndent, (inInitial? "init_": ""), getSequenceNumber());
        str.format("%s/***** %s: %s *****/\n", indent, inInitial ? "Init block" : "Block", getLabel());
        str.print(indent + "jmi_real_t** res = &residual;\n");
        str.print(indent + "int ef = 0;\n");
        genBlockResidualFunction_jacobianDecls_C(p, str, indent);
        genVarDecls_C(p, str, indent, null);
        
        // Nominal values
        str.print(indent + "if (evaluation_mode == JMI_BLOCK_NOMINAL) {\n");
        p.C_blockResidualAttributePrinter.print(p, str, nextIndent, FAttribute.NOMINAL, solverArrayMap);
        
        // Start values
        str.print(indent + "} else if (evaluation_mode == JMI_BLOCK_START) {\n");
        p.C_blockResidualAttributePrinter.print(p, str, nextIndent, FAttribute.START, solverArrayMap);
        
        // Min values
        str.print(indent + "} else if (evaluation_mode == JMI_BLOCK_MIN) {\n");
        p.C_blockResidualAttributePrinter.print(p, str, nextIndent, FAttribute.MIN, solverArrayMap);
        
        // Max values
        str.print(indent + "} else if (evaluation_mode == JMI_BLOCK_MAX) {\n");
        p.C_blockResidualAttributePrinter.print(p, str, nextIndent, FAttribute.MAX, solverArrayMap);
        
        // Variable value references
        str.print(indent + "} else if (evaluation_mode == JMI_BLOCK_VALUE_REFERENCE) {\n");
        for (FVariable fv : localUnsolvedVariables()) 
            fv.genBlockResidualValuref_C(p, str, nextIndent, solverArrayMap);
        
        str.print(indent + "} else if (evaluation_mode == JMI_BLOCK_NON_REAL_VALUE_REFERENCE) {\n");
        // Loop over all non-real variables and write their position in the z-vector
        Enumerator nonRealEnumerator = new Enumerator();
        for (FVariable fv : localNonRealVariables())
            str.format("%sx[%d] = %d;\n", nextIndent, nonRealEnumerator.next(), fv.valueReference());
        
        str.print(indent + "} else if (evaluation_mode == JMI_BLOCK_ACTIVE_SWITCH_INDEX) {\n");
        // Loop over all non-real variables and write their position in the z-vector
        Enumerator relExpEnumerator = new Enumerator();
        for (FRelExp relExp : activeSwitches_C())
            relExp.genBlockResidualFunction_printSwitchIndex_C(p, str, nextIndent, relExpEnumerator);
        for (FRelExp relExp : activeInitialSwitches_C())
            relExp.genBlockResidualFunction_printSwitchIndex_C(p, str, nextIndent, relExpEnumerator);
        
        // Equation nominal values
        str.print(indent + "} else if (evaluation_mode == JMI_BLOCK_EQUATION_NOMINAL) {\n");
        p.C_blockResidualAttributePrinter.printEquationNominal(p, str, nextIndent, this);
        
        str.print(indent + "} else if (evaluation_mode == JMI_BLOCK_INITIALIZE) {\n");
        // Loop over all active variables and write their value to x	
        for (FVariable fv : localUnsolvedVariables()) 
            fv.genBlockResidualInit_C(p, str, nextIndent, solverArrayMap);
        
        // Generate code for Jacobian
        genBlockResidualFunction_jacobian_C(p, str, indent);
        
        str.print(indent + "} else if (evaluation_mode & JMI_BLOCK_EVALUATE || evaluation_mode & JMI_BLOCK_WRITE_BACK) {\n");
        // Loop over all active variables and write the values in x to the z vector
        str.print(nextIndent + "if ((evaluation_mode & JMI_BLOCK_EVALUATE_NON_REALS) == 0) {\n"); // TODO: remove guard when correct x is given to JMI_BLOCK_EVALUATE_NON_REALS
        for (FVariable fv : localUnsolvedVariables()) 
            fv.genBlockResidualEvalInit_C(p, str, p.indent(nextIndent), solverArrayMap);
        str.print(nextIndent + "}\n");
        Set<FAbstractEquation> visitedList = new HashSet<FAbstractEquation>();
        genBlockResidualFunction_solvedEqns_C(p, str, nextIndent, inInitial, visitedList);
        str.print(nextIndent + "if (evaluation_mode & JMI_BLOCK_EVALUATE) {\n");
        // Write the residual expressions
        genBlockResidualFunction_residualEqns_C(p, str, p.indent(nextIndent), new Enumerator(), visitedList, solverArrayMap);
        str.print(nextIndent + "}\n");
        str.print(indent + "}\n");
        str.print(indent + "return ef;\n");
        str.print(outerIndent + "}\n\n");
    }

    /*
     * Various dispatch methods used in genBlockResidualFunction_C():
     */

    /**
     * Only needed for numerically solved equation blocks. Ensures that the
     * residual function is generated for such blocks.
     */
    protected Collection<AbstractEquationBlock> AbstractEquationBlock.genBlockResidualFunction_subBlocks_C() {
        return Collections.emptyList();
    }

    @Override
    protected Collection<AbstractEquationBlock> EquationBlock.genBlockResidualFunction_subBlocks_C() {
        return solvedBlocks();
    }
    
    /**
     * Prints the position for the switch in the z-vector
     */
    public void FRelExp.genBlockResidualFunction_printSwitchIndex_C(CodePrinter p, CodeStream str, String nextIndent, Enumerator enumerator) {
        int index = relExpInEquationsIndex();
        if (index >= 0) {
            str.format("%sx[%d] = jmi->offs_sw + %d;\n", nextIndent, enumerator.next(), index);
            return;
        }
        index = relExpInInitialEquationsIndex();
        if (index >= 0) {
            str.format("%sx[%d] = jmi->offs_sw_init + %d;\n", nextIndent, enumerator.next(), index);
            return;
        }
        throw new UnsupportedOperationException("Unable to generate switch index for relational operator, not in list of switches!");
    }

    /**
     * Generates residual equation for all unsolved equations in this block.
     */
    public abstract void AbstractEquationBlock.genBlockResidualFunction_residualEqns_C(CodePrinter p, CodeStream str, String indent,
            Enumerator enumerator, Set<FAbstractEquation> visited, Map<FVariable,String> solverArrayMap);

    @Override
    public void EquationBlock.genBlockResidualFunction_residualEqns_C(CodePrinter p, CodeStream str, String indent,
            Enumerator enumerator, Set<FAbstractEquation> visited, Map<FVariable,String> solverArrayMap) {
        for (SimpleEquationBlock block : unsolvedBlocks())
            block.genBlockResidualFunction_residualEqn_C(p, str, indent, enumerator, visited, solverArrayMap);
    }
    
    @Override
    public void SimpleEquationBlock.genBlockResidualFunction_residualEqns_C(CodePrinter p, CodeStream str, String indent,
            Enumerator enumerator, Set<FAbstractEquation> visited, Map<FVariable,String> solverArrayMap) {
        genBlockResidualFunction_residualEqn_C(p, str, indent, enumerator, visited, solverArrayMap);
    }

    /**
     * Generates residual equation for this simple block.
     */
    public void SimpleEquationBlock.genBlockResidualFunction_residualEqn_C(CodePrinter p, CodeStream str, String indent,
            Enumerator enumerator, Set<FAbstractEquation> visited, Map<FVariable,String> solverArrayMap) {
        equation().genResidual_C(p, str, indent, enumerator, visited, assignedIndices() == null ? null : new LinkedHashSet<Integer>(assignedIndices()));
    }

    /**
     * Generates solution equation for all solved equations in this block.
     * Currently only generates code for torn blocks since it is the only
     * non-simple block that have solved equations.
     */
    public void AbstractEquationBlock.genBlockResidualFunction_solvedEqns_C(CodePrinter p, CodeStream str,
            String indent, boolean inInitial, Set<FAbstractEquation> visited) {}

    @Override
    public void EquationBlock.genBlockResidualFunction_solvedEqns_C(CodePrinter p, CodeStream str,
            String indent, boolean inInitial, Set<FAbstractEquation> visited) {
        // Loop over all solved blocks and write the expressions  
        for (AbstractEquationBlock aeb : solvedBlocks())
            aeb.genBlockResidualFunction_solvedEqn_C(p, str, indent, inInitial, visited);
    }

    /**
     * Generates solved equation for this simple block
     */
    public abstract void AbstractEquationBlock.genBlockResidualFunction_solvedEqn_C(CodePrinter p, CodeStream str,
            String indent, boolean inInitial, Set<FAbstractEquation> visited);
    
    @Override
    public void EquationBlock.genBlockResidualFunction_solvedEqn_C(CodePrinter p,
            CodeStream str, String indent, boolean inInitial, Set<FAbstractEquation> visited) {
        String var = inInitial ? "dae_init_block_residuals" : "dae_block_residuals";
        str.format("%sef |= jmi_solve_block_residual(jmi->%s[%d]);\n", indent, var, getSequenceNumber());
    }
    
    @Override
    public void SimpleEquationBlock.genBlockResidualFunction_solvedEqn_C(CodePrinter p, CodeStream str,
            String indent, boolean inInitial, Set<FAbstractEquation> visited) {
        if (getSequenceNumber() >= 0) {
            String var = inInitial ? "dae_init_block_residuals" : "dae_block_residuals";
            str.format("%sef |= jmi_solve_block_residual(jmi->%s[%d]);\n", indent, var, getSequenceNumber());
        } else if (genBlockEnabled()) {
            Collection<FVariable> forVariables = allLocalVariables();
            Collection<Integer> forIndices = assignedIndices();
            if (!isReal()) {
                if (equation().isMixed()) {
                    equation().genBlockEval_C(p, str, indent, visited, forVariables, forIndices);
                }
                str.format("%sif (evaluation_mode & JMI_BLOCK_EVALUATE_NON_REALS) {\n", indent);
                equation().genBlock_C(p, str, p.indent(indent), visited, forVariables, forIndices);
                str.format("%s}\n", indent);
            } else {
                equation().genBlock_C(p, str, indent, visited, forVariables, forIndices);
            }
        } else {
            throw new UnsupportedOperationException("Unable to produce solving code for block of type " + getClass().getSimpleName() + " in residual function");
        }
    }
    
    public C_blockResidualAttributePrinter CodePrinter.C_blockResidualAttributePrinter = new C_blockResidualAttributePrinter();
    
    public abstract class CodePrinter {
        public static class C_blockResidualAttributePrinter {
            public void print(CodePrinter p, CodeStream str, String indent, String attr, Map<FVariable, String> iterVarMap) {
                if (attr.equals(FAttribute.START))
                    return;
                for (Map.Entry<FVariable, String> iterEntry : iterVarMap.entrySet()) {
                    FVariable iv = iterEntry.getKey();
                    FExp exp = iv.attributeExp(attr);
                    if (exp != null)
                        str.format("%s%s = %s;\n", indent, iterEntry.getValue(), exp.ceval());
                }
            }
            
            public boolean attributeSet(FVariable var, String attr) {
                return var.attributeSet(attr);
            }

            public void printVariability(CodePrinter p, CodeStream str, String indent, Collection<FVariable> iterVars) {
                str.print(ASTNode.fConstant().genJMIVariabilityConstant_C() + ", ");
            }

            public void printEquationNominal(CodePrinter p, CodeStream str, String indent, AbstractEquationBlock block) {
            }
        }
    }

	public void FVariable.genBlockResidualValuref_C(CodePrinter p, CodeStream str, String indent, 
	        Map<FVariable,String> solverArrayMap) {
		if (valueReference() != -1) 
			str.format("%s%s = %d;\n", indent, solverArrayMap.get(this), valueReference());
	}
	
	public void FVariable.genBlockResidualBoundsCall_C(CodePrinter p, CodeStream str, String indent,
	        String func, String msg, Map<FVariable,String> solverArrayMap) {
		boolean min = minAttributeSet();
		boolean max = maxAttributeSet();
		if (min || max) {
			String type = (min && max) ? "bounds" : (max ? "ubound" : "lbound");
			str.format("%s%s_%s(%s, ", indent, func, type, solverArrayMap.get(this));
			if (min)
				str.format("%s, ", attributeExp(FAttribute.MIN).ceval());
			if (max)
				str.format("%s, ", attributeExp(FAttribute.MAX).ceval());
			str.format("\"%s for variable %s\");\n", msg, name());
		}
	}
	
	public void FVariable.genBlockResidualInit_C(CodePrinter p, CodeStream str, String indent,
	        Map<FVariable,String> solverArrayMap) {
		str.format("%s%s = %s;\n", indent, solverArrayMap.get(this), name_C());
		genBlockResidualBoundsCall_C(p, str, indent, "init_with", "Resetting initial value", solverArrayMap);
	}
	
	public void FVariable.genBlockResidualEvalInit_C(CodePrinter p, CodeStream str, String indent,
	        Map<FVariable,String> solverArrayMap) {
		genBlockResidualBoundsCall_C(p, str, indent, "check", "Out of bounds", solverArrayMap);
		genBlockResidualWriteback_C(p, str, indent, solverArrayMap);
	}
	
	public void FVariable.genBlockResidualWriteback_C(CodePrinter p, CodeStream str, String indent,
	        Map<FVariable,String> solverArrayMap) {
		str.format("%s%s = %s;\n", indent, name_C(), solverArrayMap.get(this));
	}
	
	
    protected void AbstractEquationBlock.genVarDecls_C(CodePrinter p, CodeStream str, String indent, Set<ASTNode> visited) {
        for (ASTNode n : blockResidualNodes_C())
            if (visited == null || visited.add(n))
                p.printVarDecls(n, str, indent);
    }

    @Override
    protected void SolvedAlgorithmBlock.genVarDecls_C(CodePrinter p, CodeStream str, String indent, Set<ASTNode> visited) {
        if (visited == null || visited.add(equation())) {
            if (activeVars.size() != equation().uniqueFIdUseExpsInLHS().size())
                p.printVarDecls(equation(), str, indent);
            else
                p.printVarDecls(equation().getFStatements(), str, indent);
        }
    }

    @Override
    protected void EquationBlock.genVarDecls_C(CodePrinter p, CodeStream str, String indent, Set<ASTNode> visited) {
        if (visited == null)
            visited = new HashSet<ASTNode>();
        for (SimpleEquationBlock seb : unsolvedBlocks())
            seb.genVarDecls_C(p, str, indent, visited);
        for (SimpleEquationBlock seb : localNonRealBlocks())
            seb.genVarDecls_C(p, str, indent, visited);
    }

    @Override
    protected void TornEquationBlock.genVarDecls_C(CodePrinter p, CodeStream str, String indent, Set<ASTNode> visited) {
        if (visited == null)
            visited = new HashSet<ASTNode>();
        for (SimpleEquationBlock seb : localSolvedBlocks())
            seb.genVarDecls_C(p, str, indent, visited);
        super.genVarDecls_C(p, str, indent, visited);
    }

	public Set<ASTNode> AbstractEquationBlock.blockResidualNodes_C() {
		Set<ASTNode> res = new LinkedHashSet<ASTNode>();
		res.addAll(allLocalEquations());
		return res;
	}
    
    public Set<ASTNode> EquationBlock.blockResidualNodes_C() {
        Set<ASTNode> res = super.blockResidualNodes_C();
        res.addAll(localNonRealEquations());
        return res;
    }
    
    public Set<ASTNode> SolvedScalarEquationBlock.blockResidualNodes_C() {
        return Collections.<ASTNode>singleton(solution());
    }

    public Set<ASTNode> TornEquationBlock.blockResidualNodes_C() {
        Set<ASTNode> res = super.blockResidualNodes_C();
        res.addAll(localSolvedEquations());
        return res;
    }

    public void AbstractEquationBlock.genBlockResidualFunction_jacobianDecls_C(CodePrinter p, CodeStream str, String indent) {
        if (jacobian != null)
            for (FExp[] col : jacobian)
                for (FExp exp : col)
                    if (exp != null)
                        exp.genVarDecls_C(ASTNode.printer_C, str, indent);
    }
	
    public void AbstractEquationBlock.genBlockResidualFunction_jacobian_C(CodePrinter p, CodeStream str, String indent) {
        if (jacobian == null)
            return;
        String innerIndent = p.indent(indent);
        str.format("%s} else if (evaluation_mode==JMI_BLOCK_EVALUATE_JACOBIAN) {\n", indent);
        FExp[][] jacobian = jacobian();
        int rows = jacobian.length;
        int cols = jacobian.length;
        str.format("%smemset(residual, 0, %d * sizeof(jmi_real_t));\n", innerIndent, rows * cols);
        // Output Jacobian
        for (int col = 0; col < cols; col++) {
            for (int row = 0; row < rows; row++) {
                if (jacobian[row][col] != null) {
                    p.printPreSteps(jacobian[row][col], str, innerIndent);
                    str.format("%sresidual[%d] = ", innerIndent, rows * col + row);
                    p.print(jacobian[row][col], str, innerIndent);
                    str.format(";\n");
                    p.printPostSteps(jacobian[row][col], str, innerIndent);
                }
            }
        }
    }

    @Override
    public void TornEquationBlock.genBlockResidualFunction_jacobian_C(CodePrinter p, CodeStream str, String indent) {
        if (!isLinear())
            return;
        String outerIndent = indent;
        indent = p.indent(indent);
        String innerIndent = p.indent(indent);
        str.format("%s} else if (evaluation_mode==JMI_BLOCK_EVALUATE_JACOBIAN) {\n", outerIndent);
        FExp[][] jacobian = jacobian();
        int n1 = localSolvedRealBlocks().size();
        int n2 = unsolvedBlocks().size();
        str.format("%sjmi_real_t* Q1 = calloc(%d, sizeof(jmi_real_t));\n", indent, n1 * n2);
        str.format("%sjmi_real_t* Q2 = calloc(%d, sizeof(jmi_real_t));\n", indent, n2 * n1);
        str.format("%sjmi_real_t* Q3 = residual;\n", indent);
        str.format("%sint i;\n", indent);
        str.format("%schar trans = 'N';\n", indent);
        str.format("%sdouble alpha = -1;\n", indent);
        str.format("%sdouble beta = 1;\n", indent);
        str.format("%sint n1 = %d;\n", indent, n1);
        str.format("%sint n2 = %d;\n", indent, n2);
        
        // Write top-right quadrant, A12, to Q1.
        for (int col = n1; col < n1 + n2; col++) {
            for (int row = 0; row < n1; row++) {
                if (jacobian[row][col] != null) {
                    p.printPreSteps(jacobian[row][col], str, indent);
                    str.format("%sQ1[%d] = ", indent, n1 * (col - n1) + row);
                    p.print(jacobian[row][col], str, indent);
                    str.format(";\n");
                    p.printPostSteps(jacobian[row][col], str, indent);
                }
            }
        }
        // Compute L^-1 * A12 by doing Q1 = L^-1 * Q1
        str.format("%sfor (i = 0; i < %d; i += %d) {\n", indent, n1 * n2, n1);
        for (int row = 0; row < n1; row++) {
            str.format("%sQ1[i + %d] = (Q1[i + %d]", innerIndent, row, row);
            for (int col = 0; col < row; col++) {
                if (jacobian[row][col] != null) {
                    str.format(" - (");
                    p.print(jacobian[row][col], str, indent);
                    str.format(") * Q1[i + %d]", col);
                }
            }
            str.format(") / (");
            p.print(jacobian[row][row], str, indent);
            str.format(");\n");
        }
        str.format("%s}\n", indent);
        // Write bottom-left quadrant, A21, to Q2.
        for (int col = 0; col < n1; col++) {
            for (int row = n1; row < n1 + n2; row++) {
                if (jacobian[row][col] != null) {
                	p.printPreSteps(jacobian[row][col], str, indent);
                    str.format("%sQ2[%d] = ", indent, n2 * col + (row - n1));
                    p.print(jacobian[row][col], str, indent);
                    str.format(";\n");
                    p.printPostSteps(jacobian[row][col], str, indent);
                }
            }
        }
        
        // Write bottom-right quadrant, A22, to Q3.
        str.format("%smemset(Q3, 0, %d * sizeof(jmi_real_t));\n", indent, n2 * n2);
        for (int col = n1; col < n1 + n2; col++) {
            for (int row = n1; row < n1 + n2; row++) {
                if (jacobian[row][col] != null) {
                	p.printPreSteps(jacobian[row][col], str, indent);
                    str.format("%sQ3[%d] = ", indent, n2 * (col - n1) + (row - n1));
                    p.print(jacobian[row][col], str, indent);
                    str.format(";\n");
                    p.printPostSteps(jacobian[row][col], str, indent);
                }
            }
        }
        
        // Compute block jacobian into Q3
        str.format("%sdgemm_(&trans, &trans, &n2, &n2, &n1, &alpha, Q2, &n2, Q1, &n1, &beta, Q3, &n2);\n", indent);
        
        str.format("%sfree(Q1);\n", indent);
        str.format("%sfree(Q2);\n", indent);
    }
    
	public void AbstractEquationBlock.genBlockAddCall_C(CodePrinter p, CodeStream str, String indent, boolean dirDer, boolean inInit, String nleSolver, int parentBlockNumber) {
		if (getLabel() == null)
			return;
		for (AbstractEquationBlock subBlock : genBlockResidualFunction_subBlocks_C())
			subBlock.genBlockAddCall_C(p, str, indent, dirDer, inInit, nleSolver, getSequenceNumber());
		
		str.print(indent);
		str.print("jmi_dae_" + (inInit ? "init_" : "") + "add_equation_block(");
		str.print("*jmi, dae_" + (inInit ? "init_" : "") + "block_" + getSequenceNumber() + ", ");
		if (dirDer)
			str.print("dae_" + (inInit ? "init_" : "") + "block_dir_der_" + getSequenceNumber() + ", ");
		else
			str.print("NULL, ");
		str.print(localUnsolvedVariables().size() + ", "); // Rename to realIterationVariables() and nonRealIterationVariables()?
		str.print(localNonRealVariables().size() + ", ");
		str.print((activeSwitches_C().size() + activeInitialSwitches_C().size()) + ", ");
		str.print(variability().genJMIVariabilityConstant_C() + ", ");
		p.C_blockResidualAttributePrinter.printVariability(p, str, indent, this.localUnsolvedVariables());
		str.print(genJMISolverConstant_C(nleSolver) + ", ");
		str.print(getSequenceNumber() + ", \"");
		str.print(getLabel() + "\", ");
		str.print(parentBlockNumber + ");\n");
	}
	
	syn String FTypePrefixVariability.genJMIVariabilityConstant_C();
	eq FParameter.genJMIVariabilityConstant_C() = "JMI_PARAMETER_VARIABILITY";
	eq FDiscrete.genJMIVariabilityConstant_C() = "JMI_DISCRETE_VARIABILITY";
	eq FConstant.genJMIVariabilityConstant_C() = "JMI_CONSTANT_VARIABILITY";
	eq FContinuous.genJMIVariabilityConstant_C() = "JMI_CONTINUOUS_VARIABILITY";
	/* Composite variabilities are removed during scalarization */
	eq FCompositeVariability.genJMIVariabilityConstant_C() = null;
	
    public String AbstractEquationBlock.genJMISolverConstant_C(String nleSolver) {
        if (isLinear())
            return "JMI_LINEAR_SOLVER";
        else if (nleSolver.equals("kinsol"))
            return "JMI_KINSOL_SOLVER";
        else if (nleSolver.equals("minpack"))
            return "JMI_MINPACK_SOLVER";
        else
            throw new UnsupportedOperationException("The string value: " + nleSolver + " is not valid for the compiler option nonlinear_solver");
    }

    private Collection<FRelExp> AbstractEquationBlock.activeSwitches_C = null;
    private Collection<FRelExp> AbstractEquationBlock.inactiveSwitches_C = null;
    private Collection<FRelExp> AbstractEquationBlock.activeInitialSwitches_C = null;
    private Collection<FRelExp> AbstractEquationBlock.inactiveInitialSwitches_C = null;
    
    /**
     * Returns all active switches in the block. A switch is considered active
     * in a block if is located in the block and depends on active variables
     * in the block.
     */
    public Collection<FRelExp> AbstractEquationBlock.activeSwitches_C() {
        cacheSwitches_C();
        return activeSwitches_C;
    }
    
    
    /**
     * Returns all active initial switches in the block. A switch is considered
     * active in a block if is located in the block and depends on active
     * aariables in the block.
     */
    public Collection<FRelExp> AbstractEquationBlock.activeInitialSwitches_C() {
        cacheSwitches_C();
        return activeInitialSwitches_C;
    }
    
    /**
     * Returns all inactive switches in the block. A switch is considered active
     * in a block if is located in the block and depends on active variables
     * in the block.
     */
    public Collection<FRelExp> AbstractEquationBlock.inactiveSwitches_C() {
        cacheSwitches_C();
        return inactiveSwitches_C;
    }
    
    
    /**
     * Returns all inactive initial switches in the block. A switch is considered
     * active in a block if is located in the block and depends on active
     * aariables in the block.
     */
    public Collection<FRelExp> AbstractEquationBlock.inactiveInitialSwitches_C() {
        cacheSwitches_C();
        return inactiveInitialSwitches_C;
    }
    
    private void AbstractEquationBlock.cacheSwitches_C() {
        if (activeSwitches_C != null && activeInitialSwitches_C != null && inactiveSwitches_C != null && inactiveInitialSwitches_C != null)
            return;
        activeSwitches_C = new ArrayList<FRelExp>();
        activeInitialSwitches_C = new ArrayList<FRelExp>();
        inactiveSwitches_C = new ArrayList<FRelExp>();
        inactiveInitialSwitches_C = new ArrayList<FRelExp>();
        Collection<FVariable> allVariables = allLocalVariables();
        for (FAbstractEquation equation : allLocalEquations()) {
            for (FRelExp relExp : equation.relExpInInitialEquation()) {
                if (relExp.dependsOn(allVariables))
                    activeInitialSwitches_C.add(relExp);
                else
                    inactiveInitialSwitches_C.add(relExp);
            }
            for (FRelExp relExp : equation.relExpInEquation()) {
                if (relExp.dependsOn(allVariables))
                    activeSwitches_C.add(relExp);
                else
                    inactiveSwitches_C.add(relExp);
            }
        }
    }


    /**
     * Generate code for blocks of equations 
     */
    public void AbstractEquationBlock.genBlockBase_C(CodePrinter p, CodeStream str, String indent, boolean inInitial) {
        for (FRelExp relExp : inactiveSwitches_C())
            p.printPreSteps(relExp, str, indent);
        for (FRelExp relExp : inactiveInitialSwitches_C())
            p.printPreSteps(relExp, str, indent);
        String var = inInitial ? "dae_init_block_residuals" : "dae_block_residuals";
        str.format("%sef |= jmi_solve_block_residual(jmi->%s[%d]);\n", indent, var, getSequenceNumber());
        for (FRelExp relExp : inactiveInitialSwitches_C())
            p.printPostSteps(relExp, str, indent);
    }

    /**
     * Generate code for blocks of equations 
     */
    public void AbstractEquationBlock.genBlock_C(CodePrinter p, CodeStream str, String indent, boolean inInitial) {
        genBlockBase_C(p, str, indent, inInitial);
    }

    @Override
    public void SimpleEquationBlock.genBlock_C(CodePrinter p, CodeStream str, String indent, boolean inInitial) {
        if (getSequenceNumber() >= 0) {
            genBlockBase_C(p, str, indent, inInitial);
        } else if (genBlockEnabled()) {
            equation().genBlock_C(p, str, indent, new HashSet<FAbstractEquation>(), allLocalVariables(), assignedIndices());
        } else {
            throw new UnsupportedOperationException("Unable to produce solving code for block of type " + getClass().getSimpleName());
        }
    }

    public void MetaEquationBlock.genBlock_C(CodePrinter p, CodeStream str, String indent, boolean inInitial) {
        ASTNode.printer_C.printPreSteps(equation(), str, indent);
        ASTNode.printer_C.print(equation(), str, indent);
        ASTNode.printer_C.printPostSteps(equation(), str, indent);
    }
    
     public boolean SimpleEquationBlock.genBlockEnabled()             { return false; }
     public boolean SolvedScalarEquationBlock.genBlockEnabled()       { return true; }
     public boolean SolvedAlgorithmBlock.genBlockEnabled()            { return true; }
     public boolean SolvedFunctionCallEquationBlock.genBlockEnabled() { return true; }
     public boolean SolvedIfEquationBlock.genBlockEnabled()           { return true; }
    
    /**
     * Generate block code for equations
     * 
     * @param visited      Keeps track of visited equations
     * @param forVariables Variables that should get a writeback
     * @param forIndices   Indices of equations that should get a writeback
     */
    public void FAbstractEquation.genBlock_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {}
    
    public void FAbstractEquation.genBlockEval_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {}
    
    public void FEquation.genBlock_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        FVariable fv = forVariables.iterator().next();
        FExp sol = solution(fv);
        p.printPreSteps(sol, str, indent);
        str.format("%s%s = ", indent, fv.name_C());
        p.print(sol, str, indent);
        str.print(";\n");
        p.printPostSteps(sol, str, indent);
    }
    
    public void FFunctionCallEquation.genBlock_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        if (!getCall().isIgnored()) {
            genBlockEval_C(p, str, indent, visited, forVariables, forIndices);
            for (FFunctionCallLeft l : getLefts()) {
                l.genWriteBackAssignment_C(str, indent, forVariables);
            }
        }
    }
    
   public void FFunctionCallEquation.genBlockEval_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        boolean firstVisit = visited == null || visited.add(this);
        if (!getCall().isIgnored()) {
            if (firstVisit) {
                p.printPreSteps(this, str, indent);
                p.print(getCall(), str, indent);
                p.printPostSteps(this, str, indent);
            }
        }
   }
    
    public void FAlgorithm.genBlock_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        boolean sideEffect = forVariables.size() == uniqueFIdUseExpsInLHS().size();
        genBlockEval_C(p, str, indent, visited, forVariables, forIndices);
        if (!sideEffect)
            for (FIdUseExp use : uniqueFIdUseExpsInLHS())
                use.genWriteBackAssignment_C(str, indent, use.tempName_C(), forVariables);
    }
    
    public void FAlgorithm.genBlockEval_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        boolean firstVisit = visited == null ? true : visited.add(this);
        boolean sideEffect = forVariables.size() == uniqueFIdUseExpsInLHS().size();
        if (firstVisit) {
            p.printPreSteps(this, str, indent);
            if (sideEffect)
                p.print(this, str, indent);
            else
                prettyPrintNoSideEffect_C(str, indent);
            p.printPostSteps(this, str, indent);
        }
   }
    
    public void FIfWhenElseEquation.genBlock_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        genIfStart_C(p, str, indent);
        Iterator<FVariable> fvIt = forVariables.iterator();
        Iterator<Integer> fiIt = forIndices.iterator();
        int i = 0;
        int n = fiIt.hasNext() ? fiIt.next() : -1;
        for (FAbstractEquation equation : getFAbstractEquations()) {
            Collection<Integer> fis   = new ArrayList<Integer>();
            Collection<FVariable> fvs = new ArrayList<FVariable>();
            while (n >= i && n < i + equation.numScalarEquations()) {
                    fis.add(n - i);
                    fvs.add(fvIt.next());
                    n = fiIt.hasNext() ? fiIt.next() : -1;
            }
            if (forIndices.size() == 0 || fis.size() > 0) {
                equation.genBlock_C(p, str, p.indent(indent), visited, fvs, fis);
            }
            i += equation.numScalarEquations();
        }
    }
    
    public void FIfEquation.genBlock_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        super.genBlock_C(p, str, indent, visited, forVariables, forIndices);
        if (hasElse())
            getElse().genBlock_C(p, str, indent, visited, forVariables, forIndices);
        genIfEnd_C(p, str, indent);
    }
    
    public void FIfWhenElseEquation.genBlockEval_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        genIfStart_C(p, str, indent);
        Iterator<FVariable> fvIt = forVariables.iterator();
        Iterator<Integer> fiIt = forIndices.iterator();
        int i = 0;
        int n = fiIt.hasNext() ? fiIt.next() : -1;
        for (FAbstractEquation equation : getFAbstractEquations()) {
            Collection<Integer> fis   = new ArrayList<Integer>();
            Collection<FVariable> fvs = new ArrayList<FVariable>();
            while (n >= i && n < i + equation.numScalarEquations()) {
                    fis.add(n - i);
                    fvs.add(fvIt.next());
                    n = fiIt.hasNext() ? fiIt.next() : -1;
            }
            if (forIndices.size() == 0 || fis.size() > 0) {
                equation.genBlockEval_C(p, str, p.indent(indent), visited, fvs, fis);
            }
            i += equation.numScalarEquations();
        }
    }
    
    public void FIfEquation.genBlockEval_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        super.genBlockEval_C(p, str, indent, visited, forVariables, forIndices);
        if (hasElse())
            getElse().genBlockEval_C(p, str, indent, visited, forVariables, forIndices);
        genIfEnd_C(p, str, indent);
    }
    
    
    
    /**
     * Generate residual code for equations
     * 
     * @param enumerator Enumerates residuals
     * @param visited    Keeps track of visited equations
     * @param forIndices Indices of equations that should get a residual
     */
    public void FAbstractEquation.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator, Set<FAbstractEquation> visited, Set<Integer> forIndices) {}
    
    @Override
    public void FEquation.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        boolean firstVisit = visited == null || visited.add(this);
        p.printPreSteps(this, str, indent);
        str.print(indent + "(*res)[" + enumerator.next() + "] = ");
        p.print(getRight(), str, "");
        str.print(" - (");
        p.print(getLeft(), str, "");
        str.print(");\n");
        p.printPostSteps(this, str, indent);
    }
    
    @Override
    public void FFunctionCallEquation.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        boolean firstVisit = visited == null || visited.add(this);
        if (!getCall().isIgnored()) {
            if (firstVisit) {
                p.printPreSteps(this, str, indent);
                p.print(getCall(), str, indent);
                p.printPostSteps(this, str, indent);
            }
            Enumerator indexCounter = new Enumerator();
            for (FFunctionCallLeft l : getLefts())
                l.genWriteBackResidual_C(str, indent, enumerator, forIndices, indexCounter);
        }
    }
    
    @Override
    public void FIfWhenElseEquation.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        genIfStart_C(printer_C, str, indent);
        Iterator<Integer> fiIt = forIndices.iterator();
        int i = 0;
        int n = fiIt.hasNext() ? fiIt.next() : -1;
        for (FAbstractEquation equation : getFAbstractEquations()) {
            Set<Integer> fis = new HashSet<Integer>();
            while (n >= i && n < i + equation.numScalarEquations()) {
                fis.add(n - i);
                n = fiIt.hasNext() ? fiIt.next() : -1;
            }
            if (forIndices.size() == 0 || fis.size() > 0) {
                equation.genResidual_C(p, str, p.indent(indent), enumerator, visited, fis);
            }
            i += equation.numScalarEquations();
        }
    }
    
    @Override
    public void FIfWhenEquation.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        Enumerator enumCopy = enumerator.copy();
        super.genResidual_C(p, str, indent, enumerator, visited, forIndices);
        if (hasElse())
            getElse().genResidual_C(p, str, indent, enumCopy, visited, forIndices);
        genIfEnd_C(p, str, indent);
    }
    
    @Override
    public void FAlgorithm.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        if (!visited.contains(this)) {
            visited.add(this);
            p.printPreSteps(this, str, indent);
            prettyPrintNoSideEffect_C(str, indent);
            p.printPostSteps(this, str, indent);
        }
        Enumerator indexCounter = new Enumerator();
        for (FIdUseExp use : uniqueFIdUseExpsInLHS())
            use.genWriteBackResidual_C(str, indent, use.tempName_C(), enumerator, forIndices, indexCounter);
    }
	
    /**
     * Helper for genBlock_C and genResidual_C
     * Prints the algorithm, statements which restore LHS variables,
     * and statements which put the new values in temporaries.
     */
    public void FAlgorithm.prettyPrintNoSideEffect_C(CodeStream str, String indent) {
        String switchTemp = this.tempName_C();
        Collection<FIdUseExp> lhs = uniqueFIdUseExpsInLHS();
        for (FIdUseExp use : lhs)
            FStatement.printAssignStmt_C(str, indent, use.tempName_C(), use.myFV().name_C());
        prettyPrint_C(str, indent);
        for (FIdUseExp use : lhs) {
            FStatement.printAssignStmt_C(str, indent, switchTemp, use.myFV().name_C());
            FStatement.printAssignStmt_C(str, indent, use.myFV().name_C(), use.tempName_C());
            FStatement.printAssignStmt_C(str, indent, use.tempName_C(), switchTemp);
        }
    }
    
    public static void FStatement.printAssignStmt_C(CodeStream str, String indent, String dst, String src) {
        str.print(indent + dst + " = " + src + ";\n");
    }
    
    public void FType.printAssign_C(CodePrinter p, CodeStream str, String indent, FExp dst, FExp src) {
        str.print(indent);
        p.print(dst, str, indent);
        str.print(" = ");
        p.print(src, str, indent);
        str.print(";\n");
    }
    
    @Override
    public void FStringType.printAssign_C(CodePrinter p, CodeStream str, String indent, FExp dst, FExp src) {
        str.print(indent);
        str.print("JMI_ASG(STR, ");
        p.print(dst, str, indent);
        str.print(", ");
        p.print(src, str, indent);
        str.print(")\n");
    }
    
    public void FType.printAssignExt_C(CodePrinter p, CodeStream str, String indent, String dst, String src) {
        str.formatln("%s%s = (%s)%s;", indent, dst, argType_C(false), src);
    }
    
    @Override
    public void FStringType.printAssignExt_C(CodePrinter p, CodeStream str, String indent, String dst, String src) {
        str.formatln("%sJMI_ASG(STR, %s, %s)", indent, dst, src);
    }
    
    public void FType.printReturn_C(CodeStream str, String indent, String dst, String src, boolean set) {
        str.print(indent);
        str.print("if (");
        str.print(dst);
        str.print(" != NULL) *");
        str.print(dst);
        str.print(" = ");
        str.print(src);
        str.print(";\n");
    }
    
    public void FStringType.printReturn_C(CodeStream str, String indent, String dst, String src, boolean set) {
        str.print(indent);
        str.print("JMI_RET(STR, ");
        str.print(dst);
        str.print(", ");
        str.print(src);
        str.print(")\n");
    }
    
    public void FType.printScalarDecl_C(CodeStream str, String indent, boolean external, String name) {
        str.formatln("%s%s %s;", indent, nameScalar_C(external), name);
    }
    
    public void FRecordType.printScalarDecl_C(CodeStream str, String indent, boolean external, String name) {
        str.formatln("%sJMI_RECORD_STATIC(%s, %s)", indent, nameScalar_C(external), name);
    }
    
    public void FStringType.printScalarDecl_C(CodeStream str, String indent, boolean external, String name) {
        str.formatln("%sJMI_DEF_STR_DYNA(%s)", indent, name);
    }
    
    public void FType.printFree_C(CodeStream str, String indent, boolean external, String name) {
        if (isArray()) {
            str.formatln("%sjmi_free_str_arr(%s);", indent, name);
        } else {
            str.formatln("%sJMI_FREE(%s)", indent, name);
        }
    }
    
    /**
     * Helper for printing if equations
     */
    public void FIfWhenElseEquation.genIfStart_C(CodePrinter p, CodeStream str, String indent) {
        str.print(indent);
        str.print("} else {\n");
    }
    
    public void FIfWhenEquation.genIfStart_C(CodePrinter p, CodeStream str, String indent) {
        str.print(indent);
        if (isElse())
            str.print("} else ");
        str.print("if (");
        p.print(getTest(), str, p.indent(indent));
        str.print(") {\n");
    }
    
    /**
     * Helper for printing if equations
     */
    public void FIfWhenElseEquation.genIfEnd_C(CodePrinter p, CodeStream str, String indent) {}
    
    public void FIfWhenEquation.genIfEnd_C(CodePrinter p, CodeStream str, String indent) {
        if (!isElse()) {
            str.print(indent);
            str.print("}\n");
        }
    }
    
    
    
    /**
     * Generates code for dependent parameter assignments
     */
    public void FAbstractEquation.genAssignment_C(CodePrinter p, CodeStream str, String indent) {}
    
    @Override
	public void FEquation.genAssignment_C(CodePrinter p, CodeStream str, String indent) {
		p.printPreSteps(this, str, indent);
		FIdUseExp left = (FIdUseExp)getLeft();
		String oldindent = indent; // needed if left is EO
        if (left.myFV().isExternalObject()) {
            str.print(indent + "if (!jmi->dep_extobjs_initialized) { \n");
            indent = p.indent(indent);
        }
        str.print(indent);
		p.print(left.getFIdUse(), str, "");
		str.print(" = (");
		p.print(getRight(), str, "");
		str.print(")");
		if (left.myFV().isReal() && root().options.getBooleanOption("enable_variable_scaling") && !inFunction()) {
			str.print("/sf(");
			str.print(left.myFV().valueReference());
			str.print(")");
		}
		str.print(";\n");
		
		if (left.myFV().isExternalObject()) {
		    str.print(oldindent + "}\n");
		}
		p.printPostSteps(this, str, indent);
	}

    @Override
    public void FFunctionCallEquation.genAssignment_C(CodePrinter p, CodeStream str, String indent) {
        genBlock_C(p, str, indent, null, null, null);
    }
    
    
    syn String FFunctionCallLeft.name_C() {
        if (hasFExp() && getFExp().replaceWithTemp(true)) {
            return getFExp().tempName_C();
        } else {
            return ((FIdUseExp) getFExp()).getFIdUse().name_C();
        }
    }
    
    
	public void FFunctionCallLeft.genArgument_C(CodeStream str) {
		if (hasFExp()) {
			if (!getFExp().isComposite())
				str.print("&");
			str.print(name_C());
		} else {
			str.print("NULL");
		}
	}
	
	public void FFunctionCallLeft.genWriteBackResidual_C(CodeStream str, String indent, Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
		if (hasFExp()) 
			getFExp().type().genWriteBackResidual_C(str, indent, name_C(), getFExp(), enumerator, forIndices, indexCounter);
	}
	
	public void FType.genWriteBackResidual_C(CodeStream str, String indent, String name, FExp exp, Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
		if (isArray()) {
			String type = isRecord() ? C_ARRAY_RECORD : C_ARRAY_VALUE;
			String pre = String.format("jmi_array_%s_%d(%s, ", type, ndims(), name);
			Array arr = exp.getArray();
			for (Index i : arr.indices()) {
				String cellName = pre + i.toUnclosedString() + ")";
				genCellWriteBackResidual_C(str, indent, cellName, arr.get(i), enumerator, forIndices, indexCounter);
			}
		} else {
			genCellWriteBackResidual_C(str, indent, name, exp, enumerator, forIndices, indexCounter);
		}
	}
	
	public void FType.genCellWriteBackResidual_C(CodeStream str, String indent, String name, FExp exp, Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
		exp.genWriteBackResidual_C(str, indent, name, enumerator, forIndices, indexCounter);
	}
	
	public void FRecordType.genCellWriteBackResidual_C(CodeStream str, String indent, String name, FExp exp, Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
		for (FRecordComponentType comp : getComponents()) {
			String compName = name + "->" + comp.getName();
			FExp compExp = exp.extractRecordComponentExp(comp.getName());
			comp.getFType().genWriteBackResidual_C(str, indent, compName, compExp, enumerator, forIndices, indexCounter);
		}
	}
	
	public void FExp.genWriteBackResidual_C(CodeStream str, String indent, String name, Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
		throw new UnsupportedOperationException();
	}
    public void FNoExp.genWriteBackResidual_C(CodeStream str, String indent, String name, Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
        
    }
	public void FIdUseExp.genWriteBackResidual_C(CodeStream str, String indent, String name, Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
		int index = indexCounter.next();
		if (forIndices == null || forIndices.contains(index)) {
			if (!myFV().isReal()) 
				throw new UnsupportedOperationException("Cannot generate real residual write back for non real variable");
			
			// This variable is in the set of variables to generate code for.
			str.print(indent);
			str.print("(*res)[");
			str.print(enumerator.next());
			str.print("] = ");
			str.print(name);
			str.print(" - (");
			prettyPrint_C(str, "");
			str.print(");\n");
		}
	}
	
	public void FFunctionCallLeft.genWriteBackAssignment_C(CodeStream str, String indent, Collection<FVariable> forVariables) {
		if (hasFExp() && getFExp().replaceWithTemp(true))
			getFExp().type().genWriteBackAssignment_C(str, indent, name_C(), getFExp(), forVariables);
	}
	
	public void FType.genWriteBackAssignment_C(CodeStream str, String indent, String name, FExp exp, Collection<FVariable> forVariables) {
		if (isArray()) {
			String type = isRecord() ? C_ARRAY_RECORD : C_ARRAY_VALUE;
			String pre = String.format("jmi_array_%s_%d(%s, ", type, ndims(), name);
			Array arr = exp.getArray();
			for (Index i : arr.indices()) {
				String cellName = pre + i.toUnclosedString() + ")";
				genCellWriteBackAssignment_C(str, indent, cellName, arr.get(i), forVariables);
			}
		} else {
			genCellWriteBackAssignment_C(str, indent, name, exp, forVariables);
		}
	}
	
	public void FType.genCellWriteBackAssignment_C(CodeStream str, String indent, String name, FExp exp, Collection<FVariable> forVariables) {
		exp.genWriteBackAssignment_C(str, indent, name, forVariables);
	}
	
	public void FRecordType.genCellWriteBackAssignment_C(CodeStream str, String indent, String name, FExp exp, Collection<FVariable> forVariables) {
		for (FRecordComponentType comp : getComponents()) {
			String compName = name + "->" + comp.getName();
			FExp compExp = exp.extractRecordComponentExp(comp.getName());
			comp.getFType().genWriteBackAssignment_C(str, indent, compName, compExp, forVariables);
		}
	}

	public void FExp.genWriteBackAssignment_C(CodeStream str, String indent, String name, Collection<FVariable> forVariables) {
		throw new UnsupportedOperationException();
	}
	
    public void FNoExp.genWriteBackAssignment_C(CodeStream str, String indent, String name, Collection<FVariable> forVariables) {
        
    }
	
	public void FIdUseExp.genWriteBackAssignment_C(CodeStream str, String indent, String name, Collection<FVariable> forVariables) {
		if (forVariables != null && !forVariables.contains(myFV()))
			return; // This variable is not in the set of variables to generate code for.
        if (type().isString()) {
            str.format("%sJMI_ASG(STR, ", indent);
            printer_C.print(getFIdUse(), str, "");
            str.print(", ");
            str.print(name);
            str.println(")");
            return;
        }
		str.print(indent);
		printer_C.print(getFIdUse(), str, "");
		str.print(" = (");
		str.print(name);
		str.print(")");
		if (myFV().isReal() && root().options.getBooleanOption("enable_variable_scaling") && !inFunction()) {
			str.print("/sf(");
			str.print(myFV().valueReference());
			str.print(")");
		}
		str.print(";\n");
	}
	
	public void FExp.genArgument_C(CodePrinter p, CodeStream str, String indent) {
		if (isComposite() && !keepAsArray())
			str.print(tempName_C());
		else
			p.print(this, str, indent);
	}
    
    public void FPartialFunctionCall.genArgument_C(CodePrinter p, CodeStream str, String indent) {
        str.print("(");
        str.print(myCorrespondingInput().type().type_C());
        str.print(")");
        if (myFCallable().isPartialFunction()) {
            str.print(tempName_C());
        } else {
            p.print(this, str, indent);
        }
    }
    
	public void FRelExp.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator) {
        p.printPreSteps(getLeft(), str, indent);
        p.printPreSteps(getRight(), str, indent);
		str.print(indent + "(*res)[" + enumerator.next() + "] = ");
		printIndicator_C(p, str, indent);
		str.print(";\n");
        p.printPostSteps(getLeft(), str, indent);
        p.printPostSteps(getRight(), str, indent);
	}
	
    private void FRelExp.printIndicator_C(CodePrinter p, CodeStream str, String indent) {
        if (hasIndicator()) {
            p.print(getIndicator(), str, indent);
        } else {
            p.print(getLeft(), str, indent);
            str.print(" - (");
            p.print(getRight(), str, indent);
            str.print(")");
        }
    }

	public void FRealVariable.genStartAttributeResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator) {
		p.printPreSteps(this, str, indent);
		if (!(this instanceof FDerivativeVariable)) {
			str.print(indent + "(*res)[" + enumerator.next() + "] = ");
			if (startAttributeSet()) {
				if (root().options.getBooleanOption("enable_variable_scaling")) {
					str.print("(");
					p.print(startAttributeExp(), str, "");
					str.print(")");
					str.print("/sf(");
					str.print(valueReference());
					str.print(")");
				} else {
					p.print(startAttributeExp(), str, "");
				}
			} else {
				str.print("0.0");
			}
			str.print(" - ");
			str.print(name_C());
			str.print(";\n");
		}
		p.printPostSteps(this, str, indent);
	}
	
    public void FRelExp.genRelExpKind(CodeStream genPrinter) {
    	genPrinter.print("-1");
    }
    
    public void FLtExp.genRelExpKind(CodeStream genPrinter) {
    	genPrinter.print("JMI_REL_LT");
    }

    public void FLeqExp.genRelExpKind(CodeStream genPrinter) {
    	genPrinter.print("JMI_REL_LEQ");
    }

    public void FGtExp.genRelExpKind(CodeStream genPrinter) {
    	genPrinter.print("JMI_REL_GT");
    }
    
    public void FGeqExp.genRelExpKind(CodeStream genPrinter) {
    	genPrinter.print("JMI_REL_GEQ");
    }
    	
    /**
     * Convert to a string represenation to use in C source files.
     * 
     * @return Representation of value for C files.   
     */
	public String CValue.cCodeValue() {
		return toString();
	}
    
	public String CValueBoolean.cCodeValue() {
		return value ? "JMI_TRUE" : "JMI_FALSE";
	}
	
	public String CValueEnum.cCodeValue() {
		return Integer.toString(intValue());
	}
	
	public void FVariable.genStartValue_C(String indent, CodeStream str) {
		printer_C.printPreSteps(this, str, indent);
		str.print(indent + name_C() + " = ");
		FExp exp = useBindingExpAsStart() ? getBindingExp() : startAttributeExp();
		boolean noExp = exp == null;
		if (noExp)
			setBindingExp(exp = type().zeroLiteral());
		OptionRegistry opt = root().options;
		str.print("(");
		exp.prettyPrint_C(str,"");
		str.print(")");
		if (isReal() && opt.getBooleanOption("enable_variable_scaling"))
			str.format("/sf(%d)", valueReference());
		if (noExp)
			setBindingExpOpt(new Opt());
		str.print(";\n");
        printer_C.printPostSteps(this, str, indent);
	}
	
	public void FStringVariable.genStartValue_C(String indent, CodeStream str) {
		// Skip string variables
	}
	
	public void FExternalObjectVariable.genStartValue_C(String indent, CodeStream str) {
		str.print(indent + "if (!jmi->indep_extobjs_initialized) { \n");
		printer_C.printVarDecls(this, str, printer_C.indent(indent));
		printer_C.printPreSteps(this, str, printer_C.indent(indent));
		super.genStartValue_C(printer_C.indent(indent), str);
		str.print(indent + "}\n");
		printer_C.printPostSteps(this, str, printer_C.indent(indent));
	}
	
	public void BLT.genOdeDerivativeBlocks(CodeStream str) {
		for (AbstractEquationBlock block : this) {
			block.genBlock_C(ASTNode.printer_C, str, ASTNode.printer_C.indent(""), false); 
		}
	}
	
	public java.util.List<AbstractEquationBlock> BLT.getAllBlocks() {
		return this;
	}
	
	public void BLT.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
		for (AbstractEquationBlock eb : getAllBlocks()) {
			if(eb.isSolvable())
				eb.genVarDecls_C(p, str, indent, null);
		}
	}

	public void StructuredBLT.genOdeDerivativeBlocks(CodeStream str) {
	    CodePrinter p = ASTNode.printer_C;
	    String indent = p.indent("");
		str.print("/************* ODE section *********/\n");
		// Loop over all derivatives
		for (AbstractEquationBlock eb : getOdeBlocks()) {
			eb.genBlock_C(p, str, indent, false);
		}
		str.print("/************ Real outputs *********/\n");
		for (AbstractEquationBlock eb : getRealOutputBlocks()) {
			eb.genBlock_C(p, str, indent, false);
		}
		str.print("/****Integer and boolean outputs ***/\n");
		for (AbstractEquationBlock eb : getIntegerBooleanOutputBlocks()) {
			eb.genBlock_C(p, str, indent, false);
		}
		str.print("/**** Other variables ***/\n");
		for (AbstractEquationBlock eb : getOtherBlocks()) {
			eb.genBlock_C(p, str, indent, false);
		}
        str.print("/********* Write back reinits *******/\n");
        for (AbstractEquationBlock eb : getAllBlocks()) {
            eb.genReinitWritebacks_C(p, indent, str);
        }
	}
}

aspect Serialize {
    public class DeclPrinter_ECE extends DeclPrinter_C {
        private CodeGenContext cgc;
        private Map<String,String> tempMap;
        public DeclPrinter_ECE(CodePrinter p, CodeStream str, Map<String,String> tempMap, CodeGenContext cgc) {
            super(p, str);
            this.tempMap = tempMap;
            this.cgc = cgc;
        }
        protected String acquireTemp(String key) {
            String s = cgc.nextTempName_C();
            tempMap.put(key, s);
            return s;
        }
        public void print(FExternalObjectType type) {
            printComposite(type);
        }
        protected void printComps(FType type) {
            if (type.isExternalObject()) {
                FExternalObjectType t = (FExternalObjectType) type;
                FExternalStmt stmt = t.myConstructorStmt();
                stmt.setCodeGenContext(cgc.createProxy());
                stmt.genVarDecls_C(p, str, indent());
                stmt.setCodeGenContext(null);
                printComps(t);
            } else {
                super.printComps(type);
            }
        }
    }
    
    public class InitPrinter_ECE extends InitPrinter_C {
        protected CodeGenContext cgc;
        private Map<String,String> tempMap;
        public InitPrinter_ECE(CodePrinter p, CodeStream str, Map<String,String> tempMap, CodeGenContext cgc) {
            super(p, str);
            this.tempMap = tempMap;
            this.cgc = cgc;
        }
        protected String acquireTemp(String key) {
            return tempMap.get(key);
        }
        public void print(FExternalObjectType type) {
            printComposite(type);
        }
        protected void printComps(FType type) {
            if (type.isExternalObject())
                printComps((FExternalObjectType) type);
            else
                super.printComps(type);
        }
        protected void printArray(FType type) {
            str.formatln("%sJMCEVAL_parseArrayDims(%d);", indent(), type.ndims());
            super.printArray(type);
            if (type.isExternalObject()) {
                
            } else {
                type.genSerialize_C(str, indent(), name(), true);
            }
        }
        protected void printNumElements(FType type) {
            str.print("d[0]");
            for (int i = 1; i < type.ndims(); i++)
                str.print("*d["+i+"]");
        }
        protected void printDimensions(FType type) {
            for (int i = 0; i < type.ndims(); i++)
                str.print(", d["+i+"]");
        }
        protected void printScalar(FType type) {
            if (!type.isExternalObject()) {
                type.genSerialize_C(str, indent(), name(), true);
            }
        }
        
        protected void printComps(FExternalObjectType type) {
            super.printComps(type);
            printComps_sub(type);
        }
        
        protected void printComps_sub(FExternalObjectType type) {
            int i = 0;
            FExternalStmt stmt = ((FExternalObjectType)type).myConstructorStmt();
            stmt.setCodeGenContext(cgc.createProxy());
            ArrayList<FExp> args = stmt.myConstructorArgs();
            CommonVariableDecl out = stmt.myConstructorOutput();
            String name = acquireTemp(name());
            stmt.getCodeGenContext().setAlias(out.name_C(), name());
            for (FExp arg : args)
                stmt.getCodeGenContext().setAlias(arg.prettyPrint_C(""), name + "_arg" + i++);
            stmt.prettyPrint_C(p, str, indent());
            stmt.setCodeGenContext(null);
        }
    }
    public class FreePrinter_ECE extends InitPrinter_ECE {
        public FreePrinter_ECE(CodePrinter p, CodeStream str, Map<String,String> tempMap, CodeGenContext cgc) {
            super(p, str, tempMap, cgc);
        }
        public void print(FType type) {
            type.genFreeStrings_C(str, indent(), name());
        }
        protected void printComps_sub(FExternalObjectType type) {
            FExternalStmt stmt = type.myDestructorStmt();
            ArrayList<FExp> args = stmt.myConstructorArgs();
            stmt.setCodeGenContext(cgc.createProxy());
            stmt.getCodeGenContext().setAlias(args.get(0).prettyPrint_C(""), name());
            stmt.prettyPrint_C(p, str, indent());
            stmt.setCodeGenContext(null);
        }
    }
    
    
    public void FExternalStmt.genSerializeMain_C(CodeStream str, String indent) {
        ArrayList<CommonVariableDecl> vars  = varsToSerialize();
        Map<String,String> tempMap = new HashMap<String,String>();
        indent = ASTNode.printer_C.indent(indent);
        codeGenContext = new CodeGenContext();
        str.println(indent + "/* Declarations */");
        TypePrinter_C dp = new DeclPrinter_ECE(ASTNode.printer_C, str, tempMap, codeGenContext);
        for (CommonVariableDecl cvd : vars) {
             dp.reset(cvd.name_C(), null, cvd.size().isUnknown(), false, indent);
             cvd.type().print(dp);
        }
        genVarDecls_C(ASTNode.printer_C, str, indent);
        str.println();
        
        str.println(indent + "JMCEVAL_setup();");
        genCheckPoint(str, indent, "START");
        
        str.println(indent + "/* Parse */");
        TypePrinter_C ip = new InitPrinter_ECE(ASTNode.printer_C, str, tempMap, codeGenContext);
        for (CommonVariableDecl cvd : vars) {
             ip.reset(cvd.name_C(), null, cvd.size().isUnknown(), false, indent);
             cvd.type().print(ip);
        }
        str.println();
        
        str.println(indent + "/* Call the function */");
        genCheckPoint(str, indent, "CALC");
        prettyPrint_C(ASTNode.printer_C, str, indent);
        genCheckPoint(str, indent, "DONE");
        str.println();
        
        str.println(indent + "/* Print */");
        for (CommonVariableDecl cvd : varsToDeserialize())
            cvd.type().genSerialize_C(str, indent, cvd.name_C(), false);
        str.println();
        
        str.println(indent + "/* Free strings */");
        TypePrinter_C fp = new FreePrinter_ECE(ASTNode.printer_C, str, tempMap, codeGenContext);
        for (CommonVariableDecl cvd : vars) {
             fp.reset(cvd.name_C(), null, cvd.size().isUnknown(), false, indent);
             cvd.type().print(fp);
        }
        str.println();
        
        genCheckPoint(str, indent, "END");
        codeGenContext = null;
    }
    
    public void FExternalStmt.genCheckPoint(CodeStream str, String indent, String token) {
        str.println(indent + "printf(\"" + token + "\\n\"); fflush(stdout);");
    }
    
    /**
     * Generate code that parses the variable <code>name</code> of type 
     * <code>this</code> from stdin.
     */
    public void FType.genSerialize_C(CodeStream str, String indent, String name, boolean parse) {
        str.formatln("%sJMCEVAL_%s%s(%s, %s);",
                indent,
                parse ? "parse" : "print",
                isArray() ? "Array" : "",
                isEnum() ? "Enum" : name(),
                name);
    }
    
    /**
     * Generate code to free strings
     */
    public void FType.genFreeStrings_C(CodeStream str, String indent, String name) {
        if (isString()) {
            str.formatln("%sJMCEVAL_free%s(%s);", indent, isArray() ? "Array" : "", name);
        }
    }
    
    /**
     * List of CommonVariableDecl which has to be sent to the process
     * when evaluating an external function.
     */
    syn ArrayList<CommonVariableDecl> FExternalStmt.varsToSerialize() {
        if (!hasArg() && !hasReturnVar())
            return myCommonVarDecls();
        
        ArrayList<CommonVariableDecl> res = new ArrayList<CommonVariableDecl>();
        if (hasReturnVar())
            res.add(getReturnVar().myCommonVarDecl());
        for (FExp e : getArgs()) {
            e.varsToSerialize(res);
        }
        return res;
    }
    
    public void FExp.varsToSerialize(ArrayList<CommonVariableDecl> decls) {
        
    }
    
    public void FIdUseExp.varsToSerialize(ArrayList<CommonVariableDecl> decls) {
        CommonVariableDecl cvd = myCommonVarDecl();
        if (!decls.contains(cvd))
            decls.add(cvd);
    }
    
    public void FSizeExp.varsToSerialize(ArrayList<CommonVariableDecl> decls) {
        getFExp().varsToSerialize(decls);
    }
    
    /**
     * List of CommonVariableDecl which has to be read from the process
     * when evaluating an external function.
     */
    syn ArrayList<CommonVariableDecl> FExternalStmt.varsToDeserialize() {
        ArrayList<CommonVariableDecl> res = new ArrayList<CommonVariableDecl>();
        for (CommonVariableDecl cvd : varsToSerialize())
            if (cvd.isOutput())
                res.add(cvd);
        return res;
    }
    
    /**
     * CommonVariableDecls from enclosing function
     */
    private ArrayList<CommonVariableDecl> FExternalStmt.myCommonVarDecls() {
        FFunctionDecl decl = containingFFunctionDecl();
        if (decl != null)
            return new ArrayList<CommonVariableDecl>(decl.getFFunctionVariables().toArrayList());
        else
            return new ArrayList<CommonVariableDecl>(enclosingInstClassDecl().getInstComponentDecls().toArrayList());
    }

    /**
     * Declarations of records used in this function
     */
    syn Collection<FRecordDecl> FExternalStmt.usedRecords() {
        Set<FRecordDecl> res = new LinkedHashSet<FRecordDecl>();
        for (CommonVariableDecl cvd : varsToSerialize())
            if (cvd.type().isRecord())
                res.add(cvd.type().myFRecordDecl());
        return res;
    }
    
    /*
     * Some code generation for the instance tree.
     */
    syn String FIdUseInstAccess.name_C() = toString_C(printer_C);
    
    syn String FIdUseInstAccess.toString_C(CodePrinter p) {
        return getInstAccess().toString_C(p);
    }

    syn String InstAccess.toString_C(CodePrinter p) =
        lookupInstComponent(name()).target().name_C();

    public String InstComponentDecl.name_C() {
        StringBuilder buf = new StringBuilder();
        buf.append(getFQName().nameUnderscore());
        buf.append('_');
        buf.append(type().isArray() ? C_SUFFIX_ARRAY : C_SUFFIX_VARIABLE);
        return buf.toString();
    }
}
