/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.io.PrintStream;
import java.io.ByteArrayOutputStream;
import java.util.Collection;

import org.jmodelica.util.NotNullPrintStream;

aspect BasePrinter {

	// superclass to all classes that perform the dispatch
    public class Printer {
		
		protected String step;
		
		public Printer(String step) {
			this.step = step;
		}
		
		public String indent(String old) {
			return old + step;
		}

		public void print(ASTNode node, PrintStream str, String indent) { 
  		}

		public void print(Collection<? extends ASTNode> nodes, PrintStream str, String indent) {
			for (ASTNode node : nodes)
				print(node, str, indent);
  		}
  		
  		public String op(FBinExp e) { return e.op(); }
  		
	}
	
}

aspect PrettyPrint {

	// select first variant
    public class PrettyPrinter extends Printer {
		public PrettyPrinter() {
			super(" ");
		}
		
 		public void print(ASTNode node, PrintStream str, String indent) { 
 			node.prettyPrint(this, str, indent); 
 		}
	}
	
	// select second variant
    public class DumpTreePrinter extends Printer {
		public DumpTreePrinter() {
			super(" ");
		}
		
		public void print(ASTNode node, PrintStream str, String indent) { 
 			node._dumpTree(this, str, indent); 
 		}
	}
	
	/**
	 * Wraps a prettyPrint() call to be deferred until the sting is needed.
	 */
	public class PrettyPrintDelegate {
		private ASTNode n;
		private String i;
		
		public PrettyPrintDelegate(ASTNode node) {
			this(node, "");
		}
		
		public PrettyPrintDelegate(ASTNode node, String indent) {
			n = node;
			i = indent;
		}
		
		public String toString() {
			return n.prettyPrint(i);
		}
	}
	
	static PrettyPrinter ASTNode.prettyPrinter = new PrettyPrinter();
	
	public void ASTNode._dumpTree(PrintStream str, String indent) {
 		_dumpTree(new DumpTreePrinter(),str,indent);
	}

	// dump node names
	public void ASTNode._dumpTree(Printer p, PrintStream str, String indent) {
 		str.print(indent + getClass().getSimpleName() + "\n");
 		for(int i = 0; i < getNumChild(); i++)
   			p.print(getChild(i),str,p.indent(indent)); // distpatch through Printer
	}

	public String ASTNode.prettyPrint(String indent) {
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		PrintStream str = new NotNullPrintStream(os);
		prettyPrint(str, indent);
		return os.toString();
	}
	
	// Override ASTNode.prettyPrint to get method on Python side (jpype bug)
	public String BaseNode.prettyPrint(String indent) {
		return super.prettyPrint(indent);
	}

	public void ASTNode.prettyPrint(PrintStream str,String indent) {
 		prettyPrint(prettyPrinter,str,indent);
	}
	
	
	public void ASTNode.prettyPrint(Printer p, PrintStream str, String indent) {
  		for (ASTNode n : this)
   			p.print(n, str, indent);
	}
	
	/**
	 * \brief Prints a list of any type of ASTNode, adding <code>sep</code> between nodes.
	 * 
	 * Typical use: <code>list.prettyPrintWithSep(p, str, indent, ", ");</code> 
	 * (Prints comma-separated list.)
	 */
	public void List.prettyPrintWithSep(Printer p, PrintStream str, String indent, String sep) {
		String prefix = "";
		for (ASTNode n : this) {
			str.print(prefix);
			p.print(n, str, indent);
			prefix = sep;
		}
	}
	
	public String List.toString() {
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		PrintStream str = new PrintStream(os);
		prettyPrintWithSep(prettyPrinter, str, "", ", ");
		return os.toString();
	}
	
	/**
	 * \brief Prints an ArrayList of any type of ASTNode, adding <code>sep</code> between nodes.
	 * 
	 * Typical use: <code>prettyPrintWithSep(list, p, str, indent, ", ");</code> 
	 * (Prints comma-separated list.)
	 */
	public static void ASTNode.prettyPrintWithSep(java.util.List<? extends ASTNode> l, Printer p, PrintStream str, String indent, String sep) {
		String prefix = "";
		for (ASTNode n : l) {
			str.print(prefix);
			p.print(n, str, indent);
			prefix = sep;
		}
	}
	
	/**
	 * \brief Prints a list of any type of ASTNode, adding <code>prefix</code> before each node and 
	 * <code>suffix</code> after each node.
	 */
	public void List.prettyPrintWithFix(Printer p, PrintStream str, String indent, String prefix, String suffix) {
		for (ASTNode n : this) {
			str.print(prefix);
			p.print(n, str, indent);
			str.print(suffix);
		}
	}
	
	/**
	 * \brief Prints an ArrayList of any type of ASTNode, adding <code>prefix</code> before each node and 
	 * <code>suffix</code> after each node.
	 */
	public static void ASTNode.prettyPrintWithFix(java.util.List<? extends ASTNode> l, Printer p, PrintStream str, String indent, String prefix, String suffix) {
		for (ASTNode n : l) {
			str.print(prefix);
			p.print(n, str, indent);
			str.print(suffix);
		}
	}
	
	/**
	 * \brief Prints a list of any type of ASTNode, adding <code>indent</code> before each node and 
	 * <code>suffix</code> plus a line break after after each node.
	 */
	public void List.prettyPrintWithIndent(Printer p, PrintStream str, String indent, String suffix) {
		prettyPrintWithFix(p, str, indent, indent, suffix + "\n");
	}
	
	/**
	 * \brief Prints an ArrayList of any type of ASTNode, adding <code>indent</code> before each node and 
	 * <code>suffix</code> plus a line break after after each node.
	 */
	public static void ASTNode.prettyPrintWithIndent(java.util.List<? extends ASTNode> l, Printer p, PrintStream str, String indent, String suffix) {
		prettyPrintWithFix(l, p, str, indent, indent, suffix + "\n");
	}
	
	/**
	 * \brief Prints a list of any type of ASTNode, adding <code>indent</code> before each node and 
	 * a line break after after each node.
	 */
	public void List.prettyPrintWithIndent(Printer p, PrintStream str, String indent) {
		prettyPrintWithFix(p, str, indent, indent, "\n");
	}
	
	/**
	 * \brief Prints an ArrayList of any type of ASTNode, adding <code>indent</code> before each node and 
	 * a line break after after each node.
	 */
	public static void ASTNode.prettyPrintWithIndent(java.util.List<? extends ASTNode> l, Printer p, PrintStream str, String indent) {
		prettyPrintWithFix(l, p, str, indent, indent, "\n");
	}
	
	public void Program.prettyPrint(Printer p, PrintStream str, String indent) {
		for (StoredDefinition sd : getUnstructuredEntitys()) {
			p.print(sd,str,indent);
		}
	}
 	
 	public void StoredDefinition.prettyPrint(Printer p, PrintStream str, String indent) {
 		if (hasWithin()) {
 			str.print(indent + "within");
 			if (getWithin().hasPackageName()) {
 				str.print(" ");
 				p.print(getWithin().getPackageName(),str,indent);
 			}
 			str.print(";\n");
 		}
 		for (Element el : getElements()) {
	 		p.print(el,str,indent);
 			str.print(";\n");		
		}
	}
	
	// specialize behavior for A
	
	
    public void ShortClassDecl.prettyPrint(Printer p, PrintStream str, String indent) {
	    if (hasEncapsulated())
	    	str.print("encapsulated ");
	    if (hasPartial())
	    	str.print("partial ");
	    if (hasRedeclare())
	    	str.print("redeclare ");
	    if (hasFinal())
	    	str.print("final ");
	    if (hasInner())
	    	str.print("inner ");
	    if (hasOuter())
	    	str.print("outer ");
	    if (hasReplaceable())
	    	str.print("replaceable ");
	    
	    
	    str.print(indent + getRestriction().toString());
 		str.print(" " + getName().getID());
	    str.print(" = ");
	    str.print(getExtendsClauseShortClass().getSuper().name());
	    if (getExtendsClauseShortClass().hasArraySubscripts())
	    	p.print(getExtendsClauseShortClass().getArraySubscripts(),str,indent+"  ");
	    if (getExtendsClauseShortClass().hasClassModification())
	    	p.print(getExtendsClauseShortClass().getClassModification(),str,indent+"  ");
	    if (hasConstrainingClause())
	    	p.print(getConstrainingClause(),str,indent+"  ");
	    
	}
	
	public void FullClassDecl.prettyPrint(Printer p, PrintStream str, String indent) {
	    if (hasEncapsulated())
	    	str.print("encapsulated ");
	    if (hasPartial())
	    	str.print("partial "); 		
 	    if (hasRedeclare())
	    	str.print("redeclare ");
	    if (hasFinal())
	    	str.print("final ");
	    if (hasInner())
	    	str.print("inner ");
	    if (hasOuter())
	    	str.print("outer ");
	    if (hasReplaceable())
	    	str.print("replaceable ");
	    
 		
 		str.print(indent + getRestriction().toString());
 		str.print(" " + getName().getID() + "\n");

		
 		// Print all local classes
 		int numPubClass = 0;
// 		str.print(indent + "public\n");
 		for (int i=0;i<getNumClassDecl();i++)
 			if (((BaseClassDecl)getClassDecl(i)).isPublic()) {
 			 	numPubClass++;
	 			p.print(getClassDecl(i),str,indent+"  ");
	 			str.print(";\n\n");
			}
			
		if (getNumClassDecl()-numPubClass>0) {	
	 		str.print(indent + "protected\n");
 			for (int i=0;i<getNumClassDecl();i++)
 				if (((BaseClassDecl)getClassDecl(i)).isProtected()) {
		 			p.print(getClassDecl(i),str,indent+"  ");
		 			str.print(";\n\n");
		 		}
		}
			
		// Print all extends clauses
 		for (int i=0;i<getNumSuper();i++) {
 			p.print(getSuper(i),str,indent+"  ");
 			str.print(";\n");
		} 			
			
 		// Print all components
 		int numPubComp = 0;
// 		str.print(indent + "public\n");
 		for (int i=0;i<getNumComponentDecl();i++)
 			if (getComponentDecl(i).isPublic()) {
 			 	numPubComp++;
	 			p.print(getComponentDecl(i),str,indent+"  ");
	 			str.print(";\n");
			}
			
		if (getNumComponentDecl()-numPubComp>0) {	
	 		str.print(indent + "protected\n");
 			for (int i=0;i<getNumComponentDecl();i++)
 				if (getComponentDecl(i).isProtected()) {
		 			p.print(getComponentDecl(i),str,indent+"  ");
		 			str.print(";\n");
			}
		}	
		
		if (getNumEquation()>0) {
			str.print(indent + "equation\n");
			for (int i=0;i<getNumEquation();i++) {
				str.print(p.indent(indent));
				p.print(getEquation(i),str,indent);
				str.print(";\n");
			}
		}
		
		for (Algorithm a : getAlgorithms()) {
			p.print(a, str, indent);
		}
		
		str.print(indent + "end " + getName().getID());
	} 
	
	public void Algorithm.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		if (hasInitial())
			str.print("initial ");
		str.println("algorithm");
		
		for (Statement s : getStatements()) {
			p.print(s, str, indent + "  ");
		}
	}
	
	public void AssignStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		p.print(getLeft(), str, indent);
		str.print(":=");
		p.print(getRight(), str, indent);
		str.println(';');
	}
	
	public void FunctionCallStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		str.print('(');
		boolean first = true;
		for (FunctionCallLeft fcl : getLefts()) {
			if (!first)
				str.print(',');
			first = false;
			p.print(fcl, str, indent);
		}
		str.print("):=");
		p.print(getFunctionCall(), str, indent);
		str.println(';');
	}
	
	public void BreakStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		str.println("break;");
	}
	
	public void ReturnStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		str.println("return;");
	}
	
	public void IfStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		str.print("if ");
		boolean first = true;
		for (IfWhenClause iwc : getIfWhenClauses()) {
			if (!first) {
				str.print(indent);
				str.print("elseif ");
			}
			first = false;
			p.print(iwc, str, indent);
		}
		if (hasElseClause())
			p.print(getElseClause(), str, indent);
		str.print(indent);
		str.println("end if;");
	}
	
	public void ElseClause.prettyPrint(Printer p, PrintStream str, String indent) {
		if (getNumStmt() > 0) {
			str.print(indent);
			str.println("else");
			for (Statement stmt : getStmts()) {
				p.print(stmt, str, indent + "  ");
			}
		}
	}
	
	
	public void WhenStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		str.print("when ");
		boolean first = true;
		for (IfWhenClause iwc : getIfWhenClauses()) {
			if (!first) {
				str.print(indent);
				str.print("elsewhen ");
			}
			first = false;
			p.print(iwc, str, indent + "  ");
		}
		str.print(indent);
		str.println("end when;");
	}
	
	public void IfWhenClause.prettyPrint(Printer p, PrintStream str, String indent) {
		p.print(getTest(), str, indent);
		str.println(" then");
		for (Statement s : getStatements()) {
			p.print(s, str, indent + "  ");
		}
	}
	
	public void ForStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		str.print("for ");
		boolean first = true;
		for (ForIndex fi : getForIndexs()) {
			if (!first)
				str.print(',');
			first = false;
			p.print(fi, str, indent);
		}
		str.println(" loop");
		p.print(getForStmtList(), str, indent + "  ");
		str.print(indent);
		str.println("end for;");
	}
	public void ForStmtList.prettyPrint(Printer p, PrintStream str, String indent) {
		for (Statement stmt : getStmts())
			p.print(stmt, str, indent);
	}
	
	public void WhileStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		str.print("while ");
		p.print(getTest(), str, indent);
		str.println(" loop");
		for (Statement s : getWhileStmts())
			p.print(s, str, indent + "  ");
		str.print(indent);
		str.println("end while;");
	}
	
	public void ForIndex.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(getForIndexDecl().name());
		if (hasExp()) {
			str.print(" in ");
			p.print(getExp(), str, indent);
		}
	}
	
	// For debugging
	public void LibNode.prettyPrint(Printer p, PrintStream str, String indent) {
		str.format("%s%structured library '%s' at '%s'\n", indent, 
				(getStructured() ? "S" : "Uns"), getName(), getFileName());
	}

	public void ComponentDecl.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);//+getVisibilityType().toString()+" ";
		
		if (hasRedeclare())
			str.print(getRedeclare().toString() + " ");
		if (hasFinal())
			str.print(getFinal().toString() + " ");
		if (hasInner())
			str.print(getInner().toString() + " ");
		if (hasOuter())
			str.print(getOuter().toString() + " ");
		if (hasReplaceable())
			str.print(getReplaceable().toString() + " ");	
		if (hasTypePrefixFlow())
			str.print(getTypePrefixFlow().toString() + " ");
		if (hasTypePrefixVariability())
			str.print(getTypePrefixVariability().toString() + " ");
		if (hasTypePrefixInputOutput())
			str.print(getTypePrefixInputOutput().toString() + " ");
		
		p.print(getClassName(),str,indent);
		if (hasTypeArraySubscripts())
			p.print(getTypeArraySubscripts(),str,indent);
		str.print(" " + getName().getID()); 
	    if (hasVarArraySubscripts())
			p.print(getVarArraySubscripts(),str,indent);
		 p.print(getModificationOpt(),str,indent);
				 
		if (hasConstrainingClause()) {
		  p.print(getConstrainingClause(),str,indent);
		
		}		 

				    
	}

	public void ConstrainingClause.prettyPrint(Printer p, PrintStream str, String indent) {
       str.print(" constrainedby " + getAccess().name());
       if (hasClassModification()) {
    	   str.print(' ');
	       p.print(getClassModification(),str,indent);
       }

	}

	public void ArraySubscripts.prettyPrint(Printer p, PrintStream str, String indent) {
		if (getNumSubscript()>0) {
			str.print("[");
			for (int i=0;i<getNumSubscript();i++) {
				p.print(getSubscript(i),str,indent);
				if (i<getNumSubscript()-1)
					str.print(",");
			}
			str.print("]");
		}
	}

	public void ColonSubscript.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(":");
	}
	
	public void ExpSubscript.prettyPrint(Printer p, PrintStream str, String indent) {
		p.print(getExp(),str,indent);
	}

	public void RangeExp.prettyPrint(Printer p, PrintStream str, String indent) { 
		for (int i=0;i<getNumExp();i++) {
			p.print(getExp(i),str,indent);
			if (i<getNumExp()-1)
				str.print(":");
		}
	}

	public void ExtendsClause.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent + "extends ");
		p.print(getSuper(),str,indent);
		p.print(getClassModificationOpt(),str,indent);
	}

	public void CompleteModification.prettyPrint(Printer p, PrintStream str, String indent) {
		p.print(getClassModification(),str,indent);
		if (hasValueModification())
		  p.print(getValueModification(),str,indent);
	}
	
	public void ValueModification.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(" = ");
		p.print(getExp(),str,indent);
	}
	
	public void ClassModification.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("(");
		for (int i = 0; i < getNumArgument(); i++) {
			p.print(getArgument(i), str, indent);
			if (i < getNumArgument() - 1)
				str.print(", ");
		}
		str.print(")");
	}
	
	public void ElementModification.prettyPrint(Printer p, PrintStream str, String indent) {
		if (hasEach())
			str.print(getEach() + " ");
		if (hasFinal())
		 	str.print(getFinal() + " ");
		p.print(getName(),str, indent);
		if (hasModification())
			p.print(getModification(),str,indent);
	}


	public void ComponentRedeclare.prettyPrint(Printer p, PrintStream str, String indent) {
		if (hasEach())
			str.print(getEach().toString() + " ");
		if (hasFinal())
		 	str.print(getFinal().toString() + " ");
		p.print(getComponentDecl(),str,indent);
		

	}

	public void ClassRedeclare.prettyPrint(Printer p, PrintStream str, String indent) {
		if (hasEach())
			str.print(getEach().toString() + " ");
		if (hasFinal())
		 	str.print(getFinal().toString() + " ");
		p.print(getBaseClassDecl(),str,indent);
		

	}	

	public void Opt.prettyPrint(Printer p, PrintStream str, String indent) {
		if (getNumChild()>0)
			p.print(getChild(0),str,indent);
	}

	public void Equation.prettyPrint(Printer p,PrintStream str, String indent) {
		p.print(getLeft(),str,indent);
		str.print(" = ");
		p.print(getRight(),str,indent);
	}

	public void ConnectClause.prettyPrint(Printer p,PrintStream str, String indent) {
		str.print("connect(");
		p.print(getConnector1(),str,indent);
		str.print(",");
		p.print(getConnector2(),str,indent);
		str.print(")");
	}
	
	public void DotAddExp.prettyPrint(Printer p,PrintStream str, String indent) {
		p.print(getLeft(),str,indent);
		if(!(getRight() instanceof NegExp)) 
			str.print(op());
		p.print(getRight(),str,indent);
	}
		
	public void DotSubExp.prettyPrint(Printer p, PrintStream str, String indent) {
		p.print(getLeft(),str,indent);
		str.print(op());
		if (getRight().isAddOrSub()) {
			str.print("(");
			p.print(getRight(),str,indent);
			str.print(")");
		} else
			p.print(getRight(),str,indent);
	}
		
	public void DotMulExp.prettyPrint(Printer p,PrintStream str, String indent) {
		if (getLeft().isAddOrSub()) {
			str.print("(");
			p.print(getLeft(),str,indent);
			str.print(")");
		} else
			p.print(getLeft(),str,indent);	
		str.print(op());
		if (getRight().isAddOrSub()) {
			str.print("(");
			p.print(getRight(),str,indent);
			str.print(")");
		} else
			p.print(getRight(),str,indent);
	}
		
	public void DotDivExp.prettyPrint(Printer p, PrintStream str, String indent){
		if (getLeft().isAddOrSub()) {
			str.print("(");
			p.print(getLeft(),str,indent);
			str.print(")");
		} else
			p.print(getLeft(),str,indent);
		str.print(op());	
		str.print("(");
		p.print(getRight(),str,indent);
		str.print(")");
	}
		
	public void DotPowExp.prettyPrint(Printer p, PrintStream str, String indent){
		if (!(getLeft().isPrimary())) {
			str.print("(");
			p.print(getLeft(),str,indent);
			str.print(")");
		} else
			p.print(getLeft(),str,indent);
		str.print(op());
		if (!(getRight().isPrimary())) {
			str.print("(");
			p.print(getRight(),str,indent);
			str.print(")");
		} else
			p.print(getRight(),str,indent);
	}
		
	public void NegExp.prettyPrint(Printer p,PrintStream str, String indent){
		str.print("-");
		if (getExp().isAddOrSub()) {
			str.print("(");
			p.print(getExp(),str,indent);
			str.print(")");
		} else
			p.print(getExp(),str,indent);
	}
	
	public void IfExp.prettyPrint(Printer p, PrintStream str, String indent) {
        prettyPrintAsElseExp(p, str, indent);
    }
    
    public void Exp.prettyPrintAsElseExp(Printer p, PrintStream str, String indent) {
        str.print(' ');
        p.print(this, str, indent);
    }
    
    public void IfExp.prettyPrintAsElseExp(Printer p, PrintStream str, String indent) {
        str.print("if ");
        p.print(getIfExp(), str, indent);
        str.print(" then ");
        p.print(getThenExp(), str, indent);
        str.print(" else");
        getElseExp().prettyPrintAsElseExp(p, str, indent);
    }
	
	public void RealLitExp.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(getUNSIGNED_NUMBER());
	}

	public void IntegerLitExp.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(getUNSIGNED_INTEGER());
	}
	
	public void TimeExp.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("time");
	}

	public void EndExp.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("end");
	}
	
	public void FunctionCall.prettyPrint(Printer p, PrintStream str, String indent) {
		p.print(getName(),str,indent);
		str.print("("); 
		p.print(getFunctionArgumentsOpt(),str,indent);
		str.print(")");
	}

	public void FunctionArguments.prettyPrint(Printer p, PrintStream str, String indent) {
		for (int i=0; i<getNumExp(); i++) {
			p.print(getExp(i),str,indent);
			if (i<getNumExp()-1)
				str.print(",");
		}
	}

	public void NamedAccess.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(getID());
	}
		
	public void Dot.prettyPrint(Printer p, PrintStream str, String indent) {
		getAccesss().prettyPrintWithSep(p, str, indent, ".");
	}
	
	public void PN_Dot.prettyPrint(Printer p, PrintStream str, String indent) {
		p.print(getLeft(),str,indent);
		str.print(".");
		p.print(getRight(),str,indent);	
	}
		
	public void GlobalAccess.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(".");
		p.print(getAccess(),str,indent);	
	}
	
	public void ComponentAccess.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(getID());
		if (hasArraySubscripts())
			p.print(getArraySubscripts(),str,indent);
	}
	
	public void StringLitExp.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("\"" + getSTRING() + "\"");
	}

	public void BooleanLitExpTrue.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("true");
	}

	public void BooleanLitExpFalse.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("false");
	}
	
	public void ArrayConstructor.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("{");
		p.print(getFunctionArguments(),str,indent);
		str.print("}");
	}
	
	public void Matrix.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("[");
		getRows().prettyPrintWithSep(p, str, indent, "; ");
		str.print("]");
	}
	
	public void MatrixRow.prettyPrint(Printer p, PrintStream str, String indent) {
		getExps().prettyPrintWithSep(p, str, indent, ", ");
	}
	
	syn boolean Exp.isAddOrSub() = false;
	eq DotAddExp.isAddOrSub() = true;
	eq DotSubExp.isAddOrSub() = true;
	syn boolean Exp.isPrimary() = false;
	eq AccessExp.isPrimary() = true;
	eq RealLitExp.isPrimary() = true;

	public void LogBinExp.prettyPrint(Printer p,PrintStream str, String indent) {
		//str.print("((");
		p.print(getLeft(),str,indent);
		//str.print(")"+op()+"(");
		str.print(op());
		p.print(getRight(),str,indent);
		//str.print("))");
	}
	
	syn String BinExp.op();
	eq LtExp.op()     = "<";
	eq LeqExp.op()    = "<=";
	eq GtExp .op()    = ">";
	eq GeqExp.op()    = ">=";
	eq EqExp.op()     = "==";
	eq NeqExp.op()    = "<>";
	eq OrExp.op()     = " or ";
	eq AndExp.op()    = " and ";
	eq AddExp.op()    = "+";
	eq SubExp.op()    = "-";
	eq MulExp.op()    = "*";
	eq DivExp.op()    = "/";
	eq PowExp.op()    = "^";
	eq DotAddExp.op() = ".+";
	eq DotSubExp.op() = ".-";
	eq DotMulExp.op() = ".*";
	eq DotDivExp.op() = "./";
	eq DotPowExp.op() = ".^";
	
	public void NotExp.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("not ");
		p.print(getExp(),str,indent);
	}


	syn String Redeclare.toString() = "redeclare";
    syn String Each.toString() = "each";
    syn String Final.toString() = "final";
	syn String Inner.toString() = "inner";
	syn String Outer.toString() = "outer";
	syn String Replaceable.toString() = "replaceable";
	syn String TypePrefixFlow.toString();
	eq Flow.toString()   = "flow";
	eq Stream.toString() = "stream";
	syn String TypePrefixInputOutput.toString();
	eq Input.toString()  = "input";
	eq Output.toString() = "output";
	syn String TypePrefixVariability.toString();
	eq Parameter.toString()  = "parameter";
	eq Discrete.toString()   = "discrete";
	eq Constant.toString()   = "constant";
	eq Continuous.toString() = "";
	
	syn String FType.toString() = isArray() ? name() + size() : name();
	
	syn String FRecordComponentType.toString() = getFType() + " " + getName();

}

aspect FlatPrettyPrint {
	
	public void FClass.prettyPrint(Printer p, PrintStream str, String indent) {
		String nextInd = p.indent(indent);
		str.print(indent + "fclass " + name() + "\n");
		for (FVariable fv : getFVariables()) {
	  		if (!fv.isDerivativeVariable() && !fv.isPreVariable()) {
	  			p.print(fv, str, nextInd);
	  			str.print(";\n");  
	  		}
		}

		if (getNumFInitialEquation()>0)
			str.print(indent + "initial equation \n");
		getFInitialEquations().prettyPrintWithFix(p, str, nextInd, "", ";\n");

		if (getNumFParameterEquation()>0)
			str.print(indent + "parameter equation\n");
		getFParameterEquations().prettyPrintWithFix(p, str, nextInd, "", ";\n");
	
	    boolean wroteEquation = false;
    	for (FAbstractEquation e : getFAbstractEquations()) {
    		if (e instanceof FAlgorithm) {
    			p.print(e, str, indent);
    			wroteEquation = false;
    		} else {
    			if (!e.isIgnored()) {
	    			if (!wroteEquation) {
	    				str.print(indent);
	    				str.print("equation\n");
	    				wroteEquation = true;
	    			}
	    			p.print(e, str, nextInd);
		    		str.print(";\n");
    			}
    		}
    	}
	    
  		if (getNumFFunctionDecl() > 0 || getNumFRecordDecl() > 0 || 
  				getNumFEnumDecl() > 0 || getNumFDerivedType() > 0) {
	  		str.print("\n" + indent + "public\n");
	    	p.print(getFFunctionDecls(), str, nextInd);
	    	p.print(getFRecordDecls(), str, nextInd);
	    	p.print(getFEnumDecls(), str, nextInd);
	    	p.print(getFDerivedTypes(), str, nextInd);
  		}
    	
  		str.print(indent);
  		str.print("end ");
  		str.print(name());
  		str.print(";\n");
	}

	syn String FVariable.prettyPrintType() = 
		getDerivedType().isEmpty() ? type().scalarType().toString() : getDerivedType();
	syn String FVariable.displayName()        = getFQName().toString();
	eq FDerivativeVariable.displayName()      = name();
	eq FPreBooleanVariable.displayName()      = name();
	eq FPreEnumVariable.displayName()         = name();
	eq FPreIntegerVariable.displayName()      = name();
	eq FPreRealVariable.displayName()         = name();
	eq FPreStringVariable.displayName()       = name();
	eq FDummyDerivativeVariable.displayName() = derPrefixName();

	public void FVariable.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		
		str.print(getFTypePrefixVariability());
		
		if (hasFTypePrefixInputOutput()) {
			str.print(getFTypePrefixInputOutput());
			str.print(" ");
		}
		
		str.print(prettyPrintType());
		str.print(" ");
		str.print(displayName());
	
		getFAttributeList().prettyPrintFAttributeList(str,p);
		
		if (hasBindingExp()) {
			str.print(" = ");
			FExp bindingExp = getBindingExp();
			p.print(bindingExp,str,indent);
			
		}
		
		p.print(getFStringCommentOpt(),str,indent);
		
		CValue hgt = HGTVarCValue();
		if (hgt != null)
			str.format(" annotation(__Modelon(IterationVariable(enabled=%s)))", hgt);

		if (isIndependentParameter() && hasBindingExp()) {
			str.print(" /* ");
			try {
				str.print(getBindingExp().ceval());
			} catch (ConstantEvaluationException e){
				str.print("evalutation error");
			}
			str.print(" */");
		}
	}
	
	public void FVariable.printFAttributes(PrintStream str, String ... attributes) {
		boolean first = true;
		for (String attribute : attributes) {
			if (attributeSet(attribute)) {
				if (!first)
					str.print(',');
				first = false;
				str.print(attribute);
				str.print('=');
				str.print(attributeExp(attribute));
			}
		}
	}
	
	syn boolean FAttribute.shouldPrettyPrint() = !name().equals(HGT);

	public void List.prettyPrintFAttributeList(PrintStream str, Printer p) {
	    boolean firstAttr = true;
	    for (ASTNode astNode : this) {
	        FAttribute attr = (FAttribute)astNode;
	        if (attr.getAttributeSet() && attr.shouldPrettyPrint()) {
	            if (!firstAttr)	
	                str.print(",");
	            else
	                str.print("(");
	            firstAttr = false;
	            p.print(attr, str, "");
	        }
	    }
	    if (!firstAttr)
	        str.print(")");
	}
	
    public void FAttribute.prettyPrint(Printer p, PrintStream str, String indent) {
			
						if (hasFEach())
							str.print("each ");
						if (hasFFinal())
							str.print("final ");	
		    			str.print(getName().name());
		    			getFAttributeList().prettyPrintFAttributeList(str, p);
		    			if (hasValue()) {
		    				str.print(" = ");
	    					p.print(getValue(),str,"");
						}
	}

    public void FFunctionDecl.prettyPrint(Printer p, PrintStream str, String indent) {
    	str.print(indent + "function " + name() + "\n");
    	getFFunctionVariables().prettyPrintWithIndent(p, str, p.indent(indent), ";");
    	p.print(getFAlgorithm(), str, indent);
    	str.print(indent + "end " + name() + ";\n\n");
    }

    public void FRecordDecl.prettyPrint(Printer p, PrintStream str, String indent) {
    	str.print(indent + "record " + name() + "\n");
    	getFVariables().prettyPrintWithFix(p, str, p.indent(indent), "", ";\n");
    	str.print(indent + "end " + name() + ";\n\n");
    }

    public void FEnumDecl.prettyPrint(Printer p, PrintStream str, String indent) {
    	str.print(indent + "type " + getName().name() + " = enumeration(");
    	p.print(getFEnumSpecification(),str,indent);
    	str.print(")");
    	FDerivedType t = myFDerivedType();
    	if (t != null && t.getFAttributes().getNumChild() > 0) {
        	str.print("(");
        	t.getFAttributes().prettyPrintWithSep(p, str, indent, ", ");
        	str.print(")");
    	}
    	str.print(";\n\n");
    }
    
    public void FEquationType.prettyPrint(Printer p, PrintStream str, String indent) {}
    public void FInitialEquation.prettyPrint(Printer p, PrintStream str, String indent) {
    	str.print(indent + "initial ");
    }
    
    public void FDerivedType.prettyPrint(Printer p, PrintStream str, String indent) {
    	if (!getBaseType().isEnum()) {
	    	str.print(indent + "type " + getName() + " = ");
	    	str.print(getBaseType());
	    	getFAttributeList().prettyPrintFAttributeList(str, p);
	    	str.print(";\n");
    	}
    }
    
    public abstract void FEnumSpecification.prettyPrint(Printer p, PrintStream str, String indent);
    
    public void FEnumUnspecified.prettyPrint(Printer p, PrintStream str, String indent) {
    	str.print(":");
    }

    public void FEnumLiteralList.prettyPrint(Printer p, PrintStream str, String indent) {
    	getFEnumLiterals().prettyPrintWithSep(p, str, indent, ", ");
    }

    public void FEnumLiteral.prettyPrint(Printer p, PrintStream str, String indent) {
		p.print(getName(), str, indent);
		p.print(getFStringCommentOpt(), str, indent);
    }

    public void FStringComment.prettyPrint(Printer p, PrintStream str, String indent) {
	   	str.print(" \"");
	   	str.print(getComment());
	   	str.print("\"");
    }

    public void FFunctionVariable.prettyPrint(Printer p, PrintStream str, String indent) {
    	if (hasFTypePrefixInputOutput()) {
    		str.print(getFTypePrefixInputOutput());
    		str.print(" ");
    	}
    	if (hasInitArrayStmt) {
    		str.print(getType().scalarType());
    		str.print("[");
    		for (int i = 0; i < ndims(); i++) {
    			str.print(":");
    			if (i < ndims()-1)
    				str.print(",");
    		}
    		str.print("]");
    	} else {
    		str.print(getType());
    	}
    	str.print(" ");
    	str.print(name());
    	if (hasBindingExp()) {
    		str.print(" := ");
    		p.print(getBindingExp(), str, indent);
    	}
    }
    
    public void FQNamePart.prettyPrint(Printer p, PrintStream str, String indent) {
    	str.print(getName());
		if (hasFArraySubscripts())
			p.print(getFArraySubscripts(),str,indent);				    	
    }
    
    public void FQName.prettyPrint(Printer p, PrintStream str, String indent) {
    }
    
    public void FQNameString.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(getName());
    }
    
    public void FQNameFull.prettyPrint(Printer p, PrintStream str, String indent) {
		for (int i = 0, n = getNumFQNamePart(); i < n; i++) {
			p.print(getFQNamePart(i), str, indent);
			if (i < n - 1)
				str.print(".");
		}    	
    }
    
    public void FArraySubscripts.prettyPrint(Printer p, PrintStream str, String indent) {
		if (getNumFSubscript()>0) {
			str.print("[");
			for (int i=0;i<getNumFSubscript();i++) {
				p.print(getFSubscript(i),str,indent);
				if (i<getNumFSubscript()-1)
					str.print(",");
			}
			str.print("]");
		}
	}

	public void FColonSubscript.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(":");
	}

	public void FIntegerSubscript.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(getValue());
	}
	
	public void FExpSubscript.prettyPrint(Printer p, PrintStream str, String indent) {
		p.print(getFExp(),str,indent);
	}

	protected void FRangeExp.prettyPrintExp(Printer p, PrintStream str, String indent) { 
		for (int i=0;i<getNumFExp();i++) {
			p.print(getFExp(i),str,indent);
			if (i<getNumFExp()-1)
				str.print(":");
		}
	}


	public void FEquation.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
    	p.print(getLeft(),str,indent);
   		str.print(" = ");
   		p.print(getRight(),str,indent);
	}


	public void FIfWhenElseEquation.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		if (isElse())
   			str.print("else");
   		prettyPrintHead(p, str, indent);
   		getFAbstractEquations().prettyPrintWithFix(p, str, p.indent(indent), "", ";\n");
   		prettyPrintTail(p, str, indent);
	}

	protected void FIfWhenElseEquation.prettyPrintHead(Printer p, PrintStream str, String indent) {
   		str.print("\n");
	}

	protected void FIfWhenElseEquation.prettyPrintTail(Printer p, PrintStream str, String indent) {
	}

	protected void FIfWhenEquation.prettyPrintHead(Printer p, PrintStream str, String indent) {
   		str.print(ifWhenType());
   		str.print(" ");
    	p.print(getTest(), str, indent);
   		str.print(" then\n");
	}

	protected void FIfWhenEquation.prettyPrintTail(Printer p, PrintStream str, String indent) {
   		if (hasElse()) 
   			p.print(getElse(), str, indent);
   		if (!isElse()) {
   			str.print(indent);
   			str.print("end ");
    		str.print(ifWhenType());
   		}
	}
	
	syn String FIfWhenEquation.ifWhenType();
	eq FIfEquation.ifWhenType()   = "if";
	eq FWhenEquation.ifWhenType() = "when";
	

	public void FConnectClause.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		str.print("connect(");
    	p.print(getConnector1(),str,indent);
   		str.print(", ");
   		p.print(getConnector2(),str,indent);
   		str.print(")");
	}

	public void FFunctionCallEquation.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		if (getNumLeft() > 0) {
	   		str.print("(");
	   		getLefts().prettyPrintWithSep(p, str, indent, ", ");
	   		str.print(") = ");
		}
   		p.print(getCall(), str, indent);
	}
	
	public void FAlgorithm.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent);
		p.print(getType(),str,"");
		str.print("algorithm\n");
		getFStatements().prettyPrintWithIndent(p, str, p.indent(indent), ";");
	}
	
	public void FAssignStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		p.print(getLeft(), str, indent);
		str.print(" := ");
		p.print(getRight(), str, indent);
	}
	
	public void InstAssignStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		p.print(getLeft(), str, indent);
		str.print(" := ");
		p.print(getRight(), str, indent);
	}
	
	public void FFunctionCallStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		if (getNumLeft() > 0) {
			str.print("(");
			getLefts().prettyPrintWithSep(p, str, indent, ", ");
			str.print(") := ");
		}
		p.print(getCall(), str, indent);
	}
	
	public void FBreakStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("break");
	}
	
	public void FReturnStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("return");
	}
	
	public void FIfWhenStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		getFIfWhenClauses().prettyPrintWithSep(p, str, indent, indent + "else");
		prettyPrintElse(p, str, indent);
		str.print(indent);
		str.print("end ");
		str.print(getKeyword());
	}
	
	protected void FIfWhenStmt.prettyPrintElse(Printer p, PrintStream str, String indent) {}
	
	protected void FIfStmt.prettyPrintElse(Printer p, PrintStream str, String indent) {
		if (getNumElseStmt() > 0) {
			str.print(indent);
			str.print("else\n");
			getElseStmts().prettyPrintWithIndent(p, str, p.indent(indent), ";");
		}
	}
	
	public void FIfWhenClause.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(getKeyword());
		str.print(" ");
		p.print(getTest(), str, indent);
		str.print(" then\n");
		getFStatements().prettyPrintWithIndent(p, str, p.indent(indent), ";");
	}
	
	syn String FIfWhenStmt.getKeyword() = null;
	eq FIfStmt.getKeyword() = "if";
	eq FWhenStmt.getKeyword() = "when";
	inh String FIfWhenClause.getKeyword();
	eq FIfWhenStmt.getFIfWhenClause(int i).getKeyword() = getKeyword();
	
	public void FForStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("for ");
		p.print(getIndex(), str, indent);
		str.print(" loop\n");
		getForStmts().prettyPrintWithIndent(p, str, p.indent(indent), ";");
		str.print(indent);
		str.print("end for");
	}
	
	public void InstForStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("for ");
		getInstForIndexList().prettyPrintWithSep(p, str, indent, ", ");
		str.print(" loop\n");
		getForStmts().prettyPrintWithIndent(p, str, p.indent(indent), ";");
		str.print(indent);
		str.print("end for");
	}
	
	public void FWhileStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("while ");
		p.print(getTest(), str, indent);
		str.print(" loop\n");
		getWhileStmts().prettyPrintWithIndent(p, str, p.indent(indent), ";");
		str.print(indent);
		str.print("end while");
	}
	
	public void FExternalStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("external ");
		p.print(getFExternalLanguage(), str, indent);
		str.print(" ");
		if (hasReturnVar()) {
			p.print(getReturnVar(), str, indent);
			str.print(" = ");
		}
		str.print(getName());
		str.print("(");
		getArgs().prettyPrintWithSep(p, str, indent, ", ");
		str.print(")");
	}
	
	public void FInitArrayStmt.prettyPrint(Printer p, PrintStream str, String indent) {
		FFunctionVariable fv = (FFunctionVariable) getFIdUseExp().myFV();
		str.print("size(" + fv.name() + ") := {");
		str.print(fv.size().toUnclosedString() + "}");
	}
	
	public void FExternalLanguage.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("\"");
		str.print(getLanguage());
		str.print("\"");
	}
	
	public void InstExternal.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print("external ");
		p.print(getFExternalLanguage(), str, indent);
		str.print(" ");
		p.print(getInstExternalCall(), str, indent);
	}
	
	public void InstExternalCall.prettyPrint(Printer p, PrintStream str, String indent) {
		if (hasReturnVar()) {
			p.print(getReturnVar(), str, indent);
			str.print(" = ");
		}
		str.print(getName());
		str.print("(");
		getArgs().prettyPrintWithSep(p, str, indent, ", ");
		str.print(")");
	}
	
	syn String FExternalLanguage.getLanguage() = null;
	eq FCExternalLanguage.getLanguage()         = LANGUAGE_STRING;
	eq FFortran77ExternalLanguage.getLanguage() = LANGUAGE_STRING;
	eq FBuiltinExternalLanguage.getLanguage()   = LANGUAGE_STRING;
	
	public static final int FExp.PRECEDENCE_LOWEST         = 0;
	public static final int FExp.PRECEDENCE_CONDITIONAL    = 1;
	public static final int FExp.PRECEDENCE_ARRAY_RANGE    = 2;
	public static final int FExp.PRECEDENCE_LOGICAL_OR     = 3;
	public static final int FExp.PRECEDENCE_LOGICAL_AND    = 4;
	public static final int FExp.PRECEDENCE_UNARY          = 5;
	public static final int FExp.PRECEDENCE_RELATIONAL     = 6;
	public static final int FExp.PRECEDENCE_ADDITIVE       = 7;
	public static final int FExp.PRECEDENCE_MULTIPLICATIVE = 8;
	public static final int FExp.PRECEDENCE_EXPONENTIATION = 9;
	public static final int FExp.PRECEDENCE_HIGHEST        = 10;
	
	syn int FExp.precedence()  = PRECEDENCE_HIGHEST;
	eq FDotAddExp.precedence() = PRECEDENCE_ADDITIVE;
	eq FDotDivExp.precedence() = PRECEDENCE_MULTIPLICATIVE;
	eq FDotMulExp.precedence() = PRECEDENCE_MULTIPLICATIVE;
	eq FDotPowExp.precedence() = PRECEDENCE_EXPONENTIATION;
	eq FDotSubExp.precedence() = PRECEDENCE_ADDITIVE;
	eq FAndExp.precedence()    = PRECEDENCE_LOGICAL_AND;
	eq FOrExp.precedence()     = PRECEDENCE_LOGICAL_OR;
	eq FRelExp.precedence()    = PRECEDENCE_RELATIONAL;
	eq FIfExp.precedence()     = PRECEDENCE_CONDITIONAL;
	eq FRangeExp.precedence()  = PRECEDENCE_ARRAY_RANGE;
	eq FNegExp.precedence()    = PRECEDENCE_ADDITIVE;
	eq FNotExp.precedence()    = PRECEDENCE_UNARY;

	/**
	 * The reason for using parent here is that this attribute is intended to be used by 
	 * prettyPrint(), that is in turn used by toString(). Checking if our parent is null lets   
	 * us use toString() on expressions that are not yet in the AST without getting a 
	 * NullPointerException. This is useful e.g. when debugging. */
	syn int FExp.parentPrecedence() = parent != null ? retrieveParentPrecedence() : FExp.PRECEDENCE_LOWEST;
	syn int List.parentPrecedence() = parent != null ? retrieveParentPrecedence() : FExp.PRECEDENCE_LOWEST;
	syn int Opt.parentPrecedence()  = parent != null ? retrieveParentPrecedence() : FExp.PRECEDENCE_LOWEST;
	
	inh int FExp.retrieveParentPrecedence();
	inh int List.retrieveParentPrecedence();
	inh int Opt.retrieveParentPrecedence();
	eq FExp.getChild().retrieveParentPrecedence() {
		int precedence = precedence();
		if (precedence == PRECEDENCE_HIGHEST)
			return PRECEDENCE_LOWEST;
		else
			return precedence;
	}
	eq List.getChild().retrieveParentPrecedence()                  = parentPrecedence();
	eq Opt.getChild().retrieveParentPrecedence()                   = parentPrecedence();
	eq ASTNode.getChild().retrieveParentPrecedence()               = FExp.PRECEDENCE_LOWEST;
	
	/**
	 * Used if precedence is equal for node and its parent.
	 */
	inh boolean FExp.shouldhaveParenthesis();
	eq BaseNode.getChild().shouldhaveParenthesis()  = false;
	eq FBinExp.getRight().shouldhaveParenthesis()   = true;
	eq FDotPowExp.getLeft().shouldhaveParenthesis() = true;
	eq FNegExp.getFExp().shouldhaveParenthesis()    = true;
	
	/**
	 * Returns true if this exp should add parenthesis given a certain precedence.
	 */
	syn boolean FExp.addParenthesis(int parentPrecedence) = precedence() < parentPrecedence || precedence() == parentPrecedence && shouldhaveParenthesis();
	
	public final void FExp.prettyPrint(Printer p, PrintStream str, String indent) {
		boolean addParenthesis = addParenthesis(parentPrecedence());
		if (addParenthesis)
			str.print('(');
		prettyPrintExp(p, str, indent);
		if (addParenthesis)
			str.print(')');
	}
	
	protected abstract void FExp.prettyPrintExp(Printer p, PrintStream str, String indent);
	
	protected void FUnknownSizeExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print(":");
	}
	
	protected void FNegExp.prettyPrintExp(Printer p,PrintStream str, String indent){
		str.print("- ");
		p.print(getFExp(),str,indent);
	}
	
	protected void FMatrix.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("[");
		getFExps().prettyPrintWithSep(p, str, indent, "; ");
		str.print("]");
	}
	
	protected void FMatrixRow.prettyPrintExp(Printer p, PrintStream str, String indent) {
		getFExps().prettyPrintWithSep(p, str, indent, ", ");
	}
	
	protected void FBinExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		p.print(getLeft(),str,indent);
		str.print(p.op(this));
		p.print(getRight(),str,indent);
	}
	
	syn String FBinExp.op();
	eq FLtExp.op()        = " < ";
	eq FLeqExp.op()       = " <= ";
	eq FGtExp .op()       = " > ";
	eq FGeqExp.op()       = " >= ";
	eq FEqExp.op()        = " == ";
	eq FNeqExp.op()       = " <> ";
	eq FOrExp.op()        = " or ";
	eq FAndExp.op()       = " and ";
	eq FAddExp.op()       = " + ";
	eq FSubExp.op()       = " - ";
	eq FMulExp.op()       = " * ";
	eq FDivExp.op()       = " / ";
	eq FPowExp.op()       = " ^ ";
	eq FDotAddExp.op()    = " .+ ";
	eq FDotSubExp.op()    = " .- ";
	eq FDotMulExp.op()    = " .* ";
	eq FDotDivExp.op()    = " ./ ";
	eq FDotPowExp.op()    = " .^ ";
	eq FStringAddExp.op() = " + ";
	
	protected void FNoExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		// Dummy node
	}
	
	protected void FUnsupportedExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
	}
	
	protected void FNotExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("not ");
		p.print(getFExp(),str,indent);
	}
	
	protected void FIfExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		prettyPrintAsElseExp(p, str, indent);
	}
	
	public void FExp.prettyPrintAsElseExp(Printer p, PrintStream str, String indent) {
		str.print(' ');
		p.print(this, str, indent);
	}
	
	public void FIfExp.prettyPrintAsElseExp(Printer p, PrintStream str, String indent) {
		str.print("if ");
		p.print(getIfExp(), str, indent);
		str.print(" then ");
		p.print(getThenExp(), str, indent);
		str.print(" else");
		getElseExp().prettyPrintAsElseExp(p, str, indent);
	}
	
	protected void FRealLitExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print(getValue());
	}

	protected void FIntegerLitExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print(getValue());
	}

	protected void FEnumLitExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print(getEnum());
		str.print('.');
		str.print(getValue());
	}
	
	protected void FTimeExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("time");
	}

	protected void FEndExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("end");
	}
	
	protected void FStringLitExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("\"" + getString() + "\"");
	}

	protected void FBooleanLitExpTrue.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("true");
	}

	protected void FBooleanLitExpFalse.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("false");
	}
	
	public void FIdUse.prettyPrint(Printer p, PrintStream str, String indent) {
		if (getFQName().isScalarized())
			str.print(name());
		else 
			p.print(getFQName(), str, indent);
	}
	
	public void FIdUseInstAccess.prettyPrint(Printer p, PrintStream str, String indent) {
		p.print(getInstAccess(), str, indent);
	}

	protected void FIdUseExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		p.print(getFIdUse(), str, indent);
	}

	protected void FInstAccessExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		p.print(getInstAccess(), str, indent);
	}
	
	public void InstAccess.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(name());
		if (hasFArraySubscripts())
			p.print(getFArraySubscripts(), str, indent);
	}
	
	public void InstDot.prettyPrint(Printer p, PrintStream str, String indent) {
		getInstAccesss().prettyPrintWithSep(p, str, indent, ".");
	}
	
	public void InstGlobalAccess.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(".");
		p.print(getInstAccess(), str, indent);
	}
	
	protected void FDerExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print(name());
	}

	protected void FDummyDerExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print(derPrefixName());
	}

	protected void FPreExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print(name());
	}
	
	protected void InstDerExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("der(");
		p.print(getFExp(),str,indent);
		str.print(")");
	}
	
	protected void InstHDerExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("der(");
		p.print(getFExp(),str,indent);
		str.format(",%d)", getOrder());
	}

	protected void InstPreExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("pre(");
		p.print(getFExp(),str,indent);
		str.format(")");
	}
	
	protected void FSumExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("sum(");
		p.print(getFExp(), str, indent);
		str.print(")");
	}
	
	protected void FProductExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("product(");
		p.print(getFExp(), str, indent);
		str.print(")");
	}
	
	protected void FFunctionCall.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print(getName().name());
		str.print("(");
		getArgs().prettyPrintWithSep(p, str, "", ", ");
		str.print(")");
	}

	protected void InstFunctionCall.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print(getName().name());
		str.print("(");
		getArgs().prettyPrintWithSep(p, str, "", ", ");
		str.print(")");
	}

	public void InstDefaultArgument.prettyPrint(Printer p, PrintStream str, String indent) {
		p.print(getFExp(), str, indent);
	}

	public void InstNamedArgument.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(getName().name());
		str.print("=");
		p.print(getFExp(), str, indent);
	}
	
	protected void FBuiltInFunctionCall.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print(builtInName());
		str.print("(");
		prettyPrintArguments(p, str, indent);
		str.print(")");
	}
	
	protected static final String FBuiltInFunctionCall.SEP = ", ";
	
	/**
	 * \brief Pretty-print all arguments of function.
	 * 
	 * Default implementation prints all direct FExp children (including those in Lists and Opts), 
	 * separated by {@link #SEP}.
	 */
	protected void FBuiltInFunctionCall.prettyPrintArguments(Printer p, PrintStream str, String indent) {
		String pre = "";
		for (FExp exp : childFExps()) {
			str.print(pre);
			p.print(exp, str, indent);
			pre = SEP;
		}
	}
	
	protected void FInfArgsFunctionCall.prettyPrintArguments(Printer p, PrintStream str, String indent) {
		getFExps().prettyPrintWithSep(p, str, indent, SEP);
	}
	
	protected void FFillExp.prettyPrintArguments(Printer p, PrintStream str, String indent) {
		p.print(getFillExp(), str, indent);
		str.print(SEP);
		super.prettyPrintArguments(p, str, indent);
	}
	
	protected void FCatExp.prettyPrintArguments(Printer p, PrintStream str, String indent) {
		p.print(getDim(), str, indent);
		str.print(SEP);
		super.prettyPrintArguments(p, str, indent);
	}
	
	protected void FConnPotentialRoot.prettyPrintArguments(Printer p, PrintStream str, String indent) {
		super.prettyPrintArguments(p, str, indent);
		if (hasPriority()) {
			str.print(SEP);
			str.print("priority=");
			p.print(getPriority(), str, indent);
		}
	}

	syn String FBuiltInFunctionCall.builtInName();
	eq FRecordConstructor.builtInName()  = getRecord().name();
	eq FUnsupportedBuiltIn.builtInName() = getName();
	eq FAbsExp.builtInName()             = "abs";
	eq FSignExp.builtInName()            = "sign";
	eq FSqrtExp.builtInName()            = "sqrt";
	eq FEnumIntegerExp.builtInName()     = "Integer";
	eq FStringExp.builtInName()          = "String";
	eq FDivFuncExp.builtInName()         = "div";
	eq FModFuncExp.builtInName()         = "mod";
	eq FRemFuncExp.builtInName()         = "rem";
	eq FCeilFuncExp.builtInName()        = "ceil";
	eq FFloorFuncExp.builtInName()       = "floor";
	eq FIntegerFuncExp.builtInName()     = "integer";
	eq FSinExp.builtInName()             = "sin";
	eq FCosExp.builtInName()             = "cos";
	eq FTanExp.builtInName()             = "tan";
	eq FAsinExp.builtInName()            = "asin";
	eq FAcosExp.builtInName()            = "acos";
	eq FAtanExp.builtInName()            = "atan";
	eq FAtan2Exp.builtInName()           = "atan2";
	eq FSinhExp.builtInName()            = "sinh";
	eq FCoshExp.builtInName()            = "cosh";
	eq FTanhExp.builtInName()            = "tanh";
	eq FExpExp.builtInName()             = "exp";
	eq FLogExp.builtInName()             = "log";
	eq FLog10Exp.builtInName()           = "log10";
	eq FScalarExp.builtInName()          = "scalar";
	eq FVectorExp.builtInName()          = "vector";
	eq FMatrixExp.builtInName()          = "matrix";
	eq FTranspose.builtInName()          = "transpose";
	eq FSymmetric.builtInName()          = "symmetric";
	eq FCross.builtInName()              = "cross";
	eq FSkew.builtInName()               = "skew";
	eq FOuterProduct.builtInName()       = "outerProduct";
	eq FNdimsExp.builtInName()           = "ndims";
	eq FSizeExp.builtInName()            = "size";
	eq FNoEventExp.builtInName()         = "noEvent";
	eq FSmoothExp.builtInName()          = "smooth";
	eq InstPreExp.builtInName()          = "pre";
	eq FEdgeExp.builtInName()            = "edge";
	eq FChangeExp.builtInName()          = "change";
	eq FSampleExp.builtInName()          = "sample";
	eq FInitialExp.builtInName()         = "initial";
	eq FTerminalExp.builtInName()        = "terminal";
	eq FTerminate.builtInName()          = "terminate";
    eq FReinit.builtInName()             = "reinit";
	eq FAssert.builtInName()             = "assert";
	eq FIdentity.builtInName()           = "identity";
	eq FDiagonal.builtInName()           = "diagonal";
	eq FOnes.builtInName()               = "ones";
	eq FZeros.builtInName()              = "zeros";
	eq FFillExp.builtInName()            = "fill";
	eq FAbstractCat.builtInName()        = "cat";
	eq FParseArray.builtInName()         = "array";
	eq FMinExp.builtInName()             = "min";
	eq FMaxExp.builtInName()             = "max";
	eq FSumExp.builtInName()             = "sum";
	eq FProductExp.builtInName()         = "product";
	eq FLinspace.builtInName()           = "linspace";
	eq FHomotopyExp.builtInName()        = "homotopy";
    eq FCardinality.builtInName()        = "cardinality";
	eq FSemiLinearExp.builtInName()      = "semiLinear";
	eq FInStream.builtInName()           = "inStream";
	eq FActualStream.builtInName()       = "actualStream";
	eq FGetInstanceName.builtInName()    = "getInstanceName";
	eq FConnBranch.builtInName()         = "Connections.branch";
	eq FConnRoot.builtInName()           = "Connections.root";
	eq FConnPotentialRoot.builtInName()  = "Connections.potentialRoot";
	eq FConnIsRoot.builtInName()         = "Connections.isRoot";
	eq FConnRooted.builtInName()         = "Connections.rooted";
	eq FConnRootedDep.builtInName()      = "rooted";


	public void FForClauseE.prettyPrint(Printer p, PrintStream str, String indent) {
		str.print(indent+"for ");
		getFForIndexList().prettyPrintWithSep(p, str, indent, ", ");
		str.print(" loop\n");
		getFAbstractEquationList().prettyPrintWithFix(p, str, p.indent(indent), "", ";\n");
		str.print(indent + "end for");
	}
	
	public abstract void CommonForIndex.prettyPrint(Printer p, PrintStream str, String indent);
	
    public void FForIndex.prettyPrint(Printer p, PrintStream str, String indent) {
        str.print(getFVariable().name());
        if (hasFExp()) {
            str.print(" in ");
        p.print(getFExp(), str, indent);
        }
    }
	
    public void InstForIndex.prettyPrint(Printer p, PrintStream str, String indent) {
        str.print(getInstPrimitive().name());
        if (hasFExp()) {
            str.print(" in ");
        p.print(getFExp(), str, indent);
        }
    }
	
	protected void FArray.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("{");
		getFExps().prettyPrintWithSep(p, str, indent, ", ");
		str.print("}");
	}
	
	protected void FLongArray.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("array(");
		getFExps().prettyPrintWithSep(p, str, indent, ", ");
		str.print(")");
	}
	
	protected void FIterExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		p.print(getFExp(), str, indent);
		str.print(" for ");
		for (int i = getNumForIndex() - 1; i >= 0; i--) {
			p.print(getForIndex(i), str, indent);
			if (i > 0)
				str.print(", ");
		}
	}
	
	protected void FSubscriptedExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		str.print("(");
		p.print(getFExp(), str, indent);
		str.print(")");
		p.print(getFArraySubscripts(), str, indent);
	}
	
	protected void FArgumentExp.prettyPrintExp(Printer p, PrintStream str, String indent) {
		p.print(copiedFExp(), str, indent);
	}
	
	syn String FTypePrefixInputOutput.toString();
	eq FInput.toString() = "input";
	eq FOutput.toString()= "output";
	syn String FTypePrefixVariability.toString();
	eq FParameter.toString() = "parameter ";
	eq FDiscrete.toString() = "discrete ";
	eq FConstant.toString() = "constant ";
	eq FContinuous.toString() = "";	
	
	syn String FTypePrefixVariability.toStringLiteral();
	eq FParameter.toStringLiteral() = "Parameter";
	eq FDiscrete.toStringLiteral() = "Discrete";
	eq FConstant.toStringLiteral() = "Constant";
	eq FContinuous.toStringLiteral() = "Continuous";
	
	syn String Restriction.toString();
	eq Model.toString() = "model";
	eq Block.toString() = "block";
	eq MClass.toString() = "class";
	eq Connector.toString() = "connector";
	eq MType.toString() = "type";
	eq MPackage.toString() = "package";
	eq Function.toString() = "function";
	eq Record.toString() = "record";

    syn String ComponentDecl.toString() = prettyPrint("");
    syn String Access.toString() = prettyPrint("");
    syn String Modification.toString() = prettyPrint("");
}

aspect PrettyPrint_MC {
	
    public class MCPrettyPrinter extends Printer {
		
		public MCPrettyPrinter() {
			super("    ");
		}
		
 		public void print(ASTNode node, PrintStream str, String indent) { 
 			node.prettyPrint(this, str, indent); 
 		}
  		
	}
	
	static MCPrettyPrinter ASTNode.printer_MC = new MCPrettyPrinter();
	
	public String ASTNode.prettyPrint_MC(String indent) {
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		PrintStream str = new PrintStream(os);
		prettyPrint(str,indent);
		return os.toString();
	}

	public void List.prettyPrintFAttributeList_MC(PrintStream str, Printer p) {
	
	    boolean attrSet = false;
	    	boolean firstAttr = true;
	    	
	    	for (int i=0;i<getNumChild();i++) {
	    		if (((FAttribute)getChild(i)).getAttributeSet() && !((FAttribute)getChild(i)).getName().name().equals("fixed")) {
					attrSet=true;
					break;
	 		   	}
	    	}
	    
	    	if (attrSet){
	    		str.print("(");
	    		for (int i=0;i<getNumChild();i++) {
	    
	    			if (((FAttribute)getChild(i)).getAttributeSet() && !((FAttribute)getChild(i)).getName().name().equals("fixed")) {
	
						if (!firstAttr)	
							str.print(",");
						p.print(((FAttribute)getChild(i)),str,"");
						
						firstAttr = false;
	 		   		}
	    		}
	    		str.print(")");
	   		}
	}

	public void FVariable.prettyPrint_MC(Printer p, PrintStream str, String indent) {
			str.print(indent);
			
			str.print(getFTypePrefixVariability());
						
			if (hasFTypePrefixInputOutput()) {
				str.print(getFTypePrefixInputOutput());
				str.print(" ");
			}
			
			str.print(prettyPrintType());
			str.print(" ");
			str.print(nameUnderscore());
//			p.print(getFQName(),str,"");
		
	    	getFAttributeList().prettyPrintFAttributeList_MC(str,p);
	    	
	   if (hasBindingExp()) {
				str.print(" = ");
				FExp bindingExp = getBindingExp();
				p.print(bindingExp,str,indent);		
		} else if (hasParameterEquation()) {
				str.print(" = ");
				FExp bindingExp = ((FEquation)parameterEquation()).getRight();
				p.print(bindingExp,str,indent);				
		}
	    	
		p.print(getFStringCommentOpt(),str,indent);

	    if (isIndependentParameter() && hasBindingExp()) {
	    	str.print(" /* ");
	    	try {
				str.print(getBindingExp().ceval());
			} catch (ConstantEvaluationException e){
				str.print("evalutation error");
			}
	    	str.print(" */");
	    }
	}


	public void FClass.prettyPrint_MC(Printer p, PrintStream str, String indent) {
		String nextInd = p.indent(indent);
	
	    p.print(getFFunctionDecls(), str, indent);
    	p.print(getFRecordDecls(), str, indent);
    	p.print(getFEnumDecls(), str, indent);
    	p.print(getFDerivedTypes(), str, indent);
	
		str.print(indent + "model " + nameUnderscore() + "\n");
		for (FVariable fv : getFVariables()) {
	  		if (!fv.isDerivativeVariable() && !fv.isPreVariable()) {
	  			p.print(fv, str, nextInd);
	  			str.print(";\n");  
	  		}
		}

		if (getNumFInitialEquation()>0)
			str.print(indent + "initial equation \n");
		getFInitialEquations().prettyPrintWithFix(p, str, nextInd, "", ";\n");

	/*
		if (getNumFParameterEquation()>0)
			str.print(indent + "parameter equation\n");
		getFParameterEquations().prettyPrintWithFix(p, str, nextInd, "", ";\n");
	*/
	    boolean wroteEquation = false;
    	for (FAbstractEquation e : getFAbstractEquations()) {
    		if (e instanceof FAlgorithm) {
    			p.print(e, str, indent);
    			wroteEquation = false;
    		} else {
    			if (!e.isIgnored()) {
	    			if (!wroteEquation) {
	    				str.print(indent);
	    				str.print("equation\n");
	    				wroteEquation = true;
	    			}
	    			p.print(e, str, nextInd);
		    		str.print(";\n");
    			}
    		}
    	}
	        	
  		str.print(indent);
  		str.print("end ");
  		str.print(nameUnderscore());
  		str.print(";\n");
	}


	public void ASTNode.prettyPrint_MC(PrintStream str, String indent) {
 		prettyPrint_MC(printer_MC, str, indent);
	}

	public void ASTNode.prettyPrint_MC(Printer p, PrintStream str, String indent) {
 		prettyPrint(p, str, indent);
	}
	
	public void FIdUseExp.prettyPrint_MC(Printer p, PrintStream str, String indent) {
		str.print(nameUnderscore());
	}
	
	public void FDerExp.prettyPrint_MC(Printer p, PrintStream str, String indent) {
		str.print("der(");
		str.print(getFIdUse().nameUnderscore());
		str.print(")");
	}

}