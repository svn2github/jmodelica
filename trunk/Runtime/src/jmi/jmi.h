/** \file jmi.h
 *  \brief The public JMI model interface.
 *  */

/** \mainpage The JModelica C runtime library
 *
 * The JModelica C runtime library contains functions and data structures for accessing
 * the C model representation that is generated by the JModelica Modelica and Optimica
 * front-ends, respectively. The library is organized into three main parts:
 *
 *  - <a href="group__Jmi.html">The JMI Model interface. </a> This interface contains functions
 *    for evaluating
 *    the function generated by the compiler, including the DAE residual, the
 *    residual functions for the DAE initialization problem, and the functions related to
 *    the optimization problem such as cost functions and constraint residual functions.
 *    The JMI Model interface also supports evaluation of symbolic Jacobians (if available)
 *    and/or Jacobians computed by means of automatic differentiation. Sparsity patterns for
 *    Jacobians are supported.
 *  - The JMI Algorithm interface. Based on the JMI Model interface, algorithms (in particular
 *    optimization algorithms) are implemented. These includes a framework for implementation of
 *    simultaneous optimization algorithms as well as a particular implementation of an algorithm
 *    based on Lagrange polynomials on Radau points.
 *  - The JMI Solver interface. Typically, the JMI Model and Algorithm interfaces are intended to
 *    be integrated with numerical solvers. The JMI Solver interface then contains functions that
 *    are often necessary to manage such integrations.
 *
 */


/**
 * \defgroup Jmi The JMI Model interface
 *
 * \brief Documentation of the public JMI Model interface.
 *
 *  \section DesignConsiderations Design considerations
 *
 * The JMI Model interface is intended to be used in a wide range of
 * applications and on multiple platforms. This also includes embedded
 * platforms in HILS applications.
 *
 * It is desirable that the JMI Model interface can be easily interfaced
 * with Python. Python is the intended language for scripting in JModelica and it is
 * therefore important that the generated code is straight forward to use with the
 * Python extensions or ctypes framework.
 *
 * The JMI Model interface is intended to be used by wide range of users,
 * with different backgrounds and programming skills. It is therefore desirable that
 * the interface is as simple and intuitive as possible.
 *
 * Given these motivations, it is reasonable to use pure C where possible, and to a
 * limited extent C++ where needed (e.g. in solver interfaces and in most likely in the
 * AD framework).
 *
 * It should also be possible to build shared libraries, in order to.
 * build applications that contains several models.
 *
 *
 * \section MathDescr Mathematical description of the JMI Model interface
 *
 *   The jmi interface consists of three parts: DAE, DAE initialization and optimization.
 *   Essentially, the jmi interface consists of a collection of functions that are
 *   offered to the user for evaluation of the DAE residual, cost functions, constraints
 *   etc. These functions takes as arguments one more of the following three argument
 *   types:
 *
 *   Parameters (denoted \f$p\f$):
 *    - \f$c_i\f$   independent constant
 *    - \f$c_d\f$   dependent constants
 *    - \f$p_i\f$   independent parameters
 *    - \f$p_d\f$   dependent parameters
 *
 *    with
 *
 *      \f$ p = [c_i^T, c_d^T, p_i^T, p_d^T]^T \f$
 *
 *   Variables (denoted \f$v\f$):
 *
 *    - \f$dx\f$    differentiated variables
 *    - \f$x\f$     variables that appear differentiated
 *    - \f$u\f$     inputs
 *    - \f$w\f$     algebraic variables
 *    - \f$t\f$     time
 *
 *    with
 *
 *    \f$v = [dx^T, x^T, u^T, w^T, t]^T\f$
 *
 *   Variables defined at particular time instants (denoted \f$q\f$):
 *
 *      - \f$dx(t_i)\f$    differentiated variables evaluated at time \f$t_i, i \in 1..n_{tp}\f$
 *      - \f$x(t_i)\f$     variables that appear differentiated evaluated at time \f$t_i, t_i \in 1..n_{tp}\f$
 *      - \f$u(t_i)\f$     inputs evaluated at time \f$t_i, i \in 1..n_{tp}\f$
 *      - \f$w(t_i)\f$     algebraic variables evaluated at time \f$t_i, i \in 1..n_{tp}\f$
 *
 *    \f$ q = [dx(t_1)^T, x(t_1)^T, u(t_1)^T, w(t_1)^T, ...,
 *           dx(t_{n_{tp}})^T, x(t_{n_{tp}})^T, u(t_{n_{tp}})^T, w(t_{n_{tp}})^T]^T\f$
 *
 *   All parameters, variables and point-wise evaluated variables are denoted z:
 *
 *     \f$ z = [p^T, v^T, q^T]^T \f$
 *
 *   \subsection The DAE interface
 *
 *   The DAE interface is defined by the residual function
 *
 *     \f$ F(p,v) = 0 \f$
 *
 *    \subsection The DAE initialization interface
 *
 *	 The DAE initialization interface is defined by the functions
 *
 *	  \f$  F_0(p,v) = 0 \f$<br>
 *	  \f$  F_1(p,v) = 0 \f$
 *
 *   \f$F_0\f$ represents the DAE system augmented with additional initial equations
 *   and start values that are fixed. \f$F_1\f$ on the other hand contains equations for
 *   initialization of variables for which the value given in the start attribute is
 *   not fixed.
 *
 *   \subsection The optimization interface
 *
 *   The optimization part of the interface is defined by the functions
 *
 *      \f$J(p,q)\f$<br>
 *      \f$C_{eq}(p,v,q) = 0\f$<br>
 *      \f$C_{ineq}(p,v,q) \leq 0\f$<br>
 *      \f$H_{eq}(p,q) = 0\f$<br>
 *      \f$H_{ineq}(p,q) \leq 0\f$<br>
 *
 *   where \f$J\f$ is the cost function to be minimized, \f$C_{eq}\f$ are path equality constraints,
 *   \f$C_{ineq}\f$ are path inequality constraints, \f$H_{eq}\f$ are (time) point equality constraints,
 *   and \f$H_{ineq}\f$ are (time) point inequality constraints. The rationale for introducing
 *   \f$H_{eq}\f$ and \f$H_{ineq}\f$ is to enable expression of e.g. terminal constraints.
 *
 *  \section Jacobians Evaluation of Jacobians
 *
 *  Evaluation of Jacobians is controlled by four arguments:
 *
 *   - eval_alg    This argument is used to select the method evaluation
 *                     for the Jacobian. JMI_DER_SYMBOLIC and JMI_DER_CPPAD
 *                     is currently supported.
 *   - sparsity          This argument is a mask that selects whether
 *                     sparse or dense evaluation of the Jacobian should
 *                     be used. The constants JMI_DER_SPARSE are used to
 *                     specify a sparse Jacobian, whereas JMI_DER_DENSE_COL_MAJOR
 *                     and JMI_DER_DENSE_ROW_MAJOR are used to specify dense
 *                     column major or row major Jacobians respectively.
 *   - independent_vars  This argument is used to specify which variable types
 *                     are considered to be independent variables in the Jacobian
 *                     evaluation. The constants JMI_DER_NN are used to indicate that
 *                     the Jacobian w.r.t. a particular vector should be evaluated.
 *   - mask              This array has the same size as the number of column of the dense
 *                     Jacobian, and holds the value of 0 if the corresponding Jacobian
 *                     column should not be computed. If the value of an entry in
 *                     mask i 1, then the corresponding Jacobian column will be evaluated.
 *                     The evaluated Jacobian columns are stored in the first
 *                     entries of the output argument jac.
 *
 *  TODO: It may be interesting to include an additional layer that enables
 *  support for partially defined Jacobians. This would be beneficial if symbolic
 *  expressions for the Jacobian is available for some entries, but for other
 *  an AD algorithm is to be used.
 *
 * \section ErrorHandling Error handling
 */

#ifndef _JMI_H
#define _JMI_H

#include "jmi_common.h"

/* @{ */


/**
 * \defgroup Defines Defined constants
 * \brief Constants defined in the JMI Model interface.
 */
/* @{ */

#define JMI_INF 1e20; /**< \brief A Very Large Number denoting infinity.*/

#define JMI_DER_SYMBOLIC 1 /**< \brief Use symbolic evaluation of derivatives (if available). */
#define JMI_DER_CPPAD 2 /**< \brief Use automatic differentiation (CppAD) to evaluate derivatives. */

#define JMI_DER_SPARSE 1 /**< \brief Sparse evaluation of derivatives. */
#define JMI_DER_DENSE_COL_MAJOR 2 /**<  \brief Dense evaluation (column major) of derivatives. */
#define JMI_DER_DENSE_ROW_MAJOR 4 /**<  \brief Dense evaluation (row major) of derivatives. */

// Flags for evaluation of Jacobians w.r.t. parameters in the p vector
#define JMI_DER_CI 1 /**<  \brief Evaluate derivatives w.r.t. independent constants, \f$c_i\f$.*/
#define JMI_DER_CD 2 /**<  \brief Evaluate derivatives w.r.t. dependent constants, \f$c_d\f$.*/
#define JMI_DER_PI 4 /**<  \brief Evaluate derivatives w.r.t. independent parameters, \f$p_i\f$.*/
#define JMI_DER_PD 8 /**<  \brief Evaluate derivatives w.r.t. dependent constants, \f$p_d\f$.*/
// Flags for evaluation of Jacobians w.r.t. variables in the v vector
#define JMI_DER_DX 16 /**<  \brief Evaluate derivatives w.r.t. derivatives, \f$dx\f$.*/
#define JMI_DER_X 32 /**<  \brief Evaluate derivatives w.r.t. differentiated variables, \f$x\f$.*/
#define JMI_DER_U 64 /**<  \brief Evaluate derivatives w.r.t. inputs, \f$u\f$.*/
#define JMI_DER_W 128 /**<  \brief Evaluate derivatives w.r.t. algebraic variables, \f$w\f$.*/
#define JMI_DER_T 256 /**<  \brief Evaluate derivatives w.r.t. time, \f$t\f$.*/
// Flags for evaluation of Jacobians w.r.t. variables in the q vector
#define JMI_DER_DX_P 512 /**<  \brief Evaluate derivatives w.r.t. derivatives at time points, \f$dx_p\f$.*/
#define JMI_DER_X_P 1024 /**<  \brief Evaluate derivatives w.r.t. differentiated variables at time points, \f$x_p\f$.*/
#define JMI_DER_U_P 2048 /**<  \brief Evaluate derivatives w.r.t. inputs at time points, \f$u_p\f$.*/
#define JMI_DER_W_P 4096 /**<  \brief Evaluate derivatives w.r.t. algebraic variables at time points, \f$w_p\f$.*/

/** \brief Evaluate derivatives w.r.t. all variables, \f$z\f$.*/
#define JMI_DER_ALL JMI_DER_CI | JMI_DER_CD | JMI_DER_PI | JMI_DER_PD |\
	JMI_DER_DX | JMI_DER_X | JMI_DER_U | JMI_DER_W |\
	JMI_DER_T | JMI_DER_DX_P | JMI_DER_X_P | JMI_DER_U_P | JMI_DER_W_P


/**  \brief Evaluate derivatives w.r.t. all variables in \f$p\f$.*/
#define JMI_DER_ALL_P JMI_DER_CI | JMI_DER_CD | JMI_DER_PI | JMI_DER_PD

/**  \brief Evaluate derivatives w.r.t. all variables in \f$v\f$.*/
#define JMI_DER_ALL_V JMI_DER_DX | JMI_DER_X | JMI_DER_U | JMI_DER_W |\
	JMI_DER_T

/**  \brief Evaluate derivatives w.r.t. all variables in \f$q\f$.*/
#define JMI_DER_ALL_Q  JMI_DER_DX_P | JMI_DER_X_P | JMI_DER_U_P | JMI_DER_W_P

/* @} */

/*
 *****************************************
 *
 *    Public interface
 *
 ****************************************
 */

/**
 * \defgroup jmi_struct Creation, initialization and destruction of jmi_t structs
 * \brief The main data structure in the JMI Model interface is jmi_t, which contains
 * all information needed to evaluate the functions in the JMI Model interface.
 *
 * Typically,
 * a pointer to a jmi_t struct is passed as the first argument to functions in the interface.
 *
 *
 */

/* @{ */

/**
 * \brief Create a new jmi_t struct.
 *
 * This function creates a new jmi struct, for which a pointer is returned in the output argument jmi.
 *
 * Typically this function is defined in the generated code.
 *
 * @param jmi A pointer to a jmi_t pointer where the new jmi_t struct is stored.
 * @return Error code.
 */
int jmi_new(jmi_t** jmi);

/**
 * Initializes the AD variables and tapes.
 *
 * Prior to this call, the variables in z should
 * be initialized, which is also the reason why this function must be provided for
 * the user to call after the actual creation of the jmi_t struct.
 *
 * @param jmi A pointer to a jmi_t struct.
 * @return Error code.
 */
int jmi_ad_init(jmi_t* jmi);

/**
 * Deallocates memory and deletes a jmi_t struct.
 *
 * @param jmi A pointer to the jmi_t struc to be deleted.
 */
int jmi_delete(jmi_t* jmi);

/* @} */

/**
 * \defgroup Access Setters and getters for the fields in jmi_t
 *
 * \brief The fields of jmi_t are conveniently accessed using the setter and getter
 * functions provided in the JMI Model interface.
 *
 * Notice that it is not recommended to access the fields directely, since the internal
 * implementation of jmi_t may change, wheras the setters and getters are less likely to
 * do so.
 *
 */

/* @{ */

/**
 * \brief Get the sizes of the variable vectors.
 *
 * @param jmi The jmi_t struct.
 * @param n_ci (Output) number of independent constants.
 * @param n_cd (Output) number of dependent constants.
 * @param n_pi (Output) number of independent parameters.
 * @param n_pd (Output) number of dependent parameters.
 * @param n_dx (Output) number of derivatives.
 * @param n_x (Output) number of differentiated variables.
 * @param n_u (Output) number of inputs.
 * @param n_w (Output) number of algebraic variables.
 * @param n_tp (Output) number of time points included in the model.
 * @param n_z (Output) total number of variables in the \f$z\f$ vector.
 * @return Error code.
 *
 */
int jmi_get_sizes(jmi_t* jmi, int* n_ci, int* n_cd, int* n_pi, int* n_pd,
		int* n_dx, int* n_x, int* n_u, int* n_w, int* n_tp, int* n_z);

/**
 * \brief Get the offsets for the variable types in the \f$z\f$ vector.
 *
 * @param offs_ci (Output) offset of independent constants.
 * @param offs_cd (Output) offset of dependent constants.
 * @param offs_pi (Output) offset of independent parameters.
 * @param offs_pd (Output) offset of dependent parameters.
 * @param offs_dx (Output) offset of derivatives.
 * @param offs_x (Output) offset of differentiated variables.
 * @param offs_u (Output) offset of inputs.
 * @param offs_w (Output) offset of algebraic variables.
 * @param offs_t (Output) offset of time.
 * @param offs_dx_p (Output) offset of the first derivatives in the time point part of \f$z\f$.
 * @param offs_x_p (Output) offset of the first differentiated variables in the time point part of \f$z\f$.
 * @param offs_u_p (Output) offset of the first inputs in the time point part of \f$z\f$.
 * @param offs_w_p (Output) offset of the first algebraic variables in the time point part of \f$z\f$.
 * @return Error code.
 */
int jmi_get_offsets(jmi_t* jmi, int* offs_ci, int* offs_cd, int* offs_pi, int* offs_pd,
		int* offs_dx, int* offs_x, int* offs_u, int* offs_w, int* offs_t,
		int* offs_dx_p, int* offs_x_p, int* offs_u_p, int* offs_w_p);

/**
 *Ê\brief Get the number of time points.
 *Ê
 * @param jmi The jmi_t struct.
 * @param n_tp (Output) number of time points in the model.
 * @return Error code.
 *Ê
 */
int jmi_get_n_tp(jmi_t *jmi, int *n_tp);

/**
 * \brief Set the vector of time points included in the problem.
 *
 * @param jmi The jmi_t struct.
 * @param tp A pointer to a jmi_real_t array of size n_tp that contains the time points.
 * @return Error code.
 *
 */
int jmi_set_tp(jmi_t *jmi, jmi_real_t *tp);

/**
 * \brief Get the vector of time points included in the problem.
 *
 * @param jmi The jmi_t struct.
 * @param tp (Output) a pointer to a jmi_real_t array of size n_tp. Upon return the array contains the time points of the model.
 * @return Error code.
 *
 */
int jmi_get_tp(jmi_t *jmi, jmi_real_t *tp);

/**
 * \brief Get a pointer to the independent constants vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$c_i\f$ vector.
 *
 */
jmi_real_t* jmi_get_ci(jmi_t* jmi);

/**
 * \brief Get a pointer to the dependent constants vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$c_d\f$ vector.
 *
 */
jmi_real_t* jmi_get_cd(jmi_t* jmi);

/**
 * \brief Get a pointer to the independent parameter vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$p_i\f$ vector.
 *
 */
jmi_real_t* jmi_get_pi(jmi_t* jmi);

/**
 * \brief Get a pointer to the dependent parameters vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$p_d\f$ vector.
 *
 */
jmi_real_t* jmi_get_pd(jmi_t* jmi);

/**
 * \brief Get a pointer to the derivatives vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$dx\f$ vector.
 *
 */
jmi_real_t* jmi_get_dx(jmi_t* jmi);

/**
 * \brief Get a pointer to the differentiated variables vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$x\f$ vector.
 *
 */
jmi_real_t* jmi_get_x(jmi_t* jmi);

/**
 * \brief Get a pointer to the inputs vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$u\f$ vector.
 *
 */
jmi_real_t* jmi_get_u(jmi_t* jmi);

/**
 * \brief Get a pointer to the algebraic variables vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$w\f$ vector.
 *
 */
jmi_real_t* jmi_get_w(jmi_t* jmi);

/**
 * \brief Get a pointer to the time value.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to \f$t\f$.
 *
 */
jmi_real_t* jmi_get_t(jmi_t* jmi);

/**
 * \brief Get a pointer to the derivatives corresponding to the i:th time point.
 *
 * @param jmi The jmi_t struct.
 * @param i Index of the time point: 0 corresponds to first time point.
 * @return A pointer to the \f$dx_{p,i}\f$ vector.
 *
 */
jmi_real_t* jmi_get_dx_p(jmi_t* jmi,int i);

/**
 * \brief Get a pointer to the differentiated variables corresponding to the i:th time point.
 *
 * @param jmi The jmi_t struct.
 * @param i Index of the time point: 0 corresponds to first time point.
 * @return A pointer to the \f$x_{p,i}\f$ vector.
 *
 */
jmi_real_t* jmi_get_x_p(jmi_t* jmi, int i);

/**
 * \brief Get a pointer to the inputs corresponding to the i:th time point.
 *
 * @param jmi The jmi_t struct.
 * @param i Index of the time point: 0 corresponds to first time point.
 * @return A pointer to the \f$u_{p,i}\f$ vector.
 *
 */
jmi_real_t* jmi_get_u_p(jmi_t* jmi, int i);

/**
 * \brief Get a pointer to the algebraic variables corresponding to the i:th time point.
 *
 * @param jmi The jmi_t struct.
 * @param i Index of the time point: 0 corresponds to first time point.
 * @return A pointer to the \f$w_{p,i}\f$ vector.
 *
 */
jmi_real_t* jmi_get_w_p(jmi_t* jmi, int i);



/* @} */

/**
 * \defgroup Misc Misc.
 */
/* @{ */

/**
 * Print a summary of the content of the jmi struct.
 */
void jmi_print_summary(jmi_t *jmi);

/* @} */



/*********************************************
 *
 * DAE interface
 *
 ********************************************/

/**
 * \defgroup DAE DAE interface
 */
/* @{ */


/**
 * \brief Get the number of equations of the DAE.
 *
 * @param jmi A jmi_t struct.
 * @param n_eq_F (Output) The number of DAE equations is stored in this argument.
 * @return Error code.
 */
int jmi_dae_get_sizes(jmi_t* jmi, int* n_eq_F);


/**
 * \brief Evaluate DAE residual. The user sets the input variables by writing to
 * the vectors obtained from the functions jmi_dae_get_x, ...
 */
int jmi_dae_F(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the DAE residual function.
 */
int jmi_dae_dF(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the DAE residual Jacobian.
 */
int jmi_dae_dF_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the DAE
 * residual Jacobian.
 */
int jmi_dae_dF_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
		                  int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non zero
 * elements in the Jacobian of the DAE residual given a sparsity configuration.
 */
int jmi_dae_dF_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/* @} */

/*********************************************
 *
 * Initialization interface
 *
 ********************************************/

/**
 * \defgroup Initialization DAE Initialization Interface
 */
/* @{ */

/*
 * Get the number of equations in the DAE initialization functions.
 */
int jmi_init_get_sizes(jmi_t* jmi, int* n_eq_F0, int* n_eq_F1);

/**
 * Evaluate the F0 function of the initialization system.
 */
int jmi_init_F0(jmi_t* jmi, jmi_real_t* res);

/**
 * Evaluate the Jacobian of the F0 initialization function.
 */
int jmi_init_dF0(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * Returns the number of non-zeros in the Jacobian of the F0 initialization function.
 */
int jmi_init_dF0_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * Returns the row and column indices of the non-zero elements of the Jacobian of the F0
 * initialization function.
 */
int jmi_init_dF0_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * This helper function computes the number of columns and the number of non zero
 * elements in the Jacobian of the F0 init function given a sparsity configuration.
 */
int jmi_init_dF0_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * Evaluate the F1 function of the initialization system.
 */
int jmi_init_F1(jmi_t* jmi, jmi_real_t* res);

/**
 * Evaluate the Jacobian of the F1 initialization function.
 */
int jmi_init_dF1(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * Returns the number of non-zeros in the Jacobian of the F1 initialization function.
 */
int jmi_init_dF1_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * Returns the row and column indices of the non-zero elements of the Jacobian of the F1
 * initialization function.
 */
int jmi_init_dF1_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * This helper function computes the number of columns and the number of non zero
 * elements in the Jacobian of the F1 init function given a sparsity configuration.
 */
int jmi_init_dF1_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);


/* @} */


/*********************************************
 *
 * Optimization interface
 *
 ********************************************/

/**
 * \defgroup Optimization Optimization interface
 */
/* @{ */


/**
 * Set the optimization interval. This function should be called prior to using other
 * functions in the optimization interface.
 */
int jmi_opt_set_optimization_interval(jmi_t *jmi, double start_time, int start_time_free,
		                              double final_time, int final_time_free);


/**
 * Specify the optimization interval.
 */
int jmi_opt_set_optimization_interval(jmi_t *jmi, double start_time, int start_time_free,
		                              double final_time, int final_time_free);

/**
 * Get the optimization interval.
 */
int jmi_opt_get_optimization_interval(jmi_t *jmi, double *start_time, int *start_time_free,
		                              double *final_time, int *final_time_free);


/**
 * Specify optimization parameters. p_opt_indices contains the indices of the
 * parameters to be optimized in the pi vector.
 */
int jmi_opt_set_p_opt_indices(jmi_t *jmi, int n_p_opt, int *p_opt_indices);

/**
 * Get the number of optimization parameters.
 */
int jmi_opt_get_n_p_opt(jmi_t *jmi, int *n_p_opt);

/**
 * Get the optimization parameter indices.
 */
int jmi_opt_get_p_opt_indices(jmi_t *jmi, int *p_opt_indices);



/**
 * Get the number of equations in the optimization functions.
 */
int jmi_opt_get_sizes(jmi_t* jmi, int* n_eq_Ceq, int* n_eq_Cineq, int* n_eq_Heq, int* n_eq_Hineq);

/**
 * Evaluate the cost function J.
 */
int jmi_opt_J(jmi_t* jmi, jmi_real_t* J);

/**
 * Evaluate the Jacobian of J.
 */
int jmi_opt_dJ(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * Returns the number of non-zeros in the Jacobian of J.
 */
int jmi_opt_dJ_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * Returns the row and column indices of the non-zero elements of the Jacobian of J.
 */
int jmi_opt_dJ_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * This helper function computes the number of columns and the number of non zero
 * elements in the Jacobian of the const function J given a sparsity configuration.
 */
int jmi_opt_dJ_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * Evaluate the equality constraint function Ceq.
 */
int jmi_opt_Ceq(jmi_t* jmi, jmi_real_t* res);

/**
 * Evaluate the Jacobian of Ceq.
 */
int jmi_opt_dCeq(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * Returns the number of non-zeros in the Jacobian of Ceq.
 */
int jmi_opt_dCeq_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * Returns the row and column indices of the non-zero elements of the Jacobian of Ceq.
 */
int jmi_opt_dCeq_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * This helper function computes the number of columns and the number of non zero
 * elements in the Jacobian of Ceq given a sparsity configuration.
 */
int jmi_opt_dCeq_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * Evaluate the equality constraint function Cineq.
 */
int jmi_opt_Cineq(jmi_t* jmi, jmi_real_t* res);

/**
 * Evaluate the Jacobian of Cineq.
 */
int jmi_opt_dCineq(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * Returns the number of non-zeros in the Jacobian of Cineq.
 */
int jmi_opt_dCineq_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * Returns the row and column indices of the non-zero elements of the Jacobian of Cineq.
 */
int jmi_opt_dCineq_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * This helper function computes the number of columns and the number of non zero
 * elements in the Jacobian of Cineq given a sparsity configuration.
 */
int jmi_opt_dCineq_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * Evaluate the equality constraint function Heq.
 */
int jmi_opt_Heq(jmi_t* jmi, jmi_real_t* res);

/**
 * Evaluate the Jacobian of Heq.
 */
int jmi_opt_dHeq(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * Returns the number of non-zeros in the Jacobian of Heq.
 */
int jmi_opt_dHeq_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * Returns the row and column indices of the non-zero elements of the Jacobian of Heq.
 */
int jmi_opt_dHeq_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * This helper function computes the number of columns and the number of non zero
 * elements in the Jacobian of Heq given a sparsity configuration.
 */
int jmi_opt_dHeq_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * Evaluate the equality constraint function Hineq.
 */
int jmi_opt_Hineq(jmi_t* jmi, jmi_real_t* res);

/**
 * Evaluate the Jacobian of Hineq.
 */
int jmi_opt_dHineq(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * Returns the number of non-zeros in the Jacobian of Hineq.
 */
int jmi_opt_dHineq_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * Returns the row and column indices of the non-zero elements of the Jacobian of Hineq.
 */
int jmi_opt_Hineq_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * This helper function computes the number of columns and the number of non zero
 * elements in the Jacobian of Hineq given a sparsity configuration.
 */
int jmi_opt_dHineq_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/* @} */

#endif


/* @} */
