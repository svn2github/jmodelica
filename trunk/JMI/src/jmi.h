 /*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 3 as published
    by the Free Software Foundation, or optionally, under the terms of the
    Common Public License version 1.0 as published by IBM.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License, or the Common Public License, for more details.

    You should have received copies of the GNU General Public License
    and the Common Public License along with this program.  If not,
    see <http://www.gnu.org/licenses/> or
    <http://www.ibm.com/developerworks/library/os-cpl.html/> respectively.
*/


/** \file jmi.h
 *  \brief The public JMI model interface.
 **/

/** \mainpage The JModelica.org C runtime library
 *
 * The JModelica C runtime library contains functions and data structures for
 * accessing the C model representation that is generated by the JModelica
 * Modelica and Optimica front-ends, respectively. The library is organized into
 * three main parts.
 *
 *  \section jmi_model_interface The JMI Model interface
 *   The JMI Model interface interface contains functions
 *    for evaluating the function generated by the compiler, including the DAE residual, the
 *    residual functions for the DAE initialization problem, and the functions related to
 *    the optimization problem such as cost functions and constraint residual functions.
 *    The JMI Model interface also supports evaluation of symbolic Jacobians (if available)
 *    and/or Jacobians computed by means of automatic differentiation. Sparsity patterns for
 *    Jacobians are supported.
 *      - <a href="group__Jmi.html"> Documentation of the public JMI Model interface </a>
 *      - <a href="group__Jmi__internal.html"> Documentation of the internal JMI Model interface </a>
 *  \section jmi_algorithm_interface The JMI Algorithm interface
 *    Based on the JMI Model interface, algorithms (in particular
 *    optimization algorithms) are implemented. These includes a framework for implementation of
 *    simultaneous optimization algorithms as well as a particular implementation of an algorithm
 *    based on Lagrange polynomials on Radau points.
 *     - <a href="group__jmi__init__opt.html"> Documentation of DAE initialization
 *     optimization algorithm.</a>
 *     - <a href="group__jmi__opt__sim.html"> Documentation of simultaneous
 *     interface optimization </a>
 *     - <a href="group__jmi__opt__sim__lp.html"> Documentation of implementation
 *     based on Lagrange polynomials and Radau points</a>
 *  \section jmi_solver_interface The JMI Solver interface
 *    Typically, the JMI Model and Algorithm interfaces are intended to
 *    be integrated with numerical solvers. Currently, the JMI interface provides
 *    an interface to the NLP solver Ipopt (https://projects.coin-or.org/Ipopt).
 *     - <a href="group__jmi__init__opt__ipopt.html"> Documentation of the Ipopt
 *     interface to the DAE initialization optimization algorithm</a>
 *     - <a href="group__jmi__opt__sim__ipopt.html"> Documentation of the Ipopt
 *     interface to the JMI simultaneous optimization interface</a>
 *
 * \section limitations Limitations
 * The JModelica.org JMI interface in under development. The function signatures
 * are likely to change in the future - all feedback is very welcome. The following
 * limitations apply:
 *   - Minimum time problems are not supported.
 *   - Optimization of element lengths in the JMI simultaneous optimization
 *   interface is not supportd.
 *   - Symbolic Jacobians are not provided by the compiler. This is actually
 *   a limitation in the code generation module, but as a consequence, the
 *   JMI_DER_SYMBOLIC flag cannot be used in the JMI interface.
 *   - The ODE interface is very limited and requires a Modelica model to be
 *   stated on explicit ODE form (\f$\dot x=f(x,u)\f$) in order to work.
 *
 */

/**
 * \defgroup Jmi The JMI Model interface
 *
 * \brief Documentation of the public JMI Model interface.
 *
 *  \section DesignConsiderations Design considerations
 *
 * The JMI Model interface is intended to be used in a wide range of
 * applications and on multiple platforms. This also includes embedded
 * platforms in HILS applications.
 *
 * It is desirable that the JMI Model interface can be easily interfaced
 * with Python. Python is the intended language for scripting in JModelica and it is
 * therefore important that the generated code is straight forward to use with the
 * Python extensions or ctypes framework.
 *
 * The JMI Model interface is intended to be used by wide range of users,
 * with different backgrounds and programming skills. It is therefore desirable that
 * the interface is as simple and intuitive as possible.
 *
 * Given these motivations, it is reasonable to use pure C where possible, and to a
 * limited extent C++ where needed (e.g. in solver interfaces and in most likely in the
 * AD framework).
 *
 * It should also be possible to build shared libraries, in order to.
 * build applications that contains several models.
 *
 *
 * \section MathDescr Mathematical description of the JMI Model interface
 *
 *   The jmi interface consists of three parts: DAE, DAE initialization and optimization.
 *   Essentially, the jmi interface consists of a collection of functions that are
 *   offered to the user for evaluation of the DAE residual, cost functions, constraints
 *   etc. These functions takes as arguments one more of the following three argument
 *   types:
 *
 *   Parameters (denoted \f$p\f$):
 *    - \f$c_i\f$   independent constant
 *    - \f$c_d\f$   dependent constants
 *    - \f$p_i\f$   independent parameters
 *    - \f$p_d\f$   dependent parameters
 *
 *    with
 *
 *      \f$ p = [c_i^T, c_d^T, p_i^T, p_d^T]^T \f$
 *
 *   Variables (denoted \f$v\f$):
 *
 *    - \f$\dot x\f$    differentiated variables
 *    - \f$x\f$     variables that appear differentiated
 *    - \f$u\f$     inputs
 *    - \f$w\f$     algebraic variables
 *    - \f$t\f$     time
 *
 *    with
 *
 *    \f$v = [\dot x^T, x^T, u^T, w^T, t]^T\f$
 *
 *   Variables defined at particular time instants (denoted \f$q\f$):
 *
 *      - \f$\dot x(t_i)\f$    differentiated variables evaluated at time \f$t_i, i \in 1..n_{tp}\f$
 *      - \f$x(t_i)\f$     variables that appear differentiated evaluated at time \f$t_i, t_i \in 1..n_{tp}\f$
 *      - \f$u(t_i)\f$     inputs evaluated at time \f$t_i, i \in 1..n_{tp}\f$
 *      - \f$w(t_i)\f$     algebraic variables evaluated at time \f$t_i, i \in 1..n_{tp}\f$
 *
 *    \f$ q = [\dot x(t_1)^T, x(t_1)^T, u(t_1)^T, w(t_1)^T, ...,
 *           \dot x(t_{n_{tp}})^T, x(t_{n_{tp}})^T, u(t_{n_{tp}})^T, w(t_{n_{tp}})^T]^T\f$
 *
 *   All parameters, variables and point-wise evaluated variables are denoted z:
 *
 *     \f$ z = [p^T, v^T, q^T]^T \f$
 *
 *   \subsection DAE The DAE interface
 *
 *   The DAE interface is defined by the residual function \f$F(p,v)\f$ where
 *
 *     \f$ F(p,v) = 0 \f$
 *
 *	For details on the functions included in the DAE interface, see the <a href="group__DAE.html">DAE functions documentation. </a>
 *
 *    \subsection Init The DAE initialization interface
 *
 *	 The DAE initialization interface is defined by the functions \f$F_0(p,v)\f$ and \f$F_1(p,v)\f$ where
 *
 *	  \f$  F_0(p,v) = 0 \f$<br>
 *	  \f$  F_1(p,v) = 0 \f$
 *
 *   \f$F_0\f$ represents the DAE system augmented with additional initial equations
 *   and start values that are fixed. \f$F_1\f$ on the other hand contains equations for
 *   initialization of variables for which the value given in the start attribute is
 *   not fixed.
 *
 *   In addition, a residual function for dependent parameters is provided
 *
 *	  \f$  F_p(ci,cd,pi,pd) = 0 \f$
 *
 *   The iteration variables of this system are the elements in the \f$p_d\f$
 *   vector.
 *
 *   For details on the functions included in the DAE initialization interface, see the
 *   <a href="group__Initialization.html">DAE initialization functions documentation. </a>
 *
 *   \subsection Ode_interface The ODE interface
 *
 *   The ODE interace is defined by the relation
 *
 *   \f$\dot x = f(p,x,u,t). \f$
 *
 *   WARNING: The current version of the JMI interface supports only Modelica
 *   models which are written explicitly on ODE form. Accordingly, no
 *   algebraic variables are supported in this version.
 *
 *   \subsection Opt The optimization interface
 *
 *   The optimization part of the interface is defined by the functions \f$J(p,q)\f$,
 *   \f$C_{eq}(p,v,q)\f$, \f$C_{ineq}(p,v,q)\f$, \f$H_{eq}(p,q)\f$, \f$H_{ineq}(p,q)\f$.
 *   Based on these functions, an optimization problem is then formulated as
 *
 *      \f$\min_{p^{opt},u}J(p,q)\f$<br>
 *      subject to <br>
 *      \f$C_{eq}(p,v,q) = 0\f$<br>
 *      \f$C_{ineq}(p,v,q) \leq 0\f$<br>
 *      \f$H_{eq}(p,q) = 0\f$<br>
 *      \f$H_{ineq}(p,q) \leq 0\f$<br>
 *
 *   where \f$J\f$ is the cost function to be minimized, \f$C_{eq}\f$ are path equality constraints,
 *   \f$C_{ineq}\f$ are path inequality constraints, \f$H_{eq}\f$ are (time) point equality constraints,
 *   and \f$H_{ineq}\f$ are (time) point inequality constraints. The rationale for introducing
 *   \f$H_{eq}\f$ and \f$H_{ineq}\f$ is to enable expression of e.g. terminal constraints. In addition, the
 *   DAE and the DAE initialization relations are constraints in the optimization problem.
 *   The \f$n_{p^{opt}}\f$ optimization parameters \f$p^{opt}\f$ are a subset
 *   of the \f$p_i\f$
 *
 *   The optimization problem is defined on the interval \f$[t_0,t_f]\f$, where \f$t_0\f$ and \f$t_f\f$,
 *   respectively, can be free or fixed.
 *
 * For details on the functions included in the optimization interface, see the
 * <a href="group__Optimization.html">optimization functions documentation. </a>
 *
 *  \section Jacobians Evaluation of Jacobians
 *
 *  Evaluation of Jacobians is controlled by four arguments:
 *
 *   - eval_alg    This argument is used to select the method evaluation
 *                     for the Jacobian. JMI_DER_SYMBOLIC and JMI_DER_CPPAD
 *                     is currently supported.
 *   - sparsity          This argument is a mask that selects whether
 *                     sparse or dense evaluation of the Jacobian should
 *                     be used. The constants JMI_DER_SPARSE are used to
 *                     specify a sparse Jacobian, whereas JMI_DER_DENSE_COL_MAJOR
 *                     and JMI_DER_DENSE_ROW_MAJOR are used to specify dense
 *                     column major or row major Jacobians respectively.
 *   - independent_vars  This argument is used to specify which variable types
 *                     are considered to be independent variables in the Jacobian
 *                     evaluation. The constants JMI_DER_NN are used to indicate that
 *                     the Jacobian w.r.t. a particular vector should be evaluated.
 *   - mask              This array has the same size as the number of column of the dense
 *                     Jacobian (equal to the size of the vector \f$z\f$), and holds the value of 0 if the corresponding Jacobian
 *                     column should not be computed. If the value of an entry in
 *                     mask i 1, then the corresponding Jacobian column will be evaluated.
 *                     The evaluated Jacobian columns are stored in the first
 *                     entries of the output argument jac.
 *
 *  TODO: It may be interesting to include an additional layer that enables
 *  support for partially defined Jacobians. This would be beneficial if symbolic
 *  expressions for the Jacobian is available for some entries, but for other
 *  an AD algorithm is to be used.
 *
 * \section ErrorHandling Error handling
 */

#ifndef _JMI_H
#define _JMI_H

#include "jmi_common.h"

/* @{ */

#ifdef __cplusplus
extern "C" {
#endif

/**
 * \defgroup Defines Defined constants
 * \brief Constants defined in the JMI Model interface.
 */
/* @{ */

#define JMI_INF 1e20; /**< \brief A Very Large Number denoting infinity.*/

#define JMI_DER_SYMBOLIC 1 /**< \brief Use symbolic evaluation of derivatives (if available). */
#define JMI_DER_CPPAD 2 /**< \brief Use automatic differentiation (CppAD) to evaluate derivatives. */

#define JMI_DER_SPARSE 1 /**< \brief Sparse evaluation of derivatives. */
#define JMI_DER_DENSE_COL_MAJOR 2 /**<  \brief Dense evaluation (column major) of derivatives. */
#define JMI_DER_DENSE_ROW_MAJOR 4 /**<  \brief Dense evaluation (row major) of derivatives. */

// Flags for evaluation of Jacobians w.r.t. parameters in the p vector
#define JMI_DER_CI 1 /**<  \brief Evaluate derivatives w.r.t. independent constants, \f$c_i\f$.*/
#define JMI_DER_CD 2 /**<  \brief Evaluate derivatives w.r.t. dependent constants, \f$c_d\f$.*/
#define JMI_DER_PI 4 /**<  \brief Evaluate derivatives w.r.t. independent parameters, \f$p_i\f$.*/
#define JMI_DER_PD 8 /**<  \brief Evaluate derivatives w.r.t. dependent constants, \f$p_d\f$.*/
// Flags for evaluation of Jacobians w.r.t. variables in the v vector
#define JMI_DER_DX 16 /**<  \brief Evaluate derivatives w.r.t. derivatives, \f$\dot x\f$.*/
#define JMI_DER_X 32 /**<  \brief Evaluate derivatives w.r.t. differentiated variables, \f$x\f$.*/
#define JMI_DER_U 64 /**<  \brief Evaluate derivatives w.r.t. inputs, \f$u\f$.*/
#define JMI_DER_W 128 /**<  \brief Evaluate derivatives w.r.t. algebraic variables, \f$w\f$.*/
#define JMI_DER_T 256 /**<  \brief Evaluate derivatives w.r.t. time, \f$t\f$.*/
// Flags for evaluation of Jacobians w.r.t. variables in the q vector
#define JMI_DER_DX_P 512 /**<  \brief Evaluate derivatives w.r.t. derivatives at time points, \f$\dot x_p\f$.*/
#define JMI_DER_X_P 1024 /**<  \brief Evaluate derivatives w.r.t. differentiated variables at time points, \f$x_p\f$.*/
#define JMI_DER_U_P 2048 /**<  \brief Evaluate derivatives w.r.t. inputs at time points, \f$u_p\f$.*/
#define JMI_DER_W_P 4096 /**<  \brief Evaluate derivatives w.r.t. algebraic variables at time points, \f$w_p\f$.*/

/** \brief Evaluate derivatives w.r.t. all variables, \f$z\f$.*/
#define JMI_DER_ALL (JMI_DER_CI | JMI_DER_CD | JMI_DER_PI | JMI_DER_PD |\
	JMI_DER_DX | JMI_DER_X | JMI_DER_U | JMI_DER_W |\
	JMI_DER_T | JMI_DER_DX_P | JMI_DER_X_P | JMI_DER_U_P | JMI_DER_W_P)


/**  \brief Evaluate derivatives w.r.t. all variables in \f$p\f$.*/
#define JMI_DER_ALL_P JMI_DER_CI | JMI_DER_CD | JMI_DER_PI | JMI_DER_PD

/**  \brief Evaluate derivatives w.r.t. all variables in \f$v\f$.*/
#define JMI_DER_ALL_V JMI_DER_DX | JMI_DER_X | JMI_DER_U | JMI_DER_W |\
	JMI_DER_T

/**  \brief Evaluate derivatives w.r.t. all variables in \f$q\f$.*/
#define JMI_DER_ALL_Q  JMI_DER_DX_P | JMI_DER_X_P | JMI_DER_U_P | JMI_DER_W_P

/* @} */

/*
 *****************************************
 *
 *    Public interface
 *
 ****************************************
 */

/**
 * \defgroup jmi_struct Creation, initialization and destruction of jmi_t structs
 * \brief The main data structure in the JMI Model interface is jmi_t, which contains
 * all information needed to evaluate the functions in the JMI Model interface.
 *
 * Typically,
 * a pointer to a jmi_t struct is passed as the first argument to functions in the interface.
 *
 *
 */

/* @{ */

/**
 * \brief Create a new jmi_t struct.
 *
 * This function creates a new jmi struct, for which a pointer is returned in the output argument jmi.
 *
 * Typically this function is defined in the generated code.
 *
 * @param jmi A pointer to a jmi_t pointer where the new jmi_t struct is stored.
 * @return Error code.
 */
int jmi_new(jmi_t** jmi);

/**
 * Initializes the AD variables and tapes.
 *
 * Prior to this call, the variables in z should
 * be initialized, which is also the reason why this function must be provided for
 * the user to call after the actual creation of the jmi_t struct.
 *
 * @param jmi A pointer to a jmi_t struct.
 * @return Error code.
 */
int jmi_ad_init(jmi_t* jmi);

/**
 * Deallocates memory and deletes a jmi_t struct.
 *
 * @param jmi A pointer to the jmi_t struc to be deleted.
 */
int jmi_delete(jmi_t* jmi);

/* @} */

/**
 * \defgroup Access Setters and getters for the fields in jmi_t
 *
 * \brief The fields of jmi_t are conveniently accessed using the setter and getter
 * functions provided in the JMI Model interface.
 *
 * Notice that it is not recommended to access the fields directely, since the internal
 * implementation of jmi_t may change, wheras the setters and getters are less likely to
 * do so.
 *
 */

/* @{ */

/**
 * \brief Get the sizes of the variable vectors.
 *
 * @param jmi The jmi_t struct.
 * @param n_ci (Output) number of independent constants.
 * @param n_cd (Output) number of dependent constants.
 * @param n_pi (Output) number of independent parameters.
 * @param n_pd (Output) number of dependent parameters.
 * @param n_dx (Output) number of derivatives.
 * @param n_x (Output) number of differentiated variables.
 * @param n_u (Output) number of inputs.
 * @param n_w (Output) number of algebraic variables.
 * @param n_tp (Output) number of time points included in the model.
 * @param n_sw (output) number of switching functions in the DAE \f$F\f$.
 * @param n_sw_init (output) number of switching functions in the initialization system \f$F_0\f$.
 * @param n_z (Output) total number of variables in the \f$z\f$ vector.
 * @return Error code.
 *
 */
int jmi_get_sizes(jmi_t* jmi, int* n_ci, int* n_cd, int* n_pi, int* n_pd,
		int* n_dx, int* n_x, int* n_u, int* n_w, int* n_tp, int* n_sw, int* n_sw_init, int* n_z);

/**
 * \brief Get the offsets for the variable types in the \f$z\f$ vector.
 *
 * @param jmi The jmi_t struct.
 * @param offs_ci (Output) offset of independent constants.
 * @param offs_cd (Output) offset of dependent constants.
 * @param offs_pi (Output) offset of independent parameters.
 * @param offs_pd (Output) offset of dependent parameters.
 * @param offs_dx (Output) offset of derivatives.
 * @param offs_x (Output) offset of differentiated variables.
 * @param offs_u (Output) offset of inputs.
 * @param offs_w (Output) offset of algebraic variables.
 * @param offs_t (Output) offset of time.
 * @param offs_dx_p (Output) offset of the first derivatives in the time point part of \f$z\f$.
 * @param offs_x_p (Output) offset of the first differentiated variables in the time point part of \f$z\f$.
 * @param offs_u_p (Output) offset of the first inputs in the time point part of \f$z\f$.
 * @param offs_w_p (Output) offset of the first algebraic variables in the time point part of \f$z\f$.
 * @param offs_sw (Output) offset of the first switching function in the DAE \f$F_0\f$.
 * @param offs_sw_init (Output) offset of the first switching function in the initialization system \f$F_0\f$.
 * @return Error code.
 */
int jmi_get_offsets(jmi_t* jmi, int* offs_ci, int* offs_cd, int* offs_pi, int* offs_pd,
		int* offs_dx, int* offs_x, int* offs_u, int* offs_w, int* offs_t,
		int* offs_dx_p, int* offs_x_p, int* offs_u_p, int* offs_w_p, int* offs_sw, int* offs_sw_init);

/**
 * \brief Get the number of time points.
 *
 * @param jmi The jmi_t struct.
 * @param n_tp (Output) number of time points in the model.
 * @return Error code.
 *Ê
 */
int jmi_get_n_tp(jmi_t *jmi, int *n_tp);

/**
 * \brief Set the vector of time points included in the problem.
 *
 * @param jmi The jmi_t struct.
 * @param tp A pointer to a jmi_real_t array of size n_tp that contains the time
 * points. Notice that the time points should be normalized to the interval
 * [0,1], where 0 corresponds to the interval start time and where 1 corresponds
 * to the interval final time.
 * @return Error code.
 *
 */
int jmi_set_tp(jmi_t *jmi, jmi_real_t *tp);

/**
 * \brief Get the vector of time points included in the problem.
 *
 * @param jmi The jmi_t struct.
 * @param tp (Output) a pointer to a jmi_real_t array of size n_tp.
 * Upon return the array contains the normalized time points of the model.
 * @return Error code.
 *
 */
int jmi_get_tp(jmi_t *jmi, jmi_real_t *tp);

/**
 * \brief Get a pointer to the z vector containing all real variables.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$z\f$ vector.
 *
 */
jmi_real_t* jmi_get_z(jmi_t* jmi);


/**
 * \brief Get a pointer to the independent constants vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$c_i\f$ vector.
 *
 */
jmi_real_t* jmi_get_ci(jmi_t* jmi);

/**
 * \brief Get a pointer to the dependent constants vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$c_d\f$ vector.
 *
 */
jmi_real_t* jmi_get_cd(jmi_t* jmi);

/**
 * \brief Get a pointer to the independent parameter vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$p_i\f$ vector.
 *
 */
jmi_real_t* jmi_get_pi(jmi_t* jmi);

/**
 * \brief Get a pointer to the dependent parameters vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$p_d\f$ vector.
 *
 */
jmi_real_t* jmi_get_pd(jmi_t* jmi);

/**
 * \brief Get a pointer to the derivatives vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$dx\f$ vector.
 *
 */
jmi_real_t* jmi_get_dx(jmi_t* jmi);

/**
 * \brief Get a pointer to the differentiated variables vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$x\f$ vector.
 *
 */
jmi_real_t* jmi_get_x(jmi_t* jmi);

/**
 * \brief Get a pointer to the inputs vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$u\f$ vector.
 *
 */
jmi_real_t* jmi_get_u(jmi_t* jmi);

/**
 * \brief Get a pointer to the algebraic variables vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$w\f$ vector.
 *
 */
jmi_real_t* jmi_get_w(jmi_t* jmi);

/**
 * \brief Get a pointer to the time value.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to \f$t\f$.
 *
 */
jmi_real_t* jmi_get_t(jmi_t* jmi);

/**
 * \brief Get a pointer to the derivatives corresponding to the i:th time point.
 *
 * @param jmi The jmi_t struct.
 * @param i Index of the time point: 0 corresponds to first time point.
 * @return A pointer to the \f$dx_{p,i}\f$ vector.
 *
 */
jmi_real_t* jmi_get_dx_p(jmi_t* jmi,int i);

/**
 * \brief Get a pointer to the differentiated variables corresponding to the i:th time point.
 *
 * @param jmi The jmi_t struct.
 * @param i Index of the time point: 0 corresponds to first time point.
 * @return A pointer to the \f$x_{p,i}\f$ vector.
 *
 */
jmi_real_t* jmi_get_x_p(jmi_t* jmi, int i);

/**
 * \brief Get a pointer to the inputs corresponding to the i:th time point.
 *
 * @param jmi The jmi_t struct.
 * @param i Index of the time point: 0 corresponds to first time point.
 * @return A pointer to the \f$u_{p,i}\f$ vector.
 *
 */
jmi_real_t* jmi_get_u_p(jmi_t* jmi, int i);

/**
 * \brief Get a pointer to the algebraic variables corresponding to the i:th time point.
 *
 * @param jmi The jmi_t struct.
 * @param i Index of the time point: 0 corresponds to first time point.
 * @return A pointer to the \f$w_{p,i}\f$ vector.
 *
 */
jmi_real_t* jmi_get_w_p(jmi_t* jmi, int i);

/**
 * \brief Get a pointer to the first switching function in the DAE \$fF\$f.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the vector of switching functions.
 *
 */
jmi_real_t* jmi_get_sw(jmi_t* jmi);

/**
 * \brief Get a pointer to the first switching function in the initialization system \$fF_0\$f.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the vector of switching functions.
 *
 */
jmi_real_t* jmi_get_sw_init(jmi_t* jmi);


/* @} */


/*********************************************
 *
 * DAE interface
 *
 ********************************************/

/**
 * \defgroup ODE ODE interface
 * \brief Access to the ODE representation.
 *
 * WARNING: The current version of the ODE interface is very limited and
 * requires that the Modelica model is explicitly given on ODE form.
 * Accordingly, algebraic variables are not supported.
 */
/* @{ */


/**
 * \brief Evaluate the right hand side of the ODE.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_x, ::jmi_get_u etc. The
 * output (the values of the derivatives) is available after a call to
 * ::jmi_ode_f in the vector obtained by calling ::jmi_get_dx.
 *
 * @param jmi A jmi_t struct.
 * @return Error code.
 *
 */
int jmi_ode_f(jmi_t* jmi);

/**
 * \brief Evaluate the Jacobian of the right hand side of the ODE.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_x, ::jmi_get_u etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg Set to either JMI_DER_SYMBOLIC to evaluate a symbolic Jacobian or
 *                 JMI_DER_CPPAD to evaluate the Jacobian by means of CppAD.
 * @param sparsity Set to JMI_DER_SPARSE, JMI_DER_DENSE_COL_MAJOR, or JMI_DER_DENS_ROW_MAJOR
 *                to indicate the output format of the Jacobian.
 * @param independent_vars Used to indicate which columns of the full Jacobian should
 *                         be evaluated. The constants JMI_DER_X, JMI_DER_DX etc are used
 *                         to set this argument. Setting independent_vars to
 *                         JMI_DER_DX has no effect.
 * @param mask This argument is a vector containing ones for the Jacobian columns that
 *             should be included in the Jacobian and zeros for those which should not.
 *             The size of this vector is the same as the z vector.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_ode_df(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the Jacobian of the right hand
 * side of the ODE.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg Indicates which for which Jacobian the number of non-zero elements should be returned:
 *                 Symbolic (JMI_DER_SYMBOLIC) or CppAD (JMI_DER_CPPAD).
 * @param n_nz (Output) The number of non-zero Jacobian entries.
 * @return Error code.
 */
int jmi_ode_df_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the
 * Jacobian of the right hand side.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_ode_df_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
		                  int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non zero
 * elements in the Jacobian of the right hand side of the ODE given a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param df_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param df_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_ode_df_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *df_n_cols, int *df_n_nz);

/* @} */

/*********************************************
 *
 * DAE interface
 *
 ********************************************/

/**
 * \defgroup DAE DAE interface
 * \brief Access to the DAE residual function.
 *
 */
/* @{ */


/**
 * \brief Get the number of equations of the DAE and the number of event
 * indicator residuals.
 *
 * @param jmi A jmi_t struct.
 * @param n_eq_F (Output) The number of DAE equations is stored in this
 * argument.
 * @param n_eq_R (Output) The number of DAE event indicator residuals is
 * stored in this argument.
 * @return Error code.
 */
int jmi_dae_get_sizes(jmi_t* jmi, int* n_eq_F, int* n_eq_R);


/**
 * \brief Evaluate DAE residual.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res (Output) The DAE residual vector.
 * @return Error code.
 *
 */
int jmi_dae_F(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the DAE residual function.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg Set to either JMI_DER_SYMBOLIC to evaluate a symbolic Jacobian or
 *                 JMI_DER_CPPAD to evaluate the Jacobian by means of CppAD.
 * @param sparsity Set to JMI_DER_SPARSE, JMI_DER_DENSE_COL_MAJOR, or JMI_DER_DENS_ROW_MAJOR
 *                to indicate the output format of the Jacobian.
 * @param independent_vars Used to indicate which columns of the full Jacobian should
 *                         be evaluated. The constants JMI_DER_DX, JMI_DER_X etc are used
 *                         to set this argument.
 * @param mask This argument is a vector containing ones for the Jacobian columns that
 *             should be included in the Jacobian and zeros for those which should not.
 *             The size of this vector is the same as the z vector.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_dae_dF(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full DAE residual Jacobian.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg Indicates which for which Jacobian the number of non-zero elements should be returned:
 *                 Symbolic (JMI_DER_SYMBOLIC) or CppAD (JMI_DER_CPPAD).
 * @param n_nz (Output) The number of non-zero Jacobian entries.
 * @return Error code.
 */
int jmi_dae_dF_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the DAE
 * residual Jacobian.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the DAE residual Jacobian.
 * @param col (Output) The column indices of the non-zeros in the DAE residual Jacobian.
 * @return Error code.
 *
 */
int jmi_dae_dF_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
		                  int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non zero
 * elements in the Jacobian of the DAE residual given a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_dae_dF_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate DAE event indicator residuals.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res (Output) The event indicator residuals.
 * @return Error code.
 *
 */
int jmi_dae_R(jmi_t* jmi, jmi_real_t* res);

/* @} */

/*********************************************
 *
 * Initialization interface
 *
 ********************************************/

/**
 * \defgroup Initialization DAE Initialization Interface
 * \brief Access to the DAE initialization functions.
 */
/* @{ */

/**
 * \brief Get the number of equations in the DAE initialization functions.
 *
 * @param jmi A jmi_t struct.
 * @param n_eq_F0 (Output) The number of equations in \f$F_0\f$ is stored in this argument.
 * @param n_eq_F1 (Output) The number of equations in \f$F_1\f$ is stored in this argument.
 * @param n_eq_Fp (Output) The number of equations in \f$F_p\f$ is stored in this argument.
 * @param n_eq_R0 (Output) The number of equations in \f$R_0\f$ is stored in this argument.
 * @return Error code.
 *
 */
int jmi_init_get_sizes(jmi_t* jmi, int* n_eq_F0, int* n_eq_F1, int* n_eq_Fp,
		int* n_eq_R0);

/**
 * \brief Evaluate the \f$F_0\f$ residual function of the initialization system.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual of \f$F_0\f$.
 * @return Error code.
 */
int jmi_init_F0(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the DAE initialization residual function \f$F_0\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_init_dF0(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the DAE initialization residual function \f$F_0\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_init_dF0_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobain of the DAE
 * initialization residual function \f$F_0\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_init_dF0_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the DAE initialization residual function \f$F_0\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_init_dF0_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate the \f$F_1\f$ residual function of the initialization system.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual of \f$F_1\f$.
 * @return Error code.
 */
int jmi_init_F1(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the DAE initialization residual function \f$F_1\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_init_dF1(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the DAE initialization residual function \f$F_1\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_init_dF1_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobain of the DAE
 * initialization residual function \f$F_1\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_init_dF1_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the DAE initialization residual function \f$F_1\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_init_dF1_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate the \f$F_p\f$ residual function of the initialization system.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual of \f$F_p\f$.
 * @return Error code.
 */
int jmi_init_Fp(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the DAE initialization residual function \f$F_p\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_init_dFp(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the DAE initialization residual function \f$F_p\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_init_dFp_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobain of the DAE
 * initialization residual function \f$F_p\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_init_dFp_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the DAE initialization residual function \f$F_p\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_init_dFp_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate DAE event indicator residuals for the initialization system.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res (Output) The event indicator residuals.
 * @return Error code.
 *
 */
int jmi_init_R0(jmi_t* jmi, jmi_real_t* res);

/* @} */


/*********************************************
 *
 * Optimization interface
 *
 ********************************************/

/**
 * \defgroup Optimization Optimization interface
 * \brief Access to the optimization functions.
 */
/* @{ */


/**
 * \brief Set the optimization interval.
 *
 * This function should be called prior to using other
 * functions in the optimization interface.
 *
 * @param jmi A jmi_t struct.
 * @param start_time The start time of the optimization interval.
 * @param start_time_free Set to 0 if the start time of the optimization interval is fixed
 *                        or 1 if the start time is free. CURRENTLY NOT SUPPORTED.
 * @param final_time Final time of the optimization interval.
 * @param final_time_free Set to 0 if the final time of the optimization interval is fixed
 *                        or 1 if the final time is free. CURRENTLY NOT SUPPORTED.
 * @return Error code.
 *
 */
int jmi_opt_set_optimization_interval(jmi_t *jmi, double start_time, int start_time_free,
		                              double final_time, int final_time_free);

/**
 * \brief Get the optimization interval.
 *
 * @param jmi A jmi_t struct.
 * @param start_time (Output) The start time of the optimization interval.
 * @param start_time_free (Output) 0 if the start time of the optimization interval is fixed
 *                        or 1 if the start time is free.
 * @param final_time (Output) Final time of the optimization interval.
 * @param final_time_free (Output) 0 if the final time of the optimization interval is fixed
 *                        or 1 if the final time is free.
 * @return Error code.
 *
 */
int jmi_opt_get_optimization_interval(jmi_t *jmi, double *start_time, int *start_time_free,
		                              double *final_time, int *final_time_free);


/**
 * \brief Specify optimization parameters of the model.
 *
 * Typically only a few model parameters are optimized. Using this function, the
 * indices of the parameters in the independent parameters vector, \f$p_i\f$ is set.
 *
 * @param jmi A jmi_t struct.
 * @param n_p_opt The number of parameters to be optimized.
 * @param p_opt_indices The indices of the parameters to be optimized in the
 *                      \f$p_i\f$ vector.
 * @return Error code.
 */
int jmi_opt_set_p_opt_indices(jmi_t *jmi, int n_p_opt, int *p_opt_indices);

/**
 * \brief Get the number of optimization parameters.
 *
 * @param jmi A jmi_t struct.
 * @param n_p_opt (Output) The number of parameters to be optimized.
 * @return Error code.
 *
 */
int jmi_opt_get_n_p_opt(jmi_t *jmi, int *n_p_opt);

/**
 * \brief Get the optimization parameter indices.
 *
 * @param jmi A jmi_t struct.
 * @param p_opt_indices (Output) The indices of the parameters to be optimized in the
 *                      \f$p_i\f$ vector.
 * @return Error code.
 *
 */
int jmi_opt_get_p_opt_indices(jmi_t *jmi, int *p_opt_indices);

/**
 * \brief Get the sizes of the the optimization functions.
 *
 * @param jmi A jmi_t struct.
 * @param n_eq_Ceq (Output) The number of equations in the \f$C_{eq}\f$ residual.
 * @param n_eq_Cineq (Output) The number of equations in the \f$C_{ineq}\f$ residual.
 * @param n_eq_Heq (Output) The number of equations in the \f$H_{eq}\f$ residual.
 * @param n_eq_Hineq (Output) The number of equations in the \f$H_{ineq}\f$ residual.
 * @return Error code.
 *
 */
int jmi_opt_get_sizes(jmi_t* jmi, int* n_eq_Ceq, int* n_eq_Cineq, int* n_eq_Heq, int* n_eq_Hineq);

/**
 * \brief Evaluate the cost function \f$J\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param J The value of the cost function.
 * @return Error code.
 *
 */
int jmi_opt_J(jmi_t* jmi, jmi_real_t* J);

/**
 * \brief Evaluate the gradient of the cost function \f$J\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The gradient.
 * @return Error code.
 *
 */
int jmi_opt_dJ(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the gradient of the cost function \f$J\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full gradient.
 * @return Error code.
 */
int jmi_opt_dJ_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the gradient
 * of the cost function \f$J\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the gradient.
 * @param col (Output) The column indices of the non-zeros in the gradient.
 * @return Error code.
 *
 */
int jmi_opt_dJ_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the gradient of the cost function \f$J\f$ given a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dJ_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dJ_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_opt_dJ_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dJ_n_cols, int *dJ_n_nz);

/**
 * \brief Evaluate the residual of the equality path constraints \f$C_{eq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual.
 * @return Error code.
 *
 */
int jmi_opt_Ceq(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the equality path constraint \f$C_{eq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dCeq(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the equality path
 * constraint \f$C_{eq}\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_opt_dCeq_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobian
 * of the equality path constraint residual \f$C_{eq}\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dCeq_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the equality path constraint residual function \f$C_{eq}\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_opt_dCeq_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate the residual of the inequality path constraints \f$C_{ineq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual.
 * @return Error code.
 *
 */
int jmi_opt_Cineq(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the inequality path constraint \f$C_{ineq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dCineq(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the inequality path
 * constraint \f$C_{ineq}\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_opt_dCineq_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobian
 * of the inequality path constraint residual \f$C_{ineq}\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dCineq_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the inequality path constraint residual function \f$C_{ineq}\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_opt_dCineq_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate the residual of the equality point constraints \f$H_{eq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual.
 * @return Error code.
 *
 */
int jmi_opt_Heq(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the equality point constraint \f$H_{eq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dHeq(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the equality point
 * constraint \f$H_{eq}\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_opt_dHeq_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobian
 * of the equality point constraint residual \f$H_{eq}\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dHeq_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the equality point constraint residual function \f$H_{eq}\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_opt_dHeq_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate the residual of the inequality point constraints \f$H_{ineq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual.
 * @return Error code.
 *
 */
int jmi_opt_Hineq(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the inequality point constraint \f$H_{ineq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dHineq(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the inequality point
 * constraint \f$H_{ineq}\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_opt_dHineq_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobian
 * of the inequality point constraint residual \f$H_{ineq}\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dHineq_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the inequality point constraint residual function \f$H_{ineq}\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_opt_dHineq_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/* @} */

/**
 * \defgroup Misc Miscanellous
 * \brief Miscanellous functions.
 */
/* @{ */

/**
 * \brief Print a summary of the content of the jmi_t struct.
 *
 * @param jmi A jmi_t struct.
 */
void jmi_print_summary(jmi_t *jmi);

/**
 * \brief Linear interpolation in table.
 *
 * Linear interpolation is performed in a table consisting of an abscissa and
 * one or more ordinates. If the interpolation point resides outside of the
 * interval of the provided abscissa, then the initial or final ordinate
 * values, respectively, are returned.
 *
 * @param x The interpolation point.
 * @param z A matrix stored in column major format containing the abscissa,
 * stored in the first column, and the ordinates, stored in the following
 * columns.
 * @param n Number of points in the abscissa vector.
 * @param m Number of columns of z, i.e., the number of ordinate vectors plus
 * one for the abscissa.
 * @param y (Output) A vector of size m-1 containing the interpolated ordinate
 * values.
 */
void jmi_lin_interpolate(jmi_real_t x, jmi_real_t *z , int n ,int m,
		jmi_real_t *y);

/* @} */

#ifdef __cplusplus
}
#endif

/* @} */

#endif
