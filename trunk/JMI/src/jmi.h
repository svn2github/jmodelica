 /*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 3 as published
    by the Free Software Foundation, or optionally, under the terms of the
    Common Public License version 1.0 as published by IBM.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License, or the Common Public License, for more details.

    You should have received copies of the GNU General Public License
    and the Common Public License along with this program.  If not,
    see <http://www.gnu.org/licenses/> or
    <http://www.ibm.com/developerworks/library/os-cpl.html/> respectively.
*/

/** \file jmi.h
 *  \brief The public JMI model interface.
 **/

/** \mainpage The JModelica.org C runtime library
 *
 * The JModelica C runtime library contains functions and data structures for
 * accessing the C model representation that is generated by the JModelica
 * Modelica and Optimica front-ends, respectively. The library is organized into
 * three main parts.
 *
 *  \section jmi_model_interface The JMI Model interface
 *   The JMI Model interface interface contains functions
 *    for evaluating the function generated by the compiler, including the DAE residual, the
 *    residual functions for the DAE initialization problem, and the functions related to
 *    the optimization problem such as cost functions and constraint residual functions.
 *    The JMI Model interface also supports evaluation of symbolic Jacobians (if available)
 *    and/or Jacobians computed by means of automatic differentiation. Sparsity patterns for
 *    Jacobians are supported.
 *      - <a href="group__Jmi.html"> Documentation of the public JMI Model interface </a>
 *      - <a href="group__Jmi__internal.html"> Documentation of the internal JMI Model interface </a>
 *  \section jmi_algorithm_interface The JMI Algorithm interface
 *    Based on the JMI Model interface, algorithms (in particular
 *    optimization algorithms) are implemented. These includes a framework for implementation of
 *    simultaneous optimization algorithms as well as a particular implementation of an algorithm
 *    based on Lagrange polynomials on Radau points.
 *     - <a href="group__jmi__init__opt.html"> Documentation of DAE initialization
 *     optimization algorithm.</a>
 *     - <a href="group__jmi__opt__sim.html"> Documentation of simultaneous
 *     interface optimization </a>
 *     - <a href="group__jmi__opt__sim__lp.html"> Documentation of implementation
 *     based on Lagrange polynomials and Radau points</a>
 *  \section jmi_solver_interface The JMI Solver interface
 *    Typically, the JMI Model and Algorithm interfaces are intended to
 *    be integrated with numerical solvers. Currently, the JMI interface provides
 *    an interface to the NLP solver Ipopt (https://projects.coin-or.org/Ipopt).
 *     - <a href="group__jmi__init__opt__ipopt.html"> Documentation of the Ipopt
 *     interface to the DAE initialization optimization algorithm</a>
 *     - <a href="group__jmi__opt__sim__ipopt.html"> Documentation of the Ipopt
 *     interface to the JMI simultaneous optimization interface</a>
 *
 * \section limitations Limitations
 * The JModelica.org JMI interface in under development. The function signatures
 * are likely to change in the future - all feedback is very welcome. The following
 * limitations apply:
 *   - Optimization of element lengths in the JMI simultaneous optimization
 *   interface is not supportd.
 *   - Symbolic Jacobians are not provided by the compiler. This is actually
 *   a limitation in the code generation module, but as a consequence, the
 *   JMI_DER_SYMBOLIC flag cannot be used in the JMI interface.
 *   - The ODE interface is very limited and requires a Modelica model to be
 *   stated on explicit ODE form (\f$\dot x=f(x,u)\f$) in order to work.
 *
 */

/**
 * \defgroup Jmi The JMI Model interface
 *
 * \brief Documentation of the public JMI Model interface.
 *
 *  \section DesignConsiderations Design considerations
 *
 * The JMI Model interface is intended to be used in a wide range of
 * applications and on multiple platforms. This also includes embedded
 * platforms in HILS applications.
 *
 * It is desirable that the JMI Model interface can be easily interfaced
 * with Python. Python is the intended language for scripting in JModelica and it is
 * therefore important that the generated code is straight forward to use with the
 * Python extensions or ctypes framework.
 *
 * The JMI Model interface is intended to be used by wide range of users,
 * with different backgrounds and programming skills. It is therefore desirable that
 * the interface is as simple and intuitive as possible.
 *
 * Given these motivations, it is reasonable to use pure C where possible, and to a
 * limited extent C++ where needed (e.g. in solver interfaces and in most likely in the
 * AD framework).
 *
 * It should also be possible to build shared libraries, in order to
 * build applications that contains several models.
 *
 *
 * \section MathDescr Mathematical description of the JMI Model interface
 *
 *   The jmi interface consists of three parts: DAE, DAE initialization and optimization.
 *   Essentially, the jmi interface consists of a collection of functions that are
 *   offered to the user for evaluation of the DAE residual, cost functions, constraints
 *   etc. These functions takes as arguments one more of the following three argument
 *   types:
 *
 *   Parameters (denoted \f$p\f$):
 *    - \f$c_i^r\f$   independent real constant
 *    - \f$c_d^r\f$   dependent real constants
 *    - \f$p_i^r\f$   independent real parameters
 *    - \f$p_d^r\f$   dependent real parameters
 *    - \f$c_i^i\f$   independent integer constant
 *    - \f$c_d^i\f$   dependent integer constants
 *    - \f$p_i^i\f$   independent integer parameters
 *    - \f$p_d^i\f$   dependent integer parameters
 *    - \f$c_i^b\f$   independent boolean constant
 *    - \f$c_d^b\f$   dependent boolean constants
 *    - \f$p_i^b\f$   independent boolean parameters
 *    - \f$p_d^b\f$   dependent boolean parameters
 *
 *    with
 *
 *      \f$ p = [{c_i^r}^T, {c_d^r}^T, {p_i^r}^T, {p_d^r}^T, {c_i^i}^T, {c_d^i}^T, {p_i^i}^T, {p_d^i}^T, {c_i^b}^T, {c_d^b}^T, {p_i^b}^T, {p_d^b}^T]^T \f$
 *
 *   Variables (denoted \f$v\f$):
 *
 *    - \f$\dot x\f$    differentiated real variables
 *    - \f$x\f$     real variables that appear differentiated
 *    - \f$u\f$     real inputs
 *    - \f$w\f$     real algebraic variables
 *    - \f$t\f$     time
 *
 *    with
 *
 *    \f$v = [\dot x^T, x^T, u^T, w^T, t]^T\f$
 *
 *   Variables defined at particular time instants (denoted \f$q\f$):
 *
 *      - \f$\dot x(t_i)\f$    differentiated real variables evaluated at time \f$t_i, i \in 1..n_{tp}\f$
 *      - \f$x(t_i)\f$     real variables that appear differentiated evaluated at time \f$t_i, t_i \in 1..n_{tp}\f$
 *      - \f$u(t_i)\f$     real inputs evaluated at time \f$t_i, i \in 1..n_{tp}\f$
 *      - \f$w(t_i)\f$     real algebraic variables evaluated at time \f$t_i, i \in 1..n_{tp}\f$
 *
 *    \f$ q = [\dot x(t_1)^T, x(t_1)^T, u(t_1)^T, w(t_1)^T, ...,
 *           \dot x(t_{n_{tp}})^T, x(t_{n_{tp}})^T, u(t_{n_{tp}})^T, w(t_{n_{tp}})^T]^T\f$
 *
 *   Discrete variables which may only change during events (denoted \f$d\f$);
 *
 *      -  \f$d^r\f$  discrete real variables
 *      -  \f$d^i\f$  integer variables
 *      -  \f$u^i\f$  integer inputs
 *      -  \f$d^b\f$  boolean variables
 *      -  \f$u^b\f$  boolean inputs
 *      -  \f$s\f$  boolean switches mapped from relational expressions Notice that these boolean variables
 *      do not originate from boolean variable declarations, but from boolean valued expressions such as
 *      x>=3.
 *
 *    \f$ d = [{d^r}^T, {d^i}^T, {u^i}^T, {d^b}^T, {d^b}^T,s]^T\f$
 *
 *   All parameters, variables, point-wise evaluated variables and discrete variables are denoted z:
 *
 *     \f$ z = [p^T, v^T, q^T, d^T]^T \f$
 *
 *   \subsection DAE The DAE interface
 *
 *   The DAE interface is defined by the residual function \f$F(p,v,d)\f$ where
 *
 *     \f$ F(p,v,d) = 0 \f$
 *
 *	For details on the functions included in the DAE interface, see the <a href="group__DAE.html">DAE functions documentation. </a>
 *
 *    \subsection Init The DAE initialization interface
 *
 *	 The DAE initialization interface is defined by the functions \f$F_0(p,v)\f$ and \f$F_1(p,v)\f$ where
 *
 *	  \f$  F_0(p,v,d) = 0 \f$<br>
 *	  \f$  F_1(p,v,d) = 0 \f$
 *
 *   \f$F_0\f$ represents the DAE system augmented with additional initial equations
 *   and start values that are fixed. \f$F_1\f$ on the other hand contains equations for
 *   initialization of variables for which the value given in the start attribute is
 *   not fixed.
 *
 *   In addition, a residual function for dependent parameters is provided
 *
 *	  \f$  F_p(p) = 0 \f$
 *
 *   The iteration variables of this system are the elements in the \f$p_d^r\f$,
 *   \f$p_d^i\f$, \f$p_d^b\f$ vectors.
 *
 *   For details on the functions included in the DAE initialization interface, see the
 *   <a href="group__Initialization.html">DAE initialization functions documentation. </a>
 *
 *   \subsection Ode_interface The ODE interface
 *
 *   The ODE interace is defined by the relation
 *
 *   \f$\dot x = f(p,x,u,t,d). \f$
 *
 *   WARNING: The current version of the JMI interface supports only Modelica
 *   models which are written explicitly on ODE form. Accordingly, no
 *   algebraic variables are supported in this version.
 *
 *   \subsection Opt The optimization interface
 *
 *   The optimization part of the interface is defined by the functions \f$J(p,q)\f$,
 *   \f$C_{eq}(p,v,q)\f$, \f$C_{ineq}(p,v,q)\f$, \f$H_{eq}(p,q)\f$, \f$H_{ineq}(p,q)\f$.
 *   Based on these functions, an optimization problem is then formulated as
 *
 *      \f$\displaystyle\min_{p^{opt},u} \int_{t_0}^{t_f} L(p,v) dt + J(p,q)\f$<br>
 *      subject to <br>
 *      \f$F_{fdp}(p) = 0\f$<br>
 *      \f$C_{eq}(p,v,q) = 0\f$<br>
 *      \f$C_{ineq}(p,v,q) \leq 0\f$<br>
 *      \f$H_{eq}(p,q) = 0\f$<br>
 *      \f$H_{ineq}(p,q) \leq 0\f$<br>
 *
 *   where \f$L\f$ is the Lagrange integrand and \f$J\f$ is the point wise
 *   penalty penalty function in the cost to be minimized, \f$F_{fdp}\f$ are the free
 *   dependent parameter residuals, \f$C_{eq}\f$ are path equality constraints,
 *   \f$C_{ineq}\f$ are path inequality constraints, \f$H_{eq}\f$ are (time) point equality constraints,
 *   and \f$H_{ineq}\f$ are (time) point inequality constraints. Notice that \f$J\f$
 *   (corresponding to the Optimica class attribute 'objective') is a function of the parameters
 *   \f$p\f$ and the instant variables \f$q\f$, and
 *   is commonly used to express terminal costs or sums of deviations between
 *   measurement data and model trajectories in parameter estimation problems.
 *   \f$L\f$ (corresponding to the Optimica class attribute 'objectiveIntegrand')
 *   on the other hand is used to encode Lagrange type integral cost functions.
 *   The rationale for introducing
 *   \f$H_{eq}\f$ and \f$H_{ineq}\f$ is to enable expression of e.g. terminal constraints. In addition, the
 *   DAE and the DAE initialization relations are constraints in the optimization problem.
 *   The \f$n_{p^{opt}}\f$ optimization parameters \f$p^{opt}\f$ are a subset
 *   of the \f$p_i\f$
 *
 *   The optimization problem is defined on the interval \f$[t_0,t_f]\f$, where \f$t_0\f$ and \f$t_f\f$,
 *   respectively, can be free or fixed.
 *
 *   Notice that the optimization interface does not support discrete variables.
 *
 * For details on the functions included in the optimization interface, see the
 * <a href="group__Optimization.html">optimization functions documentation. </a>
 *
 *  \section Jacobians Evaluation of Jacobians
 *
 *  Evaluation of Jacobians is controlled by four arguments:
 *
 *   - eval_alg    This argument is used to select the method evaluation
 *                     for the Jacobian. JMI_DER_SYMBOLIC and JMI_DER_CPPAD
 *                     is currently supported.
 *   - sparsity          This argument is a mask that selects whether
 *                     sparse or dense evaluation of the Jacobian should
 *                     be used. The constants JMI_DER_SPARSE are used to
 *                     specify a sparse Jacobian, whereas JMI_DER_DENSE_COL_MAJOR
 *                     and JMI_DER_DENSE_ROW_MAJOR are used to specify dense
 *                     column major or row major Jacobians respectively.
 *   - independent_vars  This argument is used to specify which variable types
 *                     are considered to be independent variables in the Jacobian
 *                     evaluation. The constants JMI_DER_NN are used to indicate that
 *                     the Jacobian w.r.t. a particular vector should be evaluated.
 *   - mask              This array has the same size as the number of column of the dense
 *                     Jacobian (equal to the size of the vector \f$z\f$), and holds the value of 0 if the corresponding Jacobian
 *                     column should not be computed. If the value of an entry in
 *                     mask i 1, then the corresponding Jacobian column will be evaluated.
 *                     The evaluated Jacobian columns are stored in the first
 *                     entries of the output argument jac.
 *
 *  Notice that only Jacobian evaluation w.r.t. real parameters and variables
 *  is currently supported.
 *
 *  TODO: It may be interesting to include an additional layer that enables
 *  support for partially defined Jacobians. This would be beneficial if symbolic
 *  expressions for the Jacobian is available for some entries, but for other
 *  an AD algorithm is to be used.
 *
 * \section ErrorHandling Error handling
 */

#ifndef _JMI_H
#define _JMI_H

#include "jmi_common.h"

/* @{ */

#ifdef __cplusplus
extern "C" {
#endif

/**
 * \defgroup Defines Defined constants
 * \brief Constants defined in the JMI Model interface.
 */
/* @{ */

#define JMI_INF 1e20; /**< \brief A Very Large Number denoting infinity.*/

#define JMI_DER_SYMBOLIC 1 /**< \brief Use symbolic evaluation of derivatives (if available). */
#define JMI_DER_CPPAD 2 /**< \brief Use automatic differentiation (CppAD) to evaluate derivatives. */

#define JMI_DER_SPARSE 1 /**< \brief Sparse evaluation of derivatives. */
#define JMI_DER_DENSE_COL_MAJOR 2 /**<  \brief Dense evaluation (column major) of derivatives. */
#define JMI_DER_DENSE_ROW_MAJOR 4 /**<  \brief Dense evaluation (row major) of derivatives. */

// Flags for evaluation of Jacobians w.r.t. parameters in the p vector
#define JMI_DER_CI 1 /**<  \brief Evaluate derivatives w.r.t. real independent constants, \f$c_i\f$.*/
#define JMI_DER_CD 2 /**<  \brief Evaluate derivatives w.r.t. real dependent constants, \f$c_d\f$.*/
#define JMI_DER_PI 4 /**<  \brief Evaluate derivatives w.r.t. real independent parameters, \f$p_i\f$.*/
#define JMI_DER_PD 8 /**<  \brief Evaluate derivatives w.r.t. real dependent constants, \f$p_d\f$.*/
// Flags for evaluation of Jacobians w.r.t. variables in the v vector
#define JMI_DER_DX 16 /**<  \brief Evaluate derivatives w.r.t. real derivatives, \f$\dot x\f$.*/
#define JMI_DER_X 32 /**<  \brief Evaluate derivatives w.r.t. real differentiated variables, \f$x\f$.*/
#define JMI_DER_U 64 /**<  \brief Evaluate derivatives w.r.t. real inputs, \f$u\f$.*/
#define JMI_DER_W 128 /**<  \brief Evaluate derivatives w.r.t. real algebraic variables, \f$w\f$.*/
#define JMI_DER_T 256 /**<  \brief Evaluate derivatives w.r.t. real time, \f$t\f$.*/
// Flags for evaluation of Jacobians w.r.t. variables in the q vector
#define JMI_DER_DX_P 512 /**<  \brief Evaluate derivatives w.r.t. real derivatives at time points, \f$\dot x_p\f$.*/
#define JMI_DER_X_P 1024 /**<  \brief Evaluate derivatives w.r.t. real differentiated variables at time points, \f$x_p\f$.*/
#define JMI_DER_U_P 2048 /**<  \brief Evaluate derivatives w.r.t. real inputs at time points, \f$u_p\f$.*/
#define JMI_DER_W_P 4096 /**<  \brief Evaluate derivatives w.r.t. real algebraic variables at time points, \f$w_p\f$.*/

/** \brief Evaluate derivatives w.r.t. all variables, \f$z\f$.*/
#define JMI_DER_ALL (JMI_DER_CI | JMI_DER_CD | JMI_DER_PI | JMI_DER_PD |\
	JMI_DER_DX | JMI_DER_X | JMI_DER_U | JMI_DER_W |\
	JMI_DER_T | JMI_DER_DX_P | JMI_DER_X_P | JMI_DER_U_P | JMI_DER_W_P)

/**  \brief Evaluate derivatives w.r.t. all variables in \f$p\f$.*/
#define JMI_DER_ALL_P JMI_DER_CI | JMI_DER_CD | JMI_DER_PI | JMI_DER_PD

/**  \brief Evaluate derivatives w.r.t. all variables in \f$v\f$.*/
#define JMI_DER_ALL_V JMI_DER_DX | JMI_DER_X | JMI_DER_U | JMI_DER_W |\
	JMI_DER_T

/**  \brief Evaluate derivatives w.r.t. all variables in \f$q\f$.*/
#define JMI_DER_ALL_Q  JMI_DER_DX_P | JMI_DER_X_P | JMI_DER_U_P | JMI_DER_W_P

/**  \brief Definitions of boolean true and false literals.*/
#define JMI_TRUE  AD_WRAP_LITERAL(1.0)
#define JMI_FALSE AD_WRAP_LITERAL(0.0)

/** \brief */
#define JMI_SCALING_NONE 1 /**<  \brief No scaling.*/
#define JMI_SCALING_VARIABLES 2 /**<  \brief Scale real variables by multiplying
	incoming variables in residual functions by the scaling factors in jmi_t->variable_scaling_factors */

/* @} */

/*
 *****************************************
 *
 *    Public interface
 *
 ****************************************
 */

/**
 * \defgroup jmi_struct Creation, initialization and destruction of jmi_t structs
 * \brief The main data structure in the JMI Model interface is jmi_t, which contains
 * all information needed to evaluate the functions in the JMI Model interface.
 *
 * Typically,
 * a pointer to a jmi_t struct is passed as the first argument to functions in the interface.
 *
 *
 */

/* @{ */

/**
 * \brief Create a new jmi_t struct.
 *
 * This function creates a new jmi struct, for which a pointer is returned in the output argument jmi.
 *
 * Typically this function is defined in the generated code.
 *
 * @param jmi A pointer to a jmi_t pointer where the new jmi_t struct is stored.
 * @return Error code.
 */
int jmi_new(jmi_t** jmi);

/**
 * Initializes the AD variables and tapes.
 *
 * Prior to this call, the variables in z should
 * be initialized, which is also the reason why this function must be provided for
 * the user to call after the actual creation of the jmi_t struct.
 *
 * @param jmi A pointer to a jmi_t struct.
 * @return Error code.
 */
int jmi_ad_init(jmi_t* jmi);

/**
 * Deallocates memory and deletes a jmi_t struct.
 *
 * @param jmi A pointer to the jmi_t struc to be deleted.
 */
int jmi_delete(jmi_t* jmi);

/* @} */

/**
 * \defgroup Access Setters and getters for the fields in jmi_t
 *
 * \brief The fields of jmi_t are conveniently accessed using the setter and getter
 * functions provided in the JMI Model interface.
 *
 * Notice that it is not recommended to access the fields directely, since the internal
 * implementation of jmi_t may change, wheras the setters and getters are less likely to
 * do so.
 *
 */

/* @{ */

/**
 * \brief Get the sizes of the variable vectors.
 *
 * @param jmi The jmi_t struct.
 * @param n_real_ci (Output) number of real independent constants.
 * @param n_real_cd (Output) number of real dependent constants.
 * @param n_real_pi (Output) number of real independent parameters.
 * @param n_real_pd (Output) number of real dependent parameters.
 * @param n_integer_ci (Output) number of integer independent constants.
 * @param n_integer_cd (Output) number of integer dependent constants.
 * @param n_integer_pi (Output) number of integer independent parameters.
 * @param n_integer_pd (Output) number of integer dependent parameters.
 * @param n_boolean_ci (Output) number of boolean independent constants.
 * @param n_boolean_cd (Output) number of boolean dependent constants.
 * @param n_boolean_pi (Output) number of boolean independent parameters.
 * @param n_boolean_pd (Output) number of boolean dependent parameters.
 * @param n_real_dx (Output) number of real derivatives.
 * @param n_real_x (Output) number of real differentiated variables.
 * @param n_real_u (Output) number of real inputs.
 * @param n_real_w (Output) number of real algebraic variables.
 * @param n_real_d (Output) number of real discrete variables.
 * @param n_tp (Output) number of time points included in the model.
 * @param n_integer_d (Output) number of integer discrete variables.
 * @param n_integer_u (Output) number of integer inputs.
 * @param n_boolean_d (Output) number of boolean discrete variables.
 * @param n_boolean_u (Output) number of boolean inputs.
 * @param n_sw (output) number of switching functions in the DAE \f$F\f$.
 * @param n_sw_init (output) number of switching functions in the initialization system \f$F_0\f$.
 * @param n_z (Output) total number of variables in the \f$z\f$ vector.
 * @return Error code.
 *
 */
int jmi_get_sizes(jmi_t* jmi, int* n_real_ci, int* n_real_cd, int* n_real_pi, int* n_real_pd,
		int* n_integer_ci, int* n_integer_cd, int* n_integer_pi, int* n_integer_pd,
		int* n_boolean_ci, int* n_boolean_cd, int* n_boolean_pi, int* n_boolean_pd,
		int* n_real_dx, int* n_real_x, int* n_real_u, int* n_real_w, int* n_tp,
		int* n_real_d, int* n_integer_d, int* n_integer_u, int* n_boolean_d, int* n_boolean_u,
		int* n_sw, int* n_sw_init, int* n_z);

/**
 * \brief Get the offsets for the variable types in the \f$z\f$ vector.
 *
 * @param jmi The jmi_t struct.
 * @param offs_real_ci (Output) offset of real independent constants.
 * @param offs_real_cd (Output) offset of real dependent constants.
 * @param offs_real_pi (Output) offset of real independent parameters.
 * @param offs_real_pd (Output) offset of real dependent parameters.
 * @param offs_integer_ci (Output) offset of integer independent constants.
 * @param offs_integer_cd (Output) offset of integer dependent constants.
 * @param offs_integer_pi (Output) offset of integer independent parameters.
 * @param offs_integer_pd (Output) offset of integer dependent parameters.
 * @param offs_boolean_ci (Output) offset of boolean independent constants.
 * @param offs_boolean_cd (Output) offset of boolean dependent constants.
 * @param offs_boolean_pi (Output) offset of boolean independent parameters.
 * @param offs_boolean_pd (Output) offset of boolean dependent parameters.
 * @param offs_real_dx (Output) offset of real derivatives.
 * @param offs_real_x (Output) offset of real differentiated variables.
 * @param offs_real_u (Output) offset of real inputs.
 * @param offs_real_w (Output) offset of real algebraic variables.
 * @param offs_t (Output) offset of time.
 * @param offs_real_dx_p (Output) offset of the first real  derivatives in the time point part of \f$z\f$.
 * @param offs_real_x_p (Output) offset of the first real differentiated variables in the time point part of \f$z\f$.
 * @param offs_real_u_p (Output) offset of the first real inputs in the time point part of \f$z\f$.
 * @param offs_real_w_p (Output) offset of the first real algebraic variables in the time point part of \f$z\f$.
 * @param offs_real_d (Output) offset of real discrete variables.
 * @param offs_integer_d (Output) offset of integer discrete variables.
 * @param offs_integer_u (Output) offset of integer input variables.
 * @param offs_boolean_d (Output) offset of boolean discrete variables.
 * @param offs_boolean_u (Output) offset of boolean input variables.
 * @param offs_sw (Output) offset of the first switching function in the DAE \f$F_0\f$.
 * @param offs_sw_init (Output) offset of the first switching function in the initialization system \f$F_0\f$.
 * @return Error code.
 */
int jmi_get_offsets(jmi_t* jmi, int* offs_real_ci, int* offs_real_cd,
		int* offs_real_pi, int* offs_real_pd,
		int* offs_integer_ci, int* offs_integer_cd,
		int* offs_integer_pi, int* offs_integer_pd,
		int* offs_boolean_ci, int* offs_boolean_cd,
		int* offs_boolean_pi, int* offs_boolean_pd,
		int* offs_real_dx, int* offs_real_x, int* offs_real_u,
		int* offs_real_w, int *offs_t,
		int* offs_real_dx_p, int* offs_real_x_p,
		int* offs_real_u_p, int* offs_real_w_p,
		int* offs_real_d, int* offs_integer_d, int* offs_integer_u,
		int* offs_boolean_d, int* offs_boolean_u,
		int* offs_sw, int* offs_sw_init);

/**
 * \brief Get the number of time points.
 *
 * @param jmi The jmi_t struct.
 * @param n_tp (Output) number of time points in the model.
 * @return Error code.
 *Ê
 */
int jmi_get_n_tp(jmi_t *jmi, int *n_tp);

/**
 * \brief Set the vector of time points included in the problem.
 *
 * @param jmi The jmi_t struct.
 * @param tp A pointer to a jmi_real_t array of size n_tp that contains the time
 * points. Notice that the time points should be normalized to the interval
 * [0,1], where 0 corresponds to the interval start time and where 1 corresponds
 * to the interval final time.
 * @return Error code.
 *
 */
int jmi_set_tp(jmi_t *jmi, jmi_real_t *tp);

/**
 * \brief Get the vector of time points included in the problem.
 *
 * @param jmi The jmi_t struct.
 * @param tp (Output) a pointer to a jmi_real_t array of size n_tp.
 * Upon return the array contains the normalized time points of the model.
 * @return Error code.
 *
 */
int jmi_get_tp(jmi_t *jmi, jmi_real_t *tp);

/**
 * \brief Get a pointer to the z vector containing all variables.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$z\f$ vector.
 *
 */
jmi_real_t* jmi_get_z(jmi_t* jmi);

/**
 * \brief Get a pointer to the real independent constants vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$c_i^r\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_ci(jmi_t* jmi);

/**
 * \brief Get a pointer to the real dependent constants vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$c_d^r\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_cd(jmi_t* jmi);

/**
 * \brief Get a pointer to the real independent parameter vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$p_i^r\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_pi(jmi_t* jmi);

/**
 * \brief Get a pointer to the real dependent parameters vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$p_d^r\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_pd(jmi_t* jmi);

/**
 * \brief Get a pointer to the integer independent constants vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$c_i^r\f$ vector.
 *
 */
jmi_real_t* jmi_get_integer_ci(jmi_t* jmi);

/**
 * \brief Get a pointer to the integer dependent constants vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$c_d^i\f$ vector.
 *
 */
jmi_real_t* jmi_get_integer_cd(jmi_t* jmi);

/**
 * \brief Get a pointer to the integer independent parameter vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$p_i^i\f$ vector.
 *
 */
jmi_real_t* jmi_get_integer_pi(jmi_t* jmi);

/**
 * \brief Get a pointer to the integer dependent parameters vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$p_d^i\f$ vector.
 *
 */
jmi_real_t* jmi_get_integer_pd(jmi_t* jmi);

/**
 * \brief Get a pointer to the boolean independent constants vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$c_i^r\f$ vector.
 *
 */
jmi_real_t* jmi_get_boolean_ci(jmi_t* jmi);

/**
 * \brief Get a pointer to the boolean dependent constants vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$c_d^i\f$ vector.
 *
 */
jmi_real_t* jmi_get_boolean_cd(jmi_t* jmi);

/**
 * \brief Get a pointer to the boolean independent parameter vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$p_i^i\f$ vector.
 *
 */
jmi_real_t* jmi_get_boolean_pi(jmi_t* jmi);

/**
 * \brief Get a pointer to the boolean dependent parameters vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$p_d^i\f$ vector.
 *
 */
jmi_real_t* jmi_get_boolean_pd(jmi_t* jmi);

/**
 * \brief Get a pointer to the real derivatives vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$dx\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_dx(jmi_t* jmi);

/**
 * \brief Get a pointer to the differentiated variables vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$x\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_x(jmi_t* jmi);

/**
 * \brief Get a pointer to the inputs vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$u\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_u(jmi_t* jmi);

/**
 * \brief Get a pointer to the algebraic variables vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$w\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_w(jmi_t* jmi);

/**
 * \brief Get a pointer to the time value.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to \f$t\f$.
 *
 */
jmi_real_t* jmi_get_t(jmi_t* jmi);

/**
 * \brief Get a pointer to the derivatives corresponding to the i:th time point.
 *
 * @param jmi The jmi_t struct.
 * @param i Index of the time point: 0 corresponds to first time point.
 * @return A pointer to the \f$dx_{p,i}\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_dx_p(jmi_t* jmi,int i);

/**
 * \brief Get a pointer to the differentiated variables corresponding to the i:th time point.
 *
 * @param jmi The jmi_t struct.
 * @param i Index of the time point: 0 corresponds to first time point.
 * @return A pointer to the \f$x_{p,i}\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_x_p(jmi_t* jmi, int i);

/**
 * \brief Get a pointer to the inputs corresponding to the i:th time point.
 *
 * @param jmi The jmi_t struct.
 * @param i Index of the time point: 0 corresponds to first time point.
 * @return A pointer to the \f$u_{p,i}\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_u_p(jmi_t* jmi, int i);

/**
 * \brief Get a pointer to the algebraic variables corresponding to the i:th time point.
 *
 * @param jmi The jmi_t struct.
 * @param i Index of the time point: 0 corresponds to first time point.
 * @return A pointer to the \f$w_{p,i}\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_w_p(jmi_t* jmi, int i);

/**
 * \brief Get a pointer to the real discrete variables vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$d^r\f$ vector.
 *
 */
jmi_real_t* jmi_get_real_d(jmi_t* jmi);

/**
 * \brief Get a pointer to the integer discrete variables vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$d^i\f$ vector.
 *
 */
jmi_real_t* jmi_get_integer_d(jmi_t* jmi);

/**
 * \brief Get a pointer to the integer input variables vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$u^i\f$ vector.
 *
 */
jmi_real_t* jmi_get_integer_u(jmi_t* jmi);

/**
 * \brief Get a pointer to the boolean discrete variables vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$d^i\f$ vector.
 *
 */
jmi_real_t* jmi_get_boolean_d(jmi_t* jmi);

/**
 * \brief Get a pointer to the boolean input variables vector.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the \f$u^i\f$ vector.
 *
 */
jmi_real_t* jmi_get_boolean_u(jmi_t* jmi);

/**
 * \brief Get a pointer to the first switching function in the DAE \$fF\$f.
 * A switch value of 1 corresponds to true and 0 corresponds to false.
 *
 * @param jmi The jmi_t struct.
 * @return A pointer to the vector of switching functions.
 *
 */
jmi_real_t* jmi_get_sw(jmi_t* jmi);

/**
 * \brief Get a pointer to the first switching function in the initialization system \$fF_0\$f.
 * A switch value of 1 corresponds to true and 0 corresponds to false.
 * @param jmi The jmi_t struct.
 * @return A pointer to the vector of switching functions.
 *
 */
jmi_real_t* jmi_get_sw_init(jmi_t* jmi);

/**
 * \brief Get a pointer to the scaling factor vector.
 * @param jmi The jmi_t struct.
 * @return A pointer to the scaling factor vector.
 *
 */
jmi_real_t* jmi_get_variable_scaling_factors(jmi_t* jmi);

/**
 * \brief Get the scaling method. Alternatives are JMI_SCALING_NONE and
 * JMI_SCALING_VARIABLES.
 * @param jmi The jmi_t struct.
 * @return An integer representing the scaling method used.
 *
 */
int jmi_get_scaling_method(jmi_t* jmi);


/* @} */


/*********************************************
 *
 * ODE interface
 *
 ********************************************/

/**
 * \defgroup ODE ODE interface
 * \brief Access to the ODE representation.
 *
 * WARNING: The current version of the ODE interface is very limited and
 * requires that the Modelica model is explicitly given on ODE form.
 * Accordingly, algebraic variables are not supported.
 */
/* @{ */


/**
 * \brief Evaluate the right hand side of the ODE.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_x, ::jmi_get_u etc. The
 * output (the values of the derivatives) is available after a call to
 * ::jmi_ode_f in the vector obtained by calling ::jmi_get_dx.
 *
 * @param jmi A jmi_t struct.
 * @return Error code.
 *
 */
int jmi_ode_f(jmi_t* jmi);

/**
 * \brief Evaluate the Jacobian of the right hand side of the ODE.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_x, ::jmi_get_u etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg Set to either JMI_DER_SYMBOLIC to evaluate a symbolic Jacobian or
 *                 JMI_DER_CPPAD to evaluate the Jacobian by means of CppAD.
 * @param sparsity Set to JMI_DER_SPARSE, JMI_DER_DENSE_COL_MAJOR, or JMI_DER_DENS_ROW_MAJOR
 *                to indicate the output format of the Jacobian.
 * @param independent_vars Used to indicate which columns of the full Jacobian should
 *                         be evaluated. The constants JMI_DER_X, JMI_DER_DX etc are used
 *                         to set this argument. Setting independent_vars to
 *                         JMI_DER_DX has no effect.
 * @param mask This argument is a vector containing ones for the Jacobian columns that
 *             should be included in the Jacobian and zeros for those which should not.
 *             The size of this vector is the same as the z vector.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_ode_df(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the Jacobian of the right hand
 * side of the ODE.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg Indicates which for which Jacobian the number of non-zero elements should be returned:
 *                 Symbolic (JMI_DER_SYMBOLIC) or CppAD (JMI_DER_CPPAD).
 * @param n_nz (Output) The number of non-zero Jacobian entries.
 * @return Error code.
 */
int jmi_ode_df_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the
 * Jacobian of the right hand side.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_ode_df_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
		                  int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non zero
 * elements in the Jacobian of the right hand side of the ODE given a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param df_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param df_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_ode_df_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *df_n_cols, int *df_n_nz);

/* @} */

/*********************************************
 *
 * DAE interface
 *
 ********************************************/

/**
 * \defgroup DAE DAE interface
 * \brief Access to the DAE residual function.
 *
 */
/* @{ */


/**
 * \brief Get the number of equations of the DAE and the number of event
 * indicator residuals.
 *
 * @param jmi A jmi_t struct.
 * @param n_eq_F (Output) The number of DAE equations is stored in this
 * argument.
 * @param n_eq_R (Output) The number of DAE event indicator residuals is
 * stored in this argument.
 * @return Error code.
 */
int jmi_dae_get_sizes(jmi_t* jmi, int* n_eq_F, int* n_eq_R);


/**
 * \brief Evaluate DAE residual.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res (Output) The DAE residual vector.
 * @return Error code.
 *
 */
int jmi_dae_F(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the DAE residual function.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg Set to either JMI_DER_SYMBOLIC to evaluate a symbolic Jacobian or
 *                 JMI_DER_CPPAD to evaluate the Jacobian by means of CppAD.
 * @param sparsity Set to JMI_DER_SPARSE, JMI_DER_DENSE_COL_MAJOR, or JMI_DER_DENS_ROW_MAJOR
 *                to indicate the output format of the Jacobian.
 * @param independent_vars Used to indicate which columns of the full Jacobian should
 *                         be evaluated. The constants JMI_DER_DX, JMI_DER_X etc are used
 *                         to set this argument.
 * @param mask This argument is a vector containing ones for the Jacobian columns that
 *             should be included in the Jacobian and zeros for those which should not.
 *             The size of this vector is the same as the z vector.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_dae_dF(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full DAE residual Jacobian.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg Indicates which for which Jacobian the number of non-zero elements should be returned:
 *                 Symbolic (JMI_DER_SYMBOLIC) or CppAD (JMI_DER_CPPAD).
 * @param n_nz (Output) The number of non-zero Jacobian entries.
 * @return Error code.
 */
int jmi_dae_dF_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the DAE
 * residual Jacobian.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the DAE residual Jacobian.
 * @param col (Output) The column indices of the non-zeros in the DAE residual Jacobian.
 * @return Error code.
 *
 */
int jmi_dae_dF_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
		                  int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non zero
 * elements in the Jacobian of the DAE residual given a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_dae_dF_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate DAE event indicator residuals.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res (Output) The event indicator residuals.
 * @return Error code.
 *
 */
int jmi_dae_R(jmi_t* jmi, jmi_real_t* res);

/* @} */

/*********************************************
 *
 * Initialization interface
 *
 ********************************************/

/**
 * \defgroup Initialization DAE Initialization Interface
 * \brief Access to the DAE initialization functions.
 */
/* @{ */

/**
 * \brief Get the number of equations in the DAE initialization functions.
 *
 * @param jmi A jmi_t struct.
 * @param n_eq_F0 (Output) The number of equations in \f$F_0\f$ is stored in this argument.
 * @param n_eq_F1 (Output) The number of equations in \f$F_1\f$ is stored in this argument.
 * @param n_eq_Fp (Output) The number of equations in \f$F_p\f$ is stored in this argument.
 * @param n_eq_R0 (Output) The number of equations in \f$R_0\f$ is stored in this argument.
 * @return Error code.
 *
 */
int jmi_init_get_sizes(jmi_t* jmi, int* n_eq_F0, int* n_eq_F1, int* n_eq_Fp,
		int* n_eq_R0);

/**
 * \brief Evaluate the \f$F_0\f$ residual function of the initialization system.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual of \f$F_0\f$.
 * @return Error code.
 */
int jmi_init_F0(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the DAE initialization residual function \f$F_0\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_init_dF0(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the DAE initialization residual function \f$F_0\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_init_dF0_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobain of the DAE
 * initialization residual function \f$F_0\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_init_dF0_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the DAE initialization residual function \f$F_0\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_init_dF0_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate the \f$F_1\f$ residual function of the initialization system.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual of \f$F_1\f$.
 * @return Error code.
 */
int jmi_init_F1(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the DAE initialization residual function \f$F_1\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_init_dF1(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the DAE initialization residual function \f$F_1\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_init_dF1_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobain of the DAE
 * initialization residual function \f$F_1\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_init_dF1_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the DAE initialization residual function \f$F_1\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_init_dF1_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate the \f$F_p\f$ residual function of the initialization system.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual of \f$F_p\f$.
 * @return Error code.
 */
int jmi_init_Fp(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the DAE initialization residual function \f$F_p\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_init_dFp(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the DAE initialization residual function \f$F_p\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_init_dFp_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobain of the DAE
 * initialization residual function \f$F_p\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_init_dFp_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the DAE initialization residual function \f$F_p\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_init_dFp_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate DAE event indicator residuals for the initialization system.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res (Output) The event indicator residuals.
 * @return Error code.
 *
 */
int jmi_init_R0(jmi_t* jmi, jmi_real_t* res);

/* @} */


/*********************************************
 *
 * Optimization interface
 *
 ********************************************/

/**
 * \defgroup Optimization Optimization interface
 * \brief Access to the optimization functions.
 */
/* @{ */

/**
 * \brief Set the optimization interval.
 *
 * This function should be called prior to using other
 * functions in the optimization interface.
 *
 * @param jmi A jmi_t struct.
 * @param start_time The start time of the optimization interval.
 * @param start_time_free Set to 0 if the start time of the optimization interval is fixed
 *                        or 1 if the start time is free. CURRENTLY NOT SUPPORTED.
 * @param final_time Final time of the optimization interval.
 * @param final_time_free Set to 0 if the final time of the optimization interval is fixed
 *                        or 1 if the final time is free. CURRENTLY NOT SUPPORTED.
 * @return Error code.
 *
 */
int jmi_opt_set_optimization_interval(jmi_t *jmi, double start_time, int start_time_free,
		                              double final_time, int final_time_free);

/**
 * \brief Get the optimization interval.
 *
 * @param jmi A jmi_t struct.
 * @param start_time (Output) The start time of the optimization interval.
 * @param start_time_free (Output) 0 if the start time of the optimization interval is fixed
 *                        or 1 if the start time is free.
 * @param final_time (Output) Final time of the optimization interval.
 * @param final_time_free (Output) 0 if the final time of the optimization interval is fixed
 *                        or 1 if the final time is free.
 * @return Error code.
 *
 */
int jmi_opt_get_optimization_interval(jmi_t *jmi, double *start_time, int *start_time_free,
		                              double *final_time, int *final_time_free);

/**
 * \brief Specify optimization parameters of the model.
 *
 * Typically only a few model parameters are optimized. Using this function, the
 * indices of the parameters in the independent parameters vector, \f$p_i\f$ is set.
 *
 * @param jmi A jmi_t struct.
 * @param n_p_opt The number of parameters to be optimized.
 * @param p_opt_indices The indices of the parameters to be optimized in the
 *                      \f$p_i\f$ vector.
 * @return Error code.
 */
int jmi_opt_set_p_opt_indices(jmi_t *jmi, int n_p_opt, int *p_opt_indices);

/**
 * \brief Get the number of optimization parameters.
 *
 * @param jmi A jmi_t struct.
 * @param n_p_opt (Output) The number of parameters to be optimized.
 * @return Error code.
 *
 */
int jmi_opt_get_n_p_opt(jmi_t *jmi, int *n_p_opt);

/**
 * \brief Get the optimization parameter indices.
 *
 * @param jmi A jmi_t struct.
 * @param p_opt_indices (Output) The indices of the parameters to be optimized in the
 *                      \f$p_i\f$ vector.
 * @return Error code.
 *
 */
int jmi_opt_get_p_opt_indices(jmi_t *jmi, int *p_opt_indices);

/**
 * \brief Get the sizes of the the optimization functions.
 *
 * @param jmi A jmi_t struct.
 * @param n_eq_J (Output) The number of point wise penalty functions.
 * @param n_eq_L (Output) The number of Lagrange integrands.
 * @param n_eq_Ffdp (Output) The number of equations in the \f$F_{fdp}\f$ residual.
 * @param n_eq_Ceq (Output) The number of equations in the \f$C_{eq}\f$ residual.
 * @param n_eq_Cineq (Output) The number of equations in the \f$C_{ineq}\f$ residual.
 * @param n_eq_Heq (Output) The number of equations in the \f$H_{eq}\f$ residual.
 * @param n_eq_Hineq (Output) The number of equations in the \f$H_{ineq}\f$ residual.
 * @return Error code.
 *
 */
int jmi_opt_get_sizes(jmi_t* jmi, int* n_eq_J, int* n_eq_L, int* n_eq_Ffdp,
		int* n_eq_Ceq, int* n_eq_Cineq, int* n_eq_Heq, int* n_eq_Hineq);

/**
 * \brief Evaluate the \f$F_{fdp}\f$ residual function.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual of \f$F_{fdp}\f$.
 * @return Error code.
 */
int jmi_opt_Ffdp(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the residual function \f$F_{fdp}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dFfdp(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the residual function \f$F_{fdp}\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_opt_dFfdp_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobain of the
 * residual function \f$F_{fdp}\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dFfdp_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the residual function \f$F_{fdp}\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_opt_dFfdp_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate the penalty function \f$J\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param J The value of the penalty function.
 * @return Error code.
 *
 */
int jmi_opt_J(jmi_t* jmi, jmi_real_t* J);

/**
 * \brief Evaluate the gradient of the penalty function \f$J\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The gradient.
 * @return Error code.
 *
 */
int jmi_opt_dJ(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the gradient of the penalty function \f$J\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full gradient.
 * @return Error code.
 */
int jmi_opt_dJ_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the gradient
 * of the penalty function \f$J\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the gradient.
 * @param col (Output) The column indices of the non-zeros in the gradient.
 * @return Error code.
 *
 */
int jmi_opt_dJ_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the gradient of the penalty function \f$J\f$ given a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dJ_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dJ_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_opt_dJ_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dJ_n_cols, int *dJ_n_nz);

/**
 * \brief Evaluate the Lagrange integrand cost \f$L\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param L The value of the Lagrange integrand.
 * @return Error code.
 *
 */
int jmi_opt_L(jmi_t* jmi, jmi_real_t* L);

/**
 * \brief Evaluate the gradient of the Lagrange integrand \f$L\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The gradient.
 * @return Error code.
 *
 */
int jmi_opt_dL(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the gradient of the Lagrange
 * integrand \f$L\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full gradient.
 * @return Error code.
 */
int jmi_opt_dL_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the gradient
 * of the Lagrange integrand \f$L\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the gradient.
 * @param col (Output) The column indices of the non-zeros in the gradient.
 * @return Error code.
 *
 */
int jmi_opt_dL_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the gradient of the Lagrange integrand \f$L\f$ given a sparsity
 * configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dL_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dL_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_opt_dL_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dL_n_cols, int *dL_n_nz);

/**
 * \brief Evaluate the residual of the equality path constraints \f$C_{eq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual.
 * @return Error code.
 *
 */
int jmi_opt_Ceq(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the equality path constraint \f$C_{eq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dCeq(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the equality path
 * constraint \f$C_{eq}\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_opt_dCeq_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobian
 * of the equality path constraint residual \f$C_{eq}\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dCeq_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the equality path constraint residual function \f$C_{eq}\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_opt_dCeq_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate the residual of the inequality path constraints \f$C_{ineq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual.
 * @return Error code.
 *
 */
int jmi_opt_Cineq(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the inequality path constraint \f$C_{ineq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dCineq(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the inequality path
 * constraint \f$C_{ineq}\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_opt_dCineq_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobian
 * of the inequality path constraint residual \f$C_{ineq}\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dCineq_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the inequality path constraint residual function \f$C_{ineq}\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_opt_dCineq_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate the residual of the equality point constraints \f$H_{eq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual.
 * @return Error code.
 *
 */
int jmi_opt_Heq(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the equality point constraint \f$H_{eq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dHeq(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the equality point
 * constraint \f$H_{eq}\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_opt_dHeq_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobian
 * of the equality point constraint residual \f$H_{eq}\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dHeq_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the equality point constraint residual function \f$H_{eq}\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_opt_dHeq_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/**
 * \brief Evaluate the residual of the inequality point constraints \f$H_{ineq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param res The residual.
 * @return Error code.
 *
 */
int jmi_opt_Hineq(jmi_t* jmi, jmi_real_t* res);

/**
 * \brief Evaluate the Jacobian of the inequality point constraint \f$H_{ineq}\f$.
 *
 * The user sets the input variables by writing to
 * the vectors obtained from the functions ::jmi_get_dx, ::jmi_get_x etc.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param jac (Output) The Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dHineq(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int* mask, jmi_real_t* jac);

/**
 * \brief Returns the number of non-zeros in the full Jacobian of the inequality point
 * constraint \f$H_{ineq}\f$.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF_n_nz.
 * @param n_nz (Output) The number of non-zero entries in the full Jacobian.
 * @return Error code.
 */
int jmi_opt_dHineq_n_nz(jmi_t* jmi, int eval_alg, int* n_nz);

/**
 * \brief Returns the row and column indices of the non-zero elements in the Jacobian
 * of the inequality point constraint residual \f$H_{ineq}\f$.
 *
 * Notice that Fortran style indexing is used: the first row (and column) has index 1.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param row (Output) The row indices of the non-zeros in the Jacobian.
 * @param col (Output) The column indices of the non-zeros in the Jacobian.
 * @return Error code.
 *
 */
int jmi_opt_dHineq_nz_indices(jmi_t* jmi, int eval_alg, int independent_vars,
        int *mask, int* row, int* col);

/**
 * \brief This helper function computes the number of columns and the number of non-zero
 * elements in the Jacobian of the inequality point constraint residual function \f$H_{ineq}\f$ given
 * a sparsity configuration.
 *
 * @param jmi A jmi_t struct.
 * @param eval_alg See ::jmi_dae_dF.
 * @param sparsity See ::jmi_dae_dF.
 * @param independent_vars See ::jmi_dae_dF.
 * @param mask See ::jmi_dae_dF.
 * @param dF_n_cols (Output) The number of columns of the resulting Jacobian.
 * @param dF_n_nz (Output) The number of non-zeros of the resulting Jacobian.
 *
 */
int jmi_opt_dHineq_dim(jmi_t* jmi, int eval_alg, int sparsity, int independent_vars, int *mask,
		int *dF_n_cols, int *dF_n_nz);

/* @} */

/**
 * \defgroup Misc Miscanellous
 * \brief Miscanellous functions.
 */
/* @{ */

/**
 * \brief Print a summary of the content of the jmi_t struct.
 *
 * @param jmi A jmi_t struct.
 */
void jmi_print_summary(jmi_t *jmi);

/**
 * \brief Linear interpolation in table.
 *
 * Linear interpolation is performed in a table consisting of an abscissa and
 * one or more ordinates. If the interpolation point resides outside of the
 * interval of the provided abscissa, then the initial or final ordinate
 * values, respectively, are returned.
 *
 * @param x The interpolation point.
 * @param z A matrix stored in column major format containing the abscissa,
 * stored in the first column, and the ordinates, stored in the following
 * columns.
 * @param n Number of points in the abscissa vector.
 * @param m Number of columns of z, i.e., the number of ordinate vectors plus
 * one for the abscissa.
 * @param y (Output) A vector of size m-1 containing the interpolated ordinate
 * values.
 */
void jmi_lin_interpolate(jmi_real_t x, jmi_real_t *z , int n ,int m,
		jmi_real_t *y);

/**
 * \brief Check if there is support for CppAD derivatives or not.
 *
 * If the return value is 1 then there is support for CppAD derivatives,
 * if return value is 0 there is no CppAD support.
 *
 * @return 1 for CppAD support, 0 if no CppAD support.
 */
int jmi_with_cppad_derivatives();

/* @} */

#ifdef __cplusplus
}
#endif

/* @} */

#endif
