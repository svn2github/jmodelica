/*
    Copyright (C) 2014 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.util.Collection;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.NoSuchElementException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.nio.charset.Charset;

import org.jmodelica.util.logging.StreamingLogger;
import org.jmodelica.util.logging.Level;
import org.jmodelica.util.AbstractModelicaScanner;


aspect FlatNames {
    
    syn String FVariable.varKind() {
        if (isIndependentConstant()) {
            return "ci";
        } else if (isDependentConstant()) {
            return "cd";
        } else if (isIndependentParameter()) {
            return "pi";
        } else if (isDependentParameter()) {
            return "pd";
        } else if (isDifferentiatedVariable()) {
            return "x";
        } else if (isDerivativeVariable()) {
            return "dx";
        } else if (isAlgebraicVariable()) {
            return "w";
        } else if (isInput()) {
            return "u";
        } else {
            return "unknown";
        }
    }
    
    syn FQNamePart FQNameFull.lastFQNamePart() = getFQNamePart(getNumFQNamePart()-1);
    
    syn boolean FQNamePart.hasFArraySubscripts()          = false;
    eq FQNamePartArray.hasFArraySubscripts()              = true;
    syn FArraySubscripts FQNamePart.getFArraySubscripts() = null;
    // FQNamePartArray.getFArraySubscripts() declared from .ast file

    syn boolean FQName.hasFArraySubscripts()          = false;
    syn FArraySubscripts FQName.getFArraySubscripts() = null;
    eq FQNameFull.hasFArraySubscripts()               = lastFQNamePart().hasFArraySubscripts();
    eq FQNameFull.getFArraySubscripts()               = lastFQNamePart().getFArraySubscripts();

    syn boolean FIdUse.hasFArraySubscripts() = 
        getFQName().hasFArraySubscripts();
    syn FArraySubscripts FIdUse.getFArraySubscripts() = 
        getFQName().getFArraySubscripts();

    syn boolean FIdUseInstAccess.hasFArraySubscripts() = 
        getInstAccess().hasFArraySubscripts();
    syn FArraySubscripts FIdUseInstAccess.getFArraySubscripts() = 
        getInstAccess().getFArraySubscripts();

    syn boolean FIdUseExp.hasFArraySubscripts() = 
        getFIdUse().hasFArraySubscripts();
    syn FArraySubscripts FIdUseExp.getFArraySubscripts() = 
        getFIdUse().getFArraySubscripts();
    
    syn FQName InstNode.getFQNamePrefix() = retrieveFQName();

    syn lazy FQName InstNode.getFQName() = getFQNamePrefix();
    eq InstClassDecl.getFQName()         = new FQNameEmpty();
    eq InstComponentDecl.getFQName()     = appendMyName(retrieveFQName());
    
    syn FQName InstComponentDecl.appendMyName(FQName prefix) = 
        (isAssignable() && isArrayDecl()) ? 
                prefix.copyAndAppend(name(), size().flattenFArraySubscripts(prefix)) :
                prefix.copyAndAppend(name());
    eq InstArrayComponentDecl.appendMyName(FQName prefix)    = 
        prefix.copyAndAddSubscript(new FIntegerSubscript(getIndex()));
    eq InstEnumLiteral.appendMyName(FQName prefix)           = prefix.copyAndAppend(name());
    
    inh lazy FQName InstNode.retrieveFQName();
    inh FQName FExp.retrieveFQName();
    eq InstComponentDecl.getChild().retrieveFQName()                      = getFQName();
    eq InstComponentDecl.getInstModification().retrieveFQName()           = retrieveFQName();
    eq InstReplacingRecord.getOriginalInstComponent().retrieveFQName()    = retrieveFQName();
    eq InstReplacingComposite.getOriginalInstComponent().retrieveFQName() = retrieveFQName();
    eq InstReplacingPrimitive.getOriginalInstComponent().retrieveFQName() = retrieveFQName();
    eq InstReplacingShortClassDecl.getChild().retrieveFQName()            = isFunction() || isRecord() ? new FQNameEmpty() : retrieveFQName();
    eq InstClassDecl.getChild().retrieveFQName()                          = new FQNameEmpty();
    eq InstValueModification.getChild().retrieveFQName()                  = retrieveFQNameFromModification();
    eq InstForIndex.getChild().retrieveFQName()                           = new FQNameEmpty();
    eq InstEnumClassDecl.getChild().retrieveFQName()                      = new FQNameString(qualifiedName());
    eq InstRoot.getChild().retrieveFQName()                               = new FQNameEmpty();
    eq SourceRoot.getProgram().retrieveFQName()                           = new FQNameEmpty();
    eq FClass.getChild().retrieveFQName()                                 = null;
    
    inh FQName InstModification.retrieveFQNameFromModification();
    eq InstClassDecl.getChild().retrieveFQNameFromModification()          = retrieveFQName();
    eq InstComponentDecl.getChild().retrieveFQNameFromModification()      = retrieveFQName();
    eq InstRoot.getChild().retrieveFQNameFromModification()               = new FQNameEmpty();

    /**
     * Get a string representation of a prefix of this name.
     * 
     * @param n     the number of parts to include. If <code>n <= 0</code>, then 
     *              all but the last <code>-n</code> parts are included.
     * @param op    if not <code>null</code>, generate a name with an operator applied (e.g. "a.der(b)")
     * @param eval  if <code>true</code>, then evaluate all expressions first
     */
    private String FQNameFull.prefixName(int n, String op, boolean eval) {
        int tot = getNumFQNamePart();
        if (n <= 0)
            n = tot + n;
        StringBuilder str = new StringBuilder();
        for (int i = 0; i < n; i++) {
            FQNamePart part = getFQNamePart(i);
            boolean last = i == n - 1;
            if (last && op != null) {
                str.append(op);
                str.append("(");
            }
            str.append(part.getName());
            if ((!last || op != null || isScalarized()) && part.hasFArraySubscripts()) {
                FArraySubscripts fas = part.getFArraySubscripts();
                if (eval)
                    fas = fas.createEvaluated();
                str.append(fas);
            }
            if (!last) 
                str.append(".");
        }
        if (op != null)
            str.append(")");
        return str.toString();
    }
    
    /**
     * Gets a specific name part. Consides FQNameString as always having a single part.
     */
    syn String FQName.partName(int i) {
        throw new UnsupportedOperationException();
    }
    eq FQNameString.partName(int i) = (i == 0) ? getName() : super.partName(i);
    eq FQNameFull.partName(int i)   = getFQNamePart(i).getName();
    
    /**
     * Gets the last name part. Consides FQNameString as always having a single part.
     */
    syn String FQName.lastPartName() = partName(numParts() - 1);

    /**
     * Gets the last name part. Considers FQNameString as having one part for each '.'-separated substring.
     */
    syn String FQName.lastActualPartName() = lastPartName();
    eq FQNameString.lastActualPartName()   = getName().substring(getName().lastIndexOf('.') + 1);

    /**
     * Gets the prefix name parts. Considers FQNameString as having one part for each '.'-separated substring.
     */
    syn String FQName.prefixActualPartName();
    eq FQNameFull.prefixActualPartName()   = prefixName(-1, null, false);
    eq FQNameString.prefixActualPartName() = getName().lastIndexOf('.') < 0 ? "" : getName().substring(0, getName().lastIndexOf('.'));
    eq FQNameEmpty.prefixActualPartName() {
        throw new UnsupportedOperationException();
    }

    /**
     * The number of name parts.
     */
    syn int InstAccess.numParts() = 1;
    eq InstDot.numParts()         = getNumInstAccess();

    /**
     * The number of name parts. Will always report 1 for FQNameString.
     */
    syn int FQName.numParts()  = 0;
    eq FQNameString.numParts() = 1;
    eq FQNameFull.numParts()   = getNumFQNamePart();
    
    /**
     * The number of dots in the name.
     */
    syn int FQName.numDots() = 0;
    eq FQNameFull.numDots()  = getNumFQNamePart() - 1;
    eq FQNameString.numDots() {
        String name = getName();
        int n = 0;
        for (int i = name.indexOf('.'); i >= 0; n++, i = name.indexOf('.', i + 1));
        return n;
    }
    
    syn int FQName.numMatchingParts(FQNameFull fqn)  = 0;
    eq FQNameString.numMatchingParts(FQNameFull fqn) = 
        fqn.getFQNamePart(0).getName().equals(getName()) ? 1 : 0;
    eq FQNameFull.numMatchingParts(FQNameFull fqn) {
        int n = getNumFQNamePart();
        for (int i = 0; i < n; i++)
            if (!getFQNamePart(i).getName().equals(fqn.getFQNamePart(i).getName()))
                return i;
        return n;
    }
    
    public FArraySubscripts FArraySubscripts.createEvaluated() {
        FArraySubscripts res = new FArraySubscripts(new List());
        for (FSubscript fs : getFSubscripts())
            res.addFSubscript(fs.createEvaluated());
        return res;
    }
    
    public FSubscript FSubscript.createEvaluated() {
        return (FSubscript) fullCopy();
    }
    
    public FSubscript FExpSubscript.createEvaluated() {
        try {
            return getFExp().ceval().createFSubscript();
        } catch (ConstantEvaluationException e) {
            return fullCopy();
        }
    }
    
    syn boolean FSubscript.isColon() = false;
    eq FColonSubscript.isColon()     = true;
    
    syn boolean FSubscript.isExpSubscript() = false;
    eq FExpSubscript.isExpSubscript()       = true;
    
    syn FExpSubscript FSubscript.asExpSubscript() {
        throw new UnsupportedOperationException();
    }
    eq FExpSubscript.asExpSubscript() = this;
    
    syn FQName FAbstractVariable.getFQName() = null;

    syn String FQName.name()         = "";
    syn String FQName.resolvedName() = "";
    syn String FQName.derName()      = "";
    syn String FQName.preName()      = "";
    
    eq FQNameString.name()                 = getName();
    eq FQNameString.resolvedName()         = getName();
    syn lazy String FQNameString.derName() = applyOpToName(getName(), DER);
    syn lazy String FQNameString.preName() = applyOpToName(getName(), PRE);
    
    syn lazy String FQNameFull.name()         = prefixName(0, null, false);
    syn lazy String FQNameFull.resolvedName() = prefixName(0, null, true);
    syn lazy String FQNameFull.derName()      = prefixName(0, DER, false);
    syn lazy String FQNameFull.preName()      = prefixName(0, PRE, false);
    
    protected static final String FQName.DER = "der";
    protected static final String FQName.PRE = "pre";
    
    private String FQNameString.applyOpToName(String name, String op) {
        int p = name.lastIndexOf('.') + 1;
        return name.substring(0, p) + op + '(' + name.substring(p) + ')';
    }

    syn String FQName.scalarName() = name();
    eq FQNameFull.scalarName() {
        boolean scalar = scalarized;
        scalarized = true;
        String res = prefixName(0, null, true);
        scalarized = scalar;
        return res;
    }
    
    syn lazy String FQName.hDerName(int derOrder) {
        StringBuilder str = new StringBuilder(derName());
        int len = str.length();
        str.replace(len - 1, len, ",");
        str.append(derOrder);
        str.append(")");
        return str.toString();
    }
    
    private static String FQName.derPrefixString = "_der_der_der_der";
    
    protected static String FQName.createDerPrefixString(int order) {
        while (4 * order >= derPrefixString.length())
            derPrefixString = derPrefixString + derPrefixString;
        return derPrefixString.substring(0, 4 * order + 1);
    }
    
    syn String FQName.derPrefixName(int order) {
        String name = prefixActualPartName();
        if (!name.isEmpty())
            name += ".";
        String last = lastActualPartName();
        if (last.startsWith("_"))
            last = last.substring(1);
        name += createDerPrefixString(order) + last;
        if (hasFArraySubscripts())
            name += getFArraySubscripts();
        return name;
    }
    
    syn String FDummyDerivativeVariable.derPrefixName() = getFQName().derPrefixName(order());
    syn String FDummyDerExp.derPrefixName() = getFIdUse().getFQName().derPrefixName(order());
    
    syn String FQNamePart.name() = getName();

    syn String FIdUse.name()           = getFQName().name();
    syn String FIdUseExp.name()        = getFIdUse().name();
    eq FDerExp.name()                  = derName();
    eq FDummyDerExp.name()             = derName();
    eq FHDerExp.name()                 = hDerName(getOrder());
    eq FHDummyDerExp.name()            = hDerName(getOrder());
    eq FPreExp.name()                  = preName();
    syn String FInstAccessExp.name()   = getInstAccessNoTransform().name();
    syn String FIdUseInstAccess.name() = getInstAccessNoTransform().name();
    
    syn String FIdDecl.name() = getFQNameNoTransform().name();

    syn String FClass.name()        = getFQNameNoTransform().name();
    syn String FFunctionDecl.name() = getFQNameNoTransform().name();
    syn String FRecordDecl.name()   = getFQNameNoTransform().name();
    syn String FAttribute.name()    = getName().name();
    
    syn String FAbstractFunctionCall.name();
    eq InstFunctionCall.name()      = getNameNoTransform().name();
    eq FFunctionCall.name()         = getNameNoTransform().name();
    eq InstRecordConstructor.name() = getRecordNoTransform().name();
    eq FBuiltInFunctionCall.name()  = builtInName();
    
    syn String FAbstractVariable.name() = null;
    eq FVariable.name()         = getFQNameNoTransform().name();
    eq FFunctionVariable.name() = getFQNameNoTransform().name();
    
    syn String FEnumDecl.name() = getName().name();
    
    syn String FEnumLiteral.name() = getName().name();
    
    syn String FDerivativeFunction.name() = getNameNoTransform().name();
      
    eq FDerivativeVariable.name()       = getFQNameNoTransform().derName();
    eq FHDerivativeVariable.name()      = getFQNameNoTransform().hDerName(getOrder());
    eq FDummyDerivativeVariable.name()  = getFQNameNoTransform().derName();
    eq FHDummyDerivativeVariable.name() = getFQNameNoTransform().hDerName(getOrder());

    syn String FIdUse.derName()    = getFQNameNoTransform().derName();
    syn String FIdUseExp.derName() = getFIdUseNoTransform().derName();
    syn String FIdUse.hDerName(int derOrder)    = getFQNameNoTransform().hDerName(derOrder);
    syn String FIdUseExp.hDerName(int derOrder) = getFIdUseNoTransform().hDerName(derOrder);

    eq FPreRealVariable.name()     = getFQNameNoTransform().preName();
    eq FPreIntegerVariable.name()  = getFQNameNoTransform().preName();  
    eq FPreBooleanVariable.name()  = getFQNameNoTransform().preName();
    eq FPreStringVariable.name()   = getFQNameNoTransform().preName();
    eq FPreEnumVariable.name()     = getFQNameNoTransform().preName();

    syn String FIdUse.preName()    = getFQNameNoTransform().preName();
    syn String FIdUseExp.preName() = getFIdUseNoTransform().preName();
    
    syn String FIdUse.scalarName()    = getFQName().scalarName();
    syn String FIdUseExp.scalarName() = getFIdUse().scalarName();

    
    //syn String FIdUse.derName2() = getFQName().derName2();
    //syn String FIdUseExp.derName2() = getFIdUse().derName2();
    
    syn String FQName.nameUnderscore()            = "";
    syn lazy String FQNameString.nameUnderscore() = getName().replaceAll("]", "").replaceAll("[^0-9a-zA-Z_]", "_");
    syn lazy String FQNameFull.nameUnderscore() {
        StringBuilder str = new StringBuilder();
        int i = 0;
        int last = getNumFQNamePart() - 1;
        String sep = "";
        for (FQNamePart part : getFQNameParts()) {
            str.append(sep);
            sep = "_";
            str.append(part.nameUnderscore());
            if ((i < last || isScalarized()) && part.hasFArraySubscripts()) {
                for (FSubscript fs : part.getFArraySubscripts().getFSubscripts()) {
                    str.append(sep);
                    str.append(fs.prettyPrint(""));
                }
            }
        }
        return str.toString();
    }

    syn String FQNamePart.nameUnderscore() = getName().replaceAll("[^0-9a-zA-Z_]", "_");

    syn String FIdUse.nameUnderscore() = getFQName().nameUnderscore();
    syn String FIdUseExp.nameUnderscore() = getFIdUse().nameUnderscore();
    eq FDerExp.nameUnderscore() = "der_" + getFIdUse().nameUnderscore();
    eq FDummyDerExp.nameUnderscore() = "der_" + getFIdUse().nameUnderscore();
    eq FHDummyDerExp.nameUnderscore() = "der_" + getOrder() + "_" + getFIdUse().nameUnderscore();
    
    //syn String FInstAccessExp.nameUnderscore() = getInstAccess().nameUnderscore();
    //syn String FIdUseInstAccess.nameUnderscore() = getInstAccess().nameUnderscore();
    
    syn String FIdDecl.nameUnderscore() = getFQName().nameUnderscore();

    syn String FClass.nameUnderscore() = getFQName().nameUnderscore();
    
    public static String FClass.convertClassNameToUnderscore(String name) {
        int p = name.indexOf('(');
        if (p >= 0)
            name = name.substring(0, p);
        return name.replace(".", "_");
    }
    
    syn String FAbstractVariable.nameUnderscore() = null;
    eq FVariable.nameUnderscore()           = getFQName().nameUnderscore();
    eq FDerivativeVariable.nameUnderscore() = "der_" + getFQName().nameUnderscore();
    eq FDummyDerivativeVariable.nameUnderscore() = "der_" + getFQName().nameUnderscore();
    eq FHDummyDerivativeVariable.nameUnderscore() = "der_" + getOrder() + "_" + getFQName().nameUnderscore();
    eq FFunctionVariable.nameUnderscore()   = getFQName().nameUnderscore();
    
    syn String FQName.funcNameUnderscore(String suffix)              = "func_" + nameUnderscore() + "_" + suffix;
    syn String FIdUse.funcNameUnderscore(String suffix)              = getFQName().funcNameUnderscore(suffix);
    syn String FFunctionCall.funcNameUnderscore(String suffix)       = getName().funcNameUnderscore(suffix) + functionIndex();
    syn String FFunctionDecl.funcNameUnderscore(String suffix)       = getFQName().funcNameUnderscore(suffix) + functionIndex();
    syn String FDerivativeFunction.funcNameUnderscore(String suffix) = getName().funcNameUnderscore(suffix) + functionIndex();

    /**
     * Get the index of this function.
     */
    inh int FFunctionDecl.functionIndex();
    eq FClass.getFFunctionDecl(int i).functionIndex() = i;

    syn int FFunctionCall.functionIndex()       = myFFunctionDecl().functionIndex();
    syn int FDerivativeFunction.functionIndex() = myFFunctionDecl().functionIndex();

    syn int FAbstractVariable.variableIndex() = findVariableIndex();
    eq FPreBooleanVariable.variableIndex()    = myNonPreVariable().variableIndex();
    eq FPreIntegerVariable.variableIndex()    = myNonPreVariable().variableIndex();
    eq FPreRealVariable.variableIndex()       = myNonPreVariable().variableIndex();
    eq FPreStringVariable.variableIndex()     = myNonPreVariable().variableIndex();
    eq FPreEnumVariable.variableIndex()       = myNonPreVariable().variableIndex();
    
    inh int FAbstractVariable.findVariableIndex();
    eq FClass.getFVariable(int i).findVariableIndex()     = i;
    eq FClass.getAliasVariable(int i).findVariableIndex() = getNumFVariable() + i;
    eq FForIndex.getFVariable().findVariableIndex()       = forIndexIndex();
    eq FRecordDecl.getFVariable().findVariableIndex()     = -1;
    eq FEnumDecl.getChild().findVariableIndex()           = -1;
    eq FClass.getChild().findVariableIndex()              = -1;
    
    inh lazy int FForIndex.forIndexIndex();
    eq FClass.getChild().forIndexIndex() = nextForIndexIndex++;
    eq Root.getChild().forIndexIndex()   = -1;
    
    private int FClass.nextForIndexIndex = 0;

    inh int FRecordDecl.recordIndex();
    eq FClass.getFRecordDecl(int i).recordIndex() = i;

    inh int FEnumDecl.enumIndex();
    eq FClass.getFEnumDecl(int i).enumIndex() = i;
    
    /**
     * Check if this is a simple name, i.e. just a string or empty name.
     */
    syn boolean FQName.isSimple() = true;
    eq FQNameFull.isSimple()      = false;

    /**
     * Check if this name has any expression or colon array subscripts. 
     */
    syn boolean FQName.hasNonLiteralSubscripts() = false;
    eq FQNameFull.hasNonLiteralSubscripts() {
        for (FQNamePart part : getFQNameParts())
            if (part.hasNonLiteralSubscripts())
                return true;
        return false;
    }

    /**
     * Check if this name part has any expression or colon array subscripts.
     */
    syn boolean FQNamePart.hasNonLiteralSubscripts() = false;
    eq FQNamePartArray.hasNonLiteralSubscripts()     = getFArraySubscripts().hasNonLiteralSubscripts();
    
    /**
     * Check if this array subscript list has any expression or colon subscripts.
     */
    syn boolean FArraySubscripts.hasNonLiteralSubscripts() {
        for (FSubscript s : getFSubscripts())
            if (s.hasNonLiteralSubscripts())
                return true;
        return false;
    }

    /**
     * Check if this array subscript is an expression or colon. 
     */
    syn boolean FSubscript.hasNonLiteralSubscripts() = false;
    eq FExpSubscript.hasNonLiteralSubscripts()       = true;
    eq FColonSubscript.hasNonLiteralSubscripts()     = true;
   
    /**
     * Append a new name part.
     */
    public FQName FQName.append(String name) {
        throw new UnsupportedOperationException();
    }
    
    public FQNameString FQNameString.append(String name) {
        setName(getName() + '.' + name);
        return this;
    }
    
    public FQNameFull FQNameFull.append(String name) {
        addFQNamePart(name);
        return this;
    }

    /**
     * Copy and append all name parts from <code>fqn</code>.
     * 
     * @return  <code>this</code>, for convenience
     */
    public FQNameFull FQNameFull.append(FQName fqn) {
        return fqn.appendTo(this);
    }
 
    protected abstract FQNameFull FQName.appendTo(FQNameFull fqn);
    
    protected FQNameFull FQNameEmpty.appendTo(FQNameFull fqn) {
        return fqn;
    }
    
    protected FQNameFull FQNameString.appendTo(FQNameFull fqn) {
        return fqn.append(getName());
    }
    
    protected FQNameFull FQNameFull.appendTo(FQNameFull fqn) {
        return fqn.appendFull(this);
    }
    
    protected FQNameFull FQNameFull.appendFull(FQNameFull fqn) {
        for (FQNamePart part : fqn.getFQNameParts())
            addFQNamePart(part.fullCopy());
        return this;
    }
    
    /**
     * Create a copy of the name, with a new name part appended.
     */
    public abstract FQName FQName.copyAndAppend(String name);
    
    public FQNameString FQNameEmpty.copyAndAppend(String name) {
        return new FQNameString(name);
    }
    
    public FQNameString FQNameString.copyAndAppend(String name) {
        return new FQNameString(getName() + '.' + name);
    }
    
    public FQNameFull FQNameFull.copyAndAppend(String name) {
        return fullCopy().append(name);
    }
    
    /**
     * Create a copy of the name, with a new name part appended.
     * 
     * Passing <code>null</code> as <code>fas</code> is supported, and equivalent 
     * to using {@link #copyAndAppend(String)}.
     */
    public FQName FQName.copyAndAppend(String name, FArraySubscripts fas) {
        if (fas == null || fas.ndims() == 0)
            return copyAndAppend(name);
        FQNameFull res = copyAsFQNameFull();
        res.addFQNamePart(new FQNamePartArray(name, fas));
        return res;
    }
    
    /**
     * Create a copy of the name, with another name appended, and <code>fas</code> applied to the last part.
     * 
     * Passing <code>null</code> as <code>fas</code> is supported, and equivalent 
     * to using {@link #copyAndAppend(FQName)}.
     */
    public FQName FQName.copyAndAppend(FQName name, FArraySubscripts fas) {
        if (fas == null || fas.ndims() == 0)
            return copyAndAppend(name);
        FQName res = copyAndAppend(name);
        return res.asFQNameFull().addFArraySubscripts(fas);
    }
    
    /**
     * Create a copy of the name as an FQNameFull.
     */
    public abstract FQNameFull FQName.copyAsFQNameFull();
    
    public FQNameFull FQNameEmpty.copyAsFQNameFull() {
        return new FQNameFull();
    }
    
    public FQNameFull FQNameString.copyAsFQNameFull() {
        return new FQNameFull(getName());
    }
    
    public FQNameFull FQNameFull.copyAsFQNameFull() {
        return fullCopy();
    }
    
    /**
     * Return this name as an FQNameFull. 
     * 
     * Creates a copy only if needed.
     */
    public FQNameFull FQName.asFQNameFull() {
        return copyAsFQNameFull();
    }
    
    public FQNameFull FQNameFull.asFQNameFull() {
        return this;
    }
    
    /**
     * Create a copy of the name, with a new name part prepended.
     */
    public abstract FQName FQName.copyAndPrepend(String name);
    
    public FQNameString FQNameEmpty.copyAndPrepend(String name) {
        return new FQNameString(name);
    }
    
    public FQNameString FQNameString.copyAndPrepend(String name) {
        return new FQNameString(name + '.' + getName());
    }
    
    public FQNameFull FQNameFull.copyAndPrepend(String name) {
        FQNameFull res = new FQNameFull(name);
        int n = res.getNumFQNamePart();
        for (int i = getNumFQNamePart() - 1; i >= 0; i--)
            res.setFQNamePart(getFQNamePart(i), i + n);
        return res;
    }
    
    public FQNameFullScalarize FQNameFullScalarize.copyAndPrepend(String name) {
        return new FQNameFullScalarize(super.copyAndPrepend(name).getFQNamePartList());
     }
   
    /**
     * Create a copy of the name, with a prefix added to the first name part.
     */
    public FQName FQName.copyAndAddPrefix(String prefix) {
        return copyAndAddPrefix(prefix, false);
    }
    
    
    public abstract FQName FQName.copyAndAddPrefix(String prefix, boolean removeUnderscore);
    
    public FQNameString FQNameEmpty.copyAndAddPrefix(String prefix, boolean removeUnderscore) {
        throw new UnsupportedOperationException();
    }
    
    public FQNameString FQNameString.copyAndAddPrefix(String prefix, boolean removeUnderscore) {
        String name = getName();
        if (removeUnderscore && name.startsWith("_")) {
            name = name.substring(1);
        }
        return new FQNameString(prefix + name);
    }
    
    public FQNameFull FQNameFull.copyAndAddPrefix(String prefix, boolean removeUnderscore) {
        FQNameFull res = fullCopy();
        String name = res.getFQNamePart(0).getName();
        if (removeUnderscore && name.startsWith("_")) {
            name = name.substring(1);
        }
        res.getFQNamePart(0).setName(prefix + name);
        return res;
    }
    
    /**
     * Create a copy of the name, with another FQName appended.
     */
    public abstract FQName FQName.copyAndAppend(FQName name);
    
    public FQName FQNameEmpty.copyAndAppend(FQName name) {
        return name.fullCopy();
    }
    
    public FQName FQNameString.copyAndAppend(FQName name) {
        return name.copyAndPrepend(getName());
    }
    
    public FQName FQNameFull.copyAndAppend(FQName name) {
        return fullCopy().append(name);
    }
    
    /**
     * Create a copy of the name, with an FSubscript added to the last part.
     */
    public abstract FQName FQName.copyAndAddSubscript(FSubscript s);
    
    public FQName FQNameEmpty.copyAndAddSubscript(FSubscript s) {
        throw new UnsupportedOperationException();
    }
    
    public FQName FQNameString.copyAndAddSubscript(FSubscript s) {
        return new FQNameFull(getName()).addSubscript(s);
    }
    
    public FQName FQNameFull.copyAndAddSubscript(FSubscript s) {
        return fullCopy().addSubscript(s);
    }

    /**
     * Add new FSubscript to the last name part.
     */
    public FQName FQNameFull.addSubscript(FSubscript s) {
        int i = getNumFQNamePart() - 1;
        setFQNamePart(getFQNamePart(i).addSubscript(s), i);
        return this;
    }
    
    /**
     * Add an array subscript to this name part, if necessary creating a new name part.
     * 
     * This name part might or might not be altered - replace it with the return value.
     */
    public FQNamePartArray FQNamePart.addSubscript(FSubscript s) {
        return new FQNamePartArray(getName(), new FArraySubscripts(new List(s)));
    }
   
    public FQNamePartArray FQNamePartArray.addSubscript(FSubscript s) {
        getFArraySubscripts().addFSubscript(s);
        return this;
    }
    
    /**
     * Create a copy of the name, with an FArraySubscripts added to the last part.
     * 
     * Any previous FArraySubscripts is removed. Passing null as fas is equivalent 
     * to calling {@link #removeFArraySubscripts()}.
     */
    public abstract FQName FQName.copyAndAddFas(FArraySubscripts fas);
    
    public FQName FQNameEmpty.copyAndAddFas(FArraySubscripts fas) {
        if (fas == null)
            return fullCopy();
        throw new UnsupportedOperationException();
    }
    
    public FQName FQNameString.copyAndAddFas(FArraySubscripts fas) {
        if (fas == null)
            return fullCopy();
        return new FQNameFull(getName()).addFArraySubscripts(fas);
    }
    
    public FQName FQNameFull.copyAndAddFas(FArraySubscripts fas) {
        return fullCopy().addFArraySubscripts(fas);
    }
    
    /**
     * Copies this and add <code>i</code> as subscripts if <code>i</code>
     * has dimensions. Otherwise returns this.
     */
    public FQName FQName.copyAndAddIfFas(Index i) {
        if (i.ndims() > 0) {
            return copyAndAddFas(i.createFArraySubscripts());
        }
        return this;
    }
    
    /**
     * Set the FArraySubscripts of the last FQNamePart.
     * 
     * Passing null as fas is equivalent to calling {@link #removeFArraySubscripts()}.
     * 
     * @return  <code>this</code>, for convenience
     */
    public FQNameFull FQNameFull.addFArraySubscripts(FArraySubscripts fas) {
        if (fas == null)
            return removeFArraySubscripts();
        int i = getNumFQNamePart() - 1;
        setFQNamePart(new FQNamePartArray(getFQNamePart(i).getName(), fas), i);
        return this;
    }
    
    /**
     * Remove the FArraySubscripts of the last FQNamePart, if any.
     * 
     * @return  <code>this</code>, for convenience
     */
    public FQName FQName.removeFArraySubscripts() {
        return this;
    }
   
    public FQNameFull FQNameFull.removeFArraySubscripts() {
        int i = getNumFQNamePart() - 1;
        if (getFQNamePart(i).hasFArraySubscripts())
            setFQNamePart(new FQNamePart(getFQNamePart(i).getName()), i);
        return this;
    }
   
    /**
     * Create a copy of the name excluding the first part.
     */
    public FQName FQName.copySuffix() {
        return copyPart(1, numDots());
    }
    
    /**
     * Create a copy of the last part of this name.
     */
    public FQName FQName.copyLastSuffix() {
        int i = numDots();
        return copyPart(i, i);
    }
    
    /**
     * Create a copy of the last <code>n</code> parts of this name.
     */
    public FQName FQName.copySuffix(int n) {
        int m = numDots();
        return copyPart(m - n + 1, m);
    }
    
    /**
     * Create a copy of all but the first <code>n</code> parts of this name.
     */
    public FQName FQName.copyWithoutPrefix(int n) {
        return copyPart(n, numDots());
    }

    /**
     * Create a copy of the name excluding the last part.
     */
    public FQName FQName.copyPrefix() {
        return copyPart(0, numDots() - 1);
    }
    
    /**
     * Create a copy of the first part of this name.
     */
    public FQName FQName.copyFirstPrefix() {
        return copyPart(0, 0);
    }

    /**
     * Create a copy of the first <code>n</code> parts of this name.
     */
    public FQName FQName.copyPrefix(int n) {
        return copyPart(0, n - 1);
    }

    /**
     * Create a copy of all but the last <code>n</code> parts of this name.
     */
    public FQName FQName.copyWithoutSuffix(int n) {
        return copyPart(0, numDots() - n);
    }
    
    /**
     * Create a copy of parts <code>first</code> to <code>last</code> of this name (zero-based).
     */
    public abstract FQName FQName.copyPart(int first, int last);
    
    public FQName FQNameEmpty.copyPart(int first, int last) {
        throw new UnsupportedOperationException();
    }
    
    public FQName FQNameString.copyPart(int first, int last) {
        if (last < first)
            return new FQNameEmpty();
        int fp = -1;
        String name = getName();
        for (int i = 0; i < first && (i == 0 || fp >= 0); i++)
            fp = name.indexOf('.', fp + 1);
        if (fp < 0 && first > 0)
            throw new ArrayIndexOutOfBoundsException(first);
        int lp = (fp < 0) ? 0 : fp;
        for (int i = first; i < last && lp >= 0; i++)
            lp = name.indexOf('.', lp + 1);
        if (lp < 0 && last > 0)
            throw new ArrayIndexOutOfBoundsException(last);
        lp = name.indexOf('.', lp + 1);
        return new FQNameString((lp < 0) ? name.substring(fp + 1) : name.substring(fp + 1, lp));
    }
    
    public FQName FQNameFull.copyPart(int first, int last) {
        if (last < first)
            return new FQNameEmpty();
        if (last == first)
            return getFQNamePart(first).createFQName();
        FQNameFull res = new FQNameFull();
        for (int i = first; i <= last; i++)
            res.addFQNamePart(getFQNamePart(i).fullCopy());
        return res;
    }

    public FQName FQNameFullScalarize.copyPart(int first, int last) {
        FQName res = super.copyPart(first, last);
        if (res instanceof FQNameFull)
            return new FQNameFullScalarize(((FQNameFull) res).getFQNamePartList());
        else 
            return res;
    }

    /**
     * Create an FQName containing only a copy of this part.
     */
    public FQName FQNamePart.createFQName() {
        return new FQNameString(getName());
    }
    
    public FQName FQNamePartArray.createFQName() {
        return new FQNameFull(new List(fullCopy()));
    }
    
    /**
     * Create a copy of this name without array subscripts.
     */
    public FQName FQName.copyWithoutSubscripts() {
        return fullCopy();
    }
    
    public FQName FQNameFull.copyWithoutSubscripts() {
        FQNameFull res = new FQNameFull();
        for (FQNamePart part : getFQNameParts())
            res.addFQNamePart(part.getName());
        return res;
    }
    
    /**
     * Create a copy of this name with all array subscripts replaced with indices 
     * from <code>i</code>.
     * 
     * The number of dimensions of <code>i</code> must be the same as the number 
     * of non-literal subscripts. The subscripts to be replaced can be spread out 
     * over several name parts.
     */
    public FQName FQName.copyReplacingSubscripts(Index i) {
        return fullCopy();
    }
    
    public FQName FQNameFull.copyReplacingSubscripts(Index i) {
        FQNameFull res = new FQNameFull();
        int j = 0;
        for (FQNamePart part : getFQNameParts()) 
            j = part.appendWithReplacedSubscripts(res, i, j);
        return res;
    }
    
    /**
     * Append this name part to <code>name</code>, but with 
     * all array subscripts replaced with indices from <code>i</code>.
     * 
     * The first index in <code>i</code> to use should be given in <code>j</code>, and 
     * the new value for <code>j</code> is returned.
     */
    public int FQNamePart.appendWithReplacedSubscripts(FQNameFull name, Index i, int j) {
        name.append(getName());
        return j;
    }
    
    public int FQNamePartArray.appendWithReplacedSubscripts(FQNameFull name, Index i, int j) {
        int k = j + getFArraySubscripts().getNumFSubscript();
        name.append(getName());
        name.addFArraySubscripts(i.partIndex(j, k).createFArraySubscripts());
        return k;
    }
    
    /**
     * Interface for variable declarations in flat and instance trees.
     */
    public interface CommonVariableDecl {
        public FExp createUseExp();
    }
    
    /**
     * Create an access to this variable.
     */
    public FIdUse FAbstractVariable.createFIdUse() {
         return null;
    }
    // TODO: Add implementation for enum
   
    public FIdUse FVariable.createFIdUse() {
         return getFQName().createUseFQName().createFIdUse();
    }  
   
    public FIdUse FFunctionVariable.createFIdUse() {
         return getFQName().createUseFQName().createFIdUse();
    }  
   
    /**
     * Create an access expression to this variable.
     */
    public FIdUseExp FVariable.createUseExp() {
         return getFQName().createUseFQName().createFIdUseExp();
    }

    public FIdUseExp FDerivativeVariable.createUseExp() {
         return getFQName().createUseFQName().createFDerExp();
    }

    public FIdUseExp FHDerivativeVariable.createUseExp() {
         return getFQName().createUseFQName().createFHDerExp(getOrder());
    }

    public FIdUseExp FDummyDerivativeVariable.createUseExp() {
         return getFQName().createUseFQName().createFDummyDerExp();
    }

    public FIdUseExp FHDummyDerivativeVariable.createUseExp() {
         return getFQName().createUseFQName().createFHDummyDerExp(getOrder());
    }
    
    public FIdUseExp FFunctionVariable.createUseExp() {
         return getFQName().createUseFQName().createFIdUseExp();
    }
    
    public FExp FEnumLiteral.createUseExp() {
         return new FEnumLitExp(myFEnumDecl().name(), name(), null);
    }
    
    public FExp UnknownFVariable.createUseExp() {
         return null;
    }

    /**
     * Create an access to this variable, from a scope where it can be accessed unqualified.
     */
    public FInstAccessExp InstComponentDecl.createUseExp() {
        return new FInstAccessExp(new InstComponentAccess(name()));
    }

    /**
     * Create an access expression with this access.
     */
    abstract public FExp CommonAccess.createFExp();

    public FInstAccessExp InstAccess.createFExp() {
        return new FInstAccessExp(this);
    }

    public FIdUseExp FIdUse.createFExp() {
        return new FIdUseExp(this);
    }

    /**
     * Create a pre() expression for this variable.
     */
    public FPreExp FVariable.createFPreExp() {
        return new FPreExp(createFIdUse());
    }

    /**
     * Create an FDerExp for this name, using a copy if needed.
     */
    public FDerExp FQName.createFDerExp() {
        return new FDerExp(createFIdUse()); 
    }

    /**
     * Create an FHDerExp for this name, using a copy if needed.
     */
    public FHDerExp FQName.createFHDerExp(int order) {
        return new FHDerExp(createFIdUse(), order); 
    }

    /**
     * Create an FDummyDerExp for this name, using a copy if needed.
     */
    public FDummyDerExp FQName.createFDummyDerExp() {
        return new FDummyDerExp(createFIdUse()); 
    }

    /**
     * Create an FHDummyDerExp for this name, using a copy if needed.
     */
    public FHDummyDerExp FQName.createFHDummyDerExp(int order) {
        return new FHDummyDerExp(createFIdUse(), order); 
    }
    
    /**
     * Create an FIdUseExp for this name, using a copy if needed.
     */
    public FIdUseExp FQName.createFIdUseExp() {
        return new FIdUseExp(createFIdUse()); 
    }
    
    /**
     * Create a copy of this name that is suitable for an FIdUse.
     * 
     * It is assumed that this name is from a variable declaration.
     */
    public FQName FQName.createUseFQName() {
        if (!isScalarized() && ndims() > 0)
            return copyAndAddFas(size().createExpandedFArraySubscripts());
        else
            return fullCopy();
    }
    
    /**
     * Create an FIdUse for this name, using a copy if needed.
     */
    public FIdUse FQName.createFIdUse() {
        return new FIdUse((FQName) unboundCopy()); 
    }
    
    /**
     * Create an FIdUseExp using a copy of this name.
     * 
     * @param fas  array subscripts to use for the last name part.
     */
    public FIdUseExp FQName.createFIdUseExp(FArraySubscripts fas) {
        return new FIdUseExp(createFIdUse(fas)); 
    }
    
    /**
     * Create an FIdUse using a copy of this name.
     * 
     * @param fas  array subscripts to use for the last name part.
     */
    public FIdUse FQName.createFIdUse(FArraySubscripts fas) {
        return new FIdUse(copyAndAddFas(fas)); 
    }
    
    syn String FType.name();
    eq FRealType.name()             = "Real";
    eq FIntegerType.name()          = "Integer";
    eq FBooleanType.name()          = "Boolean";
    eq FStringType.name()           = "String";
    eq FEnumType.name()             = getName();
    eq FEnumLiteralType.name()      = getName();
    eq FRecordType.name()           = getName();
    eq FUnknownType.name()          = "(unknown type)";
    eq FNoType.name()               = "(no return value)";
    eq FExternalObjectType.name()   = getName();
    eq FPartialFunctionType.name()  = getName();
    
    
    syn boolean FAbstractFunctionCall.ignoreInFlattening() = false;
    eq FIgnoredBuiltIn.ignoreInFlattening()                = true;
    eq FConnectionsOp.ignoreInFlattening()                 = true;
    
    syn boolean FAbstractEquation.ignoreInFlattening() = false;
    eq FFunctionCallEquation.ignoreInFlattening()      = getCall().ignoreInFlattening();
    
    syn boolean FAbstractFunctionCall.isIgnored() = false;
    eq FIgnoredBuiltIn.isIgnored()                = true;
    
    syn boolean FAbstractEquation.isIgnored() = false;
    eq FFunctionCallEquation.isIgnored()      = getCall().isIgnored();
    
    /**
     * Add an equation to the first equation block.
     */
    public void FClass.addFEquation(FAbstractEquation feq) {
        addFAbstractEquationNoTransform(feq);
    }
    
}


aspect FlatFunctionUtils {
     
     syn boolean FFunctionVariable.isInput()  = hasFTypePrefixInputOutput() && getFTypePrefixInputOutput().inputCausality();
     syn boolean FFunctionVariable.isOutput() = hasFTypePrefixInputOutput() && getFTypePrefixInputOutput().outputCausality();
     
     /**
      * Returns a list of all InstComponentDecls declared as "input".
      */
     syn lazy ArrayList<InstComponentDecl> InstNode.myInputs() {
         ArrayList<InstComponentDecl> l = new ArrayList<InstComponentDecl>();
         Set<String> names = new HashSet<String>();
         for (InstComponentDecl icd : allInstComponentDecls())
             if (icd.isInput() && names.add(icd.name()))
                 l.add(icd);
         return l;
     }
     eq InstSimpleShortClassDecl.myInputs() = actualInstClass().myInputs();
     
     /**
      * Returns a list of all InstComponentDecls not declared as "input".
      */
     syn lazy ArrayList<InstComponentDecl> InstNode.myNonInputs() {
         ArrayList<InstComponentDecl> l = new ArrayList<InstComponentDecl>();
         Set<String> names = new HashSet<String>();
         for (InstComponentDecl icd : allInstComponentDecls())
             if (!icd.isInput() && names.add(icd.name()))
                 l.add(icd);
         return l;
     }
     eq InstSimpleShortClassDecl.myNonInputs() = actualInstClass().myNonInputs();
     
     /**
      * Returns a list of all InstComponentDecls declared as "output".
      */
     syn lazy ArrayList<InstComponentDecl> InstNode.myOutputs() {
         ArrayList<InstComponentDecl> l = new ArrayList<InstComponentDecl>();
         Set<String> names = new HashSet<String>();
         for (InstComponentDecl icd : allInstComponentDecls())
             if (icd.isOutput() && names.add(icd.name()))
                 l.add(icd);
         return l;
     }
     eq InstSimpleShortClassDecl.myOutputs() = actualInstClass().myOutputs();
     eq InstPartialFunction.myOutputs()      = myInstClass().myOutputs();
     
     /**
      * Returns a list of all contained InstComponentDecls that may be altered by a modification.
      */
     syn lazy ArrayList<InstComponentDecl> InstNode.myModifiableComponents() {
         ArrayList<InstComponentDecl> l = new ArrayList<InstComponentDecl>();
         for (InstComponentDecl icd : allInstComponentDecls())
             if (icd.isModifiable())
                 l.add(icd);
         return l;
     }
     eq InstSimpleShortClassDecl.myModifiableComponents() = actualInstClass().myModifiableComponents();
     
     /**
      * May this component be altered by a modification?
      */
     syn boolean InstComponentDecl.isModifiable() = !isConstant() && !getComponentDecl().hasFinal();
     // TODO: Are there other reasons a component might not be modifiable?
     
     /**
      * Returns a list of all FFunctionVariables declared as "input".
      */
     syn lazy ArrayList<FFunctionVariable> FFunctionDecl.myInputs() {
         ArrayList<FFunctionVariable> l = new ArrayList<FFunctionVariable>();
         for (FFunctionVariable var : getFFunctionVariables())
             if (var.isInput())
                 l.add(var);
         return l;
     }
     
    /**
     * Returns the i:th FFunctionVariable that is  declared as "input".
     */
    syn FFunctionVariable FFunctionDecl.myInput(int i) = myInputs().get(i);
     
     /**
      * Returns a list of all FFunctionVariables not declared as "input" or "output".
      */
     syn lazy ArrayList<FFunctionVariable> FFunctionDecl.myProtected() {
         ArrayList<FFunctionVariable> l = new ArrayList<FFunctionVariable>();
         for (FFunctionVariable var : myNonInputs())
             if (!var.isOutput())
                 l.add(var);
         return l;
     }
     
     /**
      * Returns a list of all FFunctionVariables not declared as "input".
      */
     syn lazy ArrayList<FFunctionVariable> FFunctionDecl.myNonInputs() {
         ArrayList<FFunctionVariable> l = new ArrayList<FFunctionVariable>();
         for (FFunctionVariable var : getFFunctionVariables())
             if (!var.isInput())
                 l.add(var);
         return l;
     }
     
     /**
      * Returns a list of all FFunctionVariables declared as "output".
      */
     syn lazy ArrayList<FFunctionVariable> FFunctionDecl.myOutputs() {
         ArrayList<FFunctionVariable> l = new ArrayList<FFunctionVariable>();
         for (FFunctionVariable var : getFFunctionVariables())
             if (var.isOutput())
                 l.add(var);
         return l;
     }
     
     syn ArrayList<InstComponentDecl> InstFunctionCall.myInputs() = getName().myInstFunctionDecl().myCallInputs();
     
     /**
      * Returns a list of all components in this class that would be inputs in a function call or 
      * record constructor. Treats all non-records as functions.
      */
     syn ArrayList<InstComponentDecl> InstClassDecl.myCallInputs()        = isRecord() ? myModifiableComponents() : myInputs();
     syn ArrayList<InstComponentDecl> InstPartialFunction.myCallInputs()  = myInputs();
     
     syn ArrayList<InstComponentDecl> InstFunctionCall.myOutputs() = getName().myInstFunctionDecl().myOutputs();
     syn ArrayList<FFunctionVariable> FFunctionCall.myInputs()     = myFFunctionDecl().myInputs();
     syn ArrayList<FFunctionVariable> FFunctionCall.myOutputs()    = myFFunctionDecl().myOutputs();
     
     syn boolean InstFunctionCall.hasOutputs() = !myOutputs().isEmpty();
     syn boolean FFunctionDecl.hasOutputs()    = !myOutputs().isEmpty();
     syn boolean FFunctionCall.hasOutputs()    = myFFunctionDecl().hasOutputs();
     
     syn InstComponentDecl InstFunctionCall.expOutput() = myOutputs().get(0);
     syn FFunctionVariable FFunctionDecl.expOutput()    = myOutputs().get(0);
     syn FFunctionVariable FFunctionCall.expOutput()    = myFFunctionDecl().expOutput();
    
     syn lazy FunctionReturnDefinition FFunctionDecl.returnDefinition() = new FunctionReturnDefinition(this);
     inh FunctionReturnDefinition FReturnStmt.returnDefinition();
     eq FFunctionDecl.getFAlgorithm().returnDefinition() = returnDefinition();
     eq InstProgramRoot.getChild().returnDefinition()         = null;
     eq FClass.getChild().returnDefinition()                  = null;
     
     inh String InstFunctionArgument.funcName();
     inh String FFunctionCallLeft.funcName();
     eq FAbstractFunctionCall.getChild().funcName() = name();
     eq FFunctionCallEquation.getChild().funcName() = getCall().name();
     eq FFunctionCallStmt.getChild().funcName()     = getCall().name();
     
     /**
      * Check if this function returns an array when used as an expression.
      */
     syn boolean FFunctionDecl.isArray() = hasOutputs() ? expOutput().isArray() : false;
     
     /**
      * Check if this function returns a record when used as an expression.
      */
     syn boolean FFunctionDecl.isRecord() = hasOutputs() ? expOutput().type().isRecord() : false;
     
     /**
      * Check if this function returns a non-primitive when used as an expression.
      */
     syn boolean FFunctionDecl.isComposite() = hasOutputs() ? expOutput().isComposite() : false;
     
    syn boolean FFunctionDecl.containsRealInputs() {
        for (FFunctionVariable var : myInputs())
            if (var.type().containsReal())
                return true;
        return false;
    }
    syn boolean FFunctionDecl.containsRealOutputs() {
        for (FFunctionVariable var : myOutputs())
            if (var.type().containsReal())
                return true;
        return false;
    }
    
    syn boolean FFunctionDecl.requiresDerivative() = true;
    eq FConstructorDecl.requiresDerivative()       = false;
    eq FDestructorDecl.requiresDerivative()        = false;
    
    syn boolean FFunctionDecl.derivativEqualsZero() = !containsRealInputs() || !containsRealOutputs();
    
    /**
     * Determines if the compiler is able to differentiate this function declaration
     */
    syn boolean FFunctionDecl.canDifferentiate() {
        if (hasFDerivativeFunction())
            return true;
        if (derivativEqualsZero())
            return true;
        for (FStatement statement : getFAlgorithm().getFStatements())
            if (!statement.canDifferentiate())
                return false;
        return true;
    }
    
    syn boolean FStatement.canDifferentiate() = true;
    eq FExternalStmt.canDifferentiate()       = false;
    
     
     /**
      * Returns a string (tersely) describing the signature of the function.
      * 
      * Intended to make it easier to compare the signatures of functions.
      * The string consists of one character for each input/output, followed by the number 
      * of dimensions. The inputs are first, followed by a colon, and then the oututs.
      * The characters used are R - Real, I - Integer, B - Boolean and S - String. 
      * Records are represented by the record name within parenthesis, followed by the number
      * of dimensions. Enumerations are treated the same way, but with brackets instead of 
      * parenthesis.
      * 
      * Example:
      * Inputs: Real, Integer[2], Real[:,4], outputs: Real, Real gives "r0i1r2:r0r0".
      */
     syn lazy String FFunctionDecl.signatureString() {
         StringBuilder buf = new StringBuilder();
         for (FFunctionVariable v : myInputs())
             buf.append(v.type().signatureString());
         buf.append(':');
         for (FFunctionVariable v : myOutputs())
             buf.append(v.type().signatureString());
         return buf.toString();
     }
     
     /**
      * Returns a string (tersely) describing this type.
      * 
      * @see FFunctionDecl#signatureString()
      */
     syn String FType.signatureString() = "-";
     eq FRealType.signatureString()     = String.format("r%d", ndims());
     eq FIntegerType.signatureString()  = String.format("i%d", ndims());
     eq FBooleanType.signatureString()  = String.format("b%d", ndims());
     eq FStringType.signatureString()   = String.format("s%d", ndims());
     eq FEnumType.signatureString()     = String.format("[%s]%d", getName(), ndims());
     eq FRecordType.signatureString()   = String.format("(%s)%d", getName(), ndims());
     
     /**
      * Set to a class to make all children behave as if this was declared in that function.
      */
     private InstClassDecl InstAssignable.temporarilyInFunction = null;
     
     /**
      * Check is this node is in a function.
      */
     inh boolean FQName.inFunction();
     inh boolean InstFunctionArgument.inFunction();
     inh boolean InstComponentDecl.inFunction();
     inh boolean InstExternal.inFunction();
     inh boolean InstAccess.inFunction();
     inh boolean InstForIndex.inFunction();
     inh boolean FExp.inFunction();
     inh boolean FIdUse.inFunction();
     inh boolean FStatement.inFunction();
     inh boolean FAbstractEquation.inFunction();
     inh boolean FSubscript.inFunction();
     inh boolean FFunctionCallLeft.inFunction();
     eq InstBaseClassDecl.getChild().inFunction() = isFunction();
     eq FFunctionDecl.getChild().inFunction()     = true;
     eq InstAssignable.getChild().inFunction()    = (temporarilyInFunction != null) || inFunction();
     eq Root.getChild().inFunction()              = false;
     
     /**
      * Get the containing FFunctionDecl.
      * 
      * Only valid in flat tree.
      */
     inh FFunctionDecl FExp.containingFFunctionDecl();
     inh FFunctionDecl FVariable.containingFFunctionDecl();
     inh FFunctionDecl FExternalStmt.containingFFunctionDecl();
     eq FFunctionDecl.getChild().containingFFunctionDecl()  = this;
     eq InstNode.getChild().containingFFunctionDecl()       = null;
     eq Root.getChild().containingFFunctionDecl()           = null;
     
     /**
      * Get the class or component containing this node.
      */
     inh InstNode InstNode.containingEntity();
     eq InstClassDecl.getChild().containingEntity()     = this;
     eq InstComponentDecl.getChild().containingEntity() = this;
     eq Root.getChild().containingEntity()              = null;
     
     /**
      * Check is this node is in a non-function algorithm.
      */
     inh boolean FSubscript.inAlgorithm();
     inh boolean FFunctionCall.inAlgorithm();
     inh boolean FIdUse.inAlgorithm();
     inh boolean FExp.inAlgorithm();
     eq FAlgorithm.getChild().inAlgorithm()   = !inFunction();
     eq InstNode.getChild().inAlgorithm()          = false;
     eq FAbstractEquation.getChild().inAlgorithm() = false;
     eq FClass.getChild().inAlgorithm()            = false;
     
     /**
      * Check is this node is in an algorithm or a function.
      */
     syn boolean FSubscript.inAlgorithmOrFunction() = inFunction() || inAlgorithm();
     
     /**
      * Check if this function call is the call of a function call equation 
      *        or function call statement.
      */
     inh boolean FAbstractFunctionCall.isFunctionCallClause();
     eq ASTNode.getChild().isFunctionCallClause()              = false;
     eq FFunctionCallEquation.getCall().isFunctionCallClause() = true;
     eq FFunctionCallStmt.getCall().isFunctionCallClause()     = true;
     
     inh boolean FStatement.insideBlockStmt();
     eq Root.getChild().insideBlockStmt()        = false;
     eq FAlgorithm.getChild().insideBlockStmt()  = false;
     eq FIfWhenStmt.getChild().insideBlockStmt() = true;
     eq FWhileStmt.getChild().insideBlockStmt()  = true;
     eq FForStmt.getChild().insideBlockStmt()    = true;
     eq InstForStmt.getChild().insideBlockStmt() = true;
     
     inh boolean FStatement.insideBranchedStmt();
     eq Root.getChild().insideBranchedStmt()        = false;
     eq FAlgorithm.getChild().insideBranchedStmt()  = false;
     eq FIfWhenStmt.getChild().insideBranchedStmt() = true;
     
     /**
      * Return the index of the variable assigned by this FFunctionCallLeft among 
      *        all those assigned by the same FFunctionCallEquation/Stmt
      */
     syn lazy int FFunctionCallLeft.myIndex() = prevIndex() + (hasFExp() ? 1 : 0);
     inh int FFunctionCallLeft.prevIndex();
     eq FFunctionCallEquation.getLeft(int i).prevIndex() = (i == 0) ? -1 : getLeft(i - 1).myLastIndex();
     eq FFunctionCallStmt.getLeft(int i).prevIndex()     = (i == 0) ? -1 : getLeft(i - 1).myLastIndex();
     
     syn int FFunctionCallLeft.myLastIndex() = myIndex() + (hasFExp() ? numScalarVars() - 1 : 0);
     
     /**
      * Get the number of scalar variables assigned by this FFunctionCallLeft.
      * 
      * Only valid after scalarization.
      */
     syn int FFunctionCallLeft.numScalarVars() = (hasFExp() ? getFExp().numScalarVars() : 0);
     
     /**
      * Get the number of scalar variables assigned by this a FFunctionCallLeft with this 
      *        FExp as its expression.
      * 
      * Only valid after scalarization.
      */
     syn int FExp.numScalarVars() = 1;
     eq FArray.numScalarVars() {
         int n = getNumFExp();
         return (n == 0) ? 0 : n * getFExp(0).numScalarVars();
     }
     eq FRecordConstructor.numScalarVars() {
         int n = 0;
         for (FExp e : getArgs())
             n += e.numScalarVars();
         return n;
     }
     
     inh lazy InstComponentDecl FFunctionCallLeft.myOutput();
     eq FFunctionCallEquation.getLeft(int i).myOutput() = getCall().findOutput(i);
     eq FFunctionCallStmt.getLeft(int i).myOutput()     = getCall().findOutput(i);
     syn InstComponentDecl FAbstractFunctionCall.findOutput(int i) = unknownInstComponentDecl();
     eq InstFunctionCall.findOutput(int i)                         = 
         (i >= myOutputs().size()) ? unknownInstComponentDecl() : myOutputs().get(i);
     
     inh boolean FAbstractFunctionCall.functionCallIsExp();
     eq FExp.getChild().functionCallIsExp()                 = true;
     eq FClass.getChild().functionCallIsExp()               = true;
     eq InstNode.getChild().functionCallIsExp()             = true;
     eq FFunctionCallEquation.getCall().functionCallIsExp() = false;
     eq FFunctionCallStmt.getCall().functionCallIsExp()     = false;
     
     inh lazy ArrayList<FFunctionCallLeft> FAbstractFunctionCall.myLefts();
     eq FExp.getChild().myLefts()                 = new ArrayList<FFunctionCallLeft>();
     eq FClass.getChild().myLefts()               = new ArrayList<FFunctionCallLeft>();
     eq InstNode.getChild().myLefts()             = new ArrayList<FFunctionCallLeft>();
     eq FFunctionCallEquation.getCall().myLefts() = getLefts().toArrayList();
     eq FFunctionCallStmt.getCall().myLefts()     = getLefts().toArrayList();
     
     inh FAbstractFunctionCall FExp.myFunctionCall();
     eq Root.getChild().myFunctionCall() = null;
     eq FFunctionCall.getChild().myFunctionCall() = this;
     eq FFunctionCallEquation.getLeft().myFunctionCall() = getCall();
     eq FFunctionCallStmt.getLeft().myFunctionCall() = getCall();
     
     /**
      * Get the name this expression should use for temporary variable.
      * 
      * Uses custom caching to avoid flushing.
      */
     syn String FExp.tempVarName() {
         if (myTempVarName == null)
             myTempVarName = calcTempVarName();
         return myTempVarName;
     }
     private String FExp.myTempVarName;
     inh String FExp.calcTempVarName();
     eq InstNode.getChild().calcTempVarName()            = null;
     eq FFunctionCall.getArray().calcTempVarName()       = tempVarName();
     eq FVectorFunctionCall.getArray().calcTempVarName() = calcTempVarName();
     eq FClass.getChild().calcTempVarName()              = nextTempVarName();
     eq FFunctionDecl.getChild().calcTempVarName()       = nextTempVarName();
     
     /**
      * Creates expressions based on tempVarName();
      */
     syn FIdUseExp FExp.tempUseExp() = new FIdUseExp(tempVarName());
     syn FPreExp   FExp.tempPreExp() = new FPreExp(new FIdUse(tempVarName()));
     syn FVariable FExp.tempVar() = tempVar(variability(), type());
     syn FVariable FExp.tempVar(FTypePrefixVariability variability, FType type)
         = type.createTempFVariable(new FQNameFull(tempVarName()), variability);
     
     /**
      * Throw away calculated temp names.
      */
     public void ASTNode.flushTempVarNames() {
         for (ASTNode n : this)
             n.flushTempVarNames();
     }
     public void FExp.flushTempVarNames() {
         myTempVarName = null;
         super.flushTempVarNames();
     }
     
     public String FClass.nextTempVarName() {
         FlatVariableMap vars = variablesMap();
         String name;
         do {
             name = "temp_" + nextTempVarIndex++;
         } while (vars.lookup(name) != null);
         return name;
     }
     public String FFunctionDecl.nextTempVarName() {
         FlatVariableMap vars = variablesMap();
         String name;
         do {
             name = "temp_" + nextTempVarIndex++;
         } while (vars.lookup(name) != null);
         return name;
     }
     public String FClass.nextTempVarName(FFunctionDecl func) {
         FlatVariableMap vars1 = variablesMap();
         FlatVariableMap vars2 = func.variablesMap();
         String name;
         do {
             name = "temp_" + nextTempVarIndex++;
         } while (vars1.lookup(name) != null || vars2.lookup(name) != null);
         return name;
     }
     
     private int FFunctionDecl.nextTempVarIndex = 1;
     private int FClass.nextTempVarIndex = 1;

    public String FClass.nextTempFuncName() {
        String name;
        do {
            name = "temp_" + nextTempFuncIndex++;
        } while (lookupFunc(name) != null);
        return name;
    }
    private int FClass.nextTempFuncIndex = 1;
}


aspect FlatExpressions {
    
    inh boolean FExp.inEquationSection();
    inh boolean FAbstractEquation.inEquationSection();
    inh boolean FStatement.inEquationSection();
    eq FClass.getFAbstractEquation().inEquationSection() = true;
    eq Root.getChild().inEquationSection() = false;
    inh boolean FExp.inInitialEquationSection();
    inh boolean FAbstractEquation.inInitialEquationSection();
    inh boolean FStatement.inInitialEquationSection();
    eq FClass.getFInitialEquation().inInitialEquationSection() = true;
    eq Root.getChild().inInitialEquationSection() = false;

    inh boolean FExp.inEquation();
    eq FAbstractEquation.getChild().inEquation() = true;
    eq Root.getChild().inEquation() = false;
    
    inh boolean FExp.inNoEventExp();
    eq FNoEventExp.getChild().inNoEventExp() = true;
    eq FFunctionDecl.getChild().inNoEventExp() = true;
    eq SourceRoot.getChild().inNoEventExp() = false;
    eq FlatRoot.getChild().inNoEventExp() = false;
    eq FClass.getFParameterEquation().inNoEventExp() = true;

    inh boolean FExp.inSmoothExp(int order);
    eq FSmoothExp.getChild().inSmoothExp(int order) = getOrder().ceval().intValue() >= order;
    eq SourceRoot.getChild().inSmoothExp(int order) = false;
    eq FlatRoot.getChild().inSmoothExp(int order) = false;
    
    inh boolean InstAccess.inConnectClause();
    inh boolean FExp.inConnectClause();
    eq FConnectClause.getChild().inConnectClause()    = true;
    eq FAbstractEquation.getChild().inConnectClause() = false;
    eq SourceRoot.getChild().inConnectClause()        = false;
    eq FlatRoot.getChild().inConnectClause()          = false;

    inh boolean FExp.inIfCondition();
    eq FIfExp.getChild().inIfCondition()            = true;
    eq FAssert.getTest().inIfCondition()            = true;
    eq FAbsExp.getChild().inIfCondition()           = true;
    eq FSignExp.getChild().inIfCondition()          = true;
    eq FAbstractEquation.getChild().inIfCondition() = false;
    eq SourceRoot.getChild().inIfCondition()        = false;
    eq FlatRoot.getChild().inIfCondition()          = false;

    inh boolean FAbstractEquation.inWhen();
    eq FClass.getChild().inWhen()                          = false;
    eq InstNode.getChild().inWhen()                        = false;
    eq FIfWhenElseEquation.getFAbstractEquation().inWhen() = isWhen() || inWhen();
    
    inh boolean FStatement.inWhen();
    inh boolean FIfClause.inWhen();
    eq FIfClause.getFStatement().inWhen()   = myFStatement().isWhen() || inWhen();
    eq FIfStmt.getElseStmt().inWhen()       = isWhen() || inWhen();
    eq FWhenClause.getFStatement().inWhen() = true;
    
    inh boolean FExp.inWhen();
    eq FIfExp.getThenExp().inWhen() = isWhen() || inWhen();
    eq FIfExp.getElseExp().inWhen() = isWhen() || inWhen();
    
    inh boolean FAbstractEquation.isInitial();
    inh boolean FIfExp.isInitial();
    eq FClass.getChild().isInitial()                      = false;
    eq FClass.getFInitialEquation().isInitial()           = true;
    eq InstNode.getChild().isInitial()                    = false;
    eq FAbstractEquation.getInitialEquation().isInitial() = true;
    
    /**
     * Is this expression of a type that is valid for most uses?
     * 
     * Only dummy expressions and similar return false.
     */
    syn boolean FExp.isValidExp()       = isValidExp(false);
    
    syn boolean FExp.isValidExp(boolean allowUnknownSize)       = true;
    eq FNoExp.isValidExp(boolean allowUnknownSize)              = false;
    eq FUnsupportedExp.isValidExp(boolean allowUnknownSize)     = false;
    eq FUnsupportedBuiltIn.isValidExp(boolean allowUnknownSize) = false;
    eq FUnknownSizeExp.isValidExp(boolean allowUnknownSize)     = allowUnknownSize;
    
}


aspect DefaultExperiment {
    
    /**
     * Check if a class has an "experiment" annotation.
     */
    syn boolean ClassDecl.isExperiment() = annotation("experiment").exists();
    
    /**
     * Check if a class has an "experiment" annotation.
     */
    syn boolean InstClassDecl.isExperiment() = annotation("experiment").exists();
    
    public class FClass {
        
        public Experiment experiment = null;
        
        /**
         * Create an experiment description from an experiment annotation, if it exists.
         */
        public void createExperiment(AnnotationNode a) {
            if (a.exists())
                experiment = new Experiment(a);
        }
        
        /**
         * Represents an experiment annotation.
         */
        public static class Experiment {
            
            public boolean hasStart = false;
            public double start;
            public boolean hasStop = false;
            public double stop;
            public boolean hasInterval = false;
            public double interval;
            public boolean hasTolerance = false;
            public double tolerance;
            
            public Experiment(AnnotationNode expr) {
                for (AnnotationNode val : expr) {
                    if (val.isRealValue()) {
                        if (val.name().equals("StartTime")) {
                            hasStart = true;
                            start = val.real();
                        } else if (val.name().equals("StopTime")) {
                            hasStop = true;
                            stop = val.real();
                        } else if (val.name().equals("Interval")) {
                            hasInterval = true;
                            interval = val.real();
                        } else if (val.name().equals("Tolerance")) {
                            hasTolerance = true;
                            tolerance = val.real();
                        }
                    }
                }
            }
            
        }
        
    }
    
}


aspect AttributeUtil {

    /**
     * Check if this is attribute is generated from a modification.
     */
    syn boolean FAttribute.isModification()  = true;
    eq FInternalAttribute.isModification()   = false;
    eq FAnnotationAttribute.isModification() = false;

    /**
     * Check if this is an internal generated attribute.
     */
    syn boolean FAttribute.isInternal() = false;
    eq FInternalAttribute.isInternal()  = true;

    /**
     * Check if this is attribute is genereated from an annotation.
     */
    syn boolean FAttribute.isAnnotation()  = false;
    eq FAnnotationAttribute.isAnnotation() = true;

    /**
     * Check if this FClass contains any active annotation attributes.
     */
    syn boolean FClass.containsActiveAnnotations() {
        if (getNumFAttribute() == 0)
            return false;
        for (AttributeContributer contributer : attributeContributers())
            if (contributer.containsActiveAttributes(this))
                return true;
        return false;
    }

    /**
     * Check if this FVariable contains any active annotation attributes.
     */
    syn boolean FVariable.containsActiveAnnotations() {
        if (getNumFAttribute() == 0)
            return false;
        for (AttributeContributer contributer : attributeContributers())
            if (contributer.containsActiveAttributes(this))
                return true;
        return false;
    }

    /**
     * Check if this FAbstractEquation contains any active annotation attributes.
     */
    syn boolean FAbstractEquation.containsActiveAnnotations() {
        if (getNumFAttribute() == 0)
            return false;
        for (AttributeContributer contributer : attributeContributers())
            if (contributer.containsActiveAttributes(this))
                return true;
        return false;
    }

    /**
     * Check if this FFunctionDecl contains any active annotation attributes.
     */
    syn boolean FFunctionDecl.containsActiveAnnotations() {
        if (getNumFAttribute() == 0)
            return false;
        for (AttributeContributer contributer : attributeContributers())
            if (contributer.containsActiveAttributes(this))
                return true;
        return false;
    }

}
