/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;


aspect ExternalConstantEvaluation {
    
    /**
     * Check external arguments
     */
    syn boolean FExternalStmt.canEvaluate() {
        if (myOptions().getIntegerOption("external_constant_evaluation") == 0)
            return false;
        for (CommonVariableDecl cvd : varsToSerialize()) {
            if (cvd.type().isRecord()) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * External functions does not have a FAlgorithm in the instance tree
     * so we have to generate one.
     */
    syn nta FAlgorithm InstExternal.getFAlgorithm() {
        FAlgorithm fab = new FAlgorithm(new List());
        fab.addFStatement(createStmt(surroundingInstClass(), new FQNameFull(""), false));
        return fab;
    }
    
    public int FExternalStmt.evaluateConstructor(Map<CommonVariableDecl, CValue> values) {
        ArrayList<FExp> args = myConstructorArgs();
        CValue[] vals = new CValue[args.size()];
        for (int i = 0; i < args.size(); i++)
            vals[i] = args.get(i).ceval();
        values.put(myConstructorOutput(), new CValueExternalObject(vals));
        return EVAL_CONT;
    }
    
    inh boolean FExternalStmt.isConstructorStmt();
    eq Root.getChild().isConstructorStmt() = false;
    eq FFunctionDecl.getChild().isConstructorStmt() = isConstructor();
    eq InstClassDecl.getChild().isConstructorStmt() = isConstructor();
    
    inh boolean FExternalStmt.isDestructorStmt();
    eq Root.getChild().isDestructorStmt() = false;
    eq FFunctionDecl.getChild().isDestructorStmt() = isDestructor();
    eq InstClassDecl.getChild().isDestructorStmt() = isDestructor();
    
    public ExternalFunctionCache.ExternalFunction FExternalStmt.myExternalFunction() {
        return root().getUtilInterface().getExternalFunctionCache().getExternalFunction(this);
    }
    
    /**
     * Evaluate this external statement.
     */
    public int FExternalStmt.evaluateExternal(Map<CommonVariableDecl, CValue> values) {
        
        if (isConstructorStmt()) {
            return evaluateConstructor(values);
        }
        
        int res = 0;
        int timeout = myOptions().getIntegerOption("external_constant_evaluation");
        ExternalFunctionCache.ExternalFunction ef = myExternalFunction();
        ProcessCommunicator com = ef.getProcessCommunicator(this, timeout);
        try {
            com.accept("START");
            for (CommonVariableDecl cvd : varsToSerialize()) {
                com.put(values.get(cvd), cvd.type(), cvd.canBeUnknown());
            }
            com.accept("CALC");
            com.accept("DONE");
            for (CommonVariableDecl cvd : varsToDeserialize())
                values.put(cvd, com.get(cvd.type()));
            com.accept("END");
            res = com.end();
        } catch (IOException e) {
//            ModelicaCompiler.log.debug(e);
            res = -2;
        } finally {
            com.destroy();
        }
        
        if (res != 0) {
            ModelicaCompiler.log.debug("Could not evaluate external function " + getName() + ", error code: " + res);
            throw new ConstantEvaluationException(null, "Failed to evaluate external function call, error during evaluation");
        }
        
        return EVAL_CONT;
    }
    
    
    /**
     * A class for handling communication with an external process during
     * constant evaluation.
     */
    public class ProcessCommunicator {
        private BufferedReader in;
        private BufferedWriter out;
        private Process process;
        private Timer timer;
        String buffLine = null;
        
        public ProcessCommunicator(Process proc, int timeout) {
            process = proc;
            in  = new BufferedReader(new InputStreamReader(process.getInputStream()));
            out = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
            timer = new Timer();
            if (timeout >= 0) {
                timer.schedule(new TimerTask() {
                    @Override
                    public void run() {
                        process.destroy();
                        cancel();
                    }
                }, timeout);
            }
        }
        
        private String getLine() throws IOException {
            String line = buffLine;
            if (line == null)
                line = in.readLine();
            if (line == null)
                throw new IOException();
            buffLine = null;
            return line;
        }
        
        private void buffLine(String line) {
            buffLine = line;
        }
        
        /**
         * Print <code>val</code>, serialized, to the process 
         */
        public void put(CValue val, FType type, boolean allowUninitialized) throws IOException {
//            ModelicaCompiler.log.debug("ProcessCommunicator WRITE: " + val.toString() + " of type: "+type.toString());
            val.serialize(out, type, allowUninitialized);
            out.flush();
        }
        
        /**
         * Read <code>type</code>, serialized, from the process 
         */
        public CValue get(FType type) throws IOException {
            CValue val = type.deserialize(this);
//            ModelicaCompiler.log.debug("ProcessCommunicator READ: " + val.toString());
            return val;
        }
        
        /**
         * Read a line. Check equals to <code>s</code>.
         */
        public void accept(String s) throws IOException {
            log();
            abort();
            String line = getLine();
            if (line == null || !line.equals(s)) {
                ModelicaCompiler.log.debug(String.format("ProcessCommunicator did not receive expected line\n\t'%s' != '%s'", s, (line == null ? "null" : line)));
                throw new IOException();
            }
        }
        
        private void log() throws IOException {
            String line = getLine();
            while (line.equals("LOG")) {
                double warning = deserializeReal();
                String name    = deserializeString();
                String format  = deserializeString();
                String value   = deserializeString();
                if (warning != 0)
                    ModelicaCompiler.log.warning("%s: " + format, name, value);
                else
                    ModelicaCompiler.log.info("%s: " + format, name, value);
                line = getLine();
            }
            buffLine(line);
        }
        
        private void abort() throws IOException, ConstantEvaluationException {
            String line = getLine();
            if (line.equals("ABORT")) {
                throw new ConstantEvaluationException(null, "Evaluation aborted by request of external function");
            }
            buffLine(line);
        }
        
        /**
         * Wait for and retrieve exit value from process.
         */
        public int end() {
            int res;
            try {
                process.waitFor();
                res = process.exitValue();
            } catch (InterruptedException e) {
                res = -99;
            } catch (IllegalThreadStateException e) {
                res = -100;
            }
            return res;
        }
        
        /**
         * Tear down everything
         */
        public void destroy() {
            try {
                in.close();
            } catch (IOException e) {
            }
            try {
                out.close();
            } catch (IOException e) {
            }
            
            process.destroy();
            process = null;
            timer.cancel();
            timer.purge();
            timer = null;
        }
        
        public double deserializeReal() throws IOException {
            String s = in.readLine();
            if (s == null)
                throw new IOException();
            try {
                return Double.parseDouble(s);
            } catch (NumberFormatException e) {
                throw new IOException();
            }
        }
        
        public String deserializeString() throws IOException {
            String s = in.readLine();
            if (s == null)
                throw new IOException();
            try {
                int len = Integer.parseInt(s);
                char[] c = new char[len];
                in.read(c,0,len);
                s = in.readLine();
                return new String(c);
            } catch (NumberFormatException e) {
                throw new IOException();
            }
        }
    }
    
    /**
     * Print this constant value to <code>buff</code>
     */
    public void CValue.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        throw new IOException();
    }
    public void CValueUnknown.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        if (allowUninitialized)
            type.uninitialized().serialize(buff, type, false);
        else
            super.serialize(buff, type, allowUninitialized);
    }
    public void CValueArray.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        for (int s : size().size) {
            buff.write("" + s + "\n");
        }
        for (Index i : indices()) {
            getCell(i).serialize(buff, type.scalarType(), allowUninitialized);
        }
    }
    public void CValueReal.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        buff.write(Double.toString(realValue()));
        buff.write("\n");
    }
    public void CValueInteger.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        buff.write(Integer.toString(intValue()));
        buff.write("\n");
    }
    public void CValueBoolean.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        buff.write(booleanValue() ? "1\n" : "0\n");
    }
    public void CValueString.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        String s = stringValue();
        buff.write("" + s.length() + " ");
        buff.write(s);
        buff.write("\n");
    }
    public void CValueEnum.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        buff.write(Integer.toString(intValue()));
        buff.write("\n");
    }
    public void CValueExternalObject.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        for (CValue v : values)
            v.serialize(buff, type, allowUninitialized);
    }
    
    public CValue FType.uninitialized() { return zeroCValue(); }
    public CValue FEnumType.uninitialized() { return (new FIntegerType(size())).zeroCValue(); }
    
    
    /**
     * Read a constant value of <code>this</code> type from <code>buff</code>
     */
    public CValue FType.deserialize(ProcessCommunicator com) throws IOException {
        if (isArray()) {
            CValueArray a = new CValueArray(size().ceval());
            for (Index i : a.indices()) {
                a.setCell(i, deserializeScalar(com));
            }
            return a;
        } else {
            return deserializeScalar(com);
        }
    }
    public CValue FType.deserializeScalar(ProcessCommunicator com) throws IOException {
        throw new IOException();
    }
    public CValue FRealType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueReal(com.deserializeReal());
    }
    public CValue FIntegerType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueInteger((int) com.deserializeReal());
    }
    public CValue FBooleanType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueBoolean(com.deserializeReal() != 0);
    }
    public CValue FStringType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueString(com.deserializeString());
    }
    public CValue FEnumType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueEnum(this, (int) com.deserializeReal());
    }
}

aspect ExternalConstantEvaluationCaching {
    
    public class ExternalFunctionCache {
        
        /**
         * Maps external functions names to compiled executables.
         */
        private Map<String, ExternalFunction> cachedExternals = new HashMap<String, ExternalFunction>();
        
        private UtilInterface uif;
        
        public ExternalFunctionCache(UtilInterface uif) {
            this.uif = uif;
        }
        
        /**
         * If there is no executable corresponding to <code>ext</code>, create one.
         */
        public ExternalFunction getExternalFunction(FExternalStmt ext) {
            ExternalFunction ef = cachedExternals.get(ext.getName());
            if (ef == null) {
                if (uif.getModelicaCompiler() == null) {
                    return FailedExternalFunction;
                }
                String executable = uif.getModelicaCompiler().compileExternal(ext);
                if (executable == null) {
                    ef = FailedExternalFunction;
                } else {
                    ef = new CompiledExternalFunction(ext, executable);
                }
                cachedExternals.put(ext.getName(), ef);
            }
            return ef;
        }
        
        /**
         * Remove executables compiled by the constant evaluation framework.
         */
        public void removeExternalFunctions() {
            for (ExternalFunction ef : cachedExternals.values()) {
                ef.remove();
            }
            cachedExternals = new HashMap<String,ExternalFunction>();
        }
        
        public static abstract class ExternalFunction {
            public abstract ProcessCommunicator getProcessCommunicator(FExternalStmt ext, int timeout);
            public abstract void remove();
        }
        
        public static final ExternalFunction FailedExternalFunction = new ExternalFunction() {
            
            @Override
            public ProcessCommunicator getProcessCommunicator(FExternalStmt ext, int timeout) {
                throw new ConstantEvaluationException(null, 
                        "Failed to evaluate external function call, could not start process");
            }
            
            @Override
            public void remove() {
                
            }
            
        };
        
        private class CompiledExternalFunction extends ExternalFunction {
            protected String executable;
            protected ProcessBuilder processBuilder;
            
            public CompiledExternalFunction(FExternalStmt ext, String executable) {
                this.executable = executable;
                this.processBuilder = createProcessBuilder(ext);
            }
            
            @Override
            public ProcessCommunicator getProcessCommunicator(FExternalStmt ext, int timeout) {
                try {
                    return new ProcessCommunicator(processBuilder.start(), timeout);
                } catch (IOException e) {
                    ModelicaCompiler.log.debug("Could not execute external function process for constant evaluation. Executable: " + executable);
                }
                return null;
            }
            
            @Override
            public void remove() {
                new File(executable).delete();
            }
            
            private ProcessBuilder createProcessBuilder(FExternalStmt ext) {
                ProcessBuilder pb = new ProcessBuilder(executable);
                pb.redirectErrorStream(true);
                if (ext.libraryDirectory() != null) {
                    // Update environment in case of shared library
                    String platform = ModelicaCompiler.reduceBits(ModelicaCompiler.getPlatform(), 
                            uif.getModelicaCompiler().getCCompiler().getTargetPlatforms());
                    File f = new File(ext.libraryDirectory(), platform);
                    String libLoc = f.isDirectory() ? f.getPath() : ext.libraryDirectory();
                    appendPath(pb, libLoc, platform);
                }
                return pb;
            }
            
            /**
             * Append a library location <code>libLoc</code> to the path variable in environment of <code>pb</code>.
             */
            private void appendPath(ProcessBuilder pb, String libLoc, String platform) {
                String sep = platform.startsWith("win") ? ";" : ":";
                String var = platform.startsWith("win") ? "PATH" : "LD_LIBRARY_PATH";
                String res = pb.environment().get(var);
                if (res == null)
                    res = libLoc;
                else
                    res = res + sep + libLoc;
                pb.environment().put(var, res);
            }
        }
    }
    
    public String ModelicaCompiler.compileExternal(FExternalStmt ext) {
        String executable = null;
        if (outDir == null)
            setRandomOutDir();
        String source = ext.getName().replace(".", "_");
        TargetObject target = createTargetObject("ceval", "0.1");
        Set<String> libs = new HashSet<String>();
        Set<String> libDirs = new HashSet<String>();
        Set<String> incDirs = new HashSet<String>();
        if (ext.library() != null)
            for (String lib : ext.library())
                libs.add(lib);
        if (ext.libraryDirectory() != null)
            libDirs.add(ext.libraryDirectory());
        if (ext.includeDirectory() != null)
            incDirs.add(ext.includeDirectory());
        try {
            target.getTemplates().generateCFiles(ModelicaCompiler.this, null, createCGenerator(ext), sourceDir, source);
            executable = getCCompiler().compileCCodeLocal(source, target, outDir, libs, libDirs, incDirs, 1);
            new File(sourceDir, source + ".c").delete();
            log.debug(String.format("Compiled external function \"%s\" to executable \"%s\" for constant evaluation.", ext.getName(), executable));
        } catch (FileNotFoundException e) {
            log.debug(String.format("Could not generate code for constant evaluation of external function \"%s\".", ext.getName()));
        } catch (CcodeCompilationException e) {
            log.debug(String.format("Could not compile external function \"%s\" for constant evaluation.", ext.getName()));
            e.printStackTrace(new PrintStream(log.debugStream()));
        }
        return executable;
    }
}


