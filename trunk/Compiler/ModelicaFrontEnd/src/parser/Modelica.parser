/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

%embed {:

	/**
	 * Error reporting class that creates an error message and delegates reporting the 
	 * message to a subclass.
	 */
	public abstract static class Report extends Parser.Events {

		/**
		 * Report an error with error message <code>msg</code>.
		 */
		protected abstract void report(Problem P);

		/**
		 * Creates an error message for when <code>token</code> is found unexpectedly. 
		 * Passes the error message to {@link #report(String)}.
		 * @param token		the unexpected symbol.
		 */
		public void syntaxError(Symbol token) {
			
			StringBuilder s = new StringBuilder();
			//s.append("Syntax error at line "+ Symbol.getLine(token.getStart()) + ", column " + Symbol.getColumn(token.getStart()) + "\n");
			if (token.value != null) {
				s.append("   Unexpected token: \"" + token.value + "\"");
			} else if (token.getId()<Terminals.NAMES.length)
				s.append("  Unexpected token: " + Terminals.NAMES[token.getId()]);
			else 
				s.append("  *** Syntactic error");
			Problem p = new Problem("", s.toString(), Problem.Severity.ERROR, Problem.Kind.SYNTACTIC, Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()));
			
			report(p);
		}

		/**
		 * Creates an error message for when the scanner throws an exception.
		 * Passes the error message to {@link #report(String)}.
		 * @param e		the exception.
		 */
		public void scannerError(Scanner.Exception e) {
			/*
			StringBuilder s = new StringBuilder(e.getMessage());
			s.append(" at line ");
			s.append(e.line);
			s.append(", column ");
			s.append(e.column);
			*/
			Problem p = new Problem("", e.getMessage(), Problem.Severity.ERROR, Problem.Kind.LEXICAL, e.line, e.column);
			
			report(p);
		}
		
	}
	
	/**
	 * Error reporting class that throws a {@link CompilerException} on an error.
	 * Uses error message created by {@link Report}.
	 */
	public class AbortingReport extends Report {

		/**
		 * Throws a <code>ParserException</code> with <code>msg</code> as the message.
		 */
		@Override
		protected void report(Problem p) {
		  throw new ParserException(p);
		}
		
		
	}
	
	/**
	 * Error reporting class that collects error messages for later retrieval.
	 * Uses error message created by {@link Report}.
	 */
	public static class CollectingReport extends Report {

		private ArrayList<Problem> errors = new ArrayList<Problem>();

		/**
		 * Adds error message <code>msg</code> to list.
		 */ 
		@Override
		protected void report(Problem p) {
			errors.add(p);			
		}
		
		/**
		 * Get the list of errors. Returns a reference to the internal list, not a copy.
		 * @return a {@link java.util.Collection} with the reported error messages.
		 */
		public Collection<Problem> getErrors() {
			return errors;
		}
		
		/**
		 * Reset the list of errors.
		 */
		public void resetErrors() {
			errors = new ArrayList<Problem>();
		}
		
		/**
		 * Checks if any errors has been reported.
		 * @return <code>true</code> if the list contains any errors.
		 */
		public boolean hasErrors() {
			return !errors.isEmpty();
		}

	}

	{ report = new AbortingReport(); }  // As default, throw exception on errors.
	
	/**
	 * Set the error reporting class to use.
	 * @param report	a subclass of {@link Parser.Events} to use for reporting errors.
	 */
	public void setReport(Parser.Events report) {
		this.report = report;
	}
	
	public Parser.Events getReport() {
		return report;
	}
	
	private Map<Integer, Integer> lineBreakMap;
	
	public void setLineBreakMap(Map<Integer, Integer> map) {
	    lineBreakMap = map;
	}

	public String removeWhitespace(String str) {
		String str_res = str;
    	str_res = str_res.replaceAll("\\r", "");
    	str_res = str_res.replaceAll("\\n", "");
    	str_res = str_res.replaceAll(" ", "");
		return str_res;
	}

:};
 
SourceRoot source_root
    = /* nothing */ {: 
        SourceRoot sr = new SourceRoot(new Program(new List()));
        return sr; 
      :}
   | program {: 
       SourceRoot sr = new SourceRoot(program); 
       return sr; 
   :};

Program program
    = stored_definition   {: 
        return new Program(new List().add(stored_definition)); 
    :};
  
StoredDefinition stored_definition
    = within? base_class_decl_list {:
        StoredDefinition def = new StoredDefinition(within, base_class_decl_list);
        def.setLineBreakMap(lineBreakMap);
    	return def; 
    :}
    | error {: 
        return new BadDefinition(); 
    :};

Within within
    = WITHIN parse_access? SEMICOLON {: 
        return new Within(parse_access); 
    :};
  
List base_class_decl_list  
    = base_class_decl SEMICOLON {: 
        return new List().add(base_class_decl); 
    :}
    | base_class_decl_list base_class_decl SEMICOLON {: 
        base_class_decl_list.add(base_class_decl);
        return base_class_decl_list; 
    :};

BaseClassDecl base_class_decl 
    =               
    encapsulated? 
    partial? 
    restriction  
    id_decl.start 
    string_comment? 
    composition 
    END_ID.end   {:   
        String end_s = end.substring(3,end.length());
        end_s = removeWhitespace(end_s);
        return new PN_FullClassDecl(
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            start,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            string_comment,
            composition,
            end_s); 
    :}
    |
    encapsulated? 
    partial? 
    restriction  
    id_decl.class_name EQUALS
    type_prefix_flow?
    type_prefix_variability?
    type_prefix_input_output?
    class_access /*name*/
    array_subscripts?
    class_modification?
    comment {:
        return new PN_ShortClassDecl(
            new UnknownVisibilityType(),
            encapsulated, 
            partial, 
            restriction, 
            class_name, 
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            type_prefix_flow, 
            type_prefix_variability, 
            type_prefix_input_output, 
            class_access,
            array_subscripts, 
            class_modification, 
            comment); 
    :}
    |
    encapsulated? 
    partial? 
    restriction 
    EXTENDS 
    id_decl.start 
    class_modification?
    string_comment? 
    composition 
    END_ID.end {:
        String end_s = end.substring(3,end.length());
	    end_s = removeWhitespace(end_s);
        return new PN_ExtendClassDecl(
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            start,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            string_comment,
            composition,
            end_s, 
            class_modification); 
  :}  
  | error {: 
      return new BadClassDecl(); 
  :};

Partial partial = 
  PARTIAL {: return new Partial(); :}
  ;

Encapsulated encapsulated = 
  ENCAPSULATED {: return new Encapsulated(); :}
  ;

TypePrefix type_prefix_variability = 
   DISCRETE                          {: return new Discrete(); :}
  | PARAMETER                          {: return new Parameter(); :}
  | CONSTANT                          {: return new Constant(); :}
  ;
  
TypePrefix type_prefix_input_output = 
    INPUT                          {: return new Input(); :}
  | OUTPUT                          {: return new Output(); :}
  ;


Restriction restriction = 
  CLASS                            {: return new MClass(); :}
  | MODEL                            {: return new Model(); :}
  | BLOCK                            {: return new Block(); :}
  | CONNECTOR                            {: return new Connector(); :}
  | EXPANDABLE CONNECTOR             {: return new ExpandableConnector(); :}
  | TYPE                            {: return new MType(); :}
  | PACKAGE                            {: return new MPackage(); :}
  | FUNCTION                            {: return new Function(); :}
  | RECORD                            {: return new Record(); :}  
  ;

Final final_ = 
  FINAL {: return new Final(); :}
  ;
  
Inner inner = 
  INNER {: return new Inner(); :}
  ;
  
 Outer outer = 
  OUTER {: return new Outer(); :}
  ;
   
Replaceable replaceable = 
  REPLACEABLE  {: return new Replaceable(); :}
  ;
    
Redeclare redeclare = 
  REDECLARE  {: return new Redeclare(); :}
  ;  
  
Each each =
  EACH  {: return new Each(); :}
  ;  

    
Composition composition = 
  composition_clauses  external_clause?
               {: return new Composition(composition_clauses,external_clause); :}
  | elements composition_clauses external_clause?
               {: composition_clauses.insertChild(new PublicElementList(elements), 0);
                  return new Composition(composition_clauses, external_clause); :}                             
  ;


List composition_clauses = 
             {: return new List(); :}
  | composition_clause {: return new List().add(composition_clause); :}
  | composition_clauses composition_clause {: return composition_clauses.add(composition_clause); :}
  ;


List elements
    = element {:
        return new List().add(element); 
    :} 
    | elements element {: 
        return elements.add(element);
    :};

Clause composition_clause =  
   PUBLIC                    {: return new PublicElementList(new List()); :}
   | PROTECTED               {: return new ProtectedElementList(new List()); :}
   | PUBLIC elements         {: return new PublicElementList(elements); :}
   | PROTECTED elements      {: return new ProtectedElementList(elements); :}
   | equation_clause         {: return equation_clause; :}
   | algorithm               {: return algorithm; :}
   ;
   
ExternalClause external_clause =
	EXTERNAL
	external_language?
	external_function_call?
	annotation.a1?
	SEMICOLON
	annotation_sc.a2?  {:  return new ExternalClause(external_language, external_function_call, a1, a2); :}
	;
		
	
ExternalLanguage external_language =
	STRING.s {: return new ExternalLanguage(s); :}
	;	
	
Annotation annotation_sc =
	annotation SEMICOLON {: return annotation; :}
   	;

ExternalFunctionCall external_function_call =
	parse_access_eq ID.id LPAREN arg_list RPAREN  
	            {: return new ExternalFunctionCall(new Opt(parse_access_eq), new IdDecl(id), arg_list); :}
  | ID.id LPAREN arg_list RPAREN  
                {: return new ExternalFunctionCall(new Opt(), new IdDecl(id), arg_list); :}
  ;   	 	
   	  	
ParseAccess parse_access_eq =
	parse_access
	EQUALS {: return parse_access; :}
   	;

	
Element element 
    = 
    redeclare? 
    final_? 
    inner? 
    outer? 
    base_class_decl SEMICOLON {: 
        base_class_decl.setRedeclareOpt(redeclare);
        base_class_decl.setFinalOpt(final_);   
        base_class_decl.setInnerOpt(inner);
        base_class_decl.setOuterOpt(outer);
        return base_class_decl;
    :}
    |
    redeclare? 
    final_? 
    inner? 
    outer? 
    replaceable
    base_class_decl
    constraining_clause? 
    comment SEMICOLON {: 
        base_class_decl.setRedeclareOpt(redeclare);
        base_class_decl.setFinalOpt(final_);   
        base_class_decl.setInnerOpt(inner);
        base_class_decl.setOuterOpt(outer);
        base_class_decl.setReplaceableOpt(new Opt(replaceable));
        base_class_decl.setConstrainingClauseOpt(constraining_clause);
        base_class_decl.setConstrainingClauseComment(comment);
        return base_class_decl;  
    :}  
    | extends_clause SEMICOLON {: 
        return extends_clause;
    :}
    | import_clause SEMICOLON {: 
        return import_clause;
    :}
    |
    redeclare? 
    final_? 
    inner? 
    outer? 
    type_prefix_flow? 
    type_prefix_variability? 
    type_prefix_input_output? 
    class_access/*name*/ 
    array_subscripts? 
    component_list 
    SEMICOLON {:
        return new PN_ComponentClause(
            redeclare,
            final_,
            inner,
            outer,
            new Opt(),
            type_prefix_flow,
            type_prefix_variability,
            type_prefix_input_output,
            class_access,
            array_subscripts,
            component_list,
            new Opt(),
            new Comment(new Opt(), new Opt()));
  :}
  | redeclare? 
    final_? 
    inner? 
    outer? 
    replaceable 
    type_prefix_flow? 
    type_prefix_variability? 
    type_prefix_input_output? 
    class_access/*name*/ 
    array_subscripts? 
    component_list 
    constraining_clause? 
    comment 
    SEMICOLON {: 
        return new PN_ComponentClause(
            redeclare,
            final_,
            inner,
            outer,
            new Opt(replaceable),
            type_prefix_flow,
            type_prefix_variability,
            type_prefix_input_output,
            class_access,
            array_subscripts,
            component_list,
            constraining_clause,comment); 
  :}
  | annotation SEMICOLON                  {: return new ElementAnnotation(annotation); :} 
  | error SEMICOLON						  {: return new BadElement(); :}
  ;
  
ConstrainingClause constraining_clause = 
  CONSTRAINEDBY class_access/*name*/ class_modification?{: return new ConstrainingClause(class_access,class_modification); :}
  ;
  
PN_ExtendsClause extends_clause = 
   EXTENDS  class_access/*name*/ class_modification? annotation?    {: return new PN_ExtendsClause(class_access,class_modification,annotation); :}
  ;

ImportClause import_clause = 
  IMPORT 
  parse_access_simple 
  comment {: return new ImportClauseQualified(parse_access_simple,comment); :}
  | IMPORT 
  parse_access_unqualified_simple
  comment {: return new ImportClauseUnqualified(parse_access_unqualified_simple,comment); :}
  | IMPORT 
  id_decl.alias 
  EQUALS 
  parse_access_simple 
  comment {: return new ImportClauseRename(parse_access_simple,comment,alias); :}
  ;




ArraySubscripts array_subscripts = 
  LBRACK subscript_list RBRACK {: return new ArraySubscripts(subscript_list); :}
  ;
  
List subscript_list =
  subscript               {: return new List().add(subscript); :}
  | subscript_list COMMA subscript {: subscript_list.add(subscript);
                                      return subscript_list; :}
  ;
  
Subscript subscript =
  COLON                 {: return new ColonSubscript(); :}
  | exp                 {: return new ExpSubscript(exp); :}                                                                           
  ;


List component_list = 
  pn_component_decl                    {: return new List().add(pn_component_decl); :}
  | component_list COMMA pn_component_decl           {: component_list.add(pn_component_decl);
                                                      return component_list; :}
  ;
  
PN_ComponentDecl pn_component_decl = 
  id_decl.comp_name array_subscripts? modification? conditional_attribute? comment                   {: return new PN_ComponentDecl(comp_name,array_subscripts,modification,conditional_attribute,comment); :} 
  ;
  
ConditionalAttribute conditional_attribute = 
  IF exp {: return new ConditionalAttribute(exp); :}
  ;  
  
TypePrefix type_prefix_flow = 
    FLOW     {: return new Flow(); :}
  | STREAM   {: return new Stream(); :}
  ;
  
EquationClause equation_clause =
  EQUATION abstract_equation*  {:  return new EquationClause(abstract_equation); :}
  | INITIAL_EQUATION abstract_equation*  {:  //System.out.println("equation_clause"); 
  					     for (int i=0;i<abstract_equation.getNumChild();i++)
  					     	((AbstractEquation)abstract_equation.getChild(i)).setAbstractEquationModifier(new Initial()); 
                                                 return new EquationClause(abstract_equation); :}
  ;  

Algorithm algorithm =
  ALGORITHM statement_list            {: return new Algorithm(new Opt(), statement_list); :}
  | INITIAL_ALGORITHM statement_list  {: return new Algorithm(new Opt(new Initial()), 
                                                              statement_list); :}
  ;  

/*
List abstract_equation_list =
                                  {: return new List(); :}
  |abstract_equation                           {: return new List().add(abstract_equation); :}
  | abstract_equation_list abstract_equation  {: abstract_equation_list.add(abstract_equation); 
                                                 return abstract_equation_list; :}
  ;  
*/

List statement_list =
                              {: return new List(); :}
  | statement                 {: return new List().add(statement); :}
  | statement_list statement  {: statement_list.add(statement); 
                                 return statement_list; :}
  ;  

Modification modification =
  complete_modification               {: return complete_modification; :}
  |value_modification               {: return value_modification; :}
//  |assign_modification                 {: return assign_modification; :}  
  ;
  

CompleteModification complete_modification =
  class_modification value_modification?  {: return new CompleteModification(class_modification,value_modification); :}
  ;
  
ValueModification value_modification =
  EQUALS exp  {: return new ValueModification(exp); :}
  | COLON EQUALS exp  {: return new ValueModification(exp); :}
  ;

/*  
AssignModification assign_modification =
  COLON EQUALS exp  {: return new AssignModification(exp); :}
  ;  
  */
  
  
ClassModification class_modification = 
  LPAREN argument_list RPAREN {: return new ClassModification(argument_list); :}
  ;

  
List argument_list =
  argument                          {: return new List().add(argument); :}
  | argument_list COMMA argument    {: argument_list.add(argument); 
                                       return argument_list; :}
  ;

Argument argument = 
  each? 
  final_? 
  parse_access 
  modification? 
  string_comment? {: return new ComponentModification(each, 
                                                    final_,
                                                    parse_access,
                                                    modification,
                                                    string_comment); :}
  |each? 
   final_? 
   replaceable 
   base_class_decl 
   constraining_clause? {:  ClassAccess pa = new ClassAccess(base_class_decl.getName().getID());
   							pa.setLocationNoTree(base_class_decl.getName());
   							base_class_decl.setConstrainingClauseOpt(constraining_clause);
   							base_class_decl.setReplaceable(replaceable);
   							ClassRedeclare cdr = new ClassRedeclare(each,
                                                         final_,
                                                         pa,
                                                         base_class_decl); 
                            return cdr; :} 
  |each? 
   final_? 
   replaceable 
   type_prefix_flow?
   type_prefix_variability? 
   type_prefix_input_output? 
   class_access 
   id_decl.comp_name 
   array_subscripts? 
   modification? 
   comment
   constraining_clause? 
   {: 			ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
   				pa.setLocationNoTree(comp_name);
   				PN_ComponentRedeclare cdr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(new Replaceable()),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment)),
                                                               constraining_clause,
                                                               new Comment(new Opt(),new Opt()))); 
                                         return cdr; :}
  |REDECLARE 
   each? 
   final_?  
   base_class_decl {: ClassAccess pa = new ClassAccess(base_class_decl.getName().getID());
                      pa.setLocationNoTree(base_class_decl.getName());       
                      base_class_decl.setRedeclare(new Redeclare());
                      ClassRedeclare cdr = new ClassRedeclare(each,
                                                              final_,
                                                              pa,
                                                              base_class_decl);
                      return cdr; :}
  |REDECLARE
   each? 
   final_? 
   type_prefix_flow?
   type_prefix_variability? 
   type_prefix_input_output? 
   class_access 
   id_decl.comp_name 
   array_subscripts? 
   modification? 
   comment
   {: ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
   				pa.setLocationNoTree(comp_name, array_subscripts);
   				PN_ComponentRedeclare cdr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment)),
                                                               new Opt(),
                                                               new Comment(new Opt(),new Opt()))); 
                 return cdr; :}
                                                 
  |REDECLARE
   each? 
   final_? 
   replaceable 
   base_class_decl 
   constraining_clause? {:  base_class_decl.setConstrainingClauseOpt(constraining_clause);
                            base_class_decl.setReplaceable(replaceable);
                            ClassAccess ca = new ClassAccess(base_class_decl.getName().getID());
                            ca.setLocationNoTree(base_class_decl.getName());
                             return new  ClassRedeclare(each,
                                                         final_,
                                                         ca,
                                                         base_class_decl); :} 
  |REDECLARE
   each? 
   final_? 
   replaceable 
   type_prefix_flow?
   type_prefix_variability? 
   type_prefix_input_output? 
   class_access 
   id_decl.comp_name 
   array_subscripts? 
   modification? 
   comment
   constraining_clause? 
   {:  ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
       pa.setLocationNoTree(comp_name);
       PN_ComponentRedeclare cr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(new Replaceable()),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment)),
                                                               constraining_clause,
                                                               new Comment(new Opt(),new Opt()))); 
        return cr;                                                       
                                                               :}
   | error				{: return new BadArgument(); :}                                              
   ;




Annotation annotation = 
  ANNOTATION class_modification    {: return new ParseAnnotation(class_modification); :}
  ;  
   
   
AbstractEquation abstract_equation =
  simple_expression.left EQUALS exp.right comment SEMICOLON
                                      {: return new Equation(new Opt(),comment,left,right); :}
  | conditional_equation_e SEMICOLON  {: return conditional_equation_e; :}
  | for_clause_e SEMICOLON            {: return for_clause_e; :}
  | when_clause_e SEMICOLON           {: return when_clause_e; :}
  | CONNECT LPAREN parse_access.a COMMA parse_access.b RPAREN comment SEMICOLON
                                      {: return new ConnectClause(new Opt(), comment,a,b); :}
  | LPAREN function_call_left_list RPAREN EQUALS function_call comment SEMICOLON
                                      {: return new FunctionCallEquation(new Opt(),comment,function_call_left_list,function_call); :}
  | function_call comment SEMICOLON   {: return new FunctionCallEquation(new Opt(),comment,new List(),function_call); :}
  | annotation SEMICOLON              {: return new EquationAnnotation(new Opt(),new Comment(new Opt(), new Opt()), annotation); :}
  ;

ConditionalEquationE conditional_equation_e =
  IF exp.ifexp THEN
  abstract_equation*
  else_if_clause_e*
  else_equations
  END_IF comment {: return new ConditionalEquationE(new Opt(), comment, ifexp,abstract_equation,else_if_clause_e,else_equations); :}
  ;  

ElseIfClauseE else_if_clause_e =
  ELSEIF exp.eiexp THEN
  abstract_equation* {: return new ElseIfClauseE(eiexp,abstract_equation); :}
  ;

List else_equations =
   {: return new List(); :}
  | ELSE
    abstract_equation* {: return abstract_equation; :}
    ;

ForClauseE for_clause_e =
  FOR for_indices LOOP
  abstract_equation*
  END_FOR comment   {: return new ForClauseE(new Opt(), comment, for_indices,abstract_equation); :}
  ;


List for_indices = 
  for_index        {: return new List().add(for_index); :}
  | for_indices COMMA for_index {: for_indices.add(for_index);
                                     return for_indices; :}
  ;
  
ForIndex for_index = 
  id_decl for_in_exp? {: ForIndex f = new ForIndex(new ForIndexDecl(new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(new Parameter()),
                                                              new Opt(),
                                                              new ParseAccess("Integer",new Opt()),
                                                              new Opt(),
                                                              new PublicVisibilityType(),
                                                              id_decl,
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Comment(new Opt(),new Opt()),
                                                              new Opt(),
                                                              new Comment(new Opt(),new Opt())),
                                                   for_in_exp); 
                          f.setLocationNoTree(id_decl, for_in_exp); 
                          return f; :}
  ;

Exp for_in_exp =
  IN exp.e {: return e; :}
  ;

WhenClauseE when_clause_e =
  WHEN exp.wexp THEN
  abstract_equation*
  else_when_clause_e*
  END_WHEN comment {: return new WhenClauseE(new Opt(), comment, wexp,abstract_equation,else_when_clause_e); :}
  ;  

ElseWhenClauseE else_when_clause_e =
  ELSEWHEN exp.ewexp THEN
  abstract_equation* {: return new ElseWhenClauseE(ewexp,abstract_equation); :}
  ;



Statement statement =
  parse_access.left ASSIGN exp.right comment SEMICOLON                  
                                     {: return new AssignStmt(comment, left, right); :}
  | function_call_stmt SEMICOLON     {: return function_call_stmt; :}
  | BREAK comment SEMICOLON          {: return new BreakStmt(comment); :} 
  | RETURN comment SEMICOLON         {: return new ReturnStmt(comment); :}
  | if_stmt SEMICOLON                {: return if_stmt; :}
  | when_stmt SEMICOLON              {: return when_stmt; :}
  | for_stmt SEMICOLON               {: return for_stmt; :}
  | while_stmt SEMICOLON             {: return while_stmt; :}
  | annotation SEMICOLON             {: return new AlgorithmAnnotation(new Comment(new Opt(), new Opt()), 
                                                                       annotation); :}
  | error                            {: return new BadStatement(); :}
  ;
  
FunctionCallStmt function_call_stmt =
    LPAREN function_call_left_list RPAREN ASSIGN function_call comment  
                           {: return new FunctionCallStmt(comment, function_call_left_list, function_call); :}
  | function_call comment  {: return new FunctionCallStmt(comment, new List(), function_call); :}
  ;

List function_call_left_list =
    function_call_left.a COMMA function_call_left.b   {: return new List().add(a).add(b); :}
  | function_call_left_list COMMA function_call_left  {: return function_call_left_list.add(function_call_left); :}
  ;

FunctionCallLeft function_call_left =
                   {: return new FunctionCallLeft(new Opt()); :}
  | parse_access   {: return new FunctionCallLeft(new Opt(parse_access)); :}
  ;

IfStmt if_stmt =
  IF if_clause_list else_stmts END_IF comment {: return new IfStmt(comment, if_clause_list, else_stmts); :}
  ;  

List if_clause_list =
    if_clause                        {: return new List().add(if_clause); :}
  | if_clause_list ELSEIF if_clause  {: return if_clause_list.add(if_clause); :}
  ;

IfClause if_clause =
  exp THEN statement_list  {: return new IfClause(exp, statement_list); :}
  ;

List else_stmts =
                         {: return new List(); :}
  | ELSE statement_list  {: return statement_list; :}
  ;

WhenStmt when_stmt =
  WHEN when_clause_list END_WHEN comment {: return new WhenStmt(comment, when_clause_list); :}
  ;  

List when_clause_list =
    when_clause                            {: return new List().add(when_clause); :}
  | when_clause_list ELSEWHEN when_clause  {: return when_clause_list.add(when_clause); :}
  ;

WhenClause when_clause =
  exp THEN statement_list  {: return new WhenClause(exp, statement_list); :}
  ;

ForStmt for_stmt =
  FOR for_indices LOOP statement_list END_FOR comment  
                         {: return new ForStmt(comment, for_indices, statement_list); :}
  ;

WhileStmt while_stmt = 
  WHILE exp LOOP statement_list END_WHILE comment  {: return new WhileStmt(comment, exp, statement_list); :}
  ;
  
Exp exp =
  simple_expression {: return simple_expression; :}
  | if_exp           {: return if_exp; :}
  ;

IfExp if_exp =
  IF exp.ifexp THEN
  exp.thenexp
  else_if_exp*
  else_exp  
  {: return new IfExp(ifexp,thenexp,else_if_exp,else_exp); :}
  ;  

ElseIfExp else_if_exp =
  ELSEIF exp.eiexp THEN
  exp.thenexp {: return new ElseIfExp(eiexp,thenexp); :}
  ;

Exp else_exp =
  ELSE exp.e {: return e; :}
  ;

Exp simple_expression = 
  log_exp
  range.r1? 
  range.r2? {:        if (r1.getNumChild()==0 && r2.getNumChild()==0)
                      	return log_exp;
                      else {
                      	RangeExp r = new RangeExp();
                      	r.addExp(log_exp);
                      	if (r1.getNumChild()>0)
                      		r.addExp((Exp)r1.getChildNoTransform(0));
                      	if (r2.getNumChild()>0)
                      		r.addExp((Exp)r2.getChildNoTransform(0));	
                      	return r;
                      }    
                      :}
  ;

Exp range =
  COLON log_exp {: return log_exp; :}
  ;  

Exp log_exp = 
  log_exp.a OR log_exp.b {: return new OrExp(a,b); :}  
  | log_exp.a AND log_exp.b {: return new AndExp(a,b); :}  
  | NOT relation.a {: return new NotExp(a); :}  
  | relation {: return relation; :}
;

Exp relation =
  artm_exp.a LT artm_exp.b {: return new LtExp(a,b); :}
  | artm_exp.a LEQ artm_exp.b {: return new LeqExp(a,b); :}
  | artm_exp.a GT artm_exp.b {: return new GtExp(a,b); :}
  | artm_exp.a GEQ artm_exp.b {: return new GeqExp(a,b); :}
  | artm_exp.a EQ artm_exp.b {: return new EqExp(a,b); :}
  | artm_exp.a NEQ artm_exp.b {: return new NeqExp(a,b); :}
  | artm_exp.a {: return a; :}	
  ;
  
  
  Exp artm_exp =
   additive_exp {: return additive_exp; :}
   ;

  Exp additive_exp =
     multiplicative_exp.e    {: return e; :}
   | additive_exp.e1 PLUS multiplicative_exp.e2      {: return new AddExp(e1, e2); :}
   | additive_exp.e1 MINUS multiplicative_exp.e2     {: return new SubExp(e1, e2); :}
   | additive_exp.e1 DOTPLUS multiplicative_exp.e2   {: return new DotAddExp(e1, e2); :}
   | additive_exp.e1 DOTMINUS multiplicative_exp.e2  {: return new DotSubExp(e1, e2); :}
   ;

  Exp multiplicative_exp =
     unary_exp.e                                     {: return e; :}
   | multiplicative_exp.e1 MULT unary_exp.e2     {: return new MulExp(e1, e2); :}
   | multiplicative_exp.e1 DIV unary_exp.e2      {: return new DivExp(e1, e2); :}
   | multiplicative_exp.e1 DOTMULT unary_exp.e2  {: return new DotMulExp(e1, e2); :}
   | multiplicative_exp.e1 DOTDIV unary_exp.e2   {: return new DotDivExp(e1, e2); :} 
   ;


Exp unary_exp =
   pow_exp          {: return pow_exp; :}
   | MINUS unary_exp       {: return new NegExp(unary_exp); :}
   | PLUS unary_exp        {: return unary_exp; :}
   ;

Exp pow_exp =
    primary {:return primary; :}
    | primary.a POW primary.e    {: return new PowExp(a,e); :}
    | primary.a DOTPOW primary.e {: return new DotPowExp(a,e); :}
    ;

Exp primary =        
   UNSIGNED_NUMBER.n    {: return new RealLitExp(n); :}
  | UNSIGNED_INTEGER.n    {: return new IntegerLitExp(n); :}
  | TRUE                {: return new BooleanLitExpTrue(); :}
  | FALSE                {: return new BooleanLitExpFalse(); :}
  | STRING.s               {: return new StringLitExp(s); :}
  | access_expression   {: return access_expression; :}
  | der_expression      {: return der_expression; :}
  | LPAREN exp.a RPAREN {: return a; :}
  | function_call        {: return function_call; :}
  | LBRACK matrix RBRACK {: return matrix; :}
  | LBRACE function_arguments RBRACE {: return new ArrayConstructor(function_arguments); :}
  | TIME                {: return new TimeExp(); :}
  | END                 {: return new EndExp(); :} 
  ;
 
 FunctionCall function_call =
    parse_access LPAREN function_arguments? RPAREN 
                                      {: return new FunctionCall(parse_access, function_arguments); :}
  ;  
  
FunctionArguments function_arguments =
    exp FOR for_indices               {: List arg_list_f = new List().add(new IterExp(exp, for_indices));
                                         return new FunctionArguments(arg_list_f, new List()); :} 
  | arg_list_p                        {: return new FunctionArguments(arg_list_p, new List()); :}  
  | arg_list_p COMMA named_arguments  {: return new FunctionArguments(arg_list_p, named_arguments); :}
  | named_arguments                   {: return new FunctionArguments(new List(), named_arguments); :}
  ;
  
List named_arguments =
    named_argument                       {: return new List().add(named_argument); :}
  | named_arguments COMMA named_argument {: return named_arguments.add(named_argument); :}
  ;
  
NamedArgument named_argument =
  ID.id EQUALS exp {: return new NamedArgument(new ParseAccess(id,new Opt()),exp); :}
  ;
  
Matrix matrix = 
    matrix_row                   {: return new Matrix(new List().add(matrix_row)); :}
  | matrix SEMICOLON matrix_row  {: matrix.addRow(matrix_row); 
                                    return matrix; :}      
  ;  
  
MatrixRow matrix_row = 
    exp                   {: return new MatrixRow(new List().add(exp)); :}
  | matrix_row COMMA exp  {: matrix_row.addExp(exp); 
                             return matrix_row; :}
  ; 
  
List arg_list = 
                        {: return new List(); :}
  |exp                   {: //System.out.println("arg_list at line " + exp.beginLine());
                           return new List().add(exp); :}
  | arg_list COMMA exp  {: arg_list.add(exp); 
                           return arg_list; :}
  ;
  
List arg_list_p = 
    exp                   {: return new List().add(exp); :}
  | arg_list_p COMMA exp  {: return arg_list_p.add(exp); :}
  ;
  
Comment comment = 
  string_comment?  annotation?     {: return new Comment(string_comment,annotation); :}
  ;
  
StringComment string_comment =
  STRING.s      {: return new StringComment(s); :}
  | string_comment PLUS STRING.s {: string_comment.setComment(string_comment.getComment().concat(s));
                                    return string_comment; :}
  
  ;
 
 IdDecl id_decl = 
   ID.id   {: return new IdDecl(id); :}
//   | BREAK {: return new IdDecl("break"); // This is insane, but is needed to parse
//                                          // Modelica.exp in the standard library 2.2 :}
   ;

 AccessExp access_expression =
   parse_access {: return new AccessExp(parse_access); :}
   ;

 DerExp der_expression = 
   DER LPAREN exp RPAREN  {: return new DerExp(exp); :}
   ;

 Access parse_access = 
   parse_access_single   {: return parse_access_single; :}
   | parse_access_single DOT parse_access {: return new Dot(parse_access_single.getID(),parse_access_single,parse_access); :}
   ;
 
 ParseAccess parse_access_single = 
   ID.id  array_subscripts? {: return new ParseAccess(id,array_subscripts); :}
   ;   
   
 Access parse_access_simple = 
   parse_access_single_simple  {: return parse_access_single_simple; :}
   | parse_access_single_simple DOT parse_access_simple {: return new Dot(parse_access_single_simple.getID(),parse_access_single_simple,parse_access_simple); :}
   ;
 
 ParseAccess parse_access_single_simple = 
   ID.id  {: return new ParseAccess(id,new Opt()); :}
   ;      
 
 Access parse_access_unqualified_simple = 
   parse_access_single_simple DOTMULT  
            {: return parse_access_single_simple; :} 
 | parse_access_single_simple DOT parse_access_unqualified_simple 
            {: return new Dot("",parse_access_single_simple,parse_access_unqualified_simple); :}
   ;    
 
 
 Access class_access = 
   class_access_single   {: return class_access_single; :}
   | class_access_single DOT class_access {: return new Dot("",class_access_single,class_access); :}
   ;    
  
 ClassAccess class_access_single = 
   ID.id  {: return new ClassAccess(id); :}
   ;
   
