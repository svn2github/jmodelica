/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package org.jmodelica.util;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Random;
import java.util.Stack;

aspect Graphs {

public class BiPGraph {

	public static int DERIVATIVE_VARIABLES = 1;
	public static int DIFFERENTIATED_VARIABLES = 2;
	public static int ALGEBRAIC_VARIABLES = 4;
	public static int DISCRETE_PRE_VARIABLES = 8;

	public static int MAX_N_EQ_DIFFS = 10;

	private String name;
	private String description;
	
	protected ArrayList<Eq> equations = new ArrayList<Eq>();
	protected LinkedHashMap<String,Var> variableMap = new LinkedHashMap<String,Var>();
	protected LinkedHashMap<String,Eq> equationMap = new LinkedHashMap<String,Eq>();
	protected LinkedHashMap<FAbstractEquation,ArrayList<Eq>> equationIndexMap = new LinkedHashMap<FAbstractEquation,ArrayList<Eq>>();
	
	public BiPGraph(String name, String description) {
		this.name = name;
		this.description = description;
	}

	public Eq getEquation(String name) {
		return equationMap.get(name);
	}
	

	public ArrayList<Eq> getEquations(FAbstractEquation eqn) {
		return equationIndexMap.get(eqn);
	}

	public Eq addEquation(String name, String description,
		                      FAbstractEquation eqn) {
		Eq e = equationMap.get(name);
		if (e==null) {
			e = new Eq(name,description,eqn);
			equations.add(e);
			equationMap.put(name,e);
			insertIntoEquationIndexMap(eqn,e);
		}
		return e;
	}
	
	public Var addVariable(String name, String description, FVariable var) {
		Var v = variableMap.get(name);
		if (v==null) {
			v = new Var(name,description,var);
			variableMap.put(name,v);
		}	
		return v;
	}
	
	public Eq replaceEquation(String name, String description, FAbstractEquation eqn) {
		Eq e = equationMap.get(name);
		if (e==null) {
			e = new Eq(name,description,eqn);
			equations.add(e);
			equationMap.put(name,e);
			insertIntoEquationIndexMap(eqn,e);
		} else {
			// Remove the old equation
			for (Var v : e.getVariables()) {
				if (v.getMatching() == e) {
					v.setMatching(null);
				}
			}
			e.setMatching(null);
			e.getVariables().clear();
			// Insert the new equation
			Eq ee = new Eq(name,description,eqn);
			equations.set(equations.indexOf(e),ee);
			equationMap.put(e.getName(),ee);
			removeFromEquationIndexMap(e.getEquation(),e);
			insertIntoEquationIndexMap(eqn,ee);
			e = ee;
		}
		return e;
	}

	public void removeEquation(Eq e) {
		for (Var v : e.getVariables()) {
			if (v.getMatching() == e) {
				v.setMatching(null);
			}
		}
		e.setMatching(null);
		e.getVariables().clear();
		equations.remove(e);
		equationMap.remove(e.getName());
		removeFromEquationIndexMap(e.getEquation(),e);
	}
	
	
	
	public Var addVariable(String name, String description) {
		Var v = variableMap.get(name);
		if (v==null) {
			v = new Var(name,description);
			variableMap.put(name,v);
		}	
		return v;
	}

	public void removeVariable(Var v) {
		for (Eq e : getEquations()) {
			if (e.getMatching() == v) {
				e.setMatching(null);
			}
			e.getVariables().remove(v);
		}
		v.setMatching(null);
		variableMap.remove(v.getName());
	}
	
	public Var getVariable(String name) {
		return variableMap.get(name);
	}
	
	public boolean addEdge(String equationName, String variableName) {
		Eq e = equationMap.get(equationName);
		Var v = variableMap.get(variableName);
		if (v==null || e==null) {
			return false;
		}
		if (e.getVariables().contains(v)) {
			return false;
		}
		e.addVariable(v);
		return true;
	}

	public boolean addEdge(Eq e, Var v) {
		return addEdge(e.getName(),v.getName());
	}
		
		
	public void addVariables(FClass fclass, int variableMask) {
	
		if ((variableMask & DERIVATIVE_VARIABLES) != 0) {
			for (FVariable fv : fclass.derivativeVariables()) {
				addVariable(fv.name(),"",fv);     
			}
		}

		if ((variableMask & DIFFERENTIATED_VARIABLES) != 0) {
			for (FVariable fv : fclass.differentiatedRealVariables()) {
				addVariable(fv.name(),"",fv);     
			}	
		}
		
		if ((variableMask & ALGEBRAIC_VARIABLES) != 0) {
			for (FVariable fv : fclass.algebraicRealVariables()) {
				addVariable(fv.name(),"",fv);     
			}
		
			for (FVariable fv : fclass.discreteRealVariables()) {
				addVariable(fv.name(),"",fv);     
			}
			for (FVariable fv : fclass.discreteIntegerVariables()) {
				addVariable(fv.name(),"",fv);     
			}
			for (FVariable fv : fclass.discreteBooleanVariables()) {
				addVariable(fv.name(),"",fv);     
			}
			for (FVariable fv : fclass.discreteStringVariables()) {
				addVariable(fv.name(),"",fv);     
			}
			for (FVariable fv : fclass.discreteEnumVariables()) {
				addVariable(fv.name(),"",fv);     
			}
		}
	
		if ((variableMask & DISCRETE_PRE_VARIABLES) != 0) {
			for (FVariable fv : fclass.discretePreVariables()) {
				addVariable(fv.name(),"",fv);     
			}
		}
	
	}	
		
	public void addEquations(ArrayList<FAbstractEquation> eqns, int variableMask, String eqNamePrefix, int startIndex) {	
    	int k = startIndex;
    	Eq eqn = null;
    	Var v = null;
		for (FAbstractEquation e : eqns) {

			int n_eq = e.numScalarEquations();
			for (int i=0;i<n_eq;i++) {
				eqn = addEquation("eq_"+k,e.prettyPrint(""),e);
				k++;

				if ((variableMask & DERIVATIVE_VARIABLES) != 0) {
					for (FDerivativeVariable dx : e.derivativeVariables()) { 
						v = getVariable(dx.name());     
						addEdge(eqn,v); 
					} 
				}

				if ((variableMask & DIFFERENTIATED_VARIABLES) != 0) {
					for (FVariable x : e.differentiatedVariables()) { 
						v = getVariable(x.name());     
						addEdge(eqn,v); 
					} 			
				}

				if ((variableMask & ALGEBRAIC_VARIABLES) != 0) {
					for (FVariable y : e.algebraicVariables()) { 
						v = getVariable(y.name()); 
						addEdge(eqn,v); 
					} 
				}
				
				if ((variableMask & DISCRETE_PRE_VARIABLES) != 0) {
					for (FVariable x : e.discretePreVariables()) { 
						v = getVariable(x.name());     
						addEdge(eqn,v);
					} 			
				}			
			}
		}			
	}
	
	public void greedyMatching() {
		for (Eq e : getEquations()) {
			for (Var v : e.getVariables()) {
				if (v.getMatching()==null) {
					v.setMatching(e);
					e.setMatching(v);
					break;
				}
			}
		}
	}
	
	public ArrayList<LinkedHashMap<Var,LinkedHashSet<Eq>>> bfs(LinkedHashSet<Eq> startingNodes) {
		ArrayList<LinkedHashMap<Var,LinkedHashSet<Eq>>> Lv = new ArrayList<LinkedHashMap<Var,LinkedHashSet<Eq>>>();
		LinkedHashSet<Eq> Le_current = new LinkedHashSet<Eq>();
		LinkedHashSet<Eq> Le_next = new LinkedHashSet<Eq>();
		
		Le_current.addAll(startingNodes);
		// Reset nodes
		lightReset();
		
		int layer = 0;
		boolean freeVarNodeFound = false;
		//System.out.println("************** BFS ************* starting nodes: " + startingNodes);
		
		while (Le_current.size()>0 && !freeVarNodeFound) {
			//System.out.println("*** layer: " + layer);
			//System.out.println(Lv);
			//System.out.println(Le_current);
			Lv.add(new LinkedHashMap<Var,LinkedHashSet<Eq>>());
			
			for (Eq s : Le_current) {
				//System.out.println(" eq: " + s.getName());
				for (Var t : s.getVariables()) {
					//System.out.println("  " + t.getName() + " layer: " + t.getLayer());
					if (t.getLayer() >= layer) {
						//System.out.println("    adding " + t.getName());
						t.setLayer(layer);
						LinkedHashSet<Eq> h = Lv.get(layer).get(t);
						if (h==null) {
							h = new LinkedHashSet<Eq>();
							Lv.get(layer).put(t,h);
						}
						h.add(s);
						Eq u = t.getMatching();
						if (u!=null) {
							//System.out.println("     " + t.getName() + "'s matching is " + u.getName());
							u.setLayer(layer);
							Le_next.add(u);
						} else {
							//System.out.println("     " + t.getName() + "has no matching");
							freeVarNodeFound = true;
					
						}
					}
				}
			}
			layer++;
			Le_current = Le_next;
			Le_next = new LinkedHashSet<Eq>();
		}
		
		ArrayList<Var> delQueue = new ArrayList<Var>();
		for (Var v : Lv.get(Lv.size()-1).keySet()) {
			if (v.getMatching()!=null) {
				delQueue.add(v);
			}
		}
		for (Var v : delQueue) {
			Lv.get(Lv.size()-1).remove(v);
		}
		//System.out.println(Lv);
		//System.out.println("************** BFS ends *************");
		return Lv;
	}

	public ArrayList<ArrayList<Edge>> dfs(ArrayList<LinkedHashMap<Var,LinkedHashSet<Eq>>> Lv) {
		lightReset();
		ArrayList<ArrayList<Edge>> P = new ArrayList<ArrayList<Edge>>();
	
		boolean found_path = true;
		for (Var v : Lv.get(Lv.size()-1).keySet()) {
			ArrayList<Edge> P_tmp = new ArrayList<Edge>();
			
			ListIterator<LinkedHashMap<Var,LinkedHashSet<Eq>>> iter = 
				Lv.listIterator(Lv.size());
			while (iter.hasPrevious()) {
				LinkedHashMap<Var,LinkedHashSet<Eq>> l = iter.previous();
				v.setVisited(true);
				if (!found_path) {
					break;
				}
				found_path = false;
				for (Eq e : l.get(v)) {
					if (!e.isVisited()) {
						e.setVisited(true);
						P_tmp.add(new Edge(e,v));
						v = e.getMatching();
						found_path = true;
						break;
					}
				}
			}
			if (P_tmp.size() == Lv.size()) {
				P.add(P_tmp);
			}
		}
		//System.out.println(P);
		return P;
	}
		
	public void reassign(ArrayList<ArrayList<Edge>> P) {
		for (ArrayList<Edge> l : P) {
			for (Edge ed : l) {
				ed.getEquation().setMatching(ed.getVariable());
				ed.getVariable().setMatching(ed.getEquation());
			}
		}
	}
	
	public void maximumMatching(boolean resetMatching) {
		if (resetMatching) {
			reset();
			greedyMatching();
		}
		//System.out.println(printMatching());
		
		// Initialize set of free equations
		LinkedHashSet<Eq> startingNodes = new LinkedHashSet<Eq>();
		for (Eq e : getEquations()) {
			if (e.getMatching()==null) {
				startingNodes.add(e);
			}
		}
	
		LinkedHashSet<Eq> unmatchedEquations = new LinkedHashSet<Eq>();
		for (Eq e : equations) {
			if (e.getMatching()==null) {
				unmatchedEquations.add(e);
			}
		}
		
		ArrayList<LinkedHashMap<Var,LinkedHashSet<Eq>>> Lv = null;
		ArrayList<ArrayList<Edge>> P = null;
		
		while (unmatchedEquations.size()>0) {
		
			Lv = bfs(unmatchedEquations);
			P = dfs(Lv);

			if (Lv.get(Lv.size()-1).size()==0) {
				break;
			}
			
			reassign(P);
		
			//System.out.println(printMatching());

			for (ArrayList<Edge> l : P) {
				unmatchedEquations.remove(l.get(l.size()-1).getEquation());
			}
			
			/*
			unmatchedEquations = new LinkedHashSet<Eq>();
			for (Eq e : equations) {
				if (e.getMatching()==null) {
					unmatchedEquations.add(e);
				}
			}
*/
			
		}
	}
	
	public ArrayList<MatchingPair> getMatching() {
			
		ArrayList<MatchingPair> l = new ArrayList<MatchingPair>();
		Var v = null;
		
		for (Eq e : getEquations()) {				
			int n_eq = e.getEquation().numScalarEquations();
			
			for (int i=0;i<n_eq;i++) {
				v = e.getMatching();
				if (v!=null) {
					l.add(new MatchingPair(e.getEquation(),v.getVariable()));
				}
			}
		}		
		return l;
	}	
	
	/*
	public String buildIndent(int n) {
		String s = "";
		for (int i=0;i<n;i++){
			s += " ";
		}
		return s;
	}	
	
	public int n_ind = 0;
	*/
	
	public boolean augmentPath(Eq e, ArrayList<Eq> visitedEquations,
	                                 ArrayList<Var> visitedVariables) {
		e.setVisited(true);
		visitedEquations.add(e);
		//System.out.println(n_ind + buildIndent(n_ind) + " augmentPath start: " + e.getEquation().prettyPrint(""));	
		//for (Var v : e.getVariables()) {
		//	System.out.println(n_ind + buildIndent(n_ind) + " ** " + v.getVariable().name());	
		//}
		for (Var v : e.getVariables()) {
			//System.out.println(n_ind + buildIndent(n_ind) + " augmentPath: " + e.getEquation().prettyPrint("") + " about to visit: " + v.getVariable().name());		
			if (v.getMatching()==null) {
				//System.out.println(n_ind + buildIndent(n_ind) + " augmentPath: " + e.getEquation().prettyPrint("") + " unmatched: " + v.getVariable().name());		
				v.setMatching(e);
				e.setMatching(v);
				return true;
			} else if (!v.isVisited()) {
				//System.out.println(n_ind + buildIndent(n_ind) + " augmentPath: " + e.getEquation().prettyPrint("") + " matched and unvisited: " + v.getVariable().name());		
				v.setVisited(true);
				visitedVariables.add(v);
				//n_ind++;
				if (augmentPath(v.getMatching(),visitedEquations,visitedVariables)) {
					//n_ind--;
					//System.out.println(n_ind + buildIndent(n_ind) + " augmentPath: " + e.getEquation().prettyPrint("") + " matched and unvisited path found!: " + v.getVariable().name());		
					v.setMatching(e);
					e.setMatching(v);
					return true;	
				} else {
					//n_ind--;
					//System.out.println(n_ind + buildIndent(n_ind) + " augmentPath: " + e.getEquation().prettyPrint("") + " matched and unvisited path not found!: " + v.getVariable().name());				
				}
			}
		}
		//System.out.println(n_ind + buildIndent(n_ind) + "augmentPath end: " + e.getEquation().prettyPrint(""));	
		return false;
	}
	
	public boolean solvableAugmentPath(Eq e, ArrayList<Eq> visitedEquations, ArrayList<Var> visitedVariables) {
		e.setVisited(true);
		visitedEquations.add(e);
		for (Var v : e.getSolvableVariables()) {
			if (v.getSolvableMatching()==null) {
				v.setSolvableMatching(e);
				e.setSolvableMatching(v);
				v.setMatching(e);
				e.setMatching(v);
				return true;
			} else if (!v.isVisited()) {
				v.setVisited(true);
				visitedVariables.add(v);
				if (solvableAugmentPath(v.getSolvableMatching(),visitedEquations,visitedVariables)) {
					v.setSolvableMatching(e);
					e.setSolvableMatching(v);
					v.setMatching(e);
					e.setMatching(v);
					return true;	
				} 
			}
		}
		return false;
	}	
	
	
	public IndexReductionResult reduceIndex(boolean resetMatching) {
		if (resetMatching) {
			reset();
			//greedyMatching();
		}
						
		//_maximumMatching(resetMatching);	
		IndexReductionResult result = new IndexReductionResult();		
				
		ArrayList<Eq> visitedEquations;
		ArrayList<Var> visitedVariables;		
				
		LinkedHashSet<Eq> es = new LinkedHashSet<Eq>();
		es.addAll(getEquations());
		FClass fc = es.iterator().next().getEquation().myFClass();	
		
		Eq eqToMatch;
		
		boolean pathFound = false;		
		int n_eq_diffs = 0; // Number of times a single equation has been differentiated	
		ArrayList<FVariable> newDiffedVars = new ArrayList<FVariable>();	
		// Algoritm step numbering from the original Pantelides paper		
		// Loop over all equations (step 3)
		for (Eq e : es) {
			// If the equation is not matched
			if (e.getMatching()==null && e.getMeDifferentiated()==null) {
				eqToMatch = e; // Step 3a
				pathFound = false; // Step
				n_eq_diffs = 0;
				while (!pathFound) { // Step 3b
					// Since the states are not added to the graph,
					// Step 3b-1 is skipped and is done at the end of 
					// the iteration 
					visitedEquations = new ArrayList<Eq>();
					visitedVariables = new ArrayList<Var>();	
					lightReset(); // Step 3b-2
					pathFound = false; // Step 3b-3
					// Find an augmenting path, step 3b-4
					//n_ind = 0;
					pathFound = augmentPath(eqToMatch, visitedEquations, visitedVariables); 
					fc.log.info("*************");
					fc.log.info("Looking for augmented path starting in equation: " + eqToMatch.toString());
					if (pathFound) {
						fc.log.info("Path found!");
					} else {	
					 	fc.log.info("Path not found!");
					}
					fc.log.info("Visisted equations:");
					for (Eq ee : visitedEquations) {
						fc.log.info("  " + ee.getDescription());
					}
					fc.log.info("Visisted variables:");
					for (Var vv : visitedVariables) {
						fc.log.info("  " + vv.toString());
					}
					
					if (!pathFound) { // Step 3b-5
						n_eq_diffs++;
						if (n_eq_diffs > MAX_N_EQ_DIFFS) { // Reached maximum number of differentiations of a single equation?
							// Remove variables that were added
							for (FVariable v : newDiffedVars) {
								int ind = v.myFClass().getFVariableList().getIndexOfChild(v);
								if (ind>=0) {
									v.myFClass().getFVariableList().removeChild(ind);
								}
							}
							return null;
						}
						for (Var vv : visitedVariables) { // Loop over all visited variables, Step 3b-5i
						    // Create a new differentiated variable
							FVariable newVar = vv.getVariable().myFClass().addFDerivativeVariable(vv.getVariable());
							newDiffedVars.add(newVar);
							// Add the differentiated variable to the graph 
							Var vvv = addVariable(newVar.name(),"",newVar);
							// Set the "A vector" in the paper: 
							// a reference from the visited variable to its 
							// differentiated counterpart
							vv.setMeDifferentiated(vvv); 
							vvv.setMeIntegrated(vv);
						}
						for (Eq ee : visitedEquations) { // Step 3b-5ii
							FAbstractEquation eee = ee.getEquation();
							// Create a new differentiated equation
							FAbstractEquation deee = eee.diff("time");
							result.addEquation(deee);
							fc.log.info("About to add equation: " + deee);
							// Add the differentiated equation						
							Eq eqn = addEquation("eq_" + (getEquations().size() + 1), 
							             deee.prettyPrint(""), deee);
							
							// Add edges
							for (FVariable fv : deee.variables()) {
								Var vvv = variableMap.get(fv.name());
								fc.log.info("*** " + fv.name());
								if (vvv!=null) {
									addEdge(eqn,vvv);
								}
							}
							// Set a reference from the visited equation to
							// its differentiated counterpart
							ee.setMeDifferentiated(eqn);
							eqn.setMeIntegrated(ee);
						}
						for (Var vv : visitedVariables) {
							// Set matchings, Step 3b-5iii
							Eq ee = vv.getMatching();
							vv.getMeDifferentiated().setMatching(ee.getMeDifferentiated());
							ee.getMeDifferentiated().setMatching(vv.getMeDifferentiated());
							// Remove variables that have been differentiated, Step 3b-1
							removeVariable(vv);
						}
						
						// Set the next equation to start matching from, 
						// Step 3b-5iv
						eqToMatch = eqToMatch.getMeDifferentiated();
						
						fc.log.info("Graph after addition of equations and variables:");
						fc.log.info(toString());
					}	

					fc.log.info("Matching:");
					fc.log.info(printMatching());
					fc.log.info("*************");
				
				}	
			}
		}

		// Remove equations that are not connected
		ArrayList<Eq> eqToRemove = new ArrayList<Eq>();
		for (Eq e : getEquations()) {
			if (e.getVariables().size()==0) {
				eqToRemove.add(e);
			}
		}
		for (Eq e : eqToRemove) {
			removeEquation(e);
		}
		fc.log.info("Index reduction done!");
		fc.log.info("Matching:");
		fc.log.info(printMatching());
		
		// Selection of dummy derivatives
		/*
			The algorithm is implemented differently than in the original paper
			by Mattsson and Sšderlind. In the paper, each block is treated
			individually by selecting all dummy derivatives of one block
			before proceeding to the next block. This approach, however, makes
			it hard to handle user preferences for state selection as defined
			by the stateSelect attribute. This is because selection of
			dummy derivatives in one block may restrict the choices in 
			following blocks, even though a global analysis would yield that
			it would indeed be possible to satisfy user selection.
			
			Therefore, all equations in blocks containing differentiated
			equations are treated in one block.
		*/
		
		BLT blt = computeBLT();
	
		fc.log.info(blt.toString());

		// Lists of equations and variables, notation is the same as in the 
		// paper
		ArrayList<FAbstractEquation> g = 
		   new ArrayList<FAbstractEquation>();
		
		ArrayList<FAbstractEquation> h = 
		   new ArrayList<FAbstractEquation>();

		ArrayList<FVariable> z = 
		   new ArrayList<FVariable>();

		ArrayList<FVariable> zHat = 
		   new ArrayList<FVariable>();

		
		// Collect all blocks that contain differentiated equations
		for (AbstractEquationBlock eb : blt) {
			ArrayList<FAbstractEquation> diffedEqns = eb.differentiatedEquations();
			if (diffedEqns.size()>0) {
				fc.log.info(" ********* Found block containing diffed equations ***********");
				fc.log.info(eb.toString());
		
				// Step 1: Initialize, add all equations in blocks
				// having differentiated equations
				g.addAll(eb.equations());
				
				// Step 2: Extract all active variables, i.e., highest order 
				// derivatives for each variable
				for (FVariable fv : eb.activeVariables()) {
					if (fv.isDerivativeVariable()) {
						// If the stateSelect attribute equals StateSelect.always,
						// then don't add the variable so that it cannot be
						// selected as dummy derivative.
						FRealVariable frv = (FRealVariable)fv.getMeIntegrated();
						if (frv!=null && frv.stateSelectAttribute()!=FRealVariable.StateSelect.ALWAYS) {
							z.add(fv);
						}
					} else {
						z.add(fv);
					}
				}
			}
		}
		
		// Initialize variable to keep track of there are still 
		// differentiated equations
		boolean remainingDifferentiatedEquations = true;
		
		// Iterate
		while (remainingDifferentiatedEquations) {
		   fc.log.info("----------------");
			// Step 3: Extract differentiated equations 
			h = new ArrayList<FAbstractEquation>();
			for (FAbstractEquation fe : g) {
				if (fe.getMeIntegrated()!=null) {
					h.add(fe);
				}
			}
									
			// Step 4: Select independent columns: simple matching will do for 
			// now
			BiPGraph gd = new BiPGraph("","");
					
			// Add variables to the graph
			for (FVariable fv : z) {
				gd.addVariable(fv.name(),"",fv);     
			}
				
			int k = 1;
			Eq eqn = null;
			Var v = null;
			// Add the equations to the graph
			for (FAbstractEquation e : h) {
			
				int n_eq = e.numScalarEquations();
				
				for (int i=0;i<n_eq;i++) {
					fc.log.info("*** " + e.prettyPrint(""));
					eqn = gd.addEquation("eq_"+k,e.prettyPrint(""),e);
					k++;
				
					for (FVariable y : e.variables()) { 
						fc.log.info(" ** " + y.prettyPrint("") + " " + z.contains(y));
						if (z.contains(y)) {
							v = gd.getVariable(y.name()); 
							gd.addEdge(eqn,v);
						} 
					} 
				}
			}
					
			fc.log.info(gd.toString());
			// Run matching
			gd.maximumMatching(true);	
			fc.log.info(gd.printMatching());
					
			// The matched variables are selected as dummy derivatives
			for (Var vv : gd.getMatchedVariables()) {
				zHat.add(vv.getVariable());
			}

					
			// Step 5: prepare for next iteration
			// Get the "integrated" equations
			g = new ArrayList<FAbstractEquation>();
			for (FAbstractEquation ee : h) {
				g.add(ee.getMeIntegrated());
			}
							
			// Get the "integrated" variables 
			z = new ArrayList<FVariable>();
			for (FVariable fv : zHat) {
				FVariable z_test = fv.getMeIntegrated();
				if (z_test.isDerivativeVariable()) {
					// Take into account user defined state selection
					FRealVariable frv = (FRealVariable)z_test.getMeIntegrated();
					if (frv!=null && frv.stateSelectAttribute()!=FRealVariable.StateSelect.ALWAYS) {
						z.add(z_test);
					}
				} else {
					z.add(z_test);
				}
			}

			// Check if there are remaining differentiated equations								
			remainingDifferentiatedEquations = false;
			for (FAbstractEquation fe : g) {
				if (fe.getMeIntegrated()!=null) {
					remainingDifferentiatedEquations = true;
				}
			}
			
			fc.log.info(" --- Equations in iteration: --- ");
			fc.log.info(" Equations: ");
			for (FAbstractEquation fe : g) {
				fc.log.info(fe.prettyPrint("   "));
			}

			fc.log.info(" Dummy derivatives selected in iteration: ");
			for (FVariable fv : zHat) {
				result.addDummyDerivative(fv);
				fc.log.info(fv.prettyPrint("   "));
			}
			fc.log.info("");
				
		}
		
		fc.log.info(" Dummy derivatives: ");
		for (FVariable fv : zHat) {
			result.addDummyDerivative(fv);
			fc.log.info(fv.prettyPrint("   "));
		}
		fc.log.info("");
		
		return result;
	}
	
	public ArrayList<Eq> getUnmatchedEquations() {
		ArrayList<Eq> l = new ArrayList<Eq>();
		for (Eq e : equations) {
			if (e.getMatching()==null) {
				l.add(e);
			}
		}
		return l;
	}

	public ArrayList<Var> getUnmatchedVariables() {
		ArrayList<Var> l = new ArrayList<Var>();
		for (Var v : variableMap.values()) {
			if (v.getMatching()==null) {
				l.add(v);
			}
		}
		return l;
	}
	
	public ArrayList<Eq> getSolvableUnmatchedEquations() {
		ArrayList<Eq> l = new ArrayList<Eq>();
		for (Eq e : equations) {
			if (e.getSolvableMatching()==null) {
				l.add(e);
			}
		}
		return l;
	}

	public ArrayList<Var> getSolvableUnmatchedVariables() {
		ArrayList<Var> l = new ArrayList<Var>();
		for (Var v : variableMap.values()) {
			if (v.getSolvableMatching()==null) {
				l.add(v);
			}
		}
		return l;
	}

	public ArrayList<Eq> getMatchedEquations() {
		ArrayList<Eq> l = new ArrayList<Eq>();
		for (Eq e : equations) {
			if (e.getMatching()!=null) {
				l.add(e);
			}
		}
		return l;
	}

	public ArrayList<Var> getMatchedVariables() {
		ArrayList<Var> l = new ArrayList<Var>();
		for (Var v : variableMap.values()) {
			if (v.getMatching()!=null) {
				l.add(v);
			}
		}
		return l;
	}
	
	public ArrayList<Eq> removeTearingPair(Eq res, Var tear, boolean unmatch){
		ArrayList<Eq> alteredEquations = new ArrayList<Eq>();
		equations.remove(res);
		equationMap.remove(res.getName());
		removeFromEquationIndexMap(res.getEquation(),res);
		variableMap.remove(tear.getName());	
		if(unmatch){
			// Set the matching to null for the newly unmatched equation and variable
			// (these were matched with tear and res before)
			res.getMatching().setMatching(null);
			res.getSolvableMatching().setSolvableMatching(null);
			tear.getMatching().setMatching(null);
			tear.getSolvableMatching().setSolvableMatching(null);
		}
		// Remove tear from the remaining equations
		for (Eq e : getEquations()) {
			if(e.getVariables().remove(tear)){
				alteredEquations.add(e);
				e.getSolvableVariables().remove(tear);
			}
		}
		return alteredEquations;
	}
	
	public void reinsertTearingPair(Eq res, Var tear, ArrayList<Eq> alteredEquations, boolean match){
		variableMap.put(tear.getName(),tear);
		equations.add(res);
		equationMap.put(res.getName(),res);
		insertIntoEquationIndexMap(res.getEquation(),res);
		for(Eq e: alteredEquations){
			e.addVariable(tear);
			if(e.getEquation().isSolved(tear.getName())){
				e.addSolvableVariable(tear);
			}
		}
		if(match){
			// If an augmentPath was found, the matchings has been altered and a new one must be found.
			tear.setMatching(null);
			tear.setSolvableMatching(null);
			res.setMatching(null);
			res.setSolvableMatching(null);
			lightReset();
			solvableAugmentPath(res, new ArrayList<Eq>(), new ArrayList<Var>());
		} else {
			// Set matching as it was before the removal of the tearing pair. 
			res.getMatching().setMatching(res);
			res.getSolvableMatching().setSolvableMatching(res);
			tear.getMatching().setMatching(tear);
			tear.getSolvableMatching().setSolvableMatching(tear);
		}
	}
	
	
	private int index = 0;
    private Stack<Eq> S;
    private LinkedList<Stack<Eq>> components;
		
    /* This is an implementation of the recursive Tarjan's algorithm.
     * Possibly it is less efficient than the non-recursive version, but
     * it seems to work fine.
     */
	public BLT computeBLT() {
		
		index = 0;
        S = new Stack<Eq>();
        components = new LinkedList<Stack<Eq>>();
        tarjanReset();
        
        for (Eq e : getEquations()) {
        	if (!e.isVisited()) {
        		tarjan(e);
        	}
        }
				
        BLT blt = new BLT();
        
        Var v = null;
		for (Stack<Eq> bl : components) {
			EquationBlock b = new EquationBlock();
			// TODO: handle the case of multiple scalar equations in
			// one block
			for (Eq bl_eqn : bl) {
				v = bl_eqn.getMatching();
				MatchingPair mp = new MatchingPair(bl_eqn.getEquation(),v.getVariable());
				b.addMatchingPair(mp);
			}
			if (b.isSolvable()) {
				blt.add(b.createSolvedEquationBlock());
			} else {
				blt.add(b);
			}
		}
		return blt;
	}

    /* This version of Tarjan's algorithm computes, separetely the ODE blocks
     * and the output blocks.
     */
	public ODEBLT computeODEBLT() {
		
		index = 0;
        S = new Stack<Eq>();
        tarjanReset();

        ODEBLT blt = new ODEBLT();
 
        Var v = null;
               
 		// Order the equations so that the ones matched to derivatives comes
 		// first
 		ArrayList<Eq> orderedEq = new ArrayList<Eq>();              
 		
 		for (Eq e : getEquations()) {
        	if (e.getMatching().getVariable().isDerivativeVariable()) {
        		orderedEq.add(e);
        	}
        }

 		for (Eq e : getEquations()) {
        	if (!e.getMatching().getVariable().isDerivativeVariable()) {
        		orderedEq.add(e);
        	}
        }
               
        for (Eq e : orderedEq) {
        	if (!e.isVisited()) {
        	    components = new LinkedList<Stack<Eq>>();
        		tarjan(e);
        		ArrayList<AbstractEquationBlock> odeBlocks = new ArrayList<AbstractEquationBlock>();
        		ArrayList<AbstractEquationBlock> outputBlocks = new ArrayList<AbstractEquationBlock>();	
				for (Stack<Eq> bl : components) {
					EquationBlock b = new EquationBlock();
					// TODO: handle the case of multiple scalar equations in
					// one block
					for (Eq bl_eqn : bl) {
						v = bl_eqn.getMatching();
						MatchingPair mp = new MatchingPair(bl_eqn.getEquation(),v.getVariable());
						b.addMatchingPair(mp);
					}
					AbstractEquationBlock ab = null;
					if (b.isSolvable()) {
						ab = b.createSolvedEquationBlock();
					} else {
						ab = b;
					}
					blt.add(ab);
					if (e.getMatching().getVariable().isDerivativeVariable()) {
						odeBlocks.add(ab);
					} else {
						outputBlocks.add(ab);
					}
				}
				if (odeBlocks.size()>0) {
					blt.odeBLT.add(odeBlocks);
				}
				if (outputBlocks.size()>0) {
					blt.outputBLT.add(outputBlocks);	
				}
        	}
        }
 
		return blt;
	}
	
	public LinkedList<Stack<Eq>> computeRawBLT() {
		index = 0;
        S = new Stack<Eq>();
        components = new LinkedList<Stack<Eq>>();
        tarjanReset();
        
        for (Eq e : getEquations()) {
        	if (!e.isVisited()) {
        		tarjan(e);
        	}
        }
        
        return components;	
	}
	
	public void tarjan(Eq e) {
		S.add(e);
		e.setTarjanNbr(index);
		e.setTarjanLowLink(index);
		e.setVisited(true);
		index++;
		for (Var v : e.getVariables()) {
			Eq ee = v.getMatching();
			if (!(e==ee)) {
				if (!ee.isVisited()) {
					tarjan(ee);
					e.setTarjanLowLink(Math.min(
							e.getTarjanLowLink(),ee.getTarjanLowLink()));
				} else if (S.contains(ee)) {
					e.setTarjanLowLink(Math.min(
							e.getTarjanLowLink(),ee.getTarjanNbr()));
				}
			}
 		}
		if (e.getTarjanNbr()==e.getTarjanLowLink()) {
			Stack<Eq> component = new Stack<Eq>();
			boolean done = false;
			while (!done) {
				Eq ee = S.pop();
				component.add(ee);
				if (ee==e) {
					done = true;
				}
			}
			components.add(component);
		}
	}
	
	
	/*
	public void randomTest(int n_eq, int n_var, int n_ed) {
		
		BiPGraph g = new BiPGraph("Random Graph","");
		
		for (int i=0;i<n_eq;i++) {
			g.addEquation("e_"+(i+1), "");
		}

		for (int i=0;i<n_var;i++) {
			g.addVariable("v_"+(i+1), "");
		}

		Random r = new Random();
		for (int i=0;i<n_ed;i++) {
			boolean added=false;
			while (!added) {
				int e_ind = r.nextInt(n_eq) + 1;
				int v_ind = r.nextInt(n_var) + 1;
				if (g.addEdge("e_"+e_ind,"v_"+v_ind)) {
					added = true;
				}
			}
		}
		
		//System.out.println(g);
		long before = System.currentTimeMillis();
		g.maximumMatching(true);
		long after = System.currentTimeMillis();
		System.out.println("Matching n_equations="+n_eq+" n_variables="+n_var+" n_edges="+n_ed+" --- " + (((double)(after-before))/1000.));
		
		//System.out.println(g.printMatching());
		
	}
	*/
	
	public void reset() {
		for (Eq e : getEquations()) {
			e.reset();
		}		
		for (Var v : variableMap.values()) {
			v.reset();
		}		
	}

	public void lightReset() {
		for (Eq e : getEquations()) {
			e.lightReset();
		}		
		for (Var v : variableMap.values()) {
			v.lightReset();
		}		
	}

	public void tarjanReset() {
		for (Eq e : getEquations()) {
			e.tarjanReset();
		}		
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public ArrayList<Eq> getEquations() {
		return equations;
	}

	public void insertIntoEquationIndexMap(FAbstractEquation eqn, Eq e) {
		ArrayList<Eq> l = equationIndexMap.get(eqn);
		if (l==null) {
			l = new ArrayList<Eq>();
			equationIndexMap.put(eqn, l);
		}
		l.add(e);
	}

	public void removeFromEquationIndexMap(FAbstractEquation eqn, Eq e) {
		ArrayList<Eq> l = equationIndexMap.get(eqn);
		if (l!=null) {
			l.remove(e);
		}
	}
	
	public String printMatching() {
		StringBuffer str = new StringBuffer();
		str.append("----------------------------------------\n");
		str.append("BiPGraph " + getName() + " matching:\n");
		for (Eq e : getEquations()) {
			if (e.getMatching()!=null) {
				str.append(e.getName());
//				str.append(e.getName() + "(" + e.getDescription() + ")");
				str.append(" : ");
				str.append(e.getMatching().getName());
				str.append("\n");
			}
		}		
		str.append("Unmatched equations: {");
		for (Eq e : getUnmatchedEquations()) {
			str.append(e.getName() + " ");
		}
		str.append("}\n");

		str.append("Unmatched variables: {");
		for (Var v : getUnmatchedVariables()) {
			str.append(v.getName() + " ");
		}
		str.append("}\n");

		str.append("----------------------------------------\n");
		return str.toString();
	}
	
	public String printSolvableMatching() {
		StringBuffer str = new StringBuffer();
		str.append("----------------------------------------\n");
		str.append("BiPGraph " + getName() + " SolvableMatching:\n");
		for (Eq e : getEquations()) {
			if (e.getSolvableMatching()!=null) {
				str.append(e.getName());
//				str.append(e.getName() + "(" + e.getDescription() + ")");
				str.append(" : ");
				str.append(e.getSolvableMatching().getName());
				str.append("\n");
			}
		}		
		str.append("solvableUnmatched equations: {");
		for (Eq e : getSolvableUnmatchedEquations()) {
			str.append(e.getName() + " ");
		}
		str.append("}\n");

		str.append("solvableUnmatched variables: {");
		for (Var v : getSolvableUnmatchedVariables()) {
			str.append(v.getName() + " ");
		}
		str.append("}\n");

		str.append("----------------------------------------\n");
		return str.toString();
	}
	
	public String toString() {
		StringBuffer str = new StringBuffer();
		str.append("BiPGraph " + getName() + "\n");
		if (!getDescription().equals("")) {
			str.append(" (");
			str.append(getDescription());
			str.append(")\n");
		}
		str.append("Variables: {");
		for (String vName : variableMap.keySet()) {
			Var v = variableMap.get(vName);
			str.append(v.getName());
			str.append(" ");
		}
		str.append("}\n");
		for (Eq e : getEquations()) {
			str.append(e.getName());
			str.append(" : ");
			for (Var v : e.getVariables()) {
				str.append(v.getName() + " ");
			}
			str.append("\n");
		}
		return str.toString();
	}
	
    class Edge {
    	private Var variable;
    	private Eq equation;
    	
    	public Edge(Eq e, Var v) {
    		this.equation = e;
    		this.variable = v;
    	}

		public Var getVariable() {
			return variable;
		}

		public void setVariable(Var variable) {
			this.variable = variable;
		}

		public Eq getEquation() {
			return equation;
		}

		public void setEquation(Eq equation) {
			this.equation = equation;
		}
    	
		public String toString() {
			return "(" + equation.getName() + "," + variable.getName() + ")";
		}
    	
    }
}

public class Eq {

	private String name;
	private ArrayList<Var> variables = new ArrayList<Var>();
	private ArrayList<Var> solvableVariables = new ArrayList<Var>();
	private Iterator<Var> varIterator;
	private Var matching = null;
	private Var solvableMatching;
    private boolean visited = false;
    private int layer = 1000000;
    private String description;
    private FAbstractEquation eqn;
	private Eq meDifferentiated = null;
	private Eq meIntegrated = null;

	private int tarjanNbr = 0;
    private int tarjanLowLink = 0;

	public Eq(String name,String description) {
		this.name = name;
		this.description = description;
	}
	
	public Eq(String name,String description,FAbstractEquation eqn) {
		this(name,description);
		this.eqn = eqn;
	}
			
	public void addVariable(Var v) {
		variables.add(v);
	}
	

	public void reset() {
		setMatching(null);
		setVisited(false);
		setLayer(1000000);
	}

	public void lightReset() {
		setVisited(false);
		setLayer(1000000);
	}
	
	public void tarjanReset() {
		setTarjanLowLink(0);
		setTarjanNbr(0);
		resetVariableIterator();
		setVisited(false);
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public ArrayList<Var> getVariables() {
		return variables;
	}

	public Var getMatching() {
		return matching;
	}

	public void setMatching(Var matching) {
		this.matching = matching;
	}
	
	public boolean isVisited() {
		return visited;
	}

	public void setVisited(boolean visited) {
		this.visited = visited;
	}

	public int getLayer() {
		return layer;
	}

	public void setLayer(int layer) {
		this.layer = layer;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}	
	 
	public int getTarjanNbr() {
		return tarjanNbr;
	}

	public void setTarjanNbr(int tarjanNbr) {
		this.tarjanNbr = tarjanNbr;
	}

	public int getTarjanLowLink() {
		return tarjanLowLink;
	}

	public void setTarjanLowLink(int tarjanLowLink) {
		this.tarjanLowLink = tarjanLowLink;
	}

	public void setMeDifferentiated(Eq e) {
		this.meDifferentiated = e;
		this.getEquation().setMeDifferentiated(e.getEquation());
	}
	
	public Eq getMeDifferentiated() {
		return this.meDifferentiated;
	}

	public void setMeIntegrated(Eq e) {
		this.meIntegrated = e;
		this.getEquation().setMeIntegrated(e.getEquation());
	}
	
	public Eq getMeIntegrated() {
		return this.meIntegrated;
	}
	
    public void resetVariableIterator() {
        varIterator = variables.iterator();
    }

    public Var getNextVariable() {
        if (varIterator == null) {
            resetVariableIterator();
        }

        if (!varIterator.hasNext()) {
            return null;
        }

        return varIterator.next();
    }
	    
	public String toString() {
		return getName();
	}

	public FAbstractEquation getEquation() {
		return eqn;
	}
		
	public void setEquation(FAbstractEquation eqn) {
		this.eqn = eqn;
	}
	
	public void addSolvableVariable(Var v) {
		solvableVariables.add(v);
	}
	
	public ArrayList<Var> getSolvableVariables() {
		return solvableVariables;
	}
	
	public Var getSolvableMatching() {
		return solvableMatching;
	}

	public void setSolvableMatching(Var v) {
		this.solvableMatching = v;
	}


}

public class Var {

	private String name;
	private String description;
	private Eq matching = null;
	private Eq solvableMatching = null;
	private boolean visited = false;
	private int layer = 1000000;
	private FVariable v;
	private Var meDifferentiated = null; // A reference to this variable differentiated once
	private Var meIntegrated = null;
	private int occurrences;
	
	public Var(String name, String description) {
		this.name = name;
		this.description = description;
	}

	public Var(String name, String description, FVariable v) {
		this(name,description);
		this.v = v;
		this.occurrences=0;
	}
		
	public void reset() {
		setMatching(null);
		setVisited(false);
		setLayer(1000000);
	}

	public void lightReset() {
		setVisited(false);
		setLayer(1000000);
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public Eq getMatching() {
		return matching;
	}

	public void setMatching(Eq matching) {
		this.matching = matching;
	}

	public boolean isVisited() {
		return visited;
	}

	public void setVisited(boolean visited) {
		this.visited = visited;
	}

	public int getLayer() {
		return layer;
	}

	public void setLayer(int layer) {
		this.layer = layer;
	}
	
	public FVariable getVariable() {
		return v;
	}
		
	public void setVariable(FVariable v) {
		this.v = v;
	}
	
	public void setMeDifferentiated(Var var) {
		this.meDifferentiated = var;
		this.getVariable().setMeDifferentiated(var.getVariable());
	}
	
	public Var getMeDifferentiated() {
		return this.meDifferentiated;
	}

	public void setMeIntegrated(Var var) {
		this.meIntegrated = var;
		this.getVariable().setMeIntegrated(var.getVariable());
	}
	
	public Var getMeIntegrated() {
		return this.meIntegrated;
	}
	
	public void occurrence(){
		this.occurrences++;
	}
	
	public void removeOccurrence(){
		this.occurrences--;
	}
	
	public int getOccurrences(){
		return occurrences;
	}
	
	public Eq getSolvableMatching() {
		return solvableMatching;
	}

	public void setSolvableMatching(Eq eqn) {
		this.solvableMatching = eqn;
	}
		
	public String toString() {
		return getName();
	}
	
}

public class IndexReductionResult {

	private ArrayList<FAbstractEquation> addedEquations;
	private ArrayList<FVariable> dummyDerivatives;

	public IndexReductionResult() {
		addedEquations = new ArrayList<FAbstractEquation>();
		dummyDerivatives = new ArrayList<FVariable>();
	}
	
	public void addEquation(FAbstractEquation fe) {
		addedEquations.add(fe);	
	}

	public void addDummyDerivative(FVariable fv) {
		dummyDerivatives.add(fv);	
	}

	public ArrayList<FAbstractEquation> getEquations() {
		return addedEquations;
	}

	public ArrayList<FVariable> getDummyDerivatives() {
		return dummyDerivatives;
	}

}

}