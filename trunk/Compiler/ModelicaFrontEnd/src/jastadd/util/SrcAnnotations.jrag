/*
    Copyright (C) 2017 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import org.jmodelica.util.annotations.GenericAnnotationNode;
import org.jmodelica.util.annotations.FailedToSetAnnotationValueException;
import org.jmodelica.util.annotations.AnnotationProvider;
import org.jmodelica.util.annotations.AnnotationProvider.SubNodePair;
import org.jmodelica.util.annotations.PossiblyAnnotation;
import org.jmodelica.util.collections.FilteredIterable;
import org.jmodelica.util.collections.TransformerIterable;

aspect SrcAnnotations {

    public SrcAnnotation ClassDecl.srcAnnotation(String ... path) {         return SrcAnnotation.createFor(srcAnnotationProvider(), path); }
    public SrcAnnotation InstClassDecl.srcAnnotation(String ... path) {     return getClassDecl().srcAnnotation(path); }

    public SrcAnnotation ComponentDecl.srcAnnotation(String ... path) {     return getComment().srcAnnotation(path); }
    public SrcAnnotation InstComponentDecl.srcAnnotation(String ... path) { return getComponentDecl().srcAnnotation(path); }
    
    public SrcAnnotation ExtendsClause.srcAnnotation(String ... path) {     return SrcAnnotation.createFor(getAnnotationOpt(), path); }
    public SrcAnnotation InstExtends.srcAnnotation(String ... path) {       return getExtendsClause().srcAnnotation(path); }

    public SrcAnnotation AbstractEquation.srcAnnotation(String ... path) {  return getComment().srcAnnotation(path); }

    public SrcAnnotation ExternalClause.srcAnnotation(String ... path) {    return SrcAnnotation.createFor(getAnnotationOpt(), path); }
    public SrcAnnotation InstExternal.srcAnnotation(String ... path) {      return getExternalClause().srcAnnotation(path); }

    public SrcAnnotation Comment.srcAnnotation(String ... path) {           return SrcAnnotation.createFor(getAnnotationOpt(), path); }
    
    /*******************
     *    Java Stuff    
     ******************/
    
    public class SrcAnnotation extends GenericAnnotationNode<SrcAnnotation, SrcAnnotationProvider, Exp> {
        
        public static final SrcAnnotation AMBIGUOUS_ANNOTATION =  new SrcAnnotation(null, null, null);
        
        protected SrcAnnotation(String name, SrcAnnotationProvider node, SrcAnnotation parent) {
            super(name, node, parent);
        }

        @Override
        protected SrcAnnotation self() {
            return this;
        }

        @Override
        protected SrcAnnotation createNode(String name, SrcAnnotationProvider node) {
            return new SrcAnnotation(name, node, this);
        }

        @Override
        protected SrcAnnotation ambiguousNode() {
            return AMBIGUOUS_ANNOTATION;
        }
        
        public static SrcAnnotation createFor(SrcAnnotationProvider node, String[] path) {
            if (node == null) {
                return createNull(path);
            } else {
                return new SrcAnnotation(null, node, null).forPath(path);
            }
        }

        public static SrcAnnotation createNull(String[] path) {
            return new SrcAnnotation(null, null, null).forPath(path);
        }
        
    }
    
    public interface SrcAnnotationProvider extends AnnotationProvider<SrcAnnotationProvider, Exp> {}
    
    /*******************
     *  Modifications   
     ******************/
    Modification implements SrcAnnotationProvider;
    
    syn String Modification.annotationName() = parentAnnotationName();
    eq NamedModification.annotationName() = getName().name();

    inh String Modification.parentAnnotationName();
    eq NamedModification.getChild().parentAnnotationName()    = getName().name();
    eq CompleteModification.getChild().parentAnnotationName() = parentAnnotationName();
    eq BaseNode.getChild().parentAnnotationName()             = null;

    syn Exp Modification.annotationValue() = null;
    eq CompleteModification.annotationValue() = hasValueModification() ? getValueModification().getExp() : null;
    eq ComponentModification.annotationValue() = hasModification() ? getModification().annotationValue() : null;
    eq ValueModification.annotationValue() = getExp();
    
    syn Iterable<SubNodePair<SrcAnnotationProvider>> Modification.annotationSubNodes() = Collections.emptyList();
    eq CompleteModification.annotationSubNodes() = getClassModification().annotationSubNodes();
    eq ComponentModification.annotationSubNodes() = 
            hasModification() ? getModification().annotationSubNodes() : super.annotationSubNodes();
    eq ClassModification.annotationSubNodes() {
        return new TransformerIterable<Argument, SubNodePair<SrcAnnotationProvider>>(getArguments()) {
            @Override
            protected SubNodePair<SrcAnnotationProvider> transform(Argument a) {
                return new SubNodePair<SrcAnnotationProvider>(a.annotationName(), a);
            }
        };
    }

    @Override
    public void Modification.setAnnotationValue(Exp newValue) throws FailedToSetAnnotationValueException {
        throw new FailedToSetAnnotationValueException();
    }
    @Override
    public void ValueModification.setAnnotationValue(Exp newValue) throws FailedToSetAnnotationValueException {
        setExp(newValue);
    }
    @Override
    public void ComponentModification.setAnnotationValue(Exp newValue) throws FailedToSetAnnotationValueException {
        if (hasModification()) {
            getModification().setAnnotationValue(newValue);
        } else {
            throw new FailedToSetAnnotationValueException();
        }
    }
    @Override
    public void CompleteModification.setAnnotationValue(Exp newValue) throws FailedToSetAnnotationValueException {
        if (hasValueModification()) {
            getValueModification().setAnnotationValue(newValue);
        } else {
            setValueModification(new ValueModification(newValue));
        }
    }

    @Override
    public SrcAnnotationProvider Modification.addAnnotationSubNode(String name) {
        return null;
    }
    @Override
    public SrcAnnotationProvider ClassModification.addAnnotationSubNode(String name) {
        ComponentModification cm =
                new ComponentModification(new ParseAccess(name), new CompleteModification(new ClassModification()));
        addArgument(cm);
        return cm;
    }
    @Override
    public SrcAnnotationProvider CompleteModification.addAnnotationSubNode(String name) {
        return getClassModification().addAnnotationSubNode(name);
    }

    syn boolean Modification.isEach() = false;
    eq Argument.isEach()              = hasEach();

    syn boolean Modification.isFinal() = false;
    eq Argument.isFinal()              = hasFinal();

    /*******************
     *   Class Decls    
     ******************/
    syn SrcAnnotationProvider ClassDecl.srcAnnotationProvider() = null;
    eq FullClassDecl.srcAnnotationProvider() = SrcAnnotation.createProviderFor(getAnnotationOpt());
    eq ShortClassDecl.srcAnnotationProvider() =
            SrcAnnotation.createProviderFor(getExtendsClauseShortClass().getComment().getAnnotationOpt());
    eq LibNode.srcAnnotationProvider() = resolveLib().srcAnnotationProvider();

    /*******************
     *  Annotation Opt  
     ******************/
    class AnnotationOptAnnotationProvider implements SrcAnnotationProvider {

        private final Opt<Annotation> opt;

        public AnnotationOptAnnotationProvider(Opt<Annotation> opt) {
            this.opt = opt;
        }

        @Override
        public Exp annotationValue() {
            return null;
        }

        @Override
        public Iterable<SubNodePair<SrcAnnotationProvider>> annotationSubNodes() {
            if (opt.getNumChild() > 0) {
                return opt.getChild(0).annotationSubNodes();
            } else {
                return Collections.<SubNodePair<SrcAnnotationProvider>>emptyList();
            }
        }

        @Override
        public void setAnnotationValue(Exp newValue) throws FailedToSetAnnotationValueException {
            throw new FailedToSetAnnotationValueException();
        }

        @Override
        public SrcAnnotationProvider addAnnotationSubNode(String name) {
            if (opt.getNumChild() == 0) {
                ClassModification cm = new ClassModification();
                opt.setChild(new ParseAnnotation(cm), 0);
            }
            return opt.getChild(0).addAnnotationSubNode(name);
        }

        @Override
        public boolean isEach() {
            return false;
        }

        @Override
        public boolean isFinal() {
            return false;
        }

        @Override
        public String resolveURI(String str) {
            return opt.resolveURI(str);
        }

    }

    public class SrcAnnotation {
        public static SrcAnnotation createFor(Opt<Annotation> opt, String[] path) {
            return createFor(createProviderFor(opt), path);
        }
        public static SrcAnnotationProvider createProviderFor(Opt<Annotation> opt) {
            return new AnnotationOptAnnotationProvider(opt);
        }
    }

    /*******************
     *       Exp        
     ******************/
    /*
     * Exp cant implement SrcAnnotationProvider since then it will be both the
     * provider and the value of an annotation, take for example
     * ArrayConstructor. We want to use it as an annotation node when it
     * represents the list of graphical primitives in an diagram or icon. But
     * in some situations we want to treat it as the value of annother
     * annotation node. When it is a provider, what would  annotationValue()
     * return? If it returns this, then that would be wrong, since when it is
     * the provider, then it is the RHS of the equal sign that is the value,
     * which doesn't exist for an ArrayConstructor, implying it should return
     * null. Mean while if it actually was the RHS of another exp, then it
     * should return this. So we need this class.
     * 
     * Remember a provider points to the entire annotation node, e.g.:
     *      a(b,c,d)=e
     * while annotationValue() points at 'e' in this case.
     */
    Exp implements PossiblyAnnotation<SrcAnnotationProvider>;

    syn SrcAnnotationProvider Exp.asAnnotationProvider() = null;
    eq ArrayConstructor.asAnnotationProvider()           = getFunctionArguments();
    eq FunctionCall.asAnnotationProvider()               = new SrcSingeltonProvider(name(), getFunctionArguments());

    syn SrcAnnotationProvider Exp.asNamedAnnotationProvider() = null;
    eq FunctionCall.asNamedAnnotationProvider() = hasFunctionArguments() ? getFunctionArguments() : null;

    syn String Exp.namedAnnotationProviderName() {
        throw new IllegalArgumentException("Can't call namedAnnotationName() for the type " + getClass().getSimpleName());
    }
    eq FunctionCall.namedAnnotationProviderName() = name();

    FunctionArguments implements SrcAnnotationProvider;
    
    @Override
    public Exp FunctionArguments.annotationValue() {
        return null;
    }
    
    @Override
    public Iterable<SubNodePair<SrcAnnotationProvider>> FunctionArguments.annotationSubNodes() {
        return new ChainedIterable(new TransformerIterable<Exp, SubNodePair<SrcAnnotationProvider>>(getExps()) {
            @Override
            protected SubNodePair<SrcAnnotationProvider> transform(Exp exp) {
                if (exp.asNamedAnnotationProvider() == null) {
                    return new SubNodePair<SrcAnnotationProvider>(null, new ExpValueProvider(exp));
                } else {
                    return new SubNodePair<SrcAnnotationProvider>(exp.namedAnnotationProviderName(),
                            exp.asNamedAnnotationProvider());
                }
            }
        }, new TransformerIterable<NamedArgument, SubNodePair<SrcAnnotationProvider>>(getNamedArguments()) {
            @Override
            protected SubNodePair<SrcAnnotationProvider> transform(NamedArgument arg) {
                return new SubNodePair<SrcAnnotationProvider>(arg.getName().name(), arg);
            }
        });
    }

    @Override
    public void FunctionArguments.setAnnotationValue(Exp newValue) throws FailedToSetAnnotationValueException {
        throw new FailedToSetAnnotationValueException();
    }

    @Override
    public SrcAnnotationProvider FunctionArguments.addAnnotationSubNode(String name) {
        return null;
    }

    @Override
    public boolean FunctionArguments.isEach() {
        return false;
    }

    @Override
    public boolean FunctionArguments.isFinal() {
        return false;
    }
    
    NamedArgument implements SrcAnnotationProvider;
    
    @Override
    public Exp NamedArgument.annotationValue() {
        return getExp();
    }
    
    @Override
    public Iterable<SubNodePair<SrcAnnotationProvider>> NamedArgument.annotationSubNodes() {
        return Collections.<SubNodePair<SrcAnnotationProvider>>emptyList();
    }
    
    @Override
    public void NamedArgument.setAnnotationValue(Exp newValue) throws FailedToSetAnnotationValueException {
        throw new FailedToSetAnnotationValueException();
    }
    
    @Override
    public SrcAnnotationProvider NamedArgument.addAnnotationSubNode(String name) {
        return null;
    }
    
    @Override
    public boolean NamedArgument.isEach() {
        return false;
    }
    
    @Override
    public boolean NamedArgument.isFinal() {
        return false;
    }
//    ArrayConstructor implements SrcAnnotationProvider;
//
//    @Override
//    public Exp ArrayConstructor.annotationValue() {
//        return null;
//    }
//
//    @Override
//    public Iterable<SubNodePair<SrcAnnotationProvider>> ArrayConstructor.annotationSubNodes() {
//        return new TransformerIterable<Exp, SubNodePair<SrcAnnotationProvider>>(getFunctionArguments().getExps()) {
//            @Override
//            protected SubNodePair<SrcAnnotationProvider> transform(Exp exp) {
//                return new SubNodePair<SrcAnnotationProvider>(null, new ExpAnnotationProvider(exp));
//            }
//        };
//    }
//
//    @Override
//    public void ArrayConstructor.setAnnotationValue(Exp newValue) throws FailedToSetAnnotationValueException {
//        throw new FailedToSetAnnotationValueException();
//    }
//
//    @Override
//    public SrcAnnotationProvider ArrayConstructor.addAnnotationSubNode(String name) {
//        return null;
//    }
//
//    @Override
//    public boolean ArrayConstructor.isEach() {
//        return false;
//    }
//
//    @Override
//    public boolean ArrayConstructor.isFinal() {
//        return false;
//    }

    /*******************
     *     Helpers      
     ******************/
    syn Iterable<SubNodePair<SrcAnnotationProvider>> Annotation.annotationSubNodes() = Collections.emptyList();
    eq ParseAnnotation.annotationSubNodes() = getClassModification().annotationSubNodes();
    
    public SrcAnnotationProvider Annotation.addAnnotationSubNode(String name) {
        return null;
    }
    @Override
    public SrcAnnotationProvider ParseAnnotation.addAnnotationSubNode(String name) {
        return getClassModification().addAnnotationSubNode(name);
    }

    public class SrcSingeltonProvider implements SrcAnnotationProvider {

        private final SrcAnnotationProvider provider;
        private final String name;

        public SrcSingeltonProvider(String name, SrcAnnotationProvider provider) {
            this.provider = provider;
            this.name = name;
        }

        @Override
        public Exp annotationValue() {
            return null;
        }

        @Override
        public Iterable<SubNodePair<SrcAnnotationProvider>> annotationSubNodes() {
            return Collections.singletonList(new SubNodePair<SrcAnnotationProvider>(name, provider));
        }

        @Override
        public void setAnnotationValue(Exp newValue) throws FailedToSetAnnotationValueException {
            throw new FailedToSetAnnotationValueException();
        }

        @Override
        public SrcAnnotationProvider addAnnotationSubNode(String name) {
            return null;
        }

        @Override
        public boolean isEach() {
            return false;
        }

        @Override
        public boolean isFinal() {
            return false;
        }

        @Override
        public String resolveURI(String str) {
            return provider.resolveURI(str);
        }
    }
    
    public class ExpValueProvider implements SrcAnnotationProvider {

        private final Exp exp;

        public ExpValueProvider(Exp exp) {
            this.exp = exp;
        }

        @Override
        public Exp annotationValue() {
            return exp;
        }

        @Override
        public Iterable<SubNodePair<SrcAnnotationProvider>> annotationSubNodes() {
            return Collections.<SubNodePair<SrcAnnotationProvider>>emptyList();
        }

        @Override
        public void setAnnotationValue(Exp newValue) throws FailedToSetAnnotationValueException {
            throw new FailedToSetAnnotationValueException();
        }

        @Override
        public SrcAnnotationProvider addAnnotationSubNode(String name) {
            return null;
        }

        @Override
        public boolean isEach() {
            return false;
        }

        @Override
        public boolean isFinal() {
            return false;
        }

        @Override
        public String resolveURI(String str) {
            return exp.resolveURI(str);
        }

    }
}
