/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.ArrayList;
import java.util.Collection;

aspect Constructors {

	/*
	public InstComposite.InstComposite(InstAccess a,
			                                   ComponentDecl cd,
			                                   Opt<InstModification> inst_mod_opt,
			                                   Opt<InstConstraining> inst_constr_opt) {
		this(a,new Opt<FArraySubscripts>(),cd,inst_mod_opt,inst_constr_opt);
	}
	*/
	
	/**
	 * Construct a List containing the same nodes as the given Collection.
	 */
	public List.List(Collection<T> nodes) {
		if (!nodes.isEmpty())
			setChild(null, nodes.size() - 1); // Ensure we won't need to increase size later
		int i = 0;
		for (T n : nodes)
			setChild(n, i++);
	}
	
	/**
	 * Construct a List containing the given nodes.
	 */
	public List.List(T... nodes) {
		for (int i = nodes.length - 1; i >= 0; i--)
			setChild(nodes[i], i);
	}
	
	/**
	 * \brief Constructs a real literal expression from a double.
	 */
	public RealLitExp.RealLitExp(double val) {
		this(String.valueOf(val));
	}
	
	/**
	 * \brief Constructs an integer literal expression from an integer.
	 */
	public IntegerLitExp.IntegerLitExp(int val) {
		this(String.valueOf(val));
	}
	
	/**
	 * \brief Constructs a parse access from a String.
	 */
	public ParseAccess.ParseAccess(String name) {
		this();
		setID(name);
	}
	
	/**
	 * \brief Constructs a component modification from an access and modification.
	 */
	public ComponentModification.ComponentModification(Access name, Modification mod) {
		this();
		setName(name);
		setModification(mod);
	}
	
	/**
	 * \brief Constructs a complete modification from a class modification.
	 */
	public CompleteModification.CompleteModification(ClassModification cm) {
		this();
		setClassModification(cm);
	}
	
	/**
	 * \brief Construcs a connect clause without any residual.
	 */
	public FConnectClause.FConnectClause(FEquationType type, Opt<FStringComment> comment, ConnectClause connectClause, FIdUseInstAccess left, FIdUseInstAccess right) {
		this(type, new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), comment, connectClause, left, right);
	}
	
	/**
	 * \brief Construcs a else equation without any residual.
	 */
	public FElseEquation.FElseEquation(FEquationType type, List<FAbstractEquation> eqns) {
		this(type, new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), eqns);
	}
	
	/**
	 * \brief Constructs an equation that is not initial and is not marked as
	 * residual.
	 */
	public FEquation.FEquation(FExp left, FExp right) {
		this(new FNormalEquation(), new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), left, right);
	}
	
	/**
	 * \brief Constructs an equation that is not marked as residual.
	 */
	public FEquation.FEquation(FEquationType type, FExp left, FExp right) {
		this(type, new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), left, right);
	}
	
	/**
	 * \brief Constructs an equation that is not initial
	 */
	public FEquation.FEquation(FQName name, FResidual residual, FNominal nominal, FExp left, FExp right) {
		this(new FNormalEquation(), new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), left, right);
		if (name != null)
			setName(name);
		if (residual != null)
			setResidual(residual);
		if (nominal != null)
			setNominal(nominal);
	}
	
	/**
	 * \brief Constructs a function call equation that is not initial.
	 */
	public FFunctionCallEquation.FFunctionCallEquation(List<FFunctionCallLeft> left, FAbstractFunctionCall call) {
		this(new FNormalEquation(), new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), left, call);
	}
	
	/**
	 * \brief Constructs a function call equation.
	 */
	public FFunctionCallEquation.FFunctionCallEquation(FEquationType type, List<FFunctionCallLeft> left, FAbstractFunctionCall call) {
		this(type, new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), left, call);
	}
	
	/**
	 * \brief Constructs a connection clause that is not initial.
	 */
//	public FConnectClause.FConnectClause(Opt<FStringComment> comment, FIdUseInstAccess left, FIdUseInstAccess right) {
//		this(new FNormalEquation(), comment, left, right);
//	}
	
	/**
	 * \brief Constructs a for clause equation that is not initial.
	 */
	public FForClauseE.FForClauseE(List<FForIndex> indices, List<FAbstractEquation> eqns) {
		this(new FNormalEquation(), new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), indices, eqns);
	}
	
	/**
	 * \brief Constructs a for clause equation that is not initial.
	 */
	public InstForClauseE.InstForClauseE(List<InstForIndex> indices, List<FAbstractEquation> eqns) {
		this(new FNormalEquation(), new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), indices, eqns);
	}
	
	/**
	 * \brief Constructs a for clause equation.
	 */
	public InstForClauseE.InstForClauseE(FEquationType type, List<InstForIndex> indices, List<FAbstractEquation> eqns) {
		this(type, new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), indices, eqns);
	}
	
	/**
	 * Constructor with only nessecary args. 
	 */
	public InstCreateComponentDecl.InstCreateComponentDecl(ComponentDecl cd, InstLookupRedirectNode ln) {
		this(cd.getClassName().newInstAccess(), new Opt(), cd, new Opt(), new Opt(), new Opt(), ln);
	}
	
	/**
	 * Constructor with only nessecary args. 
	 */
	public InstCreateForIndexPrimitive.InstCreateForIndexPrimitive(ComponentDecl cd) {
		// This maneuver is pretty ugly, but we need to find an InstClassDecl
		// in the instance tree from the source tree...
		this(cd.getClassName().newInstAccess(), new Opt(), cd, new Opt(), new Opt(), new Opt(), 
				((SourceRoot) cd.root()).getProgram().getInstProgramRoot());
	}
	
	/**
	 * Constructor with only nessecary args. 
	 */
	public InstCreateReplacingComponentDecl.InstCreateReplacingComponentDecl(
			ComponentDecl cd, InstLookupRedirectNode ln, ComponentDecl ocd, InstComponentRedeclare icr) {
		this(cd.getClassName().newInstAccess(), new Opt(), cd, new Opt(), new Opt(), new Opt(), ln, ocd, icr);
	}
	
	/**
	 * \brief Constructs an algorithm block that is not initial.
	 */
	public FAlgorithm.FAlgorithm(List<FStatement> stmts) {
		this(new FNormalEquation(), new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), stmts);
	}
	
	/**
	 * \brief Constructs an algorithm block.
	 */
	public FAlgorithm.FAlgorithm(FEquationType type, List<FStatement> stmts) {
		this(type, new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), stmts);
	}
	
	/**
	 * \brief Constructs a boolean literal expression from a boolean.
	 */
	public static FBooleanLitExp FBooleanLitExp.create(boolean val) {
		return val ? new FBooleanLitExpTrue() : new FBooleanLitExpFalse();
	}
	
	/**
	 * \brief Constructs a enumeration literal expression from a type and an ordinal.
	 */
	public FEnumLitExp.FEnumLitExp(FEnumType type, int val) {
		this(type.getName(), type.getFEnumLiteralType(val - 1).getName(), type);
	}
	
	/**
	 * \brief Constructs a enumeration literal expression from a type and a literal name.
	 */
	public FEnumLitExp.FEnumLitExp(FEnumType type, String val) {
		this(type.getName(), val, type);
	}
	
	/**
	 * \brief Constructs a enumeration literal expression from an enum name and a value name.
	 */
	public FEnumLitExp.FEnumLitExp(String name, String val) {
		this(name, val, null);
	}
	
	/**
	 * \brief Constructs an FIdUse that refers to the variable with the given name.
	 */
	public FIdUse.FIdUse(String name) {
		this(new FQNameString(name));
	}
	
	/**
	 * \brief Constructs an FIdUse that refers to a cell of the variable with the given name.
	 *
	 * @param fas  the array subscripts to set for the last name part
	 */
	public FIdUse.FIdUse(String name, FArraySubscripts fas) {
		this(new FQNameFull(name, fas));
	}
	
	/**
	 * \brief Constructs an if equation.
	 */
	public FIfEquation.FIfEquation(FEquationType type, List<FAbstractEquation> eqns, FExp guard, Opt<FIfWhenElseEquation> elseClause) {
		this(type, new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), eqns, guard, elseClause);
	}
    
	/**
	 * \brief Constructs an FQName by splitting the given name into name parts.
	 * 
	 * Does <em>not</em> parse array subscripts.
	 */
    public FQNameFull.FQNameFull(String name) {
        this(name.split("\\."));
    }
    
	/**
	 * Constructs an FQName with the given name parts (without any subscripts).
	 * 
	 * Does <em>not</em> parse array subscripts.
	 */
    public FQNameFull.FQNameFull(String... name) {
        this(new List());
        for (String part : name)
            addFQNamePart(part);
    }
    
    /**
     * \brief Creates and adds a new FQNamePart without array subscripts.
     */
    public void FQNameFull.addFQNamePart(String name) {
    	addFQNamePart(new FQNamePart(name));
    }
	
	/**
	 * \brief Constructs an FQName by splitting the given name into name parts and adding array subscripts.
	 * 
	 * Does <em>not</em> parse array subscripts.
	 *
	 * @param fas  the array subscripts to set for the last name part
	 */
	public FQNameFull.FQNameFull(String name, FArraySubscripts fas) {
		this(name);
		addFArraySubscripts(fas);
	}
	
	/**
	 * \brief Constructs a flat FIdUseExp that refers to the variable with the given name.
	 */
	public FIdUseExp.FIdUseExp(String name) {
		this(new FIdUse(name));
	}
	
	/**
	 * \brief Constructs an FIdUseExp that refers to the variable with the given name.
	 */
	public FIdUseExp.FIdUseExp(FQName name) {
		this(new FIdUse(name));
	}
	
	/**
	 * \brief Constructs an FIdUseExp that refers to a cell of the variable with the given name.
	 *
	 * @param fas  the array subscripts to set for the last name part
	 */
	public FIdUseExp.FIdUseExp(String name, FArraySubscripts fas) {
		this(new FIdUse(name, fas));
	}
	
	/**
	 * \brief Constructs an FDerExp that refers to the variable with the given name.
	 */
	public FDerExp.FDerExp(FQName name) {
		this(new FIdUse(name));
	}
	
	/**
	 * Constructs an FIdUseInstAccess with an empty FQName.
	 * 
	 * Note: the FQName of an FIdUseInstAccess should always be empty.
	 */
	public FIdUseInstAccess.FIdUseInstAccess(InstAccess ia) {
		this(new FQNameEmpty(), ia);
	}
	
	/**
	 * \brief Constructs an unsuported equation.
	 */
	public FUnsupportedEquation.FUnsupportedEquation(FEquationType type) {
		this(type, new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>());
	}
	
	/**
	 * \brief Constructs a when equation.
	 */
	public FWhenEquation.FWhenEquation(FEquationType type, List<FAbstractEquation> eqns, FExp guard, Opt<FIfWhenElseEquation> elseClause) {
		this(type, new Opt<FQName>(), new Opt<FResidual>(), new Opt<FNominal>(), eqns, guard, elseClause);
	}
	
	/**
	 * Create an access from a class name.
	 */
	public static Access Access.fromClassName(String name) {
		String[] parts = name.split("\\.");
		if (parts.length == 1) {
			return new ClassAccess(parts[0]);
		} else {
			List<Access> l = new List<Access>();
			for (String part : parts)
				l.add(new ClassAccess(part));
			return new Dot(l);
		}
	}
	
	/**
	 * Create an access from a class name.
	 */
	public static InstAccess InstAccess.fromName(String name) {
		String[] parts = name.split("\\.");
		if (parts.length == 1) {
			return new InstParseAccess(parts[0]);
		} else {
			List<InstAccess> l = new List<InstAccess>();
			for (String part : parts)
				l.add(new InstParseAccess(part));
			return new InstDot(l);
		}
	}
	
	/**
	 * \brief Constructs an FForIndex with a temporary index variable and a 
	 *        range expression starting at 1 as the in expression.
	 * 
	 * @param name  the name of the index
	 * @param end   the upper limit for the range expression
	 */
	public FForIndex.FForIndex(String name, FExp end) {
		this();
		setFExp(new FRangeExp(new FIntegerLitExp(1), end));
		setFVariable(new FIntegerVariable(new FTemporaryVisibilityType(), 
				fParameter(), new FQNameString(name)));
	}
	
	/**
	 * \brief Constructs an FForIndex with a temporary index variable and loops 
	 *        over the given variable.        
	 * 
	 * @param name  the name of the index
	 * @param var   the name of the variable to loop over
	 * @param dim   the dimension to loop over
	 */
	public FForIndex.FForIndex(String name, FQName var, int dim) {
		this(name, new FSizeExp(var, dim));
	}
	
	/**
	 * \brief Constructs an FSizeExp giving the size in the given dimension for the given variable.
	 */
	public FSizeExp.FSizeExp(FQName var, int dim) {
		this(new FIdUseExp(var), dim);
	}
	
	/**
	 * \brief Constructs an FSizeExp giving the size in the given dimension for the given expression.
	 */
	public FSizeExp.FSizeExp(FExp exp, int dim) {
		this(exp, new Opt(new FIntegerLitExp(dim + 1)));
	}
	
	/**
	 * \brief Constructs an FRangeExp with the given start and stop expressions.
	 */
	public FRangeExp.FRangeExp(FExp start, FExp stop) {
		this(new List().add(start).add(stop));
	}
	
	/**
	 * \brief Constructs an FRangeExp with the given start and stop literal values.
	 */
	public FRangeExp.FRangeExp(int start, int stop) {
		this(new FIntegerLitExp(start), new FIntegerLitExp(stop));
	}
	
	/**
	 * \brief Constructs an FRangeExp with the given start, step and and stop expressions.
	 */
	public FRangeExp.FRangeExp(FExp start, FExp step, FExp stop) {
		this(new List().add(start).add(step).add(stop));
	}
	
	/**
	 * Add this expression to another.
	 * 
	 * Used to gradually builf up a sum, and handles special case for first term. 
	 * The so far accumulated expession is then passed as exp, and this node will be 
	 * the right child of the created expression. May return <code>this</code>, 
	 * if exp is <code>null</code>.
	 * 
	 * @param exp  the first term, may be null
	 * @param neg  if <code>true</code>, then this will be subtracted instead of added
	 */
	public FExp FExp.appendSum(FExp exp, boolean neg) {
		if (exp == null)
			return neg ? new FNegExp(this) : this;
		else
			return neg ? new FSubExp(exp, this) : new FAddExp(exp, this);	
	}
	
	/**
	 * \brief Constructs an FRecordConstructor for a record with the given name and no arguments.
	 */
	public FRecordConstructor.FRecordConstructor(String name) {
		this(new FIdUse(name), new List());
	}
	
	public EnumLiteralDecl.EnumLiteralDecl(IdDecl name, Comment comment) {

		this(new Opt(),
                new Opt(),
                new Opt(),
                new Opt(),
                new Opt(),
                new Opt(),
                new Opt(new Constant()),      
                new Opt(),
                new ClassAccess("EnumType"),
                new Opt(),
                new PublicVisibilityType(),
                new IdDecl(name.getID()),
                new Opt(),
                new Opt(),        
                new Opt(),
                (Comment)comment.fullCopy(),
                new Opt(),
                new Comment(new Opt(),new Opt()));
		this.setLocation(name);
		
	}
	
	public ComponentDecl.ComponentDecl(boolean isParameter,
	                                   String type,
	                                   String name,
	                                   String bexp) {

		this(new Opt(),
		                         new Opt(),
		                         new Opt(),
		                         new Opt(),
		                         new Opt(),
		                         new Opt(),
	                             isParameter? new Opt(new Parameter()): new Opt(),      
                                 new Opt(),
                                 new ClassAccess(type),
                                 new Opt(),
                                 new PublicVisibilityType(),
                                 new IdDecl(name),
                                 new Opt(),
                        		 new Opt(),        
                                 new Opt(),
                                 new Comment(new Opt(),new Opt()),
                                 new Opt(),
                                 new Comment(new Opt(),new Opt()));
		
		Exp bexp_ast=null;
		
		if (!bexp.equals("")) {
		    //ModelicaParser mp = new ModelicaParser();
			//bexp_ast = mp.parseExpString(bexp);
			ParserHandler ph = new ParserHandler();
			try {
				bexp_ast = ph.parseExpString(bexp);
			} catch (Exception e) {	
				log.error("Error when parsing string");	
			}
			//log.debug("ComponentDecl.ComponentDecl");
			//bexp_ast.dumpTreeBasic("");	
		    this.setModification(new ValueModification(bexp_ast));
        }                     	
	}
	
	/**
	 * Create a real variable with only the required children.
	 */
	public FRealVariable.FRealVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, FClass.HGTVariableType.NONE);
	}
	
	/**
	 * Create a derivative variable with only the required children.
	 */
	public FDerivativeVariable.FDerivativeVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, FClass.HGTVariableType.NONE);
	}
	
	/**
	 * Create a derivative variable with only the required children.
	 */
	public FDummyDerivativeVariable.FDummyDerivativeVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, FClass.HGTVariableType.NONE);
	}
	
	/**
	 * Create a derivative variable with only the required children.
	 */
	public FHDerivativeVariable.FHDerivativeVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name, int order) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, FClass.HGTVariableType.NONE, order);
	}
	
	/**
	 * Create a derivative variable with only the required children.
	 */
	public FHDummyDerivativeVariable.FHDummyDerivativeVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name, int order) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, FClass.HGTVariableType.NONE, order);
	}
	
	/**
	 * Create a pre variable for a discrete real variable.
	 */
	public FPreRealVariable.FPreRealVariable(FRealVariable fv) {
		this(fv.getFVisibilityType().fullCopy(), fv.getFTypePrefixVariability().fullCopy(),
				new Opt(), (List) fv.getFAttributeList().fullCopy(), fv.getDerivedType(), 
				new Opt(), new Opt(), fv.getFQName().fullCopy(), fv.getHGTType());
	}
	
	/**
	 * Create a integer variable with only the required children.
	 */
	public FIntegerVariable.FIntegerVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, FClass.HGTVariableType.NONE);
	}
	
	/**
	 * Create a pre variable for an integer variable.
	 */
	public FPreIntegerVariable.FPreIntegerVariable(FIntegerVariable fv) {
		this(fv.getFVisibilityType().fullCopy(), fv.getFTypePrefixVariability().fullCopy(),
				new Opt(), (List) fv.getFAttributeList().fullCopy(), fv.getDerivedType(), 
				new Opt(), new Opt(), fv.getFQName().fullCopy(), fv.getHGTType());
	}
	
	/**
	 * Create a enum variable with only the required children.
	 */
	public FEnumVariable.FEnumVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name, FQName enumName) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, FClass.HGTVariableType.NONE, enumName);
	}
	
	/**
	 * Create a pre variable for a enum variable.
	 */
	public FPreEnumVariable.FPreEnumVariable(FEnumVariable fv) {
		this(fv.getFVisibilityType().fullCopy(), fv.getFTypePrefixVariability().fullCopy(),
				new Opt(), (List) fv.getFAttributeList().fullCopy(), fv.getDerivedType(), 
				new Opt(), new Opt(), fv.getFQName().fullCopy(), fv.getHGTType(), fv.getEnum().fullCopy());
	}
	
	/**
	 * Create a boolean variable with only the required children.
	 */
	public FBooleanVariable.FBooleanVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, FClass.HGTVariableType.NONE);
	}
	
	/**
	 * Create a pre variable for a boolean variable.
	 */
	public FPreBooleanVariable.FPreBooleanVariable(FBooleanVariable fv) {
		this(fv.getFVisibilityType().fullCopy(), fv.getFTypePrefixVariability().fullCopy(),
				new Opt(), (List) fv.getFAttributeList().fullCopy(), fv.getDerivedType(), 
				new Opt(), new Opt(), fv.getFQName().fullCopy(), fv.getHGTType());
	}
	
	/**
	 * Create a string variable with only the required children.
	 */
	public FStringVariable.FStringVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, FClass.HGTVariableType.NONE);
	}
	
	/**
	 * Create a pre variable for a string variable.
	 */
	public FPreStringVariable.FPreStringVariable(FStringVariable fv) {
		this(fv.getFVisibilityType().fullCopy(), fv.getFTypePrefixVariability().fullCopy(),
				new Opt(), (List) fv.getFAttributeList().fullCopy(), fv.getDerivedType(), 
				new Opt(), new Opt(), fv.getFQName().fullCopy(), fv.getHGTType());
	}
	
	/**
	 * Create a record variable with only the required children.
	 */
	public FRecordVariable.FRecordVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name, FQName record) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, FClass.HGTVariableType.NONE, record);
	}

	
	/**
	 * \brief Create an FInternalAttribute with only the children that are 
	 *        valid for them.
	 */
	public FInternalAttribute.FInternalAttribute(String name, FExp value) {
		this(new FIdUse(new FQNameEmpty()), new FIdDecl(new FQNameString(name)), new Opt(value), 
				true, 0, new Opt(), new Opt(), new List());
	}
	
	/**
	 * Create an attribute with only the required children.
	 */
	public FAttribute.FAttribute(FIdUse typeName, FIdDecl name, boolean isSet, int level) {
		this(typeName, name, new Opt(), isSet, level, new Opt(), new Opt(), new List());
	}
	
	/**
	 * Create an attribute with only the required children and a value.
	 * 
	 * The value may be <code>null</code>, then no value is set.
	 */
	public FAttribute.FAttribute(FIdUse typeName, FIdDecl name, FExp value, boolean isSet, int level) {
		this(typeName, name, 
				(value == null ? new Opt() : new Opt(value)), 
				isSet, level, new Opt(), new Opt(), new List());
	}
	
	/**
	 * \brief Create an FFunctionArray with the given name and type. 
	 *        Extracts array subscripts from type.
	 */
	public FFunctionArray.FFunctionArray(FType type, String name) {
		this(new Opt(), type, new Opt(), 
				new FQNameFull(name, type.size().flattenFArraySubscripts(new FQNameEmpty())));
	}
	
	/**
	 * \brief Create an FFunctionVariable with the given name and type. 
	 */
	public FFunctionVariable.FFunctionVariable(FType type, String name) {
		this(new Opt(), type, new Opt(), new FQNameString(name));
	}
	
	/**
	 * \brief Create a new FSubscriptedExp with a new FArraySubscripts, containing the 
	 *        proper number of FSubscripts (according to <code>exp</code>).
	 * 
	 * All FSubscripts except the first will be FColonSubscripts.
	 * 
	 * @param exp    the expression this FSubscriptedExp should wrap
	 * @param index  the index to use for the first FSubscript
	 * @param ndims  the number of dimensions of exp (calling ndims() might cause name lookup)
	 */
	public FSubscriptedExp.FSubscriptedExp(FExp exp, int index, int ndims) {
		this(exp, FArraySubscripts.createFColonSubscripts(ndims));
		getFArraySubscripts().specifyNext(index);
	}
	
	/**
	 * \brief Create a new FArraySubscripts <code>n</code> literal subscripts from 
	 *        <code>i</code>, starting at <code>j</code>.
	 */
	public FArraySubscripts.FArraySubscripts(Index i, int j, int n) {
		this();
		for (int k = j; k < n+j; k++)
			addFSubscript(i.get(k));
	}
	
	/**
	 * Add a new use expression subscript to the list of FSubscripts.
	 */
	public void FArraySubscripts.addFSubscript(FExp e) {
		addFSubscript(new FExpSubscript(e));
	}
	
	/**
	 * Add a new integer literal subscript to the list of FSubscripts.
	 */
	public void FArraySubscripts.addFSubscript(int i) {
		addFSubscript(new FIntegerSubscript(i));
	}
	
	/**
	 * Add new integer literal subscripts for each index to the list of FSubscripts.
	 */
	public void FArraySubscripts.addFSubscripts(int[] index) {
		for (int i : index)
			addFSubscript(i);
	}
	
	/**
	 * Add new integer literal subscripts for each index to the list of FSubscripts.
	 */
	public void FArraySubscripts.addFSubscripts(Index i) {
		addFSubscripts(i.index());
	}
	
	/**
	 * \brief Create a new FArraySubscripts containing <code>n</code> {@link FColonSubscript}s.
	 */
	public static FArraySubscripts FArraySubscripts.createFColonSubscripts(int n) {
		List<FSubscript> l = new List<FSubscript>();
		for (int i = 0; i < n; i++)
			l.add(new FColonSubscript());
		return new FArraySubscripts(l);
	}
	
	/**
	 * \brief Create a new FArraySubscripts containing an integer literal.
	 */
	public static FArraySubscripts FArraySubscripts.createLiteralSubscripts(int i) {
		List<FSubscript> l = new List<FSubscript>();
		l.add(new FIntegerSubscript(i));
		return new FArraySubscripts(l);
	}
	
	/**
	 * Create a new FArraySubscripts containing integer literals.
	 */
	public static FArraySubscripts FArraySubscripts.createLiteralSubscripts(int[] index) {
		FArraySubscripts fas = new FArraySubscripts();
		fas.addFSubscripts(index);
		return fas;
	}
	
}

/*
 * Some algorithms are the same for many node types, but require a new node 
 * to be created of the same type as the node being processed. These methods allow 
 * those algorithms to be generalized.
 */
aspect InheritedFactoryMethods {
	
	/**
	 * \brief Create a new empty node.
	 * 
	 * Abstract method needed for abstract node classes with declared 
	 * (i.e. not inherited) children.
	 */
	public abstract FExp                      FExp.createEmptyNode();
	public abstract FBinExp                   FBinExp.createEmptyNode();
	public abstract FUnaryExp                 FUnaryExp.createEmptyNode();
	public abstract FBooleanLitExp            FBooleanLitExp.createEmptyNode();   // No children, but can be useful
	public abstract FBuiltInFunctionCall      FBuiltInFunctionCall.createEmptyNode();  // Used in BuiltInTranslator 
	public abstract FUnaryBuiltIn             FUnaryBuiltIn.createEmptyNode();
	public abstract FEventGenExp              FEventGenExp.createEmptyNode();
	public abstract FBinEventGenExp           FBinEventGenExp.createEmptyNode();
	public abstract FMathematicalFunctionCall FMathematicalFunctionCall.createEmptyNode();
	public abstract FInfArgsFunctionCall      FInfArgsFunctionCall.createEmptyNode();
	public abstract FMinMaxExp      		  FMinMaxExp.createEmptyNode();
	public abstract FConnBoolOp      	      FConnBoolOp.createEmptyNode();

	// Unsupported expressions
	public FUnsupportedExp     FUnsupportedExp.createEmptyNode()     { return new FUnsupportedExp();     }
	public FUnsupportedBuiltIn FUnsupportedBuiltIn.createEmptyNode() { return new FUnsupportedBuiltIn(); }
	public FIgnoredBuiltIn     FIgnoredBuiltIn.createEmptyNode()     { return new FIgnoredBuiltIn(); }
	
	// Arithmetic oprerators
	public FAddExp       FAddExp.createEmptyNode()       { return new FAddExp();       }
	public FSubExp       FSubExp.createEmptyNode()       { return new FSubExp();       }
	public FMulExp       FMulExp.createEmptyNode()       { return new FMulExp();       }
	public FDivExp       FDivExp.createEmptyNode()       { return new FDivExp();       }
	public FPowExp       FPowExp.createEmptyNode()       { return new FPowExp();       }
	public FDotAddExp    FDotAddExp.createEmptyNode()    { return new FDotAddExp();    }
	public FDotSubExp    FDotSubExp.createEmptyNode()    { return new FDotSubExp();    }
	public FDotMulExp    FDotMulExp.createEmptyNode()    { return new FDotMulExp();    }
	public FDotDivExp    FDotDivExp.createEmptyNode()    { return new FDotDivExp();    }
	public FDotPowExp    FDotPowExp.createEmptyNode()    { return new FDotPowExp();    }
	public FNegExp       FNegExp.createEmptyNode()       { return new FNegExp();       }
	public FStringAddExp FStringAddExp.createEmptyNode() { return new FStringAddExp(); }
	
	// Logical operators
	public FLtExp  FLtExp.createEmptyNode()  { return new FLtExp();  }
	public FLeqExp FLeqExp.createEmptyNode() { return new FLeqExp(); }
	public FGtExp  FGtExp.createEmptyNode()  { return new FGtExp();  }
	public FGeqExp FGeqExp.createEmptyNode() { return new FGeqExp(); }
	public FEqExp  FEqExp.createEmptyNode()  { return new FEqExp();  }
	public FNeqExp FNeqExp.createEmptyNode() { return new FNeqExp(); }
	public FNotExp FNotExp.createEmptyNode() { return new FNotExp(); }
	public FOrExp  FOrExp.createEmptyNode()  { return new FOrExp();  }
	public FAndExp FAndExp.createEmptyNode() { return new FAndExp(); }
	
	// Literal expressions (all have different children, so mostly here for completeness)
	public FRealLitExp         FRealLitExp.createEmptyNode()         { return new FRealLitExp();         }
	public FIntegerLitExp      FIntegerLitExp.createEmptyNode()      { return new FIntegerLitExp();      }
	public FBooleanLitExpTrue  FBooleanLitExpTrue.createEmptyNode()  { return new FBooleanLitExpTrue();  }
	public FBooleanLitExpFalse FBooleanLitExpFalse.createEmptyNode() { return new FBooleanLitExpFalse(); }
	public FStringLitExp       FStringLitExp.createEmptyNode()       { return new FStringLitExp();       }
	public FEnumLitExp         FEnumLitExp.createEmptyNode()         { return new FEnumLitExp();         }
	
	// Misc expressions
	public FIfExp          FIfExp.createEmptyNode()          { return new FIfExp();          }
	public FTimeExp        FTimeExp.createEmptyNode()        { return new FTimeExp();        }
	public FNoEventExp     FNoEventExp.createEmptyNode()     { return new FNoEventExp();     }
	public FSmoothExp      FSmoothExp.createEmptyNode()      { return new FSmoothExp();      }
	public FPreExp         FPreExp.createEmptyNode()         { return new FPreExp();         }
	public FEdgeExp        FEdgeExp.createEmptyNode()        { return new FEdgeExp();        }
	public FChangeExp      FChangeExp.createEmptyNode()      { return new FChangeExp();      }
	public FSampleExp      FSampleExp.createEmptyNode()      { return new FSampleExp();      }
	public FInitialExp     FInitialExp.createEmptyNode()     { return new FInitialExp();     }
	public FTerminalExp    FTerminalExp.createEmptyNode()    { return new FTerminalExp();    }
	public FTerminate      FTerminate.createEmptyNode()      { return new FTerminate();      }
	public FAssert         FAssert.createEmptyNode()         { return new FAssert();         }
	public FNoExp          FNoExp.createEmptyNode()          { return new FNoExp();          }
	public FUnknownSizeExp FUnknownSizeExp.createEmptyNode() { return new FUnknownSizeExp(); }
	
	// Identifier expressions
	public FIdUseExp      FIdUseExp.createEmptyNode()      { return new FIdUseExp();      }
	public InstDerExp     InstDerExp.createEmptyNode()     { return new InstDerExp();     }
	public FDerExp        FDerExp.createEmptyNode()        { return new FDerExp();        }
	public InstHDerExp    InstHDerExp.createEmptyNode()    { return new InstHDerExp();    }
	public FHDerExp       FHDerExp.createEmptyNode()       { return new FHDerExp();       }
	public FInstAccessExp FInstAccessExp.createEmptyNode() { return new FInstAccessExp(); }
	
	// Array expressions
	public FArray          FArray.createEmptyNode()          { return new FArray();          }
	public FLongArray      FLongArray.createEmptyNode()      { return new FLongArray();      }
	public FParseArray     FParseArray.createEmptyNode()     { return new FParseArray();     }
	public FCatExp         FCatExp.createEmptyNode()         { return new FCatExp();         }
	public FMatrix         FMatrix.createEmptyNode()         { return new FMatrix();         }
	public FMatrixRow      FMatrixRow.createEmptyNode()      { return new FMatrixRow();      }
	public FSubscriptedExp FSubscriptedExp.createEmptyNode() { return new FSubscriptedExp(); }
	public FArgumentExp    FArgumentExp.createEmptyNode()    { return new FArgumentExp();    }
	public FRangeExp       FRangeExp.createEmptyNode()       { return new FRangeExp();       }
	public FLinspace       FLinspace.createEmptyNode()       { return new FLinspace();       }
	public FEndExp         FEndExp.createEmptyNode()         { return new FEndExp();         }
	public FIterExp        FIterExp.createEmptyNode()        { return new FIterExp();        }
	
	// Function calls
	public FFunctionCall      FFunctionCall.createEmptyNode()      { return new FFunctionCall();      }
	public InstFunctionCall   InstFunctionCall.createEmptyNode()   { return new InstFunctionCall();   }
	public FRecordConstructor FRecordConstructor.createEmptyNode() { return new FRecordConstructor(); }
	
	// Calls to built-in mathematical functions
	public FSinExp   FSinExp.createEmptyNode()   { return new FSinExp();   }
	public FCosExp   FCosExp.createEmptyNode()   { return new FCosExp();   }
	public FTanExp   FTanExp.createEmptyNode()   { return new FTanExp();   }
	public FAsinExp  FAsinExp.createEmptyNode()  { return new FAsinExp();  }
	public FAcosExp  FAcosExp.createEmptyNode()  { return new FAcosExp();  }
	public FAtanExp  FAtanExp.createEmptyNode()  { return new FAtanExp();  }
	public FAtan2Exp FAtan2Exp.createEmptyNode() { return new FAtan2Exp(); }
	public FSinhExp  FSinhExp.createEmptyNode()  { return new FSinhExp();  }
	public FCoshExp  FCoshExp.createEmptyNode()  { return new FCoshExp();  }
	public FTanhExp  FTanhExp.createEmptyNode()  { return new FTanhExp();  }
	public FExpExp   FExpExp.createEmptyNode()   { return new FExpExp();   }
	public FLogExp   FLogExp.createEmptyNode()   { return new FLogExp();   }
	public FLog10Exp FLog10Exp.createEmptyNode() { return new FLog10Exp(); }
	
	// Built-in function calls and function call-like operators
	public FNdimsExp       FNdimsExp.createEmptyNode()       { return new FNdimsExp();       }
	public FSizeExp        FSizeExp.createEmptyNode()        { return new FSizeExp();        }
	public FAbsExp         FAbsExp.createEmptyNode()         { return new FAbsExp();         }
	public FSignExp        FSignExp.createEmptyNode()        { return new FSignExp();        }
	public FSqrtExp        FSqrtExp.createEmptyNode()        { return new FSqrtExp();        }
	public FEnumIntegerExp FEnumIntegerExp.createEmptyNode() { return new FEnumIntegerExp(); }
	public FStringExp      FStringExp.createEmptyNode()      { return new FStringExp();      }
	public FDivFuncExp     FDivFuncExp.createEmptyNode()     { return new FDivFuncExp();     }
	public FModFuncExp     FModFuncExp.createEmptyNode()     { return new FModFuncExp();     }
	public FRemFuncExp     FRemFuncExp.createEmptyNode()     { return new FRemFuncExp();     }
	public FCeilFuncExp    FCeilFuncExp.createEmptyNode()    { return new FCeilFuncExp();    }
	public FFloorFuncExp   FFloorFuncExp.createEmptyNode()   { return new FFloorFuncExp();   }
	public FIntegerFuncExp FIntegerFuncExp.createEmptyNode() { return new FIntegerFuncExp(); }
	public FScalarExp      FScalarExp.createEmptyNode()      { return new FScalarExp();      }
	public FVectorExp      FVectorExp.createEmptyNode()      { return new FVectorExp();      }
	public FMatrixExp      FMatrixExp.createEmptyNode()      { return new FMatrixExp();      }
	public FTranspose      FTranspose.createEmptyNode()      { return new FTranspose();      }
	public FCross          FCross.createEmptyNode()          { return new FCross();          }
	public FSkew           FSkew.createEmptyNode()           { return new FSkew();           }
	public FOuterProduct   FOuterProduct.createEmptyNode()   { return new FOuterProduct();   }
	public FIdentity       FIdentity.createEmptyNode()       { return new FIdentity();       }
	public FDiagonal       FDiagonal.createEmptyNode()       { return new FDiagonal();       }
	public FOnes           FOnes.createEmptyNode()           { return new FOnes();           }
	public FZeros          FZeros.createEmptyNode()          { return new FZeros();          }
	public FFillExp        FFillExp.createEmptyNode()        { return new FFillExp();        }
	public FMinExp         FMinExp.createEmptyNode()         { return new FMinExp();         }
	public FMaxExp         FMaxExp.createEmptyNode()         { return new FMaxExp();         }
	public FSumExp         FSumExp.createEmptyNode()         { return new FSumExp();         }
	public FProductExp     FProductExp.createEmptyNode()     { return new FProductExp();     }
	public FSemiLinearExp  FSemiLinearExp.createEmptyNode()  { return new FSemiLinearExp();  }
	public FInStream       FInStream.createEmptyNode()       { return new FInStream();       }
	public FActualStream   FActualStream.createEmptyNode()   { return new FActualStream();   }
	
	// Operators for overconstrained connection graphs
	public FConnBranch        FConnBranch.createEmptyNode()        { return new FConnBranch();        }
	public FConnRoot          FConnRoot.createEmptyNode()          { return new FConnRoot();          }
	public FConnPotentialRoot FConnPotentialRoot.createEmptyNode() { return new FConnPotentialRoot(); }
	public FConnIsRoot        FConnIsRoot.createEmptyNode()        { return new FConnIsRoot();        }
	public FConnRooted        FConnRooted.createEmptyNode()        { return new FConnRooted();        }
	public FConnRootedDep     FConnRootedDep.createEmptyNode()     { return new FConnRootedDep();     }
	
	/**
	 * Create new node of same class as this, with the specified children.
	 */
	public FBinExp FBinExp.createNode(FExp left, FExp right) {
		FBinExp node = createEmptyNode();
		node.setLeft(left);
		node.setRight(right);
		return node;
	}
	
	/**
	 * Create new node of same class as this, with the specified children.
	 */
	public FUnaryExp FUnaryExp.createNode(FExp exp) {
		FUnaryExp node = createEmptyNode();
		node.setFExp(exp);
		return node;
	}
	
	/**
	 * Create new node of same class as this, with the specified children.
	 */
	public FIdUseExp FIdUseExp.createNode(FIdUse use) {
		FIdUseExp node = createEmptyNode();
		node.setFIdUse(use);
		return node;
	}
	
	/**
	 * Create new node of same class as this, with the specified children.
	 */
	public FMathematicalFunctionCall FMathematicalFunctionCall.createNode(FExp exp) {
		FMathematicalFunctionCall node = createEmptyNode();
		node.setFExp(exp);
		return node;
	}
	
	/**
	 * \Create new node of same class as this, with the specified children.
	 */
	public FUnaryBuiltIn FUnaryBuiltIn.createNode(FExp exp) {
		FUnaryBuiltIn node = createEmptyNode();
		node.setFExp(exp);
		return node;
	}
	
	/**
	 * \Create new node of same class as this, with the specified children.
	 */
	public FEventGenExp FEventGenExp.createNode(FExp exp) {
		FEventGenExp node = createEmptyNode();
		node.setX(exp);
		return node;
	}
	
	/**
	 * \Create new node of same class as this, with the specified children.
	 */
	public FEventGenExp FBinEventGenExp.createNode(FExp exp) {
		throw new UnsupportedOperationException();
	}
	
	/**
	 * \Create new node of same class as this, with the specified children.
	 */
	public FBinEventGenExp FBinEventGenExp.createNode(FExp x, FExp y) {
		FBinEventGenExp node = createEmptyNode();
		node.setX(x);
		node.setY(y);
		return node;
	}
	
	/**
	 * \Create new node of same class as this, with the specified children.
	 */
	public FSemiLinearExp FSemiLinearExp.createNode(FExp x, FExp y, FExp z) {
		FSemiLinearExp node = createEmptyNode();
		node.setX(x);
		node.setPosSlope(y);
		node.setNegSlope(z);
		return node;
	}
	
	/**
	 * Create new node of same class as this, with the specified 
	 * children. For missing y, use null.
	 */
	public FMinMaxExp FMinMaxExp.createNode(FExp x, FExp y) {
		FMinMaxExp node = createEmptyNode();
		node.setX(x);
		if (y != null)
			node.setY(y);
		return node;
	}
	
	/**
	 * Create new node of same class as this, with the specified children.
	 */
	public FInfArgsFunctionCall FInfArgsFunctionCall.createNode(List<FExp> exps) {
		FInfArgsFunctionCall node = createEmptyNode();
		node.setFExpList(exps);
		return node;
	}
	
	/**
	 * Create new node of same class as this, with the specified children.
	 */
	public FConnBoolOp FConnBoolOp.createNode(FExp exps) {
		FConnBoolOp node = createEmptyNode();
		node.setA(exps);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FInfArgsFunctionCall FInfArgsFunctionCall.createNode(ArrayList<FExp> exps) {
		FInfArgsFunctionCall node = createEmptyNode();
		for (FExp e : exps)
			node.addFExp(e);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FArray FArray.createNode(List<FExp> exps) {
		FArray node = createEmptyNode();
		node.setFExpList(exps);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FArray FArray.createNode(ArrayList<FExp> exps) {
		FArray node = createEmptyNode();
		for (FExp e : exps)
			node.addFExp(e);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children. Used to allow common algorithms to handle unrelated types.
	 */
	public FExp FExp.createNodeBinary(FExp a, FExp b) {
		throw new UnsupportedOperationException();
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        child. Used to allow common algorithms to handle unrelated types.
	 */
	public FExp FExp.createNodeUnary(FExp a) {
		throw new UnsupportedOperationException();
	}
	
	// Add support to new types as needed.
	public FExp FBinExp.createNodeBinary(FExp a, FExp b)    { return createNode(a, b); }
	public FExp FMinMaxExp.createNodeBinary(FExp a, FExp b) { return createNode(a, b); }
	public FExp FUnaryExp.createNodeUnary(FExp a)           { return createNode(a); }

	
	// The createNode() structure applied to various other nodes that requre common handling
	public abstract FIfWhenClause FIfWhenClause.createEmptyNode();
	public FIfClause   FIfClause.createEmptyNode()   { return new FIfClause(); }
	public FWhenClause FWhenClause.createEmptyNode() { return new FWhenClause(); }
	
	public abstract FIfWhenElseEquation FIfWhenElseEquation.createEmptyNode();
	public FIfEquation   FIfEquation.createEmptyNode()   { return new FIfEquation(); }
	public FWhenEquation FWhenEquation.createEmptyNode() { return new FWhenEquation(); }
	public FElseEquation FElseEquation.createEmptyNode() { return new FElseEquation(); }
	
	public abstract FIfWhenStmt FIfWhenStmt.createEmptyNode();
	public FIfStmt   FIfStmt.createEmptyNode()   { return new FIfStmt(); }
	public FWhenStmt FWhenStmt.createEmptyNode() { return new FWhenStmt(); }
	
	public abstract FVariable FVariable.createEmptyNode();
	public FRealVariable    FRealVariable.createEmptyNode()    					{ return new FRealVariable(); }
	public FIntegerVariable FIntegerVariable.createEmptyNode() 					{ return new FIntegerVariable(); }
	public FBooleanVariable FBooleanVariable.createEmptyNode() 					{ return new FBooleanVariable(); }
	public FStringVariable  FStringVariable.createEmptyNode()  					{ return new FStringVariable(); }
	public FEnumVariable    FEnumVariable.createEmptyNode()    					{ return new FEnumVariable(); }
	public FRecordVariable  FRecordVariable.createEmptyNode()  					{ return new FRecordVariable(); }
	public FExternalObjectVariable FExternalObjectVariable.createEmptyNode()	{ return new FExternalObjectVariable(); }

	public FAttribute         FAttribute.createEmptyNode()         { return new FAttribute(); }
	public FInternalAttribute FInternalAttribute.createEmptyNode() { return new FInternalAttribute(); }

	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FIfWhenClause FIfWhenClause.createNode(FExp test, List<FStatement> stmts) {
		FIfWhenClause node = createEmptyNode();
		node.setTest(test);
		node.setFStatementList(stmts);
		return node;
	}
		
}