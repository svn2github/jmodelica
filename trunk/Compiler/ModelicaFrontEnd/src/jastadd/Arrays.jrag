/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.HashSet;
import java.util.Map;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.NoSuchElementException;

aspect Arrays {

	/**
	 * \brief Get the array subscripts of a ComponentDecl.
	 * 
	 * @return If the ComponentDecl has subscripts, then return these, otherwise
	 * null.
	 */
	syn lazy ArraySubscripts ComponentDecl.arraySubscripts() =
		hasVarArraySubscripts() ? getVarArraySubscripts() : null;

	/**
	 * \brief Check if an expression is inside array subscripts.
	 */
	inh boolean FExp.inArraySubscripts();
	eq FArraySubscripts.getChild().inArraySubscripts() = true;
	eq Root.getChild().inArraySubscripts() = false;
	
	/**
	 * \brief Check if an access is an array access.
	 * 
	 * @return True if the access has array subscripts, otherwise false.
	 */
	syn boolean Access.isArrayAccess() = false;
	eq ArrayAccess.isArrayAccess() = hasArraySubscripts();
	
	/**
	 * \brief Get the array subscripts of an access, if any.
	 * 
	 * @return The array subscripts of the access, if any, otherwise null.
	 */
	syn ArraySubscripts Access.arraySubscripts() = null;
	eq ArrayAccess.arraySubscripts() = hasArraySubscripts()? getArraySubscripts(): null;

	/**
	 * \brief Check if an instance access has array subscripts.
	 * 
	 * @return True if the access has array subscripts, otherwise false.
	 */
	syn boolean InstAccess.isInstArrayAccess() = false;
	eq InstArrayAccess.isInstArrayAccess() = hasFArraySubscripts();
	
	
	/**
	 * \brief Get the FArraySubscripts of an InstAccess, if any.
	 * 
	 * @return A reference to a FArraySubscripts object, or null.
	 */
	syn FArraySubscripts InstAccess.fArraySubscripts() = null;
	eq InstArrayAccess.fArraySubscripts() = hasFArraySubscripts()? getFArraySubscripts(): null;
	
	/**
	 * \brief Return an Index with these array subscripts.
	 * 
	 * This version is cached, to avoid repeating constant evaluation.
	 * 
	 * @throws ConstantEvaluationException  if the subscripts can't be evaluated to 
	 *                                      constant Integer values.
	 */
	syn lazy Index FArraySubscripts.asIndex() = createIndex();
	
	/**
	 * \brief Return an Index with these array subscripts.
	 * 
	 * This version is not cached, to allow indices to be re-evaluated at each use 
	 * during function evaluation.
	 * 
	 * @throws ConstantEvaluationException  if the subscripts can't be evaluated to 
	 *                                      constant Integer values.
	 */
	public Index FArraySubscripts.createIndex() {
		int[] i = new int[getNumFSubscript()];
		int j = 0;
		for (FSubscript s : getFSubscripts()) 
			i[j++] = s.ceval().intValue();
		return new Index(i);
	}

	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FAbstractEquation.ndims() = -1;
	eq FEquation.ndims() {
		if (getLeft().ndims() == getRight().ndims()) {
			return getLeft().ndims();
		}
		return -1;
	}

	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FArraySubscripts.ndims() { 
		return getNumFSubscript();
	}

	// Array dimensions
	/**
	 * \brief Get array dimensions of array subscripts when used in an identifier.
	 * 
	 * Here it is not sufficient to check the number of subscripts; the 
	 * identifier x[1] has the dimension 0, not 1.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FArraySubscripts.accessNdims() { 
		//log.debug("FArraySubscripts.accessNdims()");
		// Need to check if each individual subscript increases 
		// dimension. (ndims(x[1])=0)
		int nd = 0;
		for (FSubscript fs : getFSubscripts()) {
			nd += fs.ndims();
		}
		return nd;
	}
	
	/**
	 * \brief Get array dimensions of a single part of an access.
	 */
	syn int InstAccess.localNdims() = 
		hasFArraySubscripts() ? getFArraySubscripts().accessNdims() : myInstComponentDecl().ndims();

	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FSubscript.ndims();
	eq FExpSubscript.ndims() = getFExp().ndims();
	eq FColonSubscript.ndims() = 1;
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FExp.ndims() = 0;
	eq FInstAccessExp.ndims() = getInstAccess().ndims();
	eq FRangeExp.ndims() = 1;
	eq FLinspace.ndims() = 1;
	eq FArray.ndims() {
		if (isIterArray())
			return getFExp(0).ndims();
		if (getNumFExp()==0)  //Empty array
			return 1;
		// We assume that the FArray is set up correctly and that
		// all brances are equal.
		return getFExp(0).ndims() + 1;
	}
	eq FAbstractCat.ndims() {
		int ndims = 2;
		for (FExp e : getFExps())
			if (e.ndims() > ndims)
				ndims = e.ndims();
		return ndims;
	}
	eq FCatExp.ndims()         = getFExp(0).ndims();
	eq FSumExp.ndims()         = getFExp().isIterExp() ? iterExp().ndims() : 0;
	eq FSubscriptedExp.ndims() = getFArraySubscripts().accessNdims();
	eq FIterExp.ndims() {
		int exp = getFExp().ndims();
		return (exp >= 0) ? exp + getNumForIndex() : -1;
	}
	
	eq FTranspose.ndims() = getFExp().ndims();
	eq FCross.ndims() = 1;
	eq FIdentity.ndims() = 2;
	
	eq FSizeExp.ndims() = hasDim() ? 0 : 1;
	
	eq FInfArgsFunctionCall.ndims() = getNumFExp();
	eq FFillExp.ndims()             = getNumFExp() + getFillExp().ndims();
	eq FFunctionCall.ndims()        = hasOutputs() ? expOutput().ndims() : -1;
	eq InstFunctionCall.ndims()     = hasOutputs() ? expOutput().ndims() : -1;
	
	eq FBinExp.ndims() = getLeft().ndims();
	eq FUnaryExp.ndims() = getFExp().ndims();
	eq FArtmBinExp.ndims() = Math.max(getLeft().ndims(), getRight().ndims());
	
	eq FDivExp.ndims() = getLeft().ndims();
	eq FPowExp.ndims() = getLeft().ndims();
	
	eq FMulExp.ndims() {
		int left = getLeft().ndims();
		int right = getRight().ndims();
		if (isElementWise())
			return Math.max(left, right);
		if (left > 2 || right > 2)
			return -1;
		return left + right - 2;
	}
	
	eq FIfExp.ndims()     = getThenExp().ndims();
	eq FElseIfExp.ndims() = getThenExp().ndims();
	
	// TODO: Expand to cover vectorization of all scalar built-in functions (see #528)
	eq FStreamBuiltIn.ndims() = getFExp().ndims();
	
	/**
	 * \brief Check if multiplication is equivalent with an element-wise multiplication.
	 * 
	 * True if any operand is scalar.
	 */
	syn boolean FMulExp.isElementWise() = (getLeft().ndims() * getRight().ndims() == 0);
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FIdUse.ndims() {
		// Notice here the use of accessNdims. Also, if the access has
		// no subscripts, it may still have dimension > 0 if its declaration
		// is an array declaration. 
		// If the FQName is marked as scalarized, then dimension must 
		// be 0 and using myFV() might cause a NullPointerException.
		// This is because if scalarization is in progress, 
		// then this node will be hanging without a proper AST.
		int n = 0;
		if (!getFQName().isScalarized())
			for (FArraySubscripts fas : allFArraySubscripts())
				n += fas.accessNdims();
		return n;
	}
	eq FIdUseInstAccess.ndims() = getInstAccess().ndims();
	eq FIdUseExp.ndims() = getFIdUse().ndims();
		
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstAccess.ndims() {
		int n = 0;
		for (FArraySubscripts fas : allFArraySubscripts())
			n += fas.accessNdims();
		return n;
	}
	
	/**
	 * \brief Get the expanded FArraySubscripts of each part of this access.
	 */
	syn lazy ArrayList<FArraySubscripts> InstAccess.allFArraySubscripts() {
		ArrayList<FArraySubscripts> res = new ArrayList<FArraySubscripts>(1);
		res.add(getExpandedSubscripts());
		return res;
	}
	eq InstDot.allFArraySubscripts() {
		ArrayList<FArraySubscripts> left = getLeft().allFArraySubscripts();
		ArrayList<FArraySubscripts> right = getRight().allFArraySubscripts();
		ArrayList<FArraySubscripts> res = new ArrayList<FArraySubscripts>(left.size() + right.size());
		res.addAll(left);
		res.addAll(right);
		return res;
	}
	
	/**
	 * \brief Get the expanded FArraySubscripts of each part of this access.
	 */
	syn lazy ArrayList<FArraySubscripts> FIdUse.allFArraySubscripts() {
		ArrayList<FArraySubscripts> res = new ArrayList<FArraySubscripts>(getFQName().getNumFQNamePart());
		for (FQNamePart part : getFQName().getFQNameParts())
			res.add(part.hasFArraySubscripts() ? part.getFArraySubscripts() : new FArraySubscripts());
		if (!hasFArraySubscripts() && myFV().isArray()) 
			res.set(res.size() - 1, getExpandedSubscripts());
		return res;
	}
	
	/**
	 * \brief Get the expanded array subscripts of this access.
	 * 
	 * An access without subscripts returns subscripts that span the entire component.
	 * Any colon subscripts are expanded into constant vector expressions.
	 */
	syn FArraySubscripts InstAccess.getExpandedSubscripts() = new FArraySubscripts();
	eq InstArrayAccess.getExpandedSubscripts() {
		return hasFArraySubscripts() ? 
				getFArraySubscripts().expandedSubscripts() :
				myInstComponentDecl().expandedSubscripts();
	}
	
	/**
	 * \brief Get the expanded array subscripts of this access.
	 * 
	 * @return  an FArraySubscripts that spans the entire FV this access points to.
	 */
	syn FArraySubscripts FIdUse.getExpandedSubscripts() {
		FArraySubscripts res = new FArraySubscripts();
		Size s = myFV().size();
		if (s.isUnknown() && myFV().inRecord()) {
			// Find enclosing record
			// TODO: extract method? problem: need i after
			// TODO: this is O(n^2) for n+1 parts in name of record (lookupFV() is O(n) if name isn't found)
			FQName name = getFQName();
			int i;
			int n = name.getNumFQNamePart();
			FVariable record = null;
			for (i = 1; record == null && i < n; i++) {
				AbstractFVariable tmp = lookupFV(name.copyPrefix(i));
				if (!tmp.isUnknown())
					record = (FVariable) tmp;
			}
			
			// Find size attribute for this member
			if (record != null) {
				FAttribute attr = record.findAttribute(name.getFQNamePart(i-1).getName());
				for (; attr != null && i < n; i++)
					attr = attr.findAttribute(name.getFQNamePart(i).getName());
				if (attr != null)
					attr = attr.findAttribute(FAttribute.SIZE);
				if (attr != null && attr.hasValue())
					s = new MutableSize(attr.getValue());
			}
		}
		for (int i = 0; i < s.ndims(); i++)
			res.addFSubscript(s.createExpandedFSubscript(i));
		return res;
	}
	
	/**
	 * \brief Create a copy of this FArraySubscripts with all colon indices expanded.
	 */
	public FArraySubscripts FArraySubscripts.expandedSubscripts() {
		FArraySubscripts res = new FArraySubscripts();
		for (FSubscript s : getFSubscripts())
			res.addFSubscript(s.expandedSubscript());
		return res;
	}
	
	/**
	 * \brief Create a copy of this FSubscript, expanding it to a vector if it is a colon.
	 */
	public FSubscript FSubscript.expandedSubscript() {
		return (FSubscript) fullCopy();
	}
	public FSubscript FColonSubscript.expandedSubscript() {
		return size().createExpandedFSubscript(0);
	}
	
	/**
	 * \brief Create an FArraySubscripts that spans all array cells of this component.
	 * 
	 * If this is a scalar component, an empty FArraySubscripts is returned.
	 */
	public FArraySubscripts InstComponentDecl.expandedSubscripts() {
		FArraySubscripts res = new FArraySubscripts();
		for (int i = 0; i < ndims(); i++)
			res.addFSubscript(size().createExpandedFSubscript(i));
		return res;
	}
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstAssignable.ndims() = hasFArraySubscripts() ? getFArraySubscripts().ndims() : 0;
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstNode.ndims() = 0;
	
	eq InstComponentDecl.ndims() = hasFArraySubscripts()? 
			getFArraySubscripts().ndims(): 0;

	syn int AbstractFVariable.ndims() = -1;
	
	eq FVariable.ndims()         = isScalarized()? 0 : getFQName().ndims();
	eq FFunctionArray.ndims()    = getType().ndims();
	eq FFunctionVariable.ndims() = 0;
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FQName.ndims() {
		// Only look at the array subscripts for the last FQNamePart,
		// all other array subscripts has been expanded in the instantiation.
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().ndims(); 
		} else {
			return 0;
		}
	}

	/**
	 * \brief Get array dimensions of an identifier when used in an identifier.
	 * 
	 * Here it is not sufficient to check the number of subscripts; the 
	 * identifier x[1] has the dimension 0, not 1.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */		
	syn int FQName.accessNdims() {
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().accessNdims(); 
		} else {
			return 0;
		}
	}

	
	// Array sizes
	
	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size FAbstractEquation.size() = Size.SCALAR;
	eq FEquation.size() {
		Size left = getLeft().size();
		Size right = getRight().size();
		return left.equals(right) ? left : Size.SCALAR;
	}

	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size FArraySubscripts.declarationSize() {
		if (ndims() == 0)
			return Size.SCALAR;
		MutableSize s = new MutableSize(ndims());
		for (FSubscript fs : getFSubscripts())
			fs.addDeclarationSize(s);
		return s;
	}
	
	/**
	 * \brief Add the size of the dimension denoted by this subscript when used 
	 *        in a declaration to the given Size.
	 */
	public abstract void FSubscript.addDeclarationSize(MutableSize s);
	
	public void FExpSubscript.addDeclarationSize(MutableSize s) {
		s.append(getFExp());
	}
	
	public void FColonSubscript.addDeclarationSize(MutableSize s) {
		s.append(new FUnknownSizeExp(surroundingVariableDecl(), myDim()));
	}
	
	/**
	 * \brief The variable declaration that this subscript is a part of the size of, if any.
	 */
	inh CommonVariableDecl FColonSubscript.surroundingVariableDecl();
	eq FVariable.getFQName().surroundingVariableDecl()                   = this;
	eq InstComponentDecl.getFArraySubscripts().surroundingVariableDecl() = this;
	eq FExp.getChild().surroundingVariableDecl()                         = null;
	eq Root.getChild().surroundingVariableDecl()                         = null;
	
	/**
	 * \brief The dimension this subscript is used for.
	 */
	inh int FSubscript.myDim();
	eq FArraySubscripts.getFSubscript(int i).myDim() = i;

	/**
	 * \brief Get the array sizes when the array subscripts are used in an
	 * access. See also documentation of accessNdims(). 
	 */
	syn lazy Size FArraySubscripts.accessSize() {
		if (accessNdims() == 0)
			return Size.SCALAR;
		MutableSize s = new MutableSize(accessNdims());
		for (FSubscript fs : getFSubscripts()) 
			if (fs.ndims() == 1)
				s.append(fs.size());
		return s;
	}

	
	/**
	 * \brief Get the array sizes. 
	 */
	syn Size FSubscript.size();

	eq FExpSubscript.size() = getFExp().size();
	
	eq FColonSubscript.size() = mySize();
	
	/**
	 * \brief Get the size this subscript(s) would have if all subscripts were colons.
	 */
	inh Size FEndExp.mySize();
	inh Size FSubscript.mySize();
	inh Size FArraySubscripts.mySize();
	eq FIdUse.getChild().mySize()                     = myFV().size();
	eq FIdUseInstAccess.getChild().mySize()           = getInstAccess().size();
	eq InstArrayAccess.getFArraySubscripts().mySize() = myInstComponentDecl().size();
	eq InstAccess.getExpandedSubscripts().mySize()    = myInstComponentDecl().size();
	eq FSubscriptedExp.getFArraySubscripts().mySize() = getFExp().size();
	eq FExpSubscript.getFExp().mySize()               = mySize();
	eq FlatRoot.getChild().mySize()                   = Size.SCALAR;
	eq InstRoot.getChild().mySize()                   = Size.SCALAR;
	
	eq FArraySubscripts.getFSubscript(int i).mySize() {
		MutableSize s = new MutableSize(1);
		if (mySize().has(i))
			s.set(0, mySize(), i);
		else 
			s.set(0, Size.UNKNOWN);
		return s;
	}
	
	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size FExp.size() = Size.SCALAR;
	eq FInstAccessExp.size() = getInstAccess().size();
	
	eq FBinExp.size() = getLeft().size();
	eq FUnaryExp.size() = getFExp().size();
	eq FArtmBinExp.size() = getLeft().isArray() ? getLeft().size() : getRight().size();

	eq FDivExp.size() = getLeft().size();
	eq FPowExp.size() = getLeft().size();
	
	eq FMulExp.size() {
		if (!getLeft().isArray())
			return getRight().size();
		if (!getRight().isArray())
			return getLeft().size();
		if (!isArray())
			return Size.SCALAR;
		MutableSize s = new MutableSize(ndims());
		if (getLeft().ndims() == 2)
			s.append(getLeft().size(), 0);
		if (getRight().ndims() == 2)
			s.append(getRight().size(), 1);
		return s;
	}
	
 	eq FRangeExp.size() {
 		MutableSize s = new MutableSize(1);
		boolean hasStep = getNumFExp() > 2;
 		FExp start = getFExp(0);
 		FExp stop = getFExp(hasStep ? 2 : 1);
 		if (!hasStep && start.isIntegerLiteral(1) && stop.type().isInteger()) {
 			s.append(stop);
 		} else {
 			start = start.makeRangeSizeExp();
 			stop = stop.makeRangeSizeExp();
 	 		FExp step = hasStep ? (FExp) getFExp(1).fullCopy() : null;
 			FExp exp = new FSubExp(stop, start);
 			if (hasStep)
 				exp = new FDivExp(exp, step);
 			exp = new FAddExp(new FIntegerExp(exp), new FIntegerLitExp(1));
 			exp = new FMaxExp(exp, new Opt(new FIntegerLitExp(0)));
 			s.append(dynamicFExp(exp));
		}
		return s;
	}
 	
 	/**
 	 * \brief Create a new expression suitable for use in an expression calculating the 
 	 *        array size of a range expression.
 	 */
 	public FExp FExp.makeRangeSizeExp() {
 		return type().wrapRangeSizeExp((FExp) fullCopy());
 	}
 	
 	/**
 	 * \brief Wrap the given expression so it is suitable for use in an expression 
 	 *        calculating the array size of a range expression.
 	 */
 	public FExp FType.wrapRangeSizeExp(FExp exp) {
 		return exp;
 	}
 	
 	public FExp FEnumType.wrapRangeSizeExp(FExp exp) {
 		return new FEnumIntegerExp(exp);
 	}
 	
 	public FExp FBooleanType.wrapRangeSizeExp(FExp exp) {
 		return new FIfExp(exp, new FIntegerLitExp(2), new List(), new FIntegerLitExp(1));
 	}
 	
 	syn boolean FExp.isIntegerLiteral(int v)  = false;
 	eq FIntegerLitExp.isIntegerLiteral(int v) = Integer.parseInt(getUNSIGNED_INTEGER()) == v;
 	
 	eq FLinspace.size() {
		MutableSize s = new MutableSize(ndims());
 		s.append(getN());
		return s;
 	}
	
	eq FArray.size() {
		if (isIterArray())
			return getFExp(0).size();
		return getFExp(0).size().expand(getNumFExp());
	}
	
	syn int FAbstractCat.dimension();
	eq FCatExp.dimension()    = getDim().ceval().intValue() - 1;
	eq FMatrix.dimension()    = 0;
	eq FMatrixRow.dimension() = 1;
	
	syn int FSizeExp.dimension() = getDim().ceval().intValue() - 1;
	
	eq FAbstractCat.size() {
		try {
			int dim = dimension();
			MutableSize ms = getFExp(0).size().promote(ndims()).mutableClone();
			for (int i = 1; i < getNumFExp(); i++)
				ms.add(dim, getFExp(i).size().promote(ndims()), dim);
			return ms;
		} catch (ConstantEvaluationException e) {
			return Size.SCALAR;
		}
	}
	
	eq FSumExp.size() = getFExp().isIterExp() ? iterExp().size() : Size.SCALAR;
	
	eq FIterExp.size() {
		if (ndims() <= 0)
			return Size.SCALAR;
		MutableSize s = new MutableSize(ndims());
		for (CommonForIndex fi : getForIndexList())
			if (fi.hasFExp() && fi.getFExp().ndims() == 1)
				s.append(fi.getFExp().size());
		s.append(getFExp().size());
		return s;
	}
	
	eq FSubscriptedExp.size() = getFArraySubscripts().accessSize();
	
	eq FTranspose.size() {
		Size size = getFExp().size();
		if (size.ndims() < 2)
			return size;
		MutableSize s = new MutableSize(size.ndims());
		s.append(size, 1);
		s.append(size, 0);
		for (int i = 2; i < s.ndims(); i++)
			s.append(size, i);
		return s;
	}
	
	eq FCross.size() = new Size(3);
	
	eq FIdentity.size() {
		MutableSize s = new MutableSize(2);
		s.append(getFExp());
		s.append(getFExp());
		return s;
	}
	
	eq FSizeExp.size() = hasDim() ? Size.SCALAR : new Size(getFExp().ndims());
	
	// TODO: Expand to cover vectorization of all scalar built-in functions (see #528)
	eq FStreamBuiltIn.size() = getFExp().size();
	
	eq FInfArgsFunctionCall.size() {
		if (!isArray())
			return Size.SCALAR;
		MutableSize s = new MutableSize(ndims());
		for (FExp fe : getFExps()) 
			s.append(fe);
		appendSpecificLengths(s);
		return s;
	}
	
	protected void FInfArgsFunctionCall.appendSpecificLengths(MutableSize s) {}
	protected void FFillExp.appendSpecificLengths(MutableSize s) {
		s.append(getFillExp().size());
	}
	
	inh Size FFunctionCallLeft.size();
	eq FFunctionCallEquation.getLeft(int i).size() = getCall().sizeOfOutput(i);
	eq FFunctionCallStmt.getLeft(int i).size()     = getCall().sizeOfOutput(i);
	
	syn Size FAbstractFunctionCall.sizeOfOutput(int i) = (i == 0) ? size() : Size.SCALAR;
	
	syn Size InstFunctionCall.sizeOfOutput(int i) {
		Size s = myOutputs().get(i).size();
		if (!s.isUnknown())
			return s;
		
		HashMap<ASTNode, FExp> varMap = new HashMap<ASTNode, FExp>();
		for (int j = 0; j < getNumArg(); j++)
			varMap.put(myInputs().get(j), getArg(j).getFExp());
		
		try {
			MutableSize ms = new MutableSize(s.ndims());
			for (int j = 0; j < s.ndims(); j++) 
				ms.append(dynamicFExp(s.createSizeFExp(j, (HashMap) varMap.clone())));
			return ms;
		} catch (ConstantEvaluationException e) {
			return s;
		}
	}
	
	syn Size FFunctionCall.sizeOfOutput(int i) = getSizes()[i];
	
	eq FFunctionCall.size()    = hasOutputs() ? sizeOfOutput(0) : Size.SCALAR;
	eq InstFunctionCall.size() = hasOutputs() ? sizeOfOutput(0) : Size.SCALAR;
	
	eq FIfExp.size()     = getThenExp().size();
	eq FElseIfExp.size() = getThenExp().size();
	
	/**
	 * \brief Get the array sizes.
	 */
	syn lazy Size FIdUse.size() {
		if (ndims() == 0)
			return Size.SCALAR;
		
		MutableSize s = new MutableSize(ndims());
		for (FArraySubscripts fas : allFArraySubscripts())
			for (FSubscript fs : fas.getFSubscripts()) 
				if (fs.ndims() == 1)
					s.append(fs.size());
		return s;
	}
	eq FIdUseInstAccess.size() = getInstAccess().size();
		
	eq FIdUseExp.size() = getFIdUse().size();
	
	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size InstAccess.size() = Size.SCALAR;
	eq InstArrayAccess.size() = hasFArraySubscripts()? 
			getFArraySubscripts().accessSize(): 
				myInstComponentDecl().size();
			
	/**
	 * \brief Get the array sizes. 
	 */
	eq InstAssignable.size() {
		Size s = declaredSize();
		if (hasBindingFExp() && s.isUnknown() && (!isInput() || !inFunction()))
			s = s.createKnown(getBindingFExp());
		return s;
	}
	
	/**
	 * \brief Get the array sizes as declared. May be unknown. 
	 */
	syn Size InstComponentDecl.declaredSize() = 
		hasFArraySubscripts() ? getFArraySubscripts().declarationSize() : Size.SCALAR;
	
	/**
	 * \brief Get the array sizes. 
	 */
	eq InstDot.size() = getRight().size().expand(getLeft().size());
	
	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size InstComponentDecl.size() = declaredSize();

	/**
	 * \brief Get the array sizes. 
	 */	
	syn lazy Size AbstractFVariable.size() = Size.SCALAR;
	eq FVariable.size()      = isScalarized()? Size.SCALAR: getFQName().size();
	eq FFunctionArray.size() = getType().size();
		
	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size FQName.size() {
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().declarationSize(); 
		} else {
			return Size.SCALAR;
		}
	}
	
	/**
	 * \brief Create a copy of this FExp with variable uses replaced with expressions 
	 *        to allow calculations of unknown sizes.
	 *        
	 * For non-FExp nodes, this simply makes a full copy.
	 *        
	 * @param varMap  a map of variables to replace and expressions to replace them with.
	 *                Also contains uses that have been replaced, to detect circularities.
	 */
	public FExp FExp.createSizeFExp(Map<ASTNode, FExp> varMap) {
		FExp exp = (FExp) copy();
		for (int i = 0; i < getNumChild(); i++) 
			exp.setChild(getChild(i).createSizeFExp(varMap), i);
		return exp;
	}
	
	public FExp FIdUseExp.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return getFIdUse().createSizeFExp(varMap);
	}
	
	public FExp FInstAccessExp.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return getInstAccess().createSizeFExp(varMap);
	}
	
	public FExp FIdUseInstAccess.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return getInstAccess().createSizeFExp(varMap);
	}
	
	public FExp InstAccess.createSizeFExp(Map<ASTNode, FExp> varMap) {
		if (varMap.containsKey(this))
			throw new ConstantEvaluationException();
		varMap.put(this, null);
		InstComponentDecl var = myInstComponentDecl();
		FExp exp = varMap.get(var);
		return (exp != null) ? exp : var.size().createDummyFExp(varMap);
	}
	
	public FExp FIdUse.createSizeFExp(Map<ASTNode, FExp> varMap) {
		if (varMap.containsKey(this))
			throw new ConstantEvaluationException();
		varMap.put(this, null);
		AbstractFVariable var = myFV();
		FExp exp = varMap.get(var);
		return (exp != null) ? exp : var.size().createDummyFExp(varMap);
	}
	
	public FExp FFunctionCall.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return size().createDummyFExp(varMap);
	}
	
	public FExp InstFunctionCall.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return size().createDummyFExp(varMap);
	}
	
	/**
	 * \brief Create a copy of this FExp with variable uses replaced with expressions 
	 *        to allow calculations of unknown sizes.
	 *        
	 * For non-FExp nodes, this simply makes a full copy.
	 *        
	 * @param varMap  a map of variables to replace and expressions to replace them with.
	 *                Also contains uses that have been replaced, to detect circularities.
	 */
	public ASTNode ASTNode.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return fullCopy();
	}
	
	public List List.createSizeFExp(Map<ASTNode, FExp> varMap) {
		List node = new List();
		for (ASTNode ch : this)
			node.add(ch.createSizeFExp(varMap));
		return node;
	}
	
	public Opt Opt.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return getNumChild() == 0 ? new Opt() : new Opt(getChild(0).createSizeFExp(varMap));
	}
		
	/**
	 * \brief check if an expression is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean FExp.isArray() = ndims()>0;
	
	/**
	 * \brief check if an access is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean InstAccess.isArray() = ndims()>0;

	/**
	 * \brief check if a variable is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean AbstractFVariable.isArray() = ndims()>0;
	
	/**
	 * \brief check if an instance node is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean InstNode.isArray() = ndims()>0;
	
	public abstract int[]  CommonForIndex.myIndices();
	public abstract String CommonForIndex.name();
	
	/**
	 * \brief Expand for all values of for indices given in <code>indices</code>.
	 * 
	 * This is used to get the set of values for array indices while error checking 
	 * and to expand summation reduction expressions.
	 * 
	 * Size of new Array will be (n + m), where n = indices.size() and m = ndims().  
	 */
	public Array Array.createExpanded(Iterable<? extends CommonForIndex> forIndices) {
		if (!forIndices.iterator().hasNext())
			return (Array) fullCopy();
		Indices newIndices = Indices.create(forIndices);
		Array arr = new Array(Indices.create(expandedSize(newIndices.size())));
		Map<String,FExp> indexMap = new HashMap<String,FExp>();
		for (Index i : newIndices) {
			int j = 0;
			int[] ii = newIndices.translate(i).index();
			for (CommonForIndex fi : forIndices) {
				indexMap.put(fi.name(), new FIntegerLitExp(ii[j]));
				j++;
			}
			fillSubset(arr, i, indexMap);
		}
		return arr;
	}
	
	protected Size Array.expandedSize(Size size) {
		return size().expand(size);
	}
	
	protected void Array.fillSubset(Array arr, Index i, Map<String,FExp> indexMap) {
		for (Index i2 : indices()) {
			FExp e = (FExp) get(i2).fullCopy();
			arr.set(i.expand(i2), (FExp) replaceIndices(e, indexMap));
		}
	}
	protected void ScalarAsArray.fillSubset(Array arr, Index i, Map<String,FExp> indexMap) {
		FExp e = (FExp) get(Index.NULL).fullCopy();
		arr.set(i, (FExp) replaceIndices(e, indexMap));
	}
	
	/**
	 * \brief Replaces all uses of indices in <code>indexMap</code> with the respective expressions.
	 * 
	 * May alter the tree below <code>org</code>.
	 */
	protected static ASTNode Array.replaceIndices(ASTNode org, Map<String,FExp> indexMap) {
		ASTNode res = org.replaceFromIndexMap(indexMap);
		if (org == res) {
			int n = org.getNumChild();
			for (int i = 0; i < n; i++) {
				ASTNode sub = org.getChild(i);
				ASTNode repl = replaceIndices(sub, indexMap);
				if (repl != sub)
					org.setChild(repl, i);
			}
		}
		return res;
	}
	
	/**
	 * \brief If this node is a use of an index in <code>indexMap</code>, return the 
	 *        respective expression, otherwise return <code>this</code>.
	 */
	public ASTNode ASTNode.replaceFromIndexMap(Map<String,FExp> indexMap) {
		return this;
	}
	public ASTNode FInstAccessExp.replaceFromIndexMap(Map<String,FExp> indexMap) {
		FExp res = indexMap.get(name());
		return (res == null) ? this : res;
	}
	public ASTNode FIdUseExp.replaceFromIndexMap(Map<String,FExp> indexMap) {
		FExp res = indexMap.get(name());
		return (res == null) ? this : res;
	}
	
	/**
	 * \brief Expand index for all values of each for index used in expression.
	 */
	syn lazy Array FExpSubscript.getExpanded() = getFExp().getArray().createExpanded(collectForIndices());
	
	/**
	 * \brief Collect all ForIndexs used in the expression of this FExpSubscript.
	 */
	coll HashSet<CommonForIndex> FExpSubscript.collectForIndices() 
		[new HashSet<CommonForIndex>()] with add root FExpSubscript;
	FIdUse contributes myForIndex() when isForIndex()
		to FExpSubscript.collectForIndices() for each allSurroundingFExpSubscripts();
	FInstAccessExp contributes myForIndex() when isForIndex()
		to FExpSubscript.collectForIndices() for each allSurroundingFExpSubscripts();
	
	/**
	 * \brief Return the FForIndex or InstForIndex that this variable belongs to, if any.
	 */
	syn CommonForIndex FIdUse.myForIndex()            = myFV().myForIndex();
	syn CommonForIndex FIdUseInstAccess.myForIndex()  = getInstAccess().myInstComponentDecl().myForIndex();
	syn CommonForIndex FInstAccessExp.myForIndex()    = getInstAccess().myInstComponentDecl().myForIndex();
	inh CommonForIndex AbstractFVariable.myForIndex();
	inh CommonForIndex InstComponentDecl.myForIndex();
	eq FForIndex.getFVariable().myForIndex()        = this;
	eq InstForIndex.getInstPrimitive().myForIndex() = this;
	eq FClass.getChild().myForIndex()               = null;
	eq FFunctionDecl.getChild().myForIndex()        = null;
	eq InstNode.getChild().myForIndex()             = null;
	
	/**
	 * \brief Find the closest ancestor that is an FExpSubscript, if any.
	 */
	inh FExpSubscript FIdUse.surroundingFExpSubscript();
	inh FExpSubscript FInstAccessExp.surroundingFExpSubscript();
	inh FExpSubscript FExpSubscript.surroundingFExpSubscript();
	eq FExpSubscript.getChild().surroundingFExpSubscript() = this;
	eq Root.getChild().surroundingFExpSubscript()          = null;
	
	/**
	 * \brief Find the all ancestors that are FExpSubscripts, if any.
	 */
	syn ArrayList<FExpSubscript> FIdUse.allSurroundingFExpSubscripts() {
		ArrayList<FExpSubscript> list = new ArrayList<FExpSubscript>();
		FExpSubscript cur = surroundingFExpSubscript();
		while (cur != null) {
			list.add(cur);
			cur = cur.surroundingFExpSubscript();
		}
		return list;
	}
	
	/**
	 * \brief Find the all ancestors that are FExpSubscripts, if any.
	 */
	syn ArrayList<FExpSubscript> FInstAccessExp.allSurroundingFExpSubscripts() {
		ArrayList<FExpSubscript> list = new ArrayList<FExpSubscript>();
		FExpSubscript cur = surroundingFExpSubscript();
		while (cur != null) {
			list.add(cur);
			cur = cur.surroundingFExpSubscript();
		}
		return list;
	}

	/**
	 * \brief Computes an Array where all elements are scalar expressions.
	 * 
	 * This is used mainly to scalarize array expressions.
	 * 
	 * @return An Array with scalar expressions if this is an array expression, 
	 *          a ScalarAsArray containing <code>this</code> otherwise.
	 */
	syn lazy Array FExp.getArray() = new ScalarAsArray(this);
	
	/**
	 * \brief Allows for more efficient execution of {@link getArray()} in some cases.
	 * 
	 * When the Array of a parent node is the same as a childs, replace 
	 * getArray() with {@link createArray()} for the types the child can have, 
	 * let getArray() for those types delegate to copyArray() and use copyArray() 
	 * on the child in getArray() for the parent.
	 * 
	 * This ensures that the Array is created only once and that only as many copies 
	 * as neccesary are made.
	 */
	syn Array FExp.copyArray() = (Array) createArray().unboundCopy();
	
	/**
	 * \brief Allows for more efficient execution of {@link getArray()} in some cases.
	 * 
	 * See {@link copyArray()} for instructions. 
	 * When overriding createArray(), always declare it as lazy.
	 */
	syn Array FExp.createArray() = getArray();
	
	eq FBinExp.getArray() {
		if (isArray()) {
			/* Standard implementation covers many binary operators.
			 * Apply operator element-wise, if one operand is scalar, use it with 
			 * all elements in other operand. Used for operators that does not 
			 * allow a scalar and an array as well, since that is caught by the 
			 * error check.
			 */
			Array left  = getLeft().getArray();
			Array right = getRight().getArray();
			Array res   = new Array(indices());
			for (Index i : res.indices())
				res.set(i, createNode((FExp) left.get(i).fullCopy(), (FExp) right.get(i).fullCopy()));
			return res;
		} else {
			return new ScalarAsArray(this);
		}
	}
	
	eq FUnaryExp.getArray() {
		if (isArray()) {
			Array src = getFExp().getArray();
			Array res = new Array(indices());
			for (Index i : res.indices())
				res.set(i, createNode((FExp) src.get(i).fullCopy()));
			return res;
		} else {
			return new ScalarAsArray(this);
		}
	}
	
	eq FMulExp.getArray() {
		if (isElementWise())
			return super.getArray();
		
		if (!isArray())
			return new ScalarAsArray(composeMulScalarCellExp(Index.NULL));
		
		Array res = new Array(indices());
		for (Index i : res.indices()) 
			res.set(i, composeMulScalarCellExp(i));
		return res;
	}
	
	protected FExp FMulExp.composeMulScalarCellExp(Index i) {
		return vectorMultiplication(getLeft().getArray().leftMulIterator(i), 
		                            getRight().getArray().rightMulIterator(i), type());
	}
	
	protected static FExp FExp.vectorMultiplication(Iterator<FExp> left, Iterator<FExp> right, FType type) {
		if (!left.hasNext())
			return type.zeroLiteral();
		FExp cur = new FMulExp((FExp) left.next().fullCopy(), (FExp) right.next().fullCopy());
		while (left.hasNext()) 
			cur = new FAddExp(cur, new FMulExp((FExp) left.next().fullCopy(), (FExp) right.next().fullCopy()));
		return cur;
	}
	
	eq FPowExp.getArray() {
		if (!isArray())
			return new ScalarAsArray(this);
		
		int e = getRight().ceval().intValue();
		if (e <= 0)
			return new FIdentity(new FIntegerLitExp(size().get(0))).getArray();
		
		Array base = getLeft().getArray();
		Array res = base;
		FType type = type();
		for (; e > 1; e--) {
			Array cur = new Array(indices());
			for (Index i : cur.indices()) {
				Iterator<FExp> left = res.leftMulIterator(i);
				Iterator<FExp> right = base.rightMulIterator(i);
				cur.set(i, vectorMultiplication(left, right, type));
			}
			res = cur;
		}
		return res;
	}
	
	eq FTranspose.getArray() {
		Array inner = getFExp().getArray();
		Array res = new Array(indices());
		int[] ind = new int[ndims()];
		Index ti = new Index(ind);
		for (Index i : res.indices()) {
			ind[0] = i.get(1);
			ind[1] = i.get(0);
			for (int j = 2; j < ind.length; j++)
				ind[j] = i.get(j);
			res.set(i, inner.get(ti));
		}
		return res;
	}
	
	eq FCross.getArray() {
		Array res = new Array(indices());
		Array x = getX().getArray();
		Array y = getY().getArray();
		Index j = new Index(new int[1]);
		Index k = new Index(new int[1]);
		for (Index i : res.indices()) {
			j.set(0, i.first() % 3 + 1);
			k.set(0, j.first() % 3 + 1);
			FExp m1 = new FMulExp((FExp) x.get(j).fullCopy(), (FExp) y.get(k).fullCopy());
			FExp m2 = new FMulExp((FExp) x.get(k).fullCopy(), (FExp) y.get(j).fullCopy());
			res.set(i, new FSubExp(m1, m2));
		}
		return res;
	}
	
	eq FIdentity.getArray() {
		Array arr = new Array(indices());
		for (Index i : arr.indices())
			arr.set(i, new FIntegerLitExp((i.get(0) == i.get(1)) ? 1 : 0));
		return arr;
	}
	
	eq FSizeExp.getArray() {
		if (hasDim()) 
			return super.getArray();
		
		Array arr = new Array(indices());
		Size size = getFExp().size();
		for (Index i : arr.indices())
			arr.set(i, size.createFExp(i.first() - 1));
		return arr;
	}
	
	eq FArray.getArray() {
		if (isIterArray())
			return getFExp(0).copyArray();
		Array arr = new Array(indices());
		for (Index i : arr.indices())
			fillArray(arr, i, 0);
		return arr;
	}
	
	eq FAbstractCat.getArray() {
		Array arr = new Array(indices());
		int dim = dimension();
		int adj = 0;
		for (FExp exp : getFExps()) {
			Array expArr = exp.getArray();
			for (Index i : expArr.indices()) 
				arr.set(i.adjusted(dim, adj, ndims()), expArr.get(i));
			adj += (exp.ndims() > dim) ? exp.size().get(dim) : 1;
		}
		return arr;
	}
	
	eq FSumExp.getArray() {
		if (!isArray())
			return super.getArray();
		
		FIterExp exp = (FIterExp) getFExp();
		Array arr = new Array(indices());
		for (Index i : arr.indices())
			arr.set(i, new FSumExp(exp.extract(i)));
		return arr;
	}
	
	public FExp FIterExp.extract(Index i) {
		FExp exp = (FExp) getFExp().getArray().get(i).fullCopy();
		List fil = (List) getForIndexList().fullCopy();
		return new FIterExp(exp, fil);
	}
	
	syn lazy Array FIterExp.createArray() = getFExp().getArray().createExpanded(getForIndexList());
	eq FIterExp.getArray() = copyArray();
	
	eq FSubscriptedExp.getArray() {
		Array arr = new Array(indices());
		Array old = getFExp().getArray();
		Indices ind = arr.indices();
		for (Index i : ind)
			arr.set(i, old.get(ind.translate(i)));
		return arr;
	}
	
	// TODO: Expand to cover vectorization of all scalar built-in functions (see #528)
	eq FStreamBuiltIn.getArray() {
		if (!isArray())
			return super.getArray();
		
		Array arr = new Array(indices());
		Array inner = getFExp().getArray();
		for (Index i : arr.indices())
			arr.set(i, createNode(inner.get(i)));
		return arr;
	}
	
	/**
	 * \brief Add a copy of this expression to arr at position i. 
	 */
	public void FExp.fillArray(Array arr, Index i, int level) {
		if (isArray())
			arr.set(i, (FExp) getArray().get(i.subIndex(level)).fullCopy());
		else
			arr.set(i, (FExp) fullCopy());
	}
	
	/**
	 * \brief Add a copy of the expression at position i to arr. 
	 * 
	 * @param arr    the Array to add the expression to.
	 * @param i      the index to add at, denotes position in both Array and FArray.
	 * @param level  the level this FArray is at in a structure of nestled FArrays.
	 */
	public void FArray.fillArray(Array arr, Index i, int level) {
		getFExp(i.get(level) - 1).fillArray(arr, i, level + 1);
	}
	
	eq FFunctionCall.getArray() {
		FClass fc = myFClass();
		if (!isArray() || fc == null)
			return super.getArray();
		
		Array arr = new Array(indices());
		for (Index i : arr.indices()) {
			FQName n = new FQName(tempVarName());
			n.setLastFArraySubscripts(i.createFArraySubscripts());
			arr.set(i, new FIdUseExp(n));
		}
		return arr;
	}
	
	eq FIfExp.getArray() {
		if (!isArray())
			return super.getArray();
		
		Array thenArr = getThenExp().getArray();
		Array elseArr = getElseExp().getArray();
		Array arr = new Array(indices());
		for (Index i : arr.indices()) {
			FExp ifExp = (FExp) getIfExp().fullCopy();
			FIfExp exp = new FIfExp(ifExp, thenArr.get(i), new List(), elseArr.get(i));
			for (FElseIfExp eie : getFElseIfExps())
				exp.addFElseIfExp((FElseIfExp) eie.getArray().get(i));
			arr.set(i, exp);
		}
		return arr;
	}
	
	eq FElseIfExp.getArray() {
		if (!isArray())
			return super.getArray();
		
		Array arr = new Array(indices());
		for (Index i : arr.indices()) 
			arr.set(i, new FElseIfExp((FExp) getIfExp().fullCopy(), getThenExp().getArray().get(i)));
		return arr;
	}
	
	eq FIdUseExp.getArray() {
		if (isArray()) {
			/*
			 * Based on an array access, say x, corresponding to the declaration
			 * Real x[2], the array {x[1],x[2]} is generated. 
			 */
			boolean scalarize = !inFunction();
			Array array = new Array(indices());
			for (Index i : array.indices()) 
				array.set(i, createNode(getFIdUse().specify(i, scalarize)));
			return array;
		} else {
			return new ScalarAsArray(this);
		}
	}
	
	eq FInstAccessExp.getArray() {
		if (isArray()) {
			/*
			 * Based on an array access, say x, corresponding to the declaration
			 * Real x[2], the array {x[1],x[2]} is generated. 
			 */
			Indices ind = indices();
			Array array = new Array(ind);
			for (Index i : ind) {
				InstAccess ia = getInstAccess().specify(i);
				array.set(i, new FInstAccessExp(ia));
			}
			return array;
		} else {
			return new ScalarAsArray(this);
		}
	}
	
	/**
	 * \brief Returns a scalar FIdUseInstAccess, as specified by an index.
	 * 
	 * @param i          the Index specifying what array subscripts to use
	 * @param scalarize  ignored (needed by superclass implementation) 
	 */
	public FIdUseInstAccess FIdUseInstAccess.specify(Index i, boolean scalarize) {
		InstAccess ia = getInstAccess().specify(i);
		return new FIdUseInstAccess(new FQName(), ia);
	}
	
	/**
	 * \brief Returns a scalar FIdUse, as specified by an index.
	 * 
	 * @param i          the Index specifying what array subscripts to use
	 * @param scalarize  <code>true</code> if the use should be marked as scalarized 
	 */
	public FIdUse FIdUse.specify(Index i, boolean scalarize) {
		return new FIdUse(getFQName().specify(i, scalarize));
	}
	
	/**
	 * \brief Creates a new FQName with the FArraySubscripts taken from the given Index.
	 * 
	 * @param i          the Index specifying what array subscripts to use
	 * @param scalarize  <code>true</code> if the FQName should be marked as scalarized 
	 */
	public FQName FQName.specify(Index i, boolean scalarize) {
		FQName res = new FQName();
		int[] dim = new int[1];
		int np = getNumFQNamePart();
		for (int j = 0; j < np; j++) {
			FQNamePart part = getFQNamePart(j);
			int n = part.numFSubscripts();
			if (n == 0 && j == np - 1)
				n = i.ndims() - dim[0];
			FArraySubscripts newfas = null;
			if (n > 0) {
				boolean hasfas = part.hasFArraySubscripts();
				newfas = new FArraySubscripts();
				FArraySubscripts oldfas = hasfas ? part.getFArraySubscripts() : null;
				for (int k = 0; k < n; k++) {
					FSubscript fs = hasfas ?
							oldfas.getFSubscript(k).createSpecified(i, dim) :
							new FExpSubscript(i.get(dim[0]++));
					newfas.addFSubscript(fs);
				}
			}
			Opt fasopt = newfas == null ? new Opt() : new Opt(newfas);
			res.addFQNamePart(new FQNamePart(getFQNamePart(j).getName(), fasopt));
		}
		res.scalarized = scalarize;
		return res;
	}
	
	/**
	 * \brief Creates a new FSubscript that specifies this array subscript to a single index.
	 * 
	 * - For scalar subscripts, a copy is returned.
	 * - For colon subscripts, the given index is used as the new subscript.
	 * - For other vector subscripts, the given index is used as the index of a 
	 *   cell in the vector, and that cell is used as the new subscript.
	 *   In this case, dim will be incremented.
	 * 
	 * @param i    the Index specifying what array subscripts to use
	 * @param dim  the dimension in <code>i</code> to use, 
	 *             wrapped in an array so that it can be changed by the method
	 */
	public FSubscript FSubscript.createSpecified(Index i, int[] dim) {
		return new FExpSubscript(i.get(dim[0]++));
	}
	
	public FSubscript FExpSubscript.createSpecified(Index i, int[] dim) {
		if (ndims() == 0)
			return fullCopy();
		
		int index = i.get(dim[0]++) - 1;
		return new FExpSubscript(getFExp().getArray().getFExp(index));
	}
	
	/**
	 * \brief Gets the number of FSubscripts in the FArraySubscripts of this FQNamePart, if any.
	 */
	syn int FQNamePart.numFSubscripts() = 
		hasFArraySubscripts() ? getFArraySubscripts().getNumFSubscript() : 0;
	
	/**
	 * \brief Creates a new InstAccess with the FArraySubscripts taken from the given Index.
	 * 
	 * @param i  the Index specifying what array subscripts to use
	 */
	public InstAccess InstAccess.specify(Index i) {
		return specifyEach(i, new int[1]);
	}

	/**
	 * \brief Sets the FArraySubscripts of each part to match the Index.
	 * 
	 * @param i    the Index specifying what array subscripts to use
	 * @param dim  the next dimension in <code>i</code> to use, 
	 *             wrapped in an array so that it can be changed by the method
	 */
	protected InstAccess InstAccess.specifyEach(Index i, int[] dim) {
		return (InstAccess) fullCopy();
	}

	protected InstDot InstDot.specifyEach(Index i, int[] dim) {
		return new InstDot(getLeft().specifyEach(i, dim), getRight().specifyEach(i, dim));
	}

	protected InstArrayAccess InstArrayAccess.specifyEach(Index i, int[] dim) {
		InstArrayAccess res = fullCopy();
		FArraySubscripts oldfas = allFArraySubscripts().get(0);
		int n = oldfas.getNumFSubscript();
		if (n > 0) {
			FArraySubscripts newfas = new FArraySubscripts();
			for (int k = 0; k < n; k++) {
				FSubscript fs = oldfas.getFSubscript(k).createSpecified(i, dim);
				newfas.addFSubscript(fs);
			}
			res.setFArraySubscripts(newfas);
		}
		return res;
	}

	eq FRangeExp.getArray() {
		//log.debug("FRangeExp.getArray(): size = " + size().get(0));
		Array array = new Array(indices());
		if (type().isReal()) {
			double i1 = getFExp(0).ceval().realValue();
			double i2 = 1.0;
			if (getNumFExp() > 2) 
				i2 = getFExp(1).ceval().realValue();
			for (Index i : array.indices()) { 
				array.set(i, new FRealLitExp(i1));
				i1 += i2;
			}
		} else {
			int i1 = getFExp(0).ceval().intValue();
			int i2 = 1;
			if (getNumFExp() > 2) 
				i2 = getFExp(1).ceval().intValue();
			for (Index i : array.indices()) { 
				array.set(i, type().createLiteral(i1));
				i1 += i2;
			}
		}
		
		return array;
	}
	
	eq FLinspace.getArray() {
		int n = size().get(0);
		FExp len = new FSubExp((FExp) getStopExp().fullCopy(), (FExp) getStartExp().fullCopy());
		FExp step = new FDivExp(len, new FIntegerLitExp(n - 1));
		Array array = new Array(indices());
		for (Index i : array.indices()) {
			FExp part = new FMulExp(new FIntegerLitExp(i.first() - 1), (FExp) step.unboundCopy());
			array.set(i, new FAddExp((FExp) getStartExp().fullCopy(), part));
		}
		return array;
	}
	
	eq FZeros.getArray()   = new Array(indices()).fill(new FIntegerLitExp(0));
	eq FOnes.getArray()    = new Array(indices()).fill(new FIntegerLitExp(1));
	eq FFillExp.getArray() = new Array(indices()).fill(getFillExp());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FExp.indices() = Indices.create(size());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FArraySubscripts.indices() = Indices.createFromFas(this);
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FSubscript.indices() = Indices.create(size());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FType.indices() = Indices.create(size());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FExpSubscript.indices() = getFExp().indices();
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	eq FIdUseExp.indices() = getFIdUse().indices();

	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FIdUse.indices() = Indices.createFromFas(allFArraySubscripts());
	syn Indices FIdUseInstAccess.indices() = getInstAccess().indices();

	/**
	 * \brief Get the set of all array indices of an instance array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	eq FInstAccessExp.indices() = getInstAccess().indices();

	/**
	 * \brief Get the set of all array indices of an instance array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices InstAccess.indices() = Indices.createFromFas(allFArraySubscripts());
		
	/**
	 * \brief Get the set of all array indices of an subscripted array expression. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FSubscriptedExp.indices() = getFArraySubscripts().indices();

	/**
	 * \brief Get the set of all array indices of an instance primitive component. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices InstAssignable.indices() = Indices.create(size());

	/**
	 * \brief Get the set of all array indices of an FVariable. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices AbstractFVariable.indices() = null;
	eq FVariable.indices()      = isScalarized() ? null : Indices.create(size());
	eq FFunctionArray.indices() = Indices.create(size());

	/**
	 * \brief Get the set of all array indices of an InstComponentDecl. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices InstComponentDecl.indices() = Indices.create(size());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FEquation.indices() = getLeft().indices();
	
	/**
	 * \brief Get the set of all indices this array subscript spans.
	 * 
	 * @return an int array containing the indices spanned
	 */
	syn int[] FSubscript.myIndices();
	
	eq FColonSubscript.myIndices() {
		int n = size().get(0);
		if (n < 0)
			return new int[0];
		int[] ind = new int[n];
		for (int i = 0; i < n; i++)
			ind[i] = i + 1;
		return ind;
	}
	
	eq FExpSubscript.myIndices() = getFExp().myIndices();
	
	syn int[] FExp.myIndices() {
		try {
			int n = 0;
			if (ndims() == 0)
				n = 1;
			else if (ndims() == 1)
				n = size().get(0);
			if (n > 0) {
				int[] indices = new int[n];
				int j = 0;
				for (CValue val : ceval())
					indices[j++] = val.intValue();
				return indices;
			}
		} catch (ConstantEvaluationException e) {
		}
		return new int[0];
	}
	
	/**
	 * \brief Get the set of all values this for index spans.
	 * 
	 * @return an int array containing the values spanned
	 */
	syn int[] FForIndex.myIndices() {
		if (hasFExp())
			return getFExp().myIndices();
		else
			return new int[0]; // TODO: return 1..n, where n is given by use.
	}
	
	/**
	 * \brief Get the set of all values this for index spans.
	 * 
	 * @return an int array containing the values spanned
	 */
	syn int[] InstForIndex.myIndices() {
		if (hasFExp())
			return getFExp().myIndices();
		else
			return new int[0]; // TODO: return 1..n, where n is given by use.
	}
	
	/**
	 * \brief Try to infer type of an expression from its surrounding Array.
	 * 
	 * An FExp that is the direct child of an Array always has the same type as the Array, except scalar.
	 * 
	 * @return  if this expression is in an Array, the inferred type, otherwise type()
	 */
	syn FType FExp.inferType() = inArray() ? inferredType() : type();
	
	/**
	 * \brief Check if this expression is the direct child of an Array.
	 */
	inh boolean FExp.inArray();
	inh boolean List.inArray();
	eq List.getChild().inArray()    = inArray();
	eq Array.getChild().inArray()   = true;
	eq ASTNode.getChild().inArray() = false;
	
	/**
	 * \brief Helper attribute to {@link FExp#inferType()}.
	 */
	inh FType FExp.inferredType();
	inh FType List.inferredType();
	eq List.getChild().inferredType()    = inferredType();
	eq Array.getChild().inferredType()   = type().scalarType();
	eq ASTNode.getChild().inferredType() = null;

	/**
	 * \brief The type of the expression this Array belongs to.
	 */
	inh FType Array.type();
	eq FExp.getArray().type()             = type();
	eq FExpSubscript.getExpanded().type() = type();

}

aspect ArrayHelpers {
	
	/**
	 * \brief An array size. Can be multi-dimensional.
	 */
	public class Size {
		
		/**
		 * \brief Used for unknown lengths.
		 */
		public static final int UNKNOWN = -1;
		
		/**
		 * \brief Used to represent the size of scalar expressions.
		 */
		public static final Size SCALAR = new Size();
		
		protected int[] size;
		
		/**
		 * \brief Private constructor that creates a scalar size.
		 */
		private Size() {
			size = new int[0];
		}
		
		/**
		 * \brief Constructs a Size with the given lengths.
		 */
		public Size(int[] size) {
			if (size.length == 0)
				throw new IllegalArgumentException();
			this.size = size;
		}
		
		/**
		 * \brief Convenience constructor to create a on-dimensional size with the given length.
		 */
		public Size(int s) {
			size = new int[] { s };
		}
		
		/**
		 * \brief Get the number of dimensions.
		 */
		public int ndims() {
			return size.length;
		}
		
		/**
		 * \brief Get length in the <code>i</code>th dimension.
		 */
		public int get(int i) {
			try {
				return size[i];
			} catch (ArrayIndexOutOfBoundsException e) {
				return UNKNOWN;
			}
		}
		
		/**
		 * \brief Get length in the last dimension.
		 */
		public int last() {
			return size[size.length - 1];
		}
		
		/**
		 * \brief Check if this size has an <code>i</code>th dimension.
		 */
		public boolean has(int i) {
			return size.length > i;
		}
		
		/**
		 * \brief Returns the number of elements spanned by this Size.
		 * 
		 * Only valid if all dimensions are known or currently evaluable.
		 */
		public int numElements() {
			int res = 1;
			for (int i = 0; i < size.length && res > 0; i++)
				res *= get(i);
			return res < 0 ? 0 : res;
		}
		
		/**
		 * \brief Create a new flattened FArraySubscripts object describing this size.
		 */
		public FArraySubscripts flattenFArraySubscripts(FQName prefix) {
			FArraySubscripts fas = new FArraySubscripts();
			for (int i = 0; i < size.length; i++)
				fas.addFSubscript(flattenFSubscript(i, prefix));
			return fas;
		}
		
		/**
		 * \brief Create a new flattened FSubscript for dimension <code>i</code>.
		 */
		protected FSubscript flattenFSubscript(int i, FQName prefix) {
			return size[i] == UNKNOWN ? new FColonSubscript() : new FExpSubscript(size[i]);
		}
		
		/**
		 * \brief Create a new FArraySubscripts object with ranges spanning this size.
		 */
		public FArraySubscripts rangeFArraySubscripts() {
			FArraySubscripts fas = new FArraySubscripts();
			for (int i = 0; i < size.length; i++)
				fas.addFSubscript(rangeFSubscript(i));
			return fas;
		}
		
		/**
		 * \brief Create a new FSubscript for dimension <code>i</code>.
		 */
		protected FSubscript rangeFSubscript(int i) {
			return size[i] == UNKNOWN ? new FColonSubscript() : new FExpSubscript(new FRangeExp(1, size[i]));
		}
		
		/**
		 * \brief Check if any lengths are unknown.
		 */
		public boolean isUnknown() {
			for (int s : size)
				if (s == UNKNOWN)
					return true;
			return false;
		}
		
		/**
		 * \brief Check if all lengths have a value (fix length or integer).
		 */
		public boolean isComplete() {
			for (int i = 0; i < size.length; i++)
				if (!hasValue(i))
					return false;
			return true;
		}
		
		/**
		 * \brief Check is the length in any dimension equals 0.
		 */
		public boolean isEmpty() {
			for (int i = 0; i < size.length; i++)
				if (size[i] == 0)
					return true;
			return false;
		}
		
		/**
		 * \brief Check if the lengths in the given dimension has a value (fix length or integer).
		 */
		protected boolean hasValue(int dim) {
			return size[dim] != UNKNOWN;
		}
		
		/**
		 * \brief Create a copy of this size.
		 */
		protected Size clone() {
			return new Size(size.clone());
		}
		
		/**
		 * \brief Create a copy of this size as a MutableSize.
		 */
		public MutableSize mutableClone() {
			MutableSize ms = new MutableSize(size.length);
			System.arraycopy(size, 0, ms.size, 0, size.length);
			return ms;
		}
		
		/**
		 * \brief Create a copy of this with <code>dim</code> dimensions, if necessary 
		 *        adding dimensions of length 1 to the right side, or removing dimensions 
		 *        from the left side.
		 */
		public Size promote(int dim) {
			if (dim == size.length) 
				return this;
			if (dim == 0)
				return SCALAR;
			Size ns = new Size(new int[dim]);
			int old = dim < size.length ? dim : size.length;
			System.arraycopy(size, size.length - old, ns.size, 0, old);
			Arrays.fill(ns.size, old, dim, 1);
			return ns;
		}
		
		/**
		 * \brief Return a Size that have the same lengths as this size where they are known, 
		 *        and any that are unknown copied from the size of <code>exp</code>. 
		 * 
		 * If the size of <code>exp</code> have more dimensions, the last part is assumed to match this size.
		 */
		public Size createKnown(FExp exp) {
			Size known;
			if (!exp.size().isUnknown() || this instanceof MutableSize) { 
				known = clone();
			} else {
				known = new MutableSize(size.length);
				System.arraycopy(size, 0, known.size, 0, size.length);
			}
			known.fillUnknownFrom(exp);
			return known;
		}
		
		/**
		 * \brief For each unknown length, copy the equivalent length from size of <code>exp</code>. 
		 * 
		 * If the size of <code>exp</code> have more dimensions, the last part is assumed to match this size.
		 */
		protected void fillUnknownFrom(FExp exp) {
			Size other = exp.size();
			if (other.size.length >= size.length)
				for (int i = 0, j = other.size.length - size.length; i < size.length; i++, j++) 
					if (!hasValue(i))
						copyFrom(i, exp, i);
		}
		
		/**
		 * \brief Copy value of dimension <code>d2</code> in <code>other</code> to dimension 
		 *        <code>d1</code> in <code>this</code>.
		 */
		protected void copyFrom(int d1, FExp exp, int d2) {
			size[d1] = exp.size().size[d2];
		}
		
		/**
		 * \brief Check if another object is equal to this one.
		 */
		public boolean equals(Object s) {
			return s instanceof Size && equivalent((Size) s, false);
		}
		
		/**
		 * \brief Calculate hash code.
		 */
		public int hashCode() {
			int res = 0;
			for (int i = 0; i < size.length; i++)
				res = (res << 8) ^ size[i];
			return res;
		}
		
		/**
		 * \brief Check if another size is equivalent to this one.
		 * 
		 * @param allowUnknown  if <code>true</code>, consider unknown lengths equal to any length, 
		 *                      otherwise consider unknown lengths to differ from all lengths, including
		 *                      other unknown lengths
		 */
		public boolean equivalent(Size s, boolean allowUnknown) {
			return equivalentExcept(s, allowUnknown, -1);
		}
		
		/**
		 * \brief Check if another size is equivalent to this one, except in a given dimension.
		 * 
		 * @param allowUnknown  if <code>true</code>, consider unknown lengths equal to any length
		 * @param dim			dimension not to check
		 */
		public boolean equivalentExcept(Size s, boolean allowUnknown, int dim) {
			if (size.length != s.size.length)
				return false;
			for (int i = 0; i < size.length; i++) 
				if (i != dim && !equivalentDim(s, allowUnknown, i, i)) 
					return false;
			return true;
		}
		
		/**
		 * \brief Check if a specific dimension of another size is equivalent to a specific 
		 *        dimension of this one.
		 * 
		 * @param allowUnknown  if <code>true</code>, consider unknown lengths equal to any length
		 * @param myDim         the dimension in this Size to compare
		 * @param itsDim        the dimension in the other Size to compare
		 */
		public boolean equivalentDim(Size s, boolean allowUnknown, int myDim, int itsDim) {
			boolean same = size[myDim] == s.size[itsDim];
			if (same || !allowUnknown)
				return same;
			return size[myDim] == UNKNOWN || s.size[itsDim] == UNKNOWN;
		}
		
		private static final String SEP = ", ";
		
		/**
		 * \brief Returns a string representation on the form "[l1, l2, l3]".
		 */
		public String toString() {
			StringBuilder buf = new StringBuilder("[");
			String prefix = "";
			for (int i = 0; i < size.length; i++) {
				buf.append(prefix);
				buf.append(toString(i));
				prefix = SEP;
			}
			buf.append("]");
			return buf.toString();
		}
		
		/**
		 * \brief Returns a string representation of a single length.
		 */
		protected String toString(int i) {
			return (size[i] == UNKNOWN) ? ":" : Integer.toString(size[i]);
		}
		
		/**
		 * \brief Returns a string representation on the form "l1, l2, l3".
		 */
		public String toUnclosedString() {
			String tmp = toString();
			return tmp.substring(1, tmp.length() - 1);
		}
		
		/**
		 * \brief Creates a new Size that is a copy of this one, but with one more dimension.
		 * 
		 * @param s  the length of the new dimension
		 */
		public Size expand(int s) {
			int[] ns = new int[size.length + 1];
			ns[0] = s;
			System.arraycopy(size, 0, ns, 1, size.length);
			return new Size(ns);
		}
		
		/**
		 * \brief Creates a new Size that is a concatenation of <code>s</code> and this size.
		 */
		public Size expand(Size s) {
			int ndims = size.length + s.size.length;
			if (ndims == 0)
				return Size.SCALAR;
			int[] ns = new int[ndims];
			System.arraycopy(s.size, 0, ns, 0, s.size.length);
			System.arraycopy(size, 0, ns, s.size.length, size.length);
			return new Size(ns);
		}
		
		/**
		 * \brief Create an FExp that describes the length of dimension <code>d</code>, 
		 *        given the supplied variable values.
		 *        
		 * @param varMap  a map of variables to replace and expressions to replace them with
		 */
		public FExp createSizeFExp(int d, Map<ASTNode, FExp> varMap) {
			return createFExp(d);
		}
		
		/**
		 * \brief Create an FSubscript that spans the length of dimension <code>d</code>.
		 * 
		 * If nothing is known of the length of the dimension, an FColonSubscripts is created.
		 */
		public FSubscript createExpandedFSubscript(int d) {
			if (hasValue(d)) {
				List<FExp> lim = new List<FExp>();
				lim.add(new FIntegerLitExp(1));
				lim.add(createFExp(d));
				return new FExpSubscript(new FRangeExp(lim));
			} else {
				return new FColonSubscript();
			}
		}
		
		/**
		 * \brief Create an FExp that describes this size.
		 * 
		 * The resulting expression is not expanded like createSizeFExp().
		 */
		public FExp createFExp() {
			List<FExp> cells = new List<FExp>();
			for (int i = 0; i < size.length; i++)
				cells.add(createFExp(i));
			return new FArray(cells);
		}
		
		/**
		 * \brief Create an FExp that describes the length of dimension <code>d</code>.
		 * 
		 * The resulting expression is not expanded like createSizeFExp().
		 */
		public FExp createFExp(int d) {
			return new FIntegerLitExp(size[d]);
		}
		
		/**
		 * \brief Create an FExp that describes the number of elements of this size.
		 */
		public FExp createNumElementsFExp() {
			return new FIntegerLitExp(numElements());
		}
		
		/**
		 * \brief Create a dummy expression that has the size described by this Size.
		 */
		public FExp createDummyFExp(Map<ASTNode, FExp> varMap) {
			FZeros z = new FZeros();
			for (int i = 0; i < size.length; i++)
				z.addFExp(createSizeFExp(i, varMap));
			return z;
		}
		
		/**
		 * \brief Create a zero expression of this size.
		 */
		public FExp createZeroFExp() {
			if (size.length == 0) {
				return new FIntegerLitExp(0);
			} else {
				FZeros res = new FZeros();
				for (int i = 0; i < size.length; i++)
					res.addFExp(createFExp(i));
				return res;
			}
		}
		
	}
	
	/**
	 * A mutable Size that can handle FExp sizes, possibly with unknown ceval().
	 */
	public class MutableSize extends Size {
		
		private int i;
		private FExp[] exps;
		
		/**
		 * \brief Constructs a new mutable Size of <code>ndims</code> dimensions.
		 */
		public MutableSize(int ndims) {
			super(new int[ndims]);
			Arrays.fill(size, UNKNOWN);
			exps = new FExp[ndims];
			i = 0;
		}
		
		/**
		 * \brief Constructs the size descrived by a vector expression.
		 */
		public MutableSize(FExp exp) {
			this(exp.ndims() == 1 ? exp.size().get(0) : 0);
			for (FExp dim : exp.getArray().iterable())
				append(dim);
		}
		
		/**
		 * \brief Sets the next length to <code>s</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void append(int s) {
			set(i++, s);
		}
		
		/**
		 * \brief Sets the next length to the value of <code>e</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void append(FExp e) {
			set(i++, e);
		}
		
		/**
		 * \brief Sets the next length to the length of dimension <code>d</code> 
		 *        of <code>s</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void append(Size s, int d) {
			set(i++, s, d);
		}
		
		/**
		 * \brief Sets the next <code>s.ndims()</code> lengths from <code>s</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void append(Size s) {
			if (s instanceof MutableSize) {
				MutableSize ms = (MutableSize) s;
				for (int j = 0; j < ms.size.length; j++, i++) {
					exps[i] = ms.exps[j];
					size[i] = ms.size[j];
				}
			} else {
				for (int si : s.size) {
					exps[i] = null;
					size[i++] = si;
				}
			}
		}
		
		/**
		 * \brief Sets length <code>i</code> to <code>s</code>.
		 */
		public void set(int i, int s) {
			size[i] = s;
			exps[i] = null;
		}
		
		/**
		 * \brief Sets length <code>d</code> to the value of <code>e</code>.
		 */
		public void set(int d, FExp e) {
			int s = UNKNOWN;
			if (e.isValidExp()) {
				try {
					s = e.ceval().intValue();
				} catch (ConstantEvaluationException uoe) {
				}
			}
			size[d] = s;
			exps[d] = (s == UNKNOWN) ? e : null;
		}
		
		/**
		 * \brief Sets length <code>d1</code> to the length of dimension <code>d2</code> 
		 *        of <code>s</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void set(int d1, Size s, int d2) {
			size[d1] = s.size[d2];
			exps[d1] = (s instanceof MutableSize) ? ((MutableSize) s).exps[d2] : null;
		}
		
		/**
		 * \brief Adds <code>s</code> to length <code>d</code>.
		 */
		public void add(int d, int s) {
			if (s == UNKNOWN) {
				size[d] = UNKNOWN;
				exps[d] = null;
			} else if (size[d] != UNKNOWN) {
				size[d] += s;
			} else if (okExp(exps[d])) {
				exps[d] = new FAddExp((FExp) exps[d].unboundCopy(), new FIntegerLitExp(s));
			}
		}
		
		/**
		 * \brief Adds the value of <code>e</code> to length <code>d</code>.
		 */
		public void add(int d, FExp e) {
			try {
				add(d, e.ceval().intValue());
			} catch (ConstantEvaluationException uoe) {
				exps[d] = new FAddExp(createFExp(d), (FExp) e.unboundCopy());
				size[d] = UNKNOWN;
			}
		}
		
		/**
		 * \brief Adds the length of dimension <code>d2</code> of <code>s</code> 
		 *        to length <code>d1</code> of this size.
		 */
		public void add(int d1, Size s, int d2) {
			FExp e = (s instanceof MutableSize) ? ((MutableSize) s).exps[d2] : null;
			if (okExp(e)) 
				add(d1, e);
			else
				add(d1, s.size[d2]);
		}
		
		/**
		 * \brief Get length in the <code>i</code>th dimension.
		 */
		public int get(int i) {
			if (i < 0 || i >= size.length)
				return UNKNOWN;
			if (exps[i] == null) // We want to evaluate FUnknownSizeExps as well
				return size[i];
			try {
				return exps[i].ceval().intValue();
			} catch (ConstantEvaluationException e) {
				return UNKNOWN;
			}
		}
		
		/**
		 * \brief Check if the lengths in the given dimension has a value (fix length or integer).
		 */
		protected boolean hasValue(int dim) {
			return size[dim] != UNKNOWN || okExp(exps[dim]);
		}
		
		/**
		 * \brief Check if an expression is valid.
		 */
		protected static boolean okExp(FExp e) {
			return e != null && e.isValidExp();
		}
		
		/**
		 * \brief Copy value of dimension <code>d2</code> in size of <code>exp</code> to dimension 
		 *        <code>d1</code> in <code>this</code>.
		 */
		protected void copyFrom(int d1, FExp exp, int d2) {
			set(d1, exp.size(), d2);
			if (!hasValue(d1)) {
				FExp copyExp = (FExp) exp.fullCopy();
				Opt dimExp = new Opt(new FIntegerLitExp(d2 + 1));
				FSizeExp sizeExp  = new FSizeExp(copyExp, dimExp);
				exps[d1] = exp.dynamicFExp(sizeExp);
			}
		}
		
		/**
		 * \brief Creates a new Size that is a copy of this one, but with one more dimension.
		 * 
		 * @param s  the length of the new dimension
		 */
		public Size expand(int s) {
			MutableSize ns = new MutableSize(size.length + 1);
			ns.size[0] = s;
			ns.exps[0] = null;
			System.arraycopy(size, 0, ns.size, 1, size.length);
			System.arraycopy(exps, 0, ns.exps, 1, size.length);
			return ns;
		}
		
		/**
		 * \brief Creates a new Size that is a concatenation of <code>s</code> and this size.
		 */
		public Size expand(Size s) {
			int ndims = size.length + s.size.length;
			if (ndims == 0)
				return Size.SCALAR;
			MutableSize ns = new MutableSize(ndims);
			System.arraycopy(s.size, 0, ns.size, 0, s.size.length);
			System.arraycopy(size, 0, ns.size, s.size.length, size.length);
			if (s instanceof MutableSize) 
				System.arraycopy(((MutableSize) s).exps, 0, ns.exps, 0, s.size.length);
			System.arraycopy(exps, 0, ns.exps, s.size.length, size.length);
			return ns;
		}
		
		/**
		 * \brief Create an FExp that describes the length of dimension <code>d</code>, 
		 *        given the supplied variable values.
		 *        
		 * @param varMap  a map of variables to replace and expressions to replace them with
		 */
		public FExp createSizeFExp(int d, Map<ASTNode, FExp> varMap) {
			return (okExp(exps[d])) ? 
					exps[d].createSizeFExp(varMap) : 
					super.createSizeFExp(d, varMap);
		}
		
		/**
		 * \brief Create an FExp that describes the length of dimension <code>d</code>.
		 * 
		 * the resulting expression is not expanded like createSizeFExp().
		 */
		public FExp createFExp(int d) {
			return (okExp(exps[d])) ? 
					(FExp) exps[d].unboundCopy() : 
					super.createFExp(d);
		}
		
		/**
		 * \brief Create an FExp that describes the number of elements of this size.
		 */
		public FExp createNumElementsFExp() {
			int known = 1;
			FExp res = null;
			for (int i = 0; i < size.length; i++) {
				// TODO: this will fail if hasValue(i) == false
				if (size[i] == UNKNOWN) {
					FExp e = (FExp) exps[i].unboundCopy();
					res = (res == null) ? e : new FMulExp(res, e);
				} else {
					known *= size[i];
				}
			}
			if (res == null)
				res = new FIntegerLitExp(known);
			else if (known > 1)
				res = new FMulExp(res, new FIntegerLitExp(known));
			return res;
		}
		
		/**
		 * \brief For each unknown length, copy the equivalent length from <code>other</code>. 
		 * 
		 * If <code>other</code> have more dimensions, the last part is assumed to match this size.
		 */
		public void makeKnown(FExp exp) {
			fillUnknownFrom(exp);
		}
		
		/**
		 * \brief Create a new flattened FSubscript for dimension <code>i</code>.
		 */
		protected FSubscript flattenFSubscript(int i, FQName prefix) {
			// TODO: use okExp() instead of "== null"?
			return exps[i] == null ? super.flattenFSubscript(i, prefix) : 
				new FExpSubscript(exps[i].flatten(prefix));
		}
		
		/**
		 * \brief Create a new FSubscript with a range spanning dimension <code>i</code>.
		 */
		protected FSubscript rangeFSubscript(int i) {
			return !okExp(exps[i]) ? super.rangeFSubscript(i) : 
				new FExpSubscript(new FRangeExp(new FIntegerLitExp(1), (FExp) exps[i].fullCopy()));
		}
		
		/**
		 * \brief Returns a string representation of a single length.
		 */
		protected String toString(int i) {
			// TODO: use okExp() instead of "== null"?
			return exps[i] == null ? super.toString(i) : exps[i].prettyPrint("");
		}
		
		/**
		 * \brief Create a copy of this size.
		 */
		protected MutableSize clone() {
			MutableSize ms = new MutableSize(size.length);
			System.arraycopy(size, 0, ms.size, 0, size.length);
			System.arraycopy(exps, 0, ms.exps, 0, exps.length);
			return ms;
		}
		
		/**
		 * \brief Create a copy of this size as a MutableSize.
		 */
		public MutableSize mutableClone() {
			return clone();
		}
		
		/**
		 * \brief Create a copy of this with <code>dim</code> dimensions, if necessary 
		 *        adding dimensions of length 1 to the right side, or removing dimensions 
		 *        from the left side.
		 */
		public Size promote(int dim) {
			if (dim == size.length) 
				return this;
			if (dim == 0)
				return SCALAR;
			MutableSize ns = new MutableSize(dim);
			int old = dim < size.length ? dim : size.length;
			System.arraycopy(size, size.length - old, ns.size, 0, old);
			System.arraycopy(exps, exps.length - old, ns.exps, 0, old);
			Arrays.fill(ns.size, old, dim, 1);
			return ns;
		}
		
	}
	
	public class Array {
		
		protected Indices indices;
		protected int length;
		
		/**
		 * \brief Create an Array spanning a given Indices.
		 */
		public Array(Indices indices) {
			this.indices = indices;
			setChild(new List<FExp>(), 0);
			length = indices.numElements();
			if (length > 0)
				setFExp(null, length - 1);
		}
		
		/**
		 * \brief Creates an iterator that iterates over all FExp nodes in this Array.
		 */
		public Iterator<FExp> iteratorFExp() {
			return getFExps().iterator();
		}
		
		/**
		 * \brief Returns an Iterable<FExp> containing all expressions in Array.
		 */
		public Iterable<FExp> iterable() {
			return getFExps();
		}
		
		/**
		 * \brief Creates a left-hand iterator for multiplication. 
		 * 
		 * Creates an iterator that iterates over all FExp nodes involved in 
		 * calculating the cell i in a multiplication with this Array at the 
		 * left side. 
		 * 
		 * If this Array is a vector, i is ignored and an iterator that iterates 
		 * over all elements in the Array is returned. 
		 * 
		 * If this Array is a matrix, an iterator that iterates over the row 
		 * specified by i is returned.
		 */
		public Iterator<FExp> leftMulIterator(Index i) {
			if (ndims() < 2)
				return new AIterator();
			else
				return new AIterator(i.first(), size().get(1));
		}
		
		/**
		 * \brief Creates a right-hand iterator for multiplication. 
		 * 
		 * Creates an iterator that iterates over all FExp nodes involved in 
		 * calculating the cell i in a multiplication with this Array at the 
		 * right side. 
		 * 
		 * If this Array is a vector, i is ignored and an iterator that iterates 
		 * over all elements in the Array is returned. 
		 * 
		 * If this Array is a matrix, an iterator that iterates over the column 
		 * specified by i is returned.
		 */
		public Iterator<FExp> rightMulIterator(Index i) {
			if (ndims() < 2)
				return new AIterator();
			else
				return new AIterator(i.last(), size().get(1), size().get(0));
		}
		
		/**
		 * \brief Returns the element referenced by <code>i</code> in this Array.
		 */
		public FExp get(Index i) {
			return getFExp(i.internal(indices));
		}
		
		/**
		 * \brief Sets the element referenced by <code>i</code> in this Array to <code>exp</code>.
		 */
		public void set(Index i, FExp exp) {
			setFExp((FExp) exp.unboundCopy(), i.internal(indices));
		}
		
		/**
		 * \brief Returns the Indices associated with this Array.
		 */
		public Indices indices() {
			return indices;
		}
		
		/**
		 * \brief Set all expressions in Array to copies of <code>exp</code>.
		 * 
		 * If <code>exp</code> is an array, it is duplicated as many times as 
		 * nessecary to fill this Array with scalar expressions.
		 * 
		 * @return <code>this</code> 
		 */
		public Array fill(FExp exp) {
			if (exp.isArray()) {
				int n = exp.size().numElements();
				for (int i = 0; i < length; i++)
					setFExp((FExp) exp.getArray().getFExp(i % n).fullCopy(), i);
			} else {
				for (int i = 0; i < length; i++)
					setFExp((FExp) exp.fullCopy(), i);
			}
			return this;
		}
		
		/**
		 * \brief Returns the number of dimensions spanned by this Array.
		 */
		public int ndims() {
			return indices.ndims();
		}
		
		/**
		 * \brief Returns the size of this Array in each dimension.
		 */
		public Size size() {
			return indices.size();
		}
		
	    /**
	     * \brief Recursive method for building an FArray describing this Array.
	     *        For use by methods creating specific types of FArrays.
	     *  
	     * @param it       the iterator returned by a call to {@link #iteratorFExp()}
	     * @param builder  helper object that processes each subexpression
	     * @param dim      the dimension to process, always use 1
	     * 
	     * @see #buildLiteral(boolean)
	     * @see #buildScalarized(java.util.HashMap<String,FExp>)
	     */
	    protected FExp buildFArray(Iterator<FExp> it, ElementBuilder builder, int dim) {
	    	FArray arr = new FArray(new List<FExp>());
	    	int n = size().get(dim - 1);
	    	if (dim < ndims()) {
	    		for (int i = 0; i < n; i++)
	    			arr.addFExp(buildFArray(it, builder, dim + 1));
	    	} else {
	    		for (int i = 0; i < n; i++) 
	    			arr.addFExp((FExp) builder.build(it.next()).unboundCopy());
	    	}
	    	return arr;
	    }
		
	    /**
	     * \brief Discribes the helper object for {@link #buildFArray(Iterator<FExp>,ElementBuilder,int)}. 
	     */
	    protected interface ElementBuilder {
	    	public FExp build(FExp e);
	    }
		
	    
		/**
		 * \brief Iterates over FExp nodes in this Array.
		 */
		private class AIterator implements Iterator<FExp> {
			
			private int i = 0;
			private int s;
			private int l;
			private int n;
			
			/**
			 * Create an iterator that iterates over all elements in the Array. 
			 */
			public AIterator() {
				s = 0;
				l = 1;
				n = length;
			}
			
			/**
			 * Create an iterator that iterates over a row. Assumes the Array is a matrix.
			 */
			public AIterator(int row, int width) {
				s = (row - 1) * width;
				l = 1;
				n = width;
			}
			
			/**
			 * Create an iterator that iterates over a column. Assumes the Array is a matrix.
			 */
			public AIterator(int col, int width, int height) {
				s = col - 1;
				l = width;
				n = height;
			}
			
			public boolean hasNext() {
				return i < n;
			}
			
			public FExp next() {
				if (i >= n)
					throw new NoSuchElementException();
				return getFExp(s + l * i++);
			}
			
			public void remove() {
				throw new UnsupportedOperationException();
			}
			
		}
		
	}

	public class ScalarAsArray {

		/**
		 * \brief Constructs a ScalarAsArray containing <code>exp</code>.
		 */
		public ScalarAsArray(FExp exp) {
			this(exp, Indices.create(Size.SCALAR));
		}
		
		/**
		 * \brief Constructs a ScalarAsArray containing <code>exp</code>, 
		 *        pretending to have <code>ind</code> indices.
		 * 
		 * This makes indices().iterator() meaningful.
		 */
		public ScalarAsArray(FExp exp, Indices ind) {
			this(new List().add(exp.unboundCopy()));
			indices = ind;
			length = 1;
		}
		
	    /**
	     * \brief Recursive method for building an FArray describing this Array.
	     *        For use by methods creating specific types of FArrays.
	     *        
	     * This implementation only applies builder to the single expression of this 
	     * ScalarAsArray.
	     * 
	     * @see #buildLiteral(boolean)
	     * @see #buildScalarized(java.util.HashMap<String,FExp>)
	     */
	    protected FExp buildFArray(Iterator<FExp> it, ElementBuilder builder, int dim) {
	    	return (FExp) builder.build(it.next()).unboundCopy();
	    }
	    
		/**
		 * \brief Returns the single element wrapped by this Array. 
		 */
		public FExp get(Index i) {
			return getFExp(0);
		}
		
		/**
		 * \brief Sets the single element wrapped by this Array to <code>exp</code>.
		 */
		public void set(Index i, FExp exp) {
			setFExp((FExp) exp.unboundCopy(), 0);
		}
		
	}

	
	/**
	 * \brief Represents the index/indices of a single cell in an (possibly 
	 *        multi-dimensional) array.
	 *        
	 * Index objects are reused to a high degree. Always use clone() when retaining 
	 * an Index object.
	 */
	public class Index implements Cloneable {
		
		public static final Index NULL = new Index(0);
		public static Index expanded = NULL;
		
		protected int[] index;
		
		/**
		 * \brief Construct an Index representing the indices given in <code>ind</code>.
		 */
		public Index(int[] ind) {
			index = ind;
		}
		
		/**
		 * \brief Returns the indices that specify this cell.
		 */
		public int[] index() {
			return index;
		}
		
		/**
		 * \brief Returns the number of dimensions of this Index.
		 */
		public int ndims() {
			return index.length;
		}
		
		/**
		 * \brief Returns the index for the first dimension.
		 */
		public int first() {
			return index.length > 0 ? index[0] : -1;
		}
		
		/**
		 * \brief Returns the index for the last dimension.
		 */
		public int last() {
			return index.length > 0 ? index[index.length - 1] : -1;
		}
		
		/**
		 * \brief Returns the index for the <code>i</code>th dimension (zero-based).
		 */
		public int get(int i) {
			return index[i];
		}
		
		/**
		 * \brief Sets the index for the <code>i</code>th dimension (zero-based).
		 */
		public void set(int i, int index) {
			this.index[i] = index;
		}
		
		/**
		 * \brief Compare two Index for equality.
		 */
		public boolean equals(Object i) {
			return (i instanceof Index) && Arrays.equals(index, ((Index) i).index);
		}
		
		/**
		 * \brief Calculate hash code.
		 * 
		 * Creates perfect hash when ndims() <= 3 and all indices are <= 1023.
		 */
		public int hashCode() {
			int shift = index.length <= 3 ? 10 : 5;
			int res = 0;
			for (int i = 0; i < index.length; i++)
				res = (res << shift) ^ index[i];
			return res;
		}
		
		/**
		 * \brief Creates a new Index that describes the last <code>ndims() - level</code>
		 *        dimensions of this Index.
		 * 
		 * @param level  the first index to copy. Must be between 0 and ndims(), inclusive.
		 */
		public Index subIndex(int level) {
			Index copy = new Index(index.length - level);
			System.arraycopy(index, level, copy.index, 0, copy.index.length);
			return copy;
		}
		
		/**
		 * \brief Creates a new Index that is a copy of this Index, but with <code>adj</code>
		 *        added to dimension <code>dim</code> and promoted to <code>ndims</code> 
		 *        dimensions by adding ones to the end.
		 * 
		 * The new Index will not be bound to any Indices object.
		 */
		public Index adjusted(int dim, int adj, int ndims) {
			Index copy = new Index(new int[ndims]);
			System.arraycopy(index, 0, copy.index, 0, index.length);
			Arrays.fill(copy.index, index.length, ndims, 1);
			copy.index[dim] += adj;
			return copy;
		}
		
		/**
		 * \brief Create a new FArraySubscripts object describing this index.
		 */
		public FArraySubscripts createFArraySubscripts() {
			return FArraySubscripts.createLiteralSubscripts(index);
		}
		
		/**
		 * \brief Copies this Index. Always use clone() when saving an Index.
		 */
		public Index clone() {
			try {
				Index i = (Index) super.clone();
				i.index = index.clone();
				return i;
			} catch (CloneNotSupportedException e) {
				return null;
			}
		}
		
		/**
		 * \brief Return an Index that is the result of appending <code>i</code>
		 *        to this Index.
		 * 
		 * @param i  the Index to append.
		 */
		public Index expand(Index i) {
			if (index.length + i.index.length != expanded.index.length) 
				expanded = new Index(index.length + i.index.length);
			System.arraycopy(index, 0, expanded.index, 0, index.length);
			System.arraycopy(i.index, 0, expanded.index, index.length, i.index.length);
			return expanded;
		}
		
		/**
		 * \brief Return a string representation on the form "[i1, i2, i3]".
		 */
		public String toString() {
			return Arrays.toString(index);
		}
		
		/**
		 * \brief Return a string representation on the form "i1, i2, i3".
		 */
		public String toUnclosedString() {
			String tmp = toString();
			return tmp.substring(1, tmp.length() - 1);
		}
		
		
		/**
		 * \brief Return the internal index in an Array of the cell this Index refers to.
		 *        Only for use from Array.
		 * 
		 * @param indices  the indices to resolve the internal index with
		 */
		public int internal(Indices ind) {
			return ind.internal(this);
		}
		
		/**
		 * \brief Construct an empty Index.
		 */
		protected Index() {
		}
		
		/**
		 * \brief Construct an Index of ndims dimensions, 
		 *        pointing at the spot before the first cell.
		 */
		protected Index(int ndims) {
			index = new int[ndims];
			for (int i = ndims - 2; i >= 0; i--)
				index[i] = 1;
			if (ndims > 0)
				index[ndims - 1] = 0;
		}
		
	}
	
	/**
	 * \brief Indices represents the set of array indices in each dimension.
	 * 
	 * Only supports indices of the form (1..n1, 1..n2, ... , 1..nk). 
	 * See {@link NonConsecutiveIndices}. 
	 * 
	 * New Indices objects should be created with the create() methods. 
	 * The subclass used is selected automatically. 
	 * 
	 * The Indices class is typically used to iterate over all possible indices
	 * of an array access of declaration.
	 */
	public class Indices implements Iterable<Index> {
		protected int ndims;
		protected Size size;
		
		/**
		 * \brief A perfect hash for all Indices that have consecutive indicies, 
		 *        ndims <= 3 and size[i] <= 1023 for 0 <= i < ndims. -1 for other 
		 *        Indices.
		 */
		protected int hash;
		
		/**
		 * \brief Create an Indices object based on array sizes. 
		 */
		public static Indices create(Size size) {
			return new Indices(size);
		}
		
		/**
		 * \brief Create an Indices object based on FArraySubcripts.
		 */
		public static Indices createFromFas(FArraySubscripts fas) {
			return NonConsecutiveIndices.createFromFas(fas);
		}
		
		/**
		 * \brief Create an Indices object based on a list of FArraySubcripts.
		 */
		public static Indices createFromFas(ArrayList<FArraySubscripts> fasl) {
			return NonConsecutiveIndices.createFromFas(fasl);
		}
		
		/**
		 * \brief Create an Indices object based on a list of int arrays.
		 */
		public static Indices create(ArrayList<int[]> ind) {
			return NonConsecutiveIndices.create(ind, true);
		}
		
		/**
		 * \brief Create an Indices object based on a list of CommonForIndexes.
		 */
		public static Indices create(Iterable<? extends CommonForIndex> forIndices) {
			ArrayList<int[]> ind = new ArrayList<int[]>();
			for (CommonForIndex fi : forIndices) 
				ind.add(fi.myIndices());
			return NonConsecutiveIndices.create(ind, false);
		}
		
		/**
		 * \brief Check that i is valid for this Indices object.
		 */
		public boolean isValid(Index i) {
			if (i.ndims() != ndims)
				return false;
			int[] index = i.index();
			for (int j = 0; j < ndims; j++)
				if (index[j] < 1 || index[j] > size.get(j))
					return false;
			return true;
		}
		
		/**
		 * \brief Returns an Iterator, that iterates over all indices spanned by this Indices object.
		 */
		public Iterator<Index> iterator() {
			return new IIterator();
		}
		
		/**
		 * \brief Returns the number of elements spanned by this Indices object.
		 */
		public int numElements() {
			return size.numElements();
		}
		
		/**
		 * \brief Returns the number of dimensions spanned by this Indices object.
		 */
		public int ndims() {
			return ndims;
		}
		
		/**
		 * \brief Returns the size of this Indices object in each dimension.
		 */
		public Size size() {
			return size;
		}
		
		/**
		 * \brief Translates an Index to the corresponding Index in the underlying 
		 *        expression.
		 * 
		 * Default implementation always returns <code>i</code>.
		 */
		public Index translate(Index i) {
			return i;
		}
				
		
		/**
		 * \brief Internal constructor to create an Indices object based on array sizes. 
		 */
		protected Indices(Size size) {
			ndims = size.ndims();
			this.size = size;
			hash = -1;
			if (ndims < 4) {
				int h = 0;
				for (int i = 0; i < ndims; i++) {
					int s = size.get(i);
					if (s > 1023) 
						return;
					h = (h << 10) | s;
				}
				hash = h;
			}
		}
				
		/**
		 * \brief Calculate the internal index in an Array that spans this Indices.
		 */
		protected int internal(Index i) {
			if (i.ndims() != ndims)
				throw new UnsupportedOperationException("Index dimensions does not match.");
			int[] index = i.index();
			int res = 0;
			for (int j = 0; j < ndims; j++)
				res = res * size.get(j) + index[j] - 1;
			return res;
		}
		
		/**
		 * \brief Iterates over all indices spanned by this Indices.
		 */
		protected class IIterator implements Iterator<Index> {
			
			protected IIndex index;
			protected int max;
			
			public IIterator() {
				index = new IIndex();
				max = numElements() - 1;
			}
			
			public boolean hasNext() {
				return index.internal < max;
			}
			
			public Index next() {
				if (index.internal >= max)
					throw new NoSuchElementException();
				index.internal++;
				if (ndims == 0)
					return index;
				int[] ind = index.index();
				int i;
				for (i = ndims - 1; i > 0 && ind[i] >= size.get(i); i--)
					ind[i] = 1;
				ind[i]++;
				return index;
			}
			
			public void remove() {
				throw new UnsupportedOperationException();
			}
			
		}
		
		/**
		 * \brief Internal implementation of Index.
		 */
		protected class IIndex extends Index {
			
			public int internal;
			
			/**
			 * \brief Construct an Index over the number of dimensions of the enclosing Indices, 
			 *        pointing at the spot before the first cell.
			 */
			public IIndex() {
				super(ndims);
				internal = -1;
			}
			
			/**
			 * \brief Return the internal index in an Array of the cell this Index refers to.
			 *        Only for use from Array.
			 * 
			 * @param indices  the indices to resolve the internal index with
			 */
			public int internal(Indices ind) {
				if (Indices.this == ind || (hash != -1 && hash == ind.hash)) 
					return internal;
				else
					return ind.internal(this);
			}
			
		}
		
	}

	/**
	 * \brief NonConsecutiveIndices describes a set of array indices that isn't 
	 *        limited to 1..n.
	 * 
	 * For example, consider the declaration Real x[4,4,4] and the access
	 * x[:,1,1:2:4]. The array indices for the declaration is then
	 * {1,2,3,4}, {1,2,3,4}, and {1,2,3,4} respectively for the three dimensions.
	 * For the access, we have {1,2,3,4}, {1} and {1,3} respectively. The access 
	 * will have size [4,2], and this class will handle the necessary translations 
	 * between indices.
	 */
	public class NonConsecutiveIndices extends Indices {
		// The indices are stored as a list of integer arrays.
		protected ArrayList<int[]> indices; 
		protected Index trans;
		protected boolean[] trim;
		
		/**
		 * \brief Create a NonConsecutiveIndices object based on FArraySubcripts.
		 *        Use Indices.create(FArraySubscripts fas).
		 */
		public static NonConsecutiveIndices createFromFas(FArraySubscripts fas) {
			int n = fas.getNumFSubscript();
			ArrayList<int[]> ind = new ArrayList<int[]>(n);
			boolean[] trim = new boolean[n];
			
			int i = 0;
			for (FSubscript fs : fas.getFSubscripts()) { 
				ind.add(fs.myIndices());
				trim[i++] = fs.ndims() == 0;
			}
			return new NonConsecutiveIndices(ind, trim);
		}
		
		/**
		 * \brief Create a NonConsecutiveIndices object based on a list of FArraySubcripts.
		 *        Use Indices.create(ArrayList<FArraySubscripts> fasl).
		 */
		public static NonConsecutiveIndices createFromFas(ArrayList<FArraySubscripts> fasl) {
			int n = 0;
			for (FArraySubscripts fas : fasl)
				n += fas.getNumFSubscript();
			ArrayList<int[]> ind = new ArrayList<int[]>(n);
			boolean[] trim = new boolean[n];
			
			int i = 0;
			for (FArraySubscripts fas : fasl) {
				for (FSubscript fs : fas.getFSubscripts()) {
					ind.add(fs.myIndices());
					trim[i++] = fs.ndims() == 0;
				} 
			}
			return new NonConsecutiveIndices(ind, trim);
		}
		
		/**
		 * \brief Create a NonConsecutiveIndices object based on a list of int arrays
		 *        Use Indices.create(ArrayList<int[]> ind).
		 * 
		 * @param trim  remove dimensions that only span one index.
		 */
		public static NonConsecutiveIndices create(ArrayList<int[]> ind, boolean trim) {
			boolean[] trims = new boolean[ind.size()];
			for (int i = 0; i < trims.length; i++)
				trims[i] = trim && ind.get(i).length == 1;
			return new NonConsecutiveIndices(ind, trims);
		}
		
		/**
		 * \brief Translates an Index to the corresponding Index in the underlying 
		 *        expression.
		 */
		public Index translate(Index i) {
			int[] ii = i.index();
			int[] ti = trans.index();
			for (int ji = 0, jt = 0; ji < ndims; ji++, jt++) {
				while (trim[jt]) 
					jt++;
				ti[jt] = indices.get(jt)[ii[ji] - 1];
			}
			return trans;
		}

		
		/**
		 * \brief Internal constructor to create a NonConsecutiveIndices object based on a 
		 *        list of int arrays containing the used indexes on the underlying array.
		 * 
		 * @param trim  the dimensions to remove.
		 */
		protected NonConsecutiveIndices(ArrayList<int[]> ind, boolean[] trim) {
			super(getSize(ind, trim));
			this.trim = trim;
			indices = ind;
			trans = new Index(ind.size());
			for (int i = 0; i < ind.size(); i++)
				if (indices.get(i).length > 0)
					trans.index()[i] = indices.get(i)[0];
		}
		
		/**
		 * \brief Calculate size for this indices from a list of int arrays containing the 
		 *        used indexes on the underlying array
		 */
		protected static Size getSize(ArrayList<int[]> ind, boolean[] trim) {
			int n = 0;
			for (boolean tr : trim)
				if (!tr)
					n++;
			MutableSize size = new MutableSize(n);
			for (int i = 0; i < trim.length; i++)
				if (!trim[i])
					size.append(ind.get(i).length);
			return size;
		}
		
	}
	
}
