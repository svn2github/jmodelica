/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect Flattening {
    
	/**
	 * \ingroup aspect_Flattening
	 * 
	 * Generic traversal method used to find a particular class instance
	 * in the instance tree, and if so, flatten it.
	 */
    public InstNode InstProgramRoot.findFlattenInst(String className,FClass fc) throws ModelicaClassNotFoundException {
    	
    	InstClassDecl icd = simpleLookupInstClassDecl(className);
    	if (!icd.isUnknown()) {
    		icd.flattenInstClassDecl(fc);
    	} else {
        	throw new ModelicaClassNotFoundException(className);
    	}
    	
    	return icd;
    }
    
    public void InstClassDecl.flattenInstClassDecl(FClass fc) {
		fc.setFQName(new FQName(qualifiedName()));
		fc.addFEquationBlock(new FEquationBlock(new List()));			
		for (FAbstractEquation ae : getFAbstractEquations()) {
		    ae.flatten(getFQName(), fc);
		}	
		getInstComponentDeclList().flatten(fc);
		getInstExtendsList().flatten(fc);
		flattenUsedFuncsAndEnums(fc);
		
		fc.genConnectionEquations();

		//log.debug(fc.prettyPrint(""));
		//fc.dumpTree("");
		HashSet<InstAccess> instAccesses = fc.collectInstAccesses();
		if (instAccesses.size()>0) {
			log.error("Flat model contains InstAccesses!");
			//return null;
		}
    }

    /**
     * \brief Find functions, record and enumeration declarations that need to be flattened.
     */
	public void ASTNode.flattenUsedFuncsAndEnums(FClass fc) {
		for (int i = 0; i < getNumChild(); i++) 
			getChild(i).flattenUsedFuncsAndEnums(fc);
	}
    
    public void InstNode.flattenUsedFuncsAndEnums(FClass fc) {
		getInstComponentDeclList().flattenUsedFuncsAndEnums(fc);
		getFAbstractEquationList().flattenUsedFuncsAndEnums(fc);
		getInstExtendsList().flattenUsedFuncsAndEnums(fc);
		super.flattenUsedFuncsAndEnums(fc);
    }

	public void InstValueModification.flattenUsedFuncsAndEnums(FClass fc) {
		getFExp().flattenUsedFuncsAndEnums(fc);
	}
	
	public void InstFunctionCall.flattenUsedFuncsAndEnums(FClass fc) {
		getName().myInstClassDecl().flattenFunction(fc);
		getArgs().flattenUsedFuncsAndEnums(fc);
	}
	
	public void FRecordConstructor.flattenUsedFuncsAndEnums(FClass fc) {
		getRecord().flattenMyRecord(fc);
		getArgs().flattenUsedFuncsAndEnums(fc);
	}
	
	public void InstClassAccess.flattenUsedFuncsAndEnums(FClass fc) {
		if (myInstClassDecl().extendsEnum())
			myInstClassDecl().flattenEnum(fc);
	}
	
	public void FIdUse.flattenMyRecord(FClass fc) {}
	
	public void FIdUseInstAccess.flattenMyRecord(FClass fc) {
		getInstAccess().myInstClassDecl().flattenRecord(fc);
	}
	
	// Flatten function if not already done
	public void InstClassDecl.flattenFunction(FClass fc) {}
	
	// TODO: Shouldn't this be InstBaseClassDecl instead?
	public void InstFullClassDecl.flattenFunction(FClass fc) {
		getInstRestriction().flattenFunction(fc, this);
	}
	
	public void InstRestriction.flattenFunction(FClass fc, InstFullClassDecl icd) {}
	
	public void InstFunction.flattenFunction(FClass fc, InstFullClassDecl icd) {
		icd.flattenThisFunction(fc);
	}
	
	public void InstFullClassDecl.flattenThisFunction(FClass fc) {
		if (fc.lookupFunc(qualifiedName()) == null) {	
	   		FFunctionDecl ffd = new FFunctionDecl();
	   		ffd.setFQName(new FQName(qualifiedName()));
	
	   		for (InstComponentDecl icd : getInstComponentDecls())
				icd.flattenInFunction(ffd, fc, false);
	   		for (InstExtends ie : getInstExtendss())
	   	   		for (InstComponentDecl icd : ie.getInstComponentDecls())
	   				icd.flattenInFunction(ffd, fc, false);
			
	   		FAlgorithmBlock fab = findFunctionAlgorithm();
	   		if (fab == null)
	   			fab = new FAlgorithmBlock(new List());
	   		else
	   			fab = fab.flattenEqn(new FQName(), fc);
			ffd.setFAlgorithmBlock(fab);
			if (hasInstExternal())
				fab.addFStatement(getInstExternal().flatten(this, new FQName()));
			fab.ensureReturn();
			
			for (InstAssignable cons : localFunctionConstantList())
				cons.flattenInFunction(ffd, fc, true);
	
			fc.addFFunctionDecl(ffd);
			
			flattenUsedFuncsAndEnums(fc);
		}
	}
	
	syn FAlgorithmBlock InstNode.findFunctionAlgorithm() {
		if (getNumFAbstractEquation() > 0) {
			FAbstractEquation equ = getFAbstractEquation(0);
			if (equ instanceof FAlgorithmBlock)
				return (FAlgorithmBlock) equ;
		} else {
			for (InstExtends ie : getInstExtendss()) {
				FAlgorithmBlock tmp = ie.findFunctionAlgorithm();
				if (tmp != null) 
					return tmp;
			}
		}
		return null;
	}
	
	// Flatten record if not already done
	public void InstClassDecl.flattenRecord(FClass fc) {}
	
	// TODO: Shouldn't this be InstBaseClassDecl instead?
	public void InstFullClassDecl.flattenRecord(FClass fc) {
		getInstRestriction().flattenRecord(fc);
	}
	
	public void InstRestriction.flattenRecord(FClass fc) {}
	
	private FClass InstMRecord.flatRecordAddedTo = null;
	
	public void InstMRecord.flattenRecord(FClass fc) {
		if (flatRecordAddedTo != fc) {
			flatRecordAddedTo = fc;
			((InstFullClassDecl) getParent()).flattenThisRecord(fc);
		}
	}
	
	public void InstFullClassDecl.flattenThisRecord(FClass fc) {
		if (fc.lookupFRec(qualifiedName()) == null) {
			FRecordDecl frd = new FRecordDecl();
	   		frd.setFQName(new FQName(qualifiedName()));
	   		
	   		for (InstComponentDecl icd : getInstComponentDecls())
				icd.flattenInRecord(frd, fc);
			
			fc.addFRecordDecl(frd);
			
			flattenUsedFuncsAndEnums(fc);
		}
	}
	
	public FExternalStmt InstExternal.flatten(InstClassDecl func, FQName prefix) {
		FExternalStmt stmt = new FExternalStmt();
		stmt.setFExternalLanguage(hasFExternalLanguage() ? 
				(FExternalLanguage) getFExternalLanguage().fullCopy() : 
				new FCExternalLanguage());
		stmt.extractLibrary(this);
		if (hasInstExternalCall()) {
			InstExternalCall call = getInstExternalCall();
			if (call.hasReturnVar())
				stmt.setReturnVar(new FIdUse(call.getReturnVar().flatten(prefix)));
			stmt.setName(call.getName());
			for (FExp arg : call.getArgs())
				stmt.addArg(arg.flatten(prefix));
		} else {
			boolean hasReturn = func.myOutputs().size() == 1 && 
					func.myOutputs().get(0).canBeExternalReturn(stmt.getFExternalLanguage());
			if (hasReturn)
				stmt.setReturnVar(new FIdUse(func.myOutputs().get(0).name()));
			stmt.setName(func.name());
			for (InstComponentDecl arg : func.getInstComponentDecls())
				if (!hasReturn || !arg.isOutput())
					arg.flattenExternalArg(stmt.getArgs());
		}
		return stmt;
	}
	
	public void InstComponentDecl.flattenExternalArg(List<FExp> args) {}
	
	public void InstAssignable.flattenExternalArg(List<FExp> args) {
		FIdUseExp use = new FIdUseExp(name());
		args.add(use);
		for (int i = 0; i < ndims(); i++)
			args.add(new FSizeExp(use.fullCopy(), new Opt(new FIntegerLitExp(i + 1))));
	}
	
	syn boolean InstComponentDecl.canBeExternalReturn(FExternalLanguage lang) = false;
	eq InstAssignable.canBeExternalReturn(FExternalLanguage lang) = 
		!isArray() && lang.canBeReturn(type());
	
	syn boolean FExternalLanguage.canBeReturn(FType type) = !type.isArray();
	eq FFortran77ExternalLanguage.canBeReturn(FType type) = !type.isComposite() && !type.isString();
	
	public FExternalStmt FExternalStmt.flatten(FQName prefix) {
		return fullCopy();
	}
	
	public void FAlgorithmBlock.ensureReturn() {
		int num = getNumFStatement();
		if (num == 0 || !(getFStatement(num - 1) instanceof FReturnStmt)) 
			addFStatement(new FReturnStmt());
	}
	
	public void InstComponentDecl.flattenInFunction(FFunctionDecl ffd, FClass fc, boolean useConstant) {}
	
	public void InstAssignable.flattenInFunction(FFunctionDecl ffd, FClass fc, boolean useConstant) {
		boolean isConstant = getComponentDecl().isConstant();
		if (useConstant || !isConstant) {
			FExp e = flattenBindingFExp();
			Opt eo = (e == null) ? new Opt() : new Opt(e);
			FQName fqn = new FQName(getFQName());
			fqn.setLastFArraySubscripts(null);
			FFunctionVariable ffv = createFFunctionVariable(eo, fqn);
			if (isInput())
				ffv.setFTypePrefixInputOutput(new FInput());
			if (isOutput())
				ffv.setFTypePrefixInputOutput(new FOutput());
			// TODO: Mark var as constant if isConstant is true?
			ffd.addFFunctionVariable(ffv);
			myInstClass().flattenRecord(fc);
		}
	}

	public FFunctionVariable InstAssignable.createFFunctionVariable(Opt eo, FQName fqn) {
		// TODO: if we need separate variable class for records, override this
		FType type = (FType) type().fullCopy();
		FFunctionVariable ffv;
		if (isArray())
			ffv = new FFunctionArray(new Opt(), type, eo, fqn);
		else
			ffv = new FFunctionVariable(new Opt(), type, eo, fqn);
		type.flattenSize(new FQName(), ffv);
		return ffv;
	}
	
	public void FType.flattenSize(FQName prefix, FFunctionVariable fv) {
		setSize(getSize().flatten(prefix, fv));
	}
	
	public void FRecordType.flattenSize(FQName prefix, FFunctionVariable fv) {
		super.flattenSize(prefix, fv);
		for (FRecordComponentType comp : getComponents())
			comp.getFType().flattenSize(prefix, null);
	}
	
	public Size Size.flatten(FQName prefix, FFunctionVariable fv) {
		return this;
	}
	
	public MutableSize MutableSize.flatten(FQName prefix, FFunctionVariable fv) {
		MutableSize res = new MutableSize(size.length);
		System.arraycopy(size, 0, res.size, 0, size.length);
		for (int i = 0; i < exps.length; i++) {
			if (exps[i] != null) {
				res.exps[i] = exps[i].flatten(prefix);
				res.exps[i].updateFUnknownSizeExps(fv);
			}
		}
		return res;
	}
	
	/**
	 * \brief Change the variable of any FUnknownSizeExp in size to the given variable.
	 */
	public void FType.updateFUnknownSizeExps(AbstractFVariable var) {
		if (getSize() != Size.SCALAR) {
			Size s = getSize().clone();
			s.updateFUnknownSizeExps(var);
			setSize(s);
		}
	}

	/**
	 * \brief Change the variable of any FUnknownSizeExp dimension to the given variable.
	 */
	public void Size.updateFUnknownSizeExps(AbstractFVariable var) {}
	
	public void MutableSize.updateFUnknownSizeExps(AbstractFVariable var) {
		for (int i = 0; i < exps.length; i++) {
			if (exps[i] != null) {
				exps[i] = (FExp) exps[i].fullCopy();
				exps[i].updateFUnknownSizeExps(var);
			}
		}
	}
	
	/**
	 * \brief Change the variable of any FUnknownSizeExp to the given variable.
	 */
	public void FExp.updateFUnknownSizeExps(AbstractFVariable var) {
		// TODO: need better way of including exp in tree
		parent = var;
	}
	
	public void FUnknownSizeExp.updateFUnknownSizeExps(AbstractFVariable var) {
		setVariable(var);
		// TODO: need better way of including exp in tree
		parent = var;
	}

	// Generic method for flattening	
	public void ASTNode.flatten(FClass fc) {
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flatten(fc);
		}
	}
	
	public void InstNode.flatten(FClass fc) {
		for (FAbstractEquation ae : getFAbstractEquations()) {
		   ae.flatten(getFQName(),fc);
		}
		getInstComponentDeclList().flatten(fc);
		getInstExtendsList().flatten(fc);
	}
	
	public void InstComponentDecl.flatten(FClass fc) {
		if (!isDisabled()) {
			super.flatten(fc);
		}
	}
	
	public void InstClassDecl.flatten(FClass fc) {}
	
	public void InstComponentDecl.flattenInRecord(FRecordDecl frd, FClass fc) {}
	
	public void InstPrimitive.flattenInRecord(FRecordDecl frd, FClass fc) {
		frd.addFVariable(createFVariable());
	}
	
	public void InstRecord.flattenInRecord(FRecordDecl frd, FClass fc) {
		frd.addFVariable(createFVariable());
		myInstClass().flattenRecord(fc);
	}
	
	public void InstPrimitive.flatten(FClass fc) {
		if (!isDisabled()) {
			fc.addFVariable(createFVariable());
			if (isFlow()) {
				// TODO: Add expanded array subscripts
				fc.getConnectionSetManager().addInsideFlowVar(this,getFQNamePrefix().append(name()));
			}
		}
	}
	
	public void InstRecord.flatten(FClass fc) {
		fc.addFVariable(createFVariable());
		myInstClass().flattenRecord(fc);
	}
	
	public FVariable InstEnum.createFVariable() {
		FEnumVariable fv = (FEnumVariable) super.createFVariable();
		fv.setEnum(new FQName(myInstClass().qualifiedName()));
		return fv;
	}

	public void InstEnum.flatten(FClass fc) {
		myInstClass().flattenEnum(fc);
		fc.addFVariable(createFVariable());
	}
	
	public FEnumLiteral InstEnumLiteral.createFEnumLiteral() {
		FEnumLiteral e = new FEnumLiteral(new FIdUse(new FQName(name())),new Opt());
		if (getComponentDecl().getComment().hasStringComment())
			e.setFStringComment(new FStringComment(getComponentDecl().getComment().getStringComment().getComment()));
		return e;
	}

	private FClass InstClassDecl.flatEnumClassDeclAddedTo = null;
	
	public void InstClassDecl.flattenEnum(FClass fc) {		
		if (flatEnumClassDeclAddedTo != fc) {
			flatEnumClassDeclAddedTo = fc;
			// Flatten all InstEnums corresponding to FEnumLiterals
			FEnumLiteralList l = new FEnumLiteralList();
			for (InstEnumLiteral ie : enumLiterals()) 
				l.addFEnumLiteral(ie.createFEnumLiteral());
			FIdDecl id = new FIdDecl(new FQName(qualifiedName()));
			ClassDecl classDecl = getClassDecl();
			Opt comment = null;
			if (classDecl.hasStringComment()) 
				comment = new Opt(new FStringComment(classDecl.getStringComment().getComment()));
			else 
				comment = new Opt();
			fc.addFEnumDecl(new FEnumDecl(id, l, comment));	
		}
	}
	
	public abstract FVariable InstAssignable.createEmptyFVariable();
	
	public FVariable InstPrimitive.createEmptyFVariable() {
		if (isReal()) 
			return new FRealVariable();
		if (isInteger()) 
			return new FIntegerVariable();
		if (isBoolean()) 
			return new FBooleanVariable();
		if (isString()) 
			return new FStringVariable();
		return null;
	}	

	public FEnumVariable InstEnum.createEmptyFVariable() {
		return new FEnumVariable();
	}	
	
	public FVariable InstRecord.createEmptyFVariable() {
		FRecordVariable rec = new FRecordVariable();
		rec.setRecord(new FQName(myInstClass().qualifiedName()));
		return rec;
	}
	
	public void InstAssignable.addParametersToFV(List<FAttribute> attr) {}
	
	public void InstPrimitive.addParametersToFV(List<FAttribute> attr) {
		// Add default values for parameters from primitive class
		// TODO: Maybe this needs a more generalized solution? Or to be moved to instantiation step?
		PrimitiveClassDecl pcd = (PrimitiveClassDecl) myInstClass().getBaseInstClass().getClassDecl();
		for (ComponentDecl c : pcd.getComponentDecls()) {
			if (c.isParameter() && c.hasModification()) {
				FIdDecl name = new FIdDecl(new FQName(c.getName().name()));
				boolean exists = false;
				for (FAttribute a2 : attr)
					if (a2.getName().name().equals(name.name()))
						exists = true;
				if (!exists) {
					FIdUse type = new FIdUse(new FQName(c.getClassName().name()));
					FExp value = ((ValueModification) c.getModification()).getExp().instantiate();
					value = dynamicFExp(value).flatten(new FQName());
					attr.add(new FAttribute(type, name, new Opt(value), false, new Opt(), new Opt(), new List()));				
				}
			}
		}
	}
	
	public void InstAssignable.addAttributesToFV(List<FAttribute> attr) {
		AttributeExpRetriever mut = new AttributeExpRetriever() {
			public FExp retrieve(InstValueModification im, boolean isEach) {
				FExp exp = super.retrieve(im, isEach);
				InstNode decl = im.myInstNode();
				return (isEach || decl == InstAssignable.this || !enclosedBy(decl)) ? 
						exp : exp.dynamicFExp(splitBindingFExp(exp, decl));
			}
		};
		for (InstModification im : totalMergedEnvironment()) 
			im.collectAttributes(attr, im.myInstNode().getFQNamePrefix(), mut);
		addParametersToFV(attr);
	}
	
	public void InstRecord.addAttributesToFV(List<FAttribute> attr) {
		super.addAttributesToFV(attr);
		generateSizeAttributes(attr);
//		if (hasBindingFExp())
//			generateSizeAttributesFromBExp(attr, getBindingFExp());
	}
	
	public void InstComponentDecl.generateSizeAttributes(List<FAttribute> attr) {}
	
	public void InstRecord.generateSizeAttributes(List<FAttribute> attr) {
		for (InstComponentDecl icd : getInstComponentDecls()) {
			FAttribute a = findMatching(attr, icd.name());
			boolean create = (a == null);
			List<FAttribute> list = create ? new List<FAttribute>() : a.getFAttributes();
			if (!icd.declaredSize().isComplete()) // TODO: use isUnknown instead?
				list.add(new FInternalAttribute("size()", icd.size().createFExp()));
			icd.generateSizeAttributes(list);
			if (create && list.getNumChild() > 0) {
				a = new FAttribute(new FIdUse(icd.getClassName().flatten(new FQName())), 
						new FIdDecl(new FQName(icd.name())), 
						new Opt(), true, new Opt(), new Opt(), list);
				attr.add(a);
			}
		}
	}
	
	public FVariable InstAssignable.createFVariable() {
		FVariable fv = createEmptyFVariable();
		
		fv.setFVisibilityType(getComponentDecl().isPublic() ? 
				new FPublicVisibilityType() : new FProtectedVisibilityType());
		
		fv.setFTypePrefixVariability((FTypePrefixVariability) variability().fullCopy());
 		
		// Only set prefix for top level inputs and outputs
		// TODO: Make sure that prefixes specified in short class declarations are propagated
		if (isInput() && getFQName().getNumFQNamePart()==1)
			fv.setFTypePrefixInputOutput(new FInput());
		if (isOutput() && getFQName().getNumFQNamePart()==1)
			fv.setFTypePrefixInputOutput(new FOutput());
		
		addAttributesToFV(fv.getFAttributes());
		
		FExp e = flattenBindingFExp();
		if (e != null)
			fv.setBindingExp(e);
		
		if (getComponentDecl().getComment().hasStringComment())
			fv.setFStringComment(new FStringComment(getComponentDecl().getComment().getStringComment().getComment()));
				
		fv.setFQName(getFQName());
		
		return fv;
	}
	
	/**
	 * \brief Retrieve the binding expression of an InstAssignable node.
	 */
	syn FExp InstAssignable.myBindingInstExp() = hasInstValueMod() ? myInstValueMod().getFExp() : null;

	/**
	 * \brief Check if this primitive or record has a binding expression.
	 */
	syn boolean InstAssignable.hasBindingFExp() = myBindingInstExp() != null;

	/**
	 * \brief Retrieve the part of the binding expression that applies to this InstAssignable.
	 */
	syn lazy FExp InstAssignable.getBindingFExp() {
		//log.debug("In file: " + fileName() + " at line: " + beginLine() + ": " + prettyPrint(""));
		if (hasInstValueMod()) {
			InstValueModification im = myInstValueMod();
			FExp fe = im.getFExp();
			boolean hasEach = im.hasEach() || 
				(!declaredSize().isUnknown() && type().typeCompatible(fe.type()));  // Assume each if types match
			if (!hasEach && im.myInstNode() != this)
				fe = splitBindingFExp(fe, im.myInstNode());
			return (FExp) fe.unboundCopy();
		}
		return null;
	}
	
	public FExp InstAssignable.flattenBindingFExp() {
		if (hasInstValueMod()) {
			InstValueModification im = myInstValueMod();
			return getBindingFExp().flatten(im.myInstNode().getFQNamePrefix());
		}
		return null;
	}
		
	
	/**
	 * \brief Extract the part of a binding array expression that refers to this primitive or record.
	 * 
	 * Will not create new nodes unless necessary.
	 * 
	 * @param fe    the expression to split
	 * @param node  the node where the binding expression was declared 
	 */
	inh FExp InstAssignable.splitBindingFExp(FExp fe, InstNode node);
	inh FExp InstArrayComponentDecl.splitBindingFExp(FExp fe, InstNode node);
	inh FExp InstComposite.splitBindingFExp(FExp fe, InstNode node);
	
	eq InstClassDecl.getChild().splitBindingFExp(FExp fe, InstNode node) = fe;
	eq InstRoot.getChild().splitBindingFExp(FExp fe, InstNode node)      = fe;
	eq FlatRoot.getChild().splitBindingFExp(FExp fe, InstNode node)      = fe;
	eq InstArrayComponentDecl.getChild().splitBindingFExp(FExp fe, InstNode node) =
		splitBindingFExp(fe, node).splitArrayExp(getIndex());
	eq InstComposite.getChild().splitBindingFExp(FExp fe, InstNode node) =
		(node == this) ? fe : splitBindingFExp(fe, node);
	eq InstRecord.getChild().splitBindingFExp(FExp fe, InstNode node) =
		(node == this) ? fe : splitBindingFExp(fe, node);
	
	/**
	 * \brief Return the expression corresponding to the given index in this array expression. 
	 * 
	 * Will not create new nodes unless necessary.
	 */
	syn FExp FExp.splitArrayExp(int index)     = new FSubscriptedExp((FExp) unboundCopy(), index);
	eq FArray.splitArrayExp(int index)         = getFExp(index - 1);
	eq FIdUseExp.splitArrayExp(int index)      = createNode(getFIdUse().splitArrayAccess(index));
	eq FInstAccessExp.splitArrayExp(int index) = new FInstAccessExp(getInstAccess().splitArrayAccess(index));
	eq InstDerExp.splitArrayExp(int index)     = new InstDerExp(getFExp().splitArrayExp(index));
	eq FSubscriptedExp.splitArrayExp(int index) {
		FSubscriptedExp exp = (FSubscriptedExp) unboundCopy();
		exp.getFArraySubscripts().specifyNext(index);
		return exp;
	}
	// TODO: consider if expressions
	
	/**
	 * \brief Return a new access that has index instead of the first array subscript 
	 *        with ndims() > 1.
	 * 
	 * If access has no subscripts, a set of subscripts with all colons is first created.
	 */
	syn FIdUse FIdUse.splitArrayAccess(int index) {
		FIdUse use = (FIdUse) fullCopy();
		if (hasFArraySubscripts()) {
			use.getFArraySubscripts().specifyNext(index);
		} else {
			FArraySubscripts fas = FArraySubscripts.createFColonSubscripts(ndims());
			use.getFQName().lastFQNamePart().setFArraySubscripts(fas);
			fas.specifyNext(index);
		}
		return use;
	}
	syn InstAccess InstAccess.splitArrayAccess(int index) = this;
	eq InstDot.splitArrayAccess(int index) {
		InstAccess left, right;
		if (getLeft().isArray()) {
			left = getLeft().splitArrayAccess(index);
			right = (InstAccess) getRight().fullCopy();
		} else {
			left = (InstAccess) getLeft().fullCopy();
			right = getRight().splitArrayAccess(index);
		}
		return new InstDot(getID(), left, right);
	}
	eq InstArrayAccess.splitArrayAccess(int index) {
		InstArrayAccess access = (InstArrayAccess) fullCopy();
		if (hasFArraySubscripts()) {
			access.getFArraySubscripts().specifyNext(index);
		} else {
			FArraySubscripts fas = FArraySubscripts.createFColonSubscripts(localNdims());
			access.setFArraySubscripts(fas);
			fas.specifyNext(index);
		}
		return access;
	}
	
	public void FArraySubscripts.specifyNext(int index) {
		for (int i = 0; i < getNumFSubscript(); i++) {
			if (getFSubscript(i).ndims() > 0) {
				setFSubscript(getFSubscript(i).specify(index), i);
				return;
			}
		}
	}
	
	syn FSubscript FSubscript.specify(int index);
	eq FExpSubscript.specify(int index)   = this; // TODO: add array index to expression
	eq FColonSubscript.specify(int index) = new FExpSubscript(new FIntegerLitExp(index));

	// TODO: The names here needs to be clearer. (Down to and including getInstValueMod().)
	/**
	 * \brief Check if the binding expression of an InstAssignable node is set 
	 *        through a modification that is declared "each".
	 */
	syn lazy boolean InstAssignable.myBindingExpHasEach() {
		return hasInstValueMod() ? myInstValueMod().hasEach() : false;
	}
	
	/**
	 * \brief Check if this InstAssignable node has an InstModification setting 
	 *        its binding expression.
	 */
	syn boolean InstAssignable.hasInstValueMod() = (myInstValueMod() != null);
	
	/**
	 * \brief Retrieve the InstModification setting the binding expression of 
	 *        this InstAssignable node.
	 */
	syn lazy InstValueModification InstAssignable.myInstValueMod() {
		for (InstModification im : totalMergedEnvironment()) 
			if (im.hasInstValueMod()) 
				return im.getInstValueMod();
		return null;
	}

	/**
	 * \brief Check if this InstValueModification is part of a modification 
	 *        that is declared "each".
	 */
	inh boolean InstValueModification.hasEach();
	eq InstArgument.getChild().hasEach()          = getEach();
	eq InstNode.getChild().hasEach()              = false;
	eq InstArrayModification.getChild().hasEach() = true;
	syn boolean InstArrayModification.hasEach()   = true;
	
	/**
	 * \ingroup aspect_Flattening
	 * 
	 * Check if a modification has a value modification.
	 */
	syn boolean InstModification.hasInstValueMod() = false;

	/**
	 * \ingroup aspect_Flattening
	 * 
	 * Check if a modification has a value modification. True for
	 * InstValueModification.
	 */
	eq InstValueModification.hasInstValueMod() = true;
	
	/**
	 * \ingroup aspect_Flattening
	 * 
	 * Check if a modification has a value modification. Delegate computation
	 * to son.
	 */
	eq InstCompleteModification.hasInstValueMod() = hasInstValueModification();
	
	syn FExp InstModification.instValueMod()   = null;
	eq InstValueModification.instValueMod()    = getFExp();
	eq InstCompleteModification.instValueMod() = getInstValueModification().getFExp();
	
	syn InstValueModification InstModification.getInstValueMod() = null;
	eq InstValueModification.getInstValueMod()    = this;
	eq InstCompleteModification.getInstValueMod() = getInstValueModification();
	
	/**
	 * \brief Delegate object that retrieves the FExp of an InstValueModification, and 
	 *        possibly alters it.
	 * 
	 * Default implementation only retrieves the expression.
	 */
	public class AttributeExpRetriever {
		public FExp retrieve(InstValueModification im, boolean isEach) { return im.instValueMod(); }
		public static final AttributeExpRetriever DEFAULT = new AttributeExpRetriever();
	}

	public void ASTNode.collectAttributes(List<FAttribute> attrs, FQName prefix, AttributeExpRetriever aer) {
		for (int i = 0; i < getNumChild(); i++)
			getChild(i).collectAttributes(attrs, prefix, aer);
	}

	// This is just to avoid collecting ComponentModification:s that resides inside
	// ClassRedeclares.
    public void InstClassRedeclare.collectAttributes(List<FAttribute> attrs, FQName prefix, AttributeExpRetriever aer) {}

	public void InstComponentModification.collectAttributes(List<FAttribute> attrs, FQName prefix, AttributeExpRetriever aer) {
		if (hasInstModification()) {
			FQName fqn = new FQName(new List().add(new FQNamePart(getName().getID(),new Opt())));
            boolean attr_set = false;
            // Check if attribute is already set
            for (int i = 0; !attr_set && i < attrs.getNumChild(); i++)
            	if (attrs.getChild(i).getName().name().equals(getName().name()))
					attr_set = true;
            // If attribute is not set, add to list
			if (!attr_set) {
				List<FAttribute> my_attr = new List<FAttribute>();
				getInstModification().collectAttributes(my_attr, prefix, aer);
				FQName fqn2 = new FQName();
				fqn2.addFQNamePart(getName().myInstComponentDecl().myInstClass().name());
				boolean isEach  = getComponentModification().hasEach();
				boolean isFinal = getComponentModification().hasFinal();
				Opt oe;
				if (getInstModification().hasInstValueMod()) {
					InstValueModification im = getInstModification().getInstValueMod();
					oe = new Opt(aer.retrieve(im, isEach).flatten(prefix));
				} else {
					oe = new Opt();
				}
				attrs.add(new FAttribute(new FIdUse(fqn2),
									new FIdDecl(fqn),
			                        oe,
			                        true,
			                        isEach ? new Opt(new FEach()) : new Opt(),
			                        isFinal ? new Opt(new FFinal()) : new Opt(),
			                   		my_attr));
			}
		}
	}
}

aspect FlatteningDebug {
	coll HashSet<InstAccess> FClass.collectInstAccesses() [new HashSet<InstAccess>()] with add root FlatRoot;
	InstAccess contributes
 		this 
	to FClass.collectInstAccesses() for myFClass();
    inh FClass InstAccess.myFClass();

}


aspect InstNodeInterface {

	syn ArraySubscripts InstComponentDecl.arraySubscripts() = 
		getComponentDecl().arraySubscripts()!=null?
			getComponentDecl().arraySubscripts(): null;

}

aspect FlatExpressions {

	public void FAbstractEquation.flatten(FQName prefix, FClass fc) {
		FAbstractEquation eqn = flattenEqn(prefix, fc);
		if (eqn != null)
			getType().addEquationTo(fc, eqn);
	}
	
	public FEquationType FEquationType.flatten(FQName prefix) {
		return (FEquationType) fullCopy();
	}
	
	abstract public void FEquationType.addEquationTo(FClass fc, FAbstractEquation f);
	
	public void FNormalEquation.addEquationTo(FClass fc, FAbstractEquation f) {
		fc.getFEquationBlock(0).addFAbstractEquation(f);
	}
	
	public void FInitialEquation.addEquationTo(FClass fc, FAbstractEquation f) {
		fc.addFInitialEquation(f);
	}

	public FAbstractEquation FAbstractEquation.flattenEqn(FQName prefix, FClass fc) {
		return (FAbstractEquation) fullCopy();
	}

	public FEquation FEquation.flattenEqn(FQName prefix, FClass fc) {
		return new FEquation(getType().flatten(prefix), getLeft().flatten(prefix), getRight().flatten(prefix));
	}

	public FForClauseE InstForClauseE.flattenEqn(FQName prefix, FClass fc) {
		List forIndex = new List();
		List eqns = new List();
		for (InstForIndex ifi : getInstForIndexs()) 
			forIndex.add(ifi.flatten(prefix));
		for (FAbstractEquation ae : getFAbstractEquations())
			eqns.add(ae.flattenEqn(prefix, fc));
		return new FForClauseE(forIndex, eqns);
	}

	public FIfWhenElseEquation FIfWhenElseEquation.flattenEqn(FQName prefix, FClass fc) {
		FIfWhenElseEquation res = createEmptyNode();
		res.setType((FEquationType) getType().fullCopy());
		for (FAbstractEquation ae : getFAbstractEquations())
			res.addFAbstractEquation(ae.flattenEqn(prefix, fc));
		return res;
	}

	public FIfWhenEquation FIfWhenEquation.flattenEqn(FQName prefix, FClass fc) {
		FIfWhenEquation res = (FIfWhenEquation) super.flattenEqn(prefix, fc);
		if (hasElse())
			res.setElse(getElse().flattenEqn(prefix, fc));
		res.setTest(getTest().flatten(prefix));
		return res;
	}

	public FAbstractEquation FConnectClause.flattenEqn(FQName prefix, FClass fc) {
		if (!getConnector1().isDisabled() && !getConnector2().isDisabled()) {
			InstAccess left  = getConnector1().getInstAccess();
			InstAccess right = getConnector2().getInstAccess();
			left.connectTo(right, prefix, fc.getConnectionSetManager());
		}
		return null;
	}
	
	public FFunctionCallEquation FFunctionCallEquation.flattenEqn(FQName prefix, FClass fc) {
		List<FFunctionCallLeft> lefts = new List<FFunctionCallLeft>();
		for (FFunctionCallLeft l : getLefts()) 
			lefts.add(l.flatten(prefix));
		return new FFunctionCallEquation(getType().flatten(prefix), lefts, getCall().flatten(prefix));
	}
	
	public FFunctionCallLeft FFunctionCallLeft.flatten(FQName prefix) {
		return new FFunctionCallLeft(hasFExp() ? new Opt(getFExp().flatten(prefix)) : new Opt());
	}

	public FAlgorithmBlock FAlgorithmBlock.flattenEqn(FQName prefix, FClass fc) {
		List l = FStatement.flattenFStatementList(prefix, getFStatements());
		return new FAlgorithmBlock(l);
	}
	
	public static List<FStatement> FStatement.flattenFStatementList(FQName prefix, List<FStatement> l) {
		List<FStatement> l2 = new List<FStatement>();
		for (FStatement s : l) 
			l2.add(s.flatten(prefix));
		return l2;
	}
	
	public abstract FStatement FStatement.flatten(FQName prefix);
	
	public FAssignStmt InstAssignStmt.flatten(FQName prefix) {
		return new FAssignStmt(getLeft().flatten(prefix), 
				               getRight().flatten(prefix));
	}
	
	public FFunctionCallStmt FFunctionCallStmt.flatten(FQName prefix) {
		List<FFunctionCallLeft> l = new List<FFunctionCallLeft>();
		for (FFunctionCallLeft a : getLefts())
			l.add(a.flatten(prefix));
		return new FFunctionCallStmt(l, getCall().flatten(prefix));
	}
	
	public FIfWhenStmt FIfWhenStmt.flatten(FQName prefix) {
		List l = new List();
		for (FIfWhenClause c : getFIfWhenClauses()) 
			l.add(c.flatten(prefix));
		return flattenFIfWhenStmt(prefix, l);
	}
	
	protected abstract FIfWhenStmt FIfWhenStmt.flattenFIfWhenStmt(FQName prefix, List l);
	
	protected FIfStmt FIfStmt.flattenFIfWhenStmt(FQName prefix, List icl) {
		List esl = FStatement.flattenFStatementList(prefix, getElseStmts());
		return new FIfStmt(icl, esl);
	}
	
	protected FWhenStmt FWhenStmt.flattenFIfWhenStmt(FQName prefix, List l) {
		return new FWhenStmt(l);
	}
	
	public FIfWhenClause FIfWhenClause.flatten(FQName prefix) {
		FExp t = getTest().flatten(prefix);
		List l = FStatement.flattenFStatementList(prefix, getFStatements());
		return flattenFIfWhenClause(t, l);
	}
	
	protected abstract FIfWhenClause FIfWhenClause.flattenFIfWhenClause(FExp t, List l);
	
	protected FIfClause FIfClause.flattenFIfWhenClause(FExp t, List l) {
		return new FIfClause(t, l);
	}
	
	protected FWhenClause FWhenClause.flattenFIfWhenClause(FExp t, List l) {
		return new FWhenClause(t, l);
	}
	
	public FForStmt FForStmt.flatten(FQName prefix) {
		return (FForStmt)(this.fullCopy());
	}
		
	public FForStmt InstForStmt.flatten(FQName prefix) {
		List sl = FStatement.flattenFStatementList(prefix, getForStmts());
		int i = getNumInstForIndex() - 1;
		FForStmt res = new FForStmt(getInstForIndex(i).flatten(prefix), sl);
		for (i--; i >= 0; i--) {
			sl = new List().add(res);
			res = new FForStmt(getInstForIndex(i).flatten(prefix), sl);
		}
		return res;		
	}

	
	public FWhileStmt FWhileStmt.flatten(FQName prefix) {
		List l = FStatement.flattenFStatementList(prefix, getWhileStmts());
		return new FWhileStmt(getTest().flatten(prefix), l);
	}
	
	public FBreakStmt FBreakStmt.flatten(FQName prefix)   { return new FBreakStmt(); }
	public FReturnStmt FReturnStmt.flatten(FQName prefix) { return new FReturnStmt(); }
	
	public FAssignStmt FAssignStmt.flatten(FQName prefix)             { return null; }

	public FArraySubscripts FArraySubscripts.flatten(FQName prefix) {
		List l = new List();
		for (int i=0;i<getNumFSubscript();i++)
			l.add(getFSubscript(i).flatten(prefix));
		return new FArraySubscripts(l);
	}
	
	abstract public FSubscript FSubscript.flatten(FQName prefix);
	public FSubscript FColonSubscript.flatten(FQName prefix) { 
		return new FColonSubscript();
	}
	
	public FSubscript FExpSubscript.flatten(FQName name) {
		return new FExpSubscript(getFExp().flatten(name));
	}
	
	public FExp FExp.flatten(FQName prefix) {
		return null;
	}
	
	public FIgnoredBuiltIn FIgnoredBuiltIn.flatten(FQName prefix) {
		return new FIgnoredBuiltIn();
	}

    public FIdUse FIdUse.flatten(FQName prefix) {
    	return (FIdUse)fullCopy();
    }
    
    public FExp FIdUseExp.flatten(FQName prefix) {
    	// TODO: Replace with constant exp for constants? Do this for FExp in general instead?
		return new FIdUseExp(getFIdUse().flatten(prefix));
    }

	public FExp FInstAccessExp.flatten(FQName prefix) {
		// If the FInstAccess referes to a constant, then inline expression
		// Checks in the instance tree ensures that constants always
		// have binding expressions, however, array subscripts may need to be 
		// flattened during error checks, when using qualifiedName()
		InstAccess ia = getInstAccess();
		if (ia.myInstComponentDecl() instanceof InstAssignable) {
			InstAssignable var = (InstAssignable) ia.myInstComponentDecl();
			if (var.isConstant()) {
				try {
					// Check if we have non-constant array subscripts
					if (ia.hasUnknownIndices()) {
						if (inFunction()) {
							// Add the constant array to the function and keep the access
							functionConstantList().add(var);
							FQName fqn = new FQName(var.getFQName());
							fqn.setLastFArraySubscripts(ia.getFArraySubscripts().flatten(prefix));
							return new FIdUseExp(fqn);
						} else {
							// Inline entire array wrapped in an FSubscriptedExp, and resolve index later
							FExp exp = var.getBindingFExp().getArray().buildLiteral(var.isReal());
							FArraySubscripts fas = ia.getFArraySubscripts().flatten(prefix);
							return new FSubscriptedExp(exp, fas);
						}
					} else {
						// Inline value
						CValue cval = ceval();
						if (var.isReal())
							cval = cval.convertReal();
						return cval.buildLiteral();
					}
				} catch (ConstantEvaluationException e) {
					// In this case, simply don't inline value
					// TODO: Really? isn't this an error?
				}
			}
		} 
		return new FIdUseExp(getInstAccess().flatten(prefix));
	}
	
	/**
	 * \brief Get the list of constants that need to be added to the surrounding function.
	 */
	inh ArrayList<InstAssignable> FInstAccessExp.functionConstantList();
	eq InstClassDecl.getChild().functionConstantList() = localFunctionConstantList();
	eq Root.getChild().functionConstantList() = null;
	
	/**
	 * \brief The list of constants that need to be added to this function.
	 * 
	 * The list will be populated when expressions in the function are flattened.
	 */
	syn lazy ArrayList<InstAssignable> InstClassDecl.localFunctionConstantList() = 
		new ArrayList<InstAssignable>();
	
	syn boolean InstAccess.hasUnknownIndices() = 
		hasFArraySubscripts() && getFArraySubscripts().hasUnknownIndices(); 
	
	syn lazy boolean FArraySubscripts.hasUnknownIndices() {
		for (FSubscript fs : getFSubscripts())
			if (fs.isUnknownIndex())
				return true;
		return false;
	}
	
	syn boolean FSubscript.isUnknownIndex() {
		try {
			return ceval().intValue() == 0;
		} catch (ConstantEvaluationException e) {
			return true;
		}
	}
	// TODO: this doesn't seem to cover arrays of unknown size
	eq FColonSubscript.isUnknownIndex() = false;
	
	public FQName InstAccess.flatten(FQName prefix) { 
		if (myInstComponentDecl().isEnumLiteral())
			return new FQName(myInstComponentDecl().getFQName());
		
		FQName myName = isForIndex() ? new FQName() : new FQName(prefix);
		ArrayList<FArraySubscripts> fasl = allFArraySubscripts();
		InstAccess cur = getFirstInstAccess();
		int last = fasl.size() - 1;
		boolean func = inFunction();
		boolean size = inSizeExp();
		for (int i = 0; i <= last; i++, cur = cur.getNextInstAccess()) {
			FArraySubscripts fas = fasl.get(i);
			boolean empty = fas.getNumFSubscript() == 0;
			if (!empty && !cur.hasFArraySubscripts()) {
				/* TODO: This is a temporary fix to make the slices code play nice 
				 *        with functions - it will probably need to be replaced with 
				 *        a more permanent fix later. See #741. */
				if (func && i == last)
					empty = true;
		        /* This prevents a potential infinite recursion, see #1150. */
				if (size)
					empty = true;
			}
			Opt as = empty ? new Opt() : new Opt(fas.flatten(prefix));
			myName.addFQNamePart(new FQNamePart(cur.name(), as));
		}
		return myName;
	}
	
	inh boolean InstAccess.inSizeExp();
	eq FSizeExp.getChild().inSizeExp() = true;
	eq InstNode.getChild().inSizeExp() = false;
	eq Root.getChild().inSizeExp()     = false;

	public FIdUse FIdUseInstAccess.flatten(FQName prefix) {
	   return new FIdUse(getInstAccess().flatten(prefix));
	}

	public FExp FArray.flatten(FQName prefix) {
	   List l = new List();
	   for (FExp exp : getFExps())
	   	 l.add(exp.flatten(prefix));
	   return createNode(l);
	}
	
	public FSumExp FSumExp.flatten(FQName prefix) {
		return new FSumExp(getFExp().flatten(prefix));
	}
	
	public FExp FIterExp.flatten(FQName prefix) {
		List<CommonForIndex> fil = new List<CommonForIndex>();
		for (CommonForIndex fi : getForIndexList())
			fil.add(fi.flatten(prefix));
		return new FIterExp(getFExp().flatten(prefix), fil);
	}

	public FExp FSubscriptedExp.flatten(FQName prefix) {
		return new FSubscriptedExp(getFExp().flatten(prefix), getFArraySubscripts().flatten(prefix));
	}

	public FIdDecl FIdDecl.flatten(FQName prefix) {
		return (FIdDecl)fullCopy();
	}

	public FExp FRangeExp.flatten(FQName prefix) {
		List l = new List();
		for (FExp e : getFExps())
			l.add(e.flatten(prefix));
		return new FRangeExp(l);
	}

	public FLinspace FLinspace.flatten(FQName prefix) {
		return new FLinspace(getStartExp().flatten(prefix), 
				             getStopExp().flatten(prefix), 
				             getN().flatten(prefix));
	}

    public FExp FIfExp.flatten(FQName prefix) {
		List etl = new List();
		for (int i=0;i<getNumFElseIfExp();i++) {
			etl.add(getFElseIfExp(i).flatten(prefix));
		}
		return new FIfExp(getIfExp().flatten(prefix),
		                  getThenExp().flatten(prefix),
		                  etl,
		                  getElseExp().flatten(prefix));
	}
	
	public FExp FElseIfExp.flatten(FQName prefix) {
		return new FElseIfExp(getIfExp().flatten(prefix),
		                      getThenExp().flatten(prefix));
	}
	

	public FExp FBinExp.flatten(FQName prefix)     { return createNode(getLeft().flatten(prefix), getRight().flatten(prefix)); }
	public FExp FUnaryExp.flatten(FQName prefix)   { return createNode(getFExp().flatten(prefix)); }
	public FExp FLitExp.flatten(FQName prefix)     { return (FLitExp) fullCopy(); }
	public FExp FEnumLitExp.flatten(FQName prefix) { return new FEnumLitExp(getEnum(), getValue(), null); }
	
	public abstract FAbstractFunctionCall FAbstractFunctionCall.flatten(FQName prefix);
	public abstract FBuiltInFunctionCall  FBuiltInFunctionCall.flatten(FQName prefix);
	
	public FBuiltInFunctionCall FUnaryBuiltIn.flatten(FQName prefix)             { return createNode(getFExp().flatten(prefix)); }
	public FBuiltInFunctionCall FMathematicalFunctionCall.flatten(FQName prefix) { return createNode(getFExp().flatten(prefix)); }
	public FAtan2Exp            FAtan2Exp.flatten(FQName prefix)                 { return new FAtan2Exp(getFExp().flatten(prefix), getY().flatten(prefix)); }
	
	public FUnsupportedBuiltIn FUnsupportedBuiltIn.flatten(FQName prefix) { return null; }
	
	// These used to delegate to standard implementation for FExp.flatten(FQName).
	public FScalar FScalar.flatten(FQName prefix) { return null; }
	
	public FCross     FCross.flatten(FQName prefix)     { return new FCross(getX().flatten(prefix), getY().flatten(prefix)); }
	public FSampleExp FSampleExp.flatten(FQName prefix) { return new FSampleExp(getSample().flatten(prefix), getInterval().flatten(prefix)); }
	
	public FMinMaxExp FMinMaxExp.flatten(FQName prefix) { 
		return createNode(getX().flatten(prefix), hasY() ? getY().flatten(prefix) : null); 
	}
	
	public FSizeExp FSizeExp.flatten(FQName prefix) {
		Opt<FExp> dim = hasDim() ? new Opt<FExp>(getDim().flatten(prefix)) : new Opt<FExp>();
		return new FSizeExp(getFExp().flatten(prefix), dim); 
	}
	
	public FUnknownSizeExp FUnknownSizeExp.flatten(FQName prefix) {
		return new FUnknownSizeExp(null, getDim());
	}
	
	public FDerExp InstDerExp.flatten(FQName prefix) {
		/* This should only ever be called on InstDerExps that has an FInstAccessExp 
		 * as its FExp. All more complex "der()" expressions should have been either 
		 * rewritten in the instance tree or have generated an error during checks. 
		 */
		FQName var = ((FInstAccessExp) getFExp()).getInstAccess().flatten(prefix);
		return new FDerExp(new FIdUse(var));
	}
	
	public FInfArgsFunctionCall FInfArgsFunctionCall.flatten(FQName prefix) {
		List<FExp> l = new List<FExp>();
		for (FExp e : getFExps()) 
			l.add(e.flatten(prefix));
		return createNode(l); 
	}
	
	public FFillExp FFillExp.flatten(FQName prefix) {
		FFillExp res = (FFillExp) super.flatten(prefix);
		res.setFillExp(getFillExp().flatten(prefix));
		return res;
	}
	
	public FCatExp FCatExp.flatten(FQName prefix) {
		FCatExp res = (FCatExp) super.flatten(prefix);
		res.setDim(getDim().flatten(prefix));
		return res;
	}
	
	public FTimeExp FTimeExp.flatten(FQName prefix) { return new FTimeExp(); }
	public FEndExp  FEndExp.flatten(FQName prefix)  { return new FEndExp(); }
	
	public FRecordConstructor FRecordConstructor.flatten(FQName prefix) {
		List args = new List();
		for (FExp e : getArgs()) 
			args.add(e.flatten(prefix));
		return new FRecordConstructor(getRecord().flattenRecordName(), args);		
	}
	
	public FIdUse FIdUse.flattenRecordName() {
		return flatten(new FQName());
	}
	
	public FIdUse FIdUseInstAccess.flattenRecordName() {
		return new FIdUse(getInstAccess().myInstClassDecl().qualifiedName());
	}
	
	public FFunctionCall FFunctionCall.flatten(FQName prefix) {
		List args = new List();
		for (FExp e : getArgs()) 
			args.add(e.flatten(prefix));
		return new FFunctionCall(getName().flatten(new FQName()), args, getSizes());		
	}

	public FFunctionCall InstFunctionCall.flatten(FQName prefix) {
		List args = new List();
		for (InstFunctionArgument e : getArgs()) 
			args.add(e.flatten(prefix));
		FIdUse name = new FIdUse(new FQName(getName().myInstClassDecl().qualifiedName()));
		Size[] sizes = new Size[myOutputs().size()];
		if (isFunctionCallClause()) 
			for (int i = 0; i < myLefts().size(); i++)
				sizes[i] = myLefts().get(i).hasFExp() ? sizeOfOutput(i) : null;
		else
			sizes[0] = size();
		return new FFunctionCall(name, args, sizes);	
	}

	public FExp InstFunctionArgument.flatten(FQName prefix) {
		return getFExp().flatten(prefix);
	}
	
	public abstract FForIndex CommonForIndex.flatten(FQName prefix);
	
	public FForIndex InstForIndex.flatten(FQName prefix) {
		return new FForIndex(hasFExp()? new Opt(getFExp().flatten(prefix)): new Opt(),
				getInstPrimitive().createFVariable());
	}
	
	public FForIndex FForIndex.flatten(FQName prefix) {
		return (FForIndex) fullCopy();
	}
	
	/**
	 * \brief Creates a flattened access to this component.
	 */
	public FQName InstComponentDecl.flattenedAccess(FQName prefix) {
		FQName fqn = prefix.copyAndAppend(name());
		if (expandedSubscripts().getNumFSubscript() > 0)
			fqn.setLastFArraySubscripts(expandedSubscripts());
		return fqn;
	}

}

aspect InstantiatedExpressions {

	public FEquationType AbstractEquation.equationType() {
		return isInitial() ? new FInitialEquation() : new FNormalEquation();
	}

	public FEquationType Algorithm.equationType() {
		return hasInitial() ? new FInitialEquation() : new FNormalEquation();
	}

	public FAbstractEquation AbstractEquation.instantiate() {
		return copyLocationTo(new FUnsupportedEquation(equationType()));
	}

	public FAbstractEquation Equation.instantiate() {
		return copyLocationTo(new FEquation(equationType(), 
				getLeft().instantiate(), getRight().instantiate()));
	}

	public FAbstractEquation ConnectClause.instantiate() {
	    Opt o = null;
	    if (getComment().hasStringComment())
		   o = new Opt(new FStringComment(getComment().getStringComment().getComment()));
	    else
	    	o = new Opt();
		FConnectClause c = new FConnectClause(equationType(), o, 
				new FIdUseInstAccess(new FQName(), getConnector1().newInstAccess()),
				new FIdUseInstAccess(new FQName(), getConnector2().newInstAccess()));
		c.setLocation(this);
		return c;
	}
	
	protected FIfWhenElseEquation IfWhenElseEquation.instantiate(FIfWhenElseEquation res) {
		res.setType(equationType());
		for (AbstractEquation eqn : getAbstractEquations())
			res.addFAbstractEquation(eqn.instantiate());
		res.setLocation(this);
		return res;
	}
	
	protected FIfWhenEquation IfWhenEquation.instantiate(FIfWhenEquation res) {
		super.instantiate(res);
		res.setTest(getTest().instantiate());
		if (hasElse())
			res.setElse(getElse().instantiate());
		return res;
	}
	
	public abstract FIfWhenElseEquation IfWhenElseEquation.instantiate();
	
	public FIfWhenElseEquation IfEquation.instantiate() {
		return instantiate(new FIfEquation());
	}
	
	public FIfWhenElseEquation WhenEquation.instantiate() {
		return instantiate(new FWhenEquation());
	}
	
	public FIfWhenElseEquation ElseEquation.instantiate() {
		return instantiate(new FElseEquation());
	}
		
	public FFunctionCallEquation FunctionCallEquation.instantiate() {
		List<FFunctionCallLeft> l = new List<FFunctionCallLeft>();
		for (FunctionCallLeft a : getLefts()) 
			l.add(a.instantiate());
		return copyLocationTo(new FFunctionCallEquation(equationType(), l, getCall().instantiate()));
	}
	
	public 	FFunctionCallLeft FunctionCallLeft.instantiate() {
		Opt id = hasAccess() ? 
				new Opt(new FIdUseExp(new FIdUseInstAccess(new FQName(), getAccess().newInstAccess()))) : 
				new Opt();
		return new FFunctionCallLeft(id);
	}
	
	public FAlgorithmBlock Algorithm.instantiate() {
		List l = Statement.instantiateStatementList(getStatements());
		return copyLocationTo(new FAlgorithmBlock(equationType(), l));
	}
	
	public InstExternal ExternalClause.instantiate() {
		// TODO: Interpret annotations and add information to InstExternal
		Opt lang = hasExternalLanguage() ? new Opt(getExternalLanguage().instantiate()) : new Opt();
		Opt call = hasExternalFunctionCall() ? new Opt(getExternalFunctionCall().instantiate()) : new Opt();
		return copyLocationTo(new InstExternal(this, lang, call));
	}
	
	public static final String FCExternalLanguage.LANGUAGE_STRING         = "C";
	public static final String FFortran77ExternalLanguage.LANGUAGE_STRING = "FORTRAN 77";
	public static final String FBuiltinExternalLanguage.LANGUAGE_STRING   = "builtin";
	
	public FExternalLanguage ExternalLanguage.instantiate() {
		String lang = getLanguage();
		if (lang.equals(FCExternalLanguage.LANGUAGE_STRING))
			return new FCExternalLanguage();
		else if (lang.equals(FFortran77ExternalLanguage.LANGUAGE_STRING))
			return new FFortran77ExternalLanguage();
		else if (lang.equals(FBuiltinExternalLanguage.LANGUAGE_STRING))
			return new FBuiltinExternalLanguage();
		else 
			return new FUnknownExternalLanguage(lang);
	}
	
	public InstExternalCall ExternalFunctionCall.instantiate() {
		InstExternalCall res = new InstExternalCall();
		if (hasReturnVar())
			res.setReturnVar(getReturnVar().newInstAccess());
		res.setName(getFunctionName().name());
		for (Exp e : getArgs())
			res.addArg(e.instantiate());
		return res;
	}
	
	public static List Statement.instantiateStatementList(List<Statement> l) {
		List l2 = new List();
		for (Statement s : l) 
			if (!(s instanceof AlgorithmAnnotation))
				l2.add(s.instantiate());
		return l2;
	}
	
	public FStatement Statement.instantiate() {
		FStatement s = instantiateStatement();
		s.setLocation(this);
		return s;
	}
	
	protected abstract FStatement Statement.instantiateStatement();
	
	protected FStatement AlgorithmAnnotation.instantiateStatement() {
		return null;
	}
	
	protected InstAssignStmt AssignStmt.instantiateStatement() {
		FIdUseInstAccess left = new FIdUseInstAccess(new FQName(), getLeft().newInstAccess());
		return new InstAssignStmt(left, getRight().instantiate());
	}
	
	protected FFunctionCallStmt FunctionCallStmt.instantiateStatement() {
		List<FFunctionCallLeft> l = new List<FFunctionCallLeft>();
		for (FunctionCallLeft a : getLefts()) 
			l.add(a.instantiate());
		return new FFunctionCallStmt(l, getFunctionCall().instantiate());
	}
	
	protected FBreakStmt BreakStmt.instantiateStatement() {
		return new FBreakStmt();
	}
	
	protected FReturnStmt ReturnStmt.instantiateStatement() {
		return new FReturnStmt();
	}
	
	protected FIfWhenStmt IfWhenStmt.instantiateStatement() {
		List l = new List();
		for (IfWhenClause c : getIfWhenClauses()) 
			l.add(c.instantiate());
		return instantiateIfWhenStmt(l);
	}
	
	protected abstract FIfWhenStmt IfWhenStmt.instantiateIfWhenStmt(List l);
	
	protected FIfStmt IfStmt.instantiateIfWhenStmt(List icl) {
		List esl = Statement.instantiateStatementList(getElseStmts());
		return new FIfStmt(icl, esl);
	}
	
	protected FWhenStmt WhenStmt.instantiateIfWhenStmt(List l) {
		return new FWhenStmt(l);
	}
	
	public FIfWhenClause IfWhenClause.instantiate() {
		FExp t = getTest().instantiate();
		List l = Statement.instantiateStatementList(getStatements());
		FIfWhenClause c = instantiateIfWhenClause(t, l);
		c.setLocation(this);
		return c;
	}
	
	protected abstract FIfWhenClause IfWhenClause.instantiateIfWhenClause(FExp t, List l);
	
	protected FIfClause IfClause.instantiateIfWhenClause(FExp t, List l) {
		return new FIfClause(t, l);
	}
	
	protected FWhenClause WhenClause.instantiateIfWhenClause(FExp t, List l) {
		return new FWhenClause(t, l);
	}
	
	
	protected InstForStmt ForStmt.instantiateStatement() {
		List il = new List();
		for (ForIndex i : getForIndexList()) 
			il.add(i.instantiate());
		List sl = Statement.instantiateStatementList(getForStmts());
		return new InstForStmt(il, sl);
	}
	
	protected FWhileStmt WhileStmt.instantiateStatement() {
		List l = Statement.instantiateStatementList(getWhileStmts());
		return new FWhileStmt(getTest().instantiate(), l);
	}

	public FArraySubscripts ArraySubscripts.instantiate() {
		List l = new List();
		for (Subscript s : getSubscripts())
			l.add(s.instantiate());
		return copyLocationTo(new FArraySubscripts(l));
	}
	
	abstract public FSubscript Subscript.instantiate();
	public FSubscript ColonSubscript.instantiate() { 
		return copyLocationTo(new FColonSubscript());
	}
	
	public FSubscript ExpSubscript.instantiate() {
		return copyLocationTo(new FExpSubscript(getExp().instantiate()));
	}
	
	public FExp Exp.instantiate() {
		return copyLocationTo(new FUnsupportedExp());
	}

	
	public InstDerExp DerExp.instantiate() {
		return copyLocationTo(new InstDerExp(getExp().instantiate()));
	}
	

	public FExp AccessExp.instantiate() {
		return copyLocationTo(new FInstAccessExp(getAccess().newInstAccess()));
	}


	public InstAccess Access.instantiate() { 
		return copyLocationTo(newInstAccess());
	}

	public FExp ArrayConstructor.instantiate() {
	   List l = new List();
	   for (Exp e : getFunctionArguments().getExps())
		   l.add(e.instantiate());
	   return copyLocationTo(new FArray(l));
	}
	
	public FExp IterExp.instantiate() {
		List<CommonForIndex> ifil = new List<CommonForIndex>();
		for (ForIndex fi : getForIndexList())
			ifil.add(fi.instantiate());
		return copyLocationTo(new FIterExp(getExp().instantiate(), ifil));
	}

	public FExp RangeExp.instantiate() {
		List l = new List();
		for (Exp e : getExps()) 
			l.add(e.instantiate());
		return copyLocationTo(new FRangeExp(l));
	}

    public FExp IfExp.instantiate() {
		List etl = new List();
		for (ElseIfExp e : getElseIfExps()) 
			etl.add(e.instantiate());
		FIfExp n = new FIfExp(getIfExp().instantiate(),
		                  getThenExp().instantiate(),
		                  etl,
		                  getElseExp().instantiate());
		return copyLocationTo(n);
    }
	
	public FExp ElseIfExp.instantiate() {
		FElseIfExp n = new FElseIfExp(getIfExp().instantiate(),
		                      getThenExp().instantiate());
		return copyLocationTo(n);
	}

	public FExp Matrix.instantiate() {
		FMatrix m = new FMatrix();
		for (MatrixRow r : getRows())
			m.addFExp(r.instantiate());
		return copyLocationTo(m);
	}
	
	public FMatrixRow MatrixRow.instantiate() {
		FMatrixRow r = new FMatrixRow();
		for (Exp e : getExps())
			r.addFExp(e.instantiate());
		return copyLocationTo(r);
	}
	
	public FExp AddExp.instantiate() { 
		return copyLocationTo(new FAddExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp SubExp.instantiate() { 
		return copyLocationTo(new FSubExp(getLeft().instantiate(),getRight().instantiate()));
	}

	public FExp MulExp.instantiate() { 
		return copyLocationTo(new FMulExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp DivExp.instantiate() { 
		return copyLocationTo(new FDivExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp PowExp.instantiate() { 
		return copyLocationTo(new FPowExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp DotAddExp.instantiate() { 
		return copyLocationTo(new FDotAddExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp DotSubExp.instantiate() { 
		return copyLocationTo(new FDotSubExp(getLeft().instantiate(),getRight().instantiate()));
	}

	public FExp DotMulExp.instantiate() { 
		return copyLocationTo(new FDotMulExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp DotDivExp.instantiate() { 
		return copyLocationTo(new FDotDivExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp DotPowExp.instantiate() { 
		return copyLocationTo(new FDotPowExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp NegExp.instantiate() { 
		return copyLocationTo(new FNegExp(getExp().instantiate()));
	}

	public FExp LtExp.instantiate() { 
		return copyLocationTo(new FLtExp(getLeft().instantiate(),getRight().instantiate()));
	}

	public FExp LeqExp.instantiate() { 
		return copyLocationTo(new FLeqExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp GtExp.instantiate() { 
		return copyLocationTo(new FGtExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp GeqExp.instantiate() { 
		return copyLocationTo(new FGeqExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp EqExp.instantiate() { 
		return copyLocationTo(new FEqExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp NeqExp.instantiate() { 
		return copyLocationTo(new FNeqExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp NotExp.instantiate() { 
		return copyLocationTo(new FNotExp(getExp().instantiate()));
	}
	
	public FExp OrExp.instantiate() { 
		return copyLocationTo(new FOrExp(getLeft().instantiate(),getRight().instantiate()));
	}
	
	public FExp AndExp.instantiate() { 
		return copyLocationTo(new FAndExp(getLeft().instantiate(),getRight().instantiate()));
	}

	public FExp RealLitExp.instantiate() { 
		return copyLocationTo(new FRealLitExp(getUNSIGNED_NUMBER()));
	}
	
	public FExp IntegerLitExp.instantiate() { 
		return copyLocationTo(new FIntegerLitExp(getUNSIGNED_INTEGER()));
	}
	
	public FExp StringLitExp.instantiate() { 
		return copyLocationTo(new FStringLitExp(getSTRING()));
	}
	
	public FExp BooleanLitExpTrue.instantiate() { 
		return copyLocationTo(new FBooleanLitExpTrue());
	}
	
	public FExp BooleanLitExpFalse.instantiate() { 
		return copyLocationTo(new FBooleanLitExpFalse());
	}
	
	public FExp TimeExp.instantiate() { 
		return copyLocationTo(new FTimeExp());
	}	

	public FExp EndExp.instantiate() { 
		return copyLocationTo(new FEndExp());
	}
	
	public InstNamedArgument NamedArgument.instantiate() {
		return copyLocationTo(new InstNamedArgument(getName().instantiate(), getExp().instantiate()));
	}
	
	public FAbstractFunctionCall FunctionCall.instantiate() {
		// Instantiate arguments
		List<InstFunctionArgument> args = new List<InstFunctionArgument>();
		if (hasFunctionArguments()) {
			int i = 0;
			for (Exp arg : getFunctionArguments().getExpList()) {
				InstPositionalArgument iarg = new InstPositionalArgument(i++, arg.instantiate());
				iarg.setLocation(arg);
				args.add(iarg);
			}
			for (NamedArgument arg : getFunctionArguments().getNamedArguments())
				args.add(arg.instantiate());
		}
		
		// Create InstFunctionCall
		return copyLocationTo(new InstFunctionCall(getName().newInstAccess(), args));
	}
  
	public InstForIndex ForIndex.instantiate() {
		SourceRoot sr = (SourceRoot)root(); // We know we are in the source tree
		// This maneuver is pretty ugly, but we need to find an InstClassDecl
		// in the instance tree from the source tree...
		InstProgramRoot ipr = sr.getProgram().getInstProgramRoot();
		InstAccess name = ipr.dynamicClassName(getForIndexDecl().getClassName().newInstAccess());
		InstPrimitive ip = (InstPrimitive) name.myInstClassDecl().newInstComponentDecl(getForIndexDecl());
		Opt o = hasExp()? new Opt(getExp().instantiate()): new Opt();
		return copyLocationTo(new InstForIndex(o, ip));
	}
	
	public InstForClauseE ForClauseE.instantiate() {
		List<InstForIndex> forIndex = new List();
		List<FAbstractEquation> eqns = new List();
		for (ForIndex fi : getForIndexs()) {
    		forIndex.add(fi.instantiate());    	
		}
		for (AbstractEquation ae : getAbstractEquations()) {
			eqns.add(ae.instantiate());
		}
		return new InstForClauseE(equationType(), forIndex, eqns);
	}

}

