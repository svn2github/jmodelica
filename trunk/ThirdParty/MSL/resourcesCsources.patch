Index: Modelica/Blocks/Types.mo
===================================================================
--- Modelica/Blocks/Types.mo	(revision 10461)
+++ Modelica/Blocks/Types.mo	(working copy)
@@ -146,7 +146,7 @@
             columns,
             size(columns, 1),
             smoothness,
-            extrapolation) annotation (Library={"ModelicaStandardTables"});
+            extrapolation) annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end constructor;
 
     function destructor "Terminate 1-dim. table where first column is time"
@@ -153,7 +153,7 @@
       extends Modelica.Icons.Function;
       input ExternalCombiTimeTable externalCombiTimeTable;
     external"C" ModelicaStandardTables_CombiTimeTable_close(
-        externalCombiTimeTable) annotation (Library={"ModelicaStandardTables"});
+        externalCombiTimeTable) annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end destructor;
 
   end ExternalCombiTimeTable;
@@ -178,7 +178,7 @@
             size(table, 2),
             columns,
             size(columns, 1),
-            smoothness) annotation (Library={"ModelicaStandardTables"});
+            smoothness) annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end constructor;
 
     function destructor "Terminate 1-dim. table defined by matrix"
@@ -185,7 +185,7 @@
       extends Modelica.Icons.Function;
       input ExternalCombiTable1D externalCombiTable1D;
     external"C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D)
-        annotation (Library={"ModelicaStandardTables"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end destructor;
 
   end ExternalCombiTable1D;
@@ -207,7 +207,7 @@
             table,
             size(table, 1),
             size(table, 2),
-            smoothness) annotation (Library={"ModelicaStandardTables"});
+            smoothness) annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end constructor;
 
     function destructor "Terminate 2-dim. table defined by matrix"
@@ -214,7 +214,7 @@
       extends Modelica.Icons.Function;
       input ExternalCombiTable2D externalCombiTable2D;
     external"C" ModelicaStandardTables_CombiTable2D_close(externalCombiTable2D)
-        annotation (Library={"ModelicaStandardTables"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end destructor;
 
   end ExternalCombiTable2D;
Index: Modelica/Blocks/Sources.mo
===================================================================
--- Modelica/Blocks/Sources.mo	(revision 10440)
+++ Modelica/Blocks/Sources.mo	(working copy)
@@ -2297,7 +2297,7 @@
       input Boolean verboseRead
         "= true: Print info message; = false: No info message";
       external"C" readSuccess = ModelicaStandardTables_CombiTimeTable_read(tableID, forceRead, verboseRead)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
       annotation(__ModelicaAssociation_Impure=true);
     end readTableData;
 
@@ -2313,7 +2313,7 @@
         "Dummy input to ensure correct sorting of function calls";
       output Real y;
       external"C" y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
       annotation (derivative(
           noDerivative=nextTimeEvent,
           noDerivative=pre_nextTimeEvent,
@@ -2332,7 +2332,7 @@
         "Dummy input to ensure correct sorting of function calls";
       output Real y;
       external"C" y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end getTableValueNoDer;
 
     function getDerTableValue
@@ -2348,7 +2348,7 @@
       input Real der_timeIn;
       output Real der_y;
       external"C" der_y = ModelicaStandardTables_CombiTimeTable_getDerValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent, der_timeIn)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end getDerTableValue;
 
     function getTableTimeTmin
@@ -2359,7 +2359,7 @@
         "Dummy input to ensure correct sorting of function calls";
       output Modelica.SIunits.Time timeMin "Minimum time value in table";
       external"C" timeMin = ModelicaStandardTables_CombiTimeTable_minimumTime(tableID)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end getTableTimeTmin;
 
     function getTableTimeTmax
@@ -2370,7 +2370,7 @@
         "Dummy input to ensure correct sorting of function calls";
       output Modelica.SIunits.Time timeMax "Maximum time value in table";
       external"C" timeMax = ModelicaStandardTables_CombiTimeTable_maximumTime(tableID)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end getTableTimeTmax;
 
     function getNextTimeEvent
@@ -2382,7 +2382,7 @@
         "Dummy input to ensure correct sorting of function calls";
       output Modelica.SIunits.Time nextTimeEvent "Next time event in table";
       external"C" nextTimeEvent = ModelicaStandardTables_CombiTimeTable_nextTimeEvent(tableID, timeIn)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end getNextTimeEvent;
 
   initial algorithm
Index: Modelica/Blocks/Tables.mo
===================================================================
--- Modelica/Blocks/Tables.mo	(revision 10440)
+++ Modelica/Blocks/Tables.mo	(working copy)
@@ -49,7 +49,7 @@
         "= true: Print info message; = false: No info message";
       output Real readSuccess "Table read success";
       external"C" readSuccess = ModelicaStandardTables_CombiTable1D_read(tableID, forceRead, verboseRead)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
       annotation(__ModelicaAssociation_Impure=true);
     end readTableData;
 
@@ -62,7 +62,7 @@
         "Dummy input to ensure correct sorting of function calls";
       output Real y;
       external"C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
       annotation (derivative(noDerivative=tableAvailable) = getDerTableValue);
     end getTableValue;
 
@@ -76,7 +76,7 @@
         "Dummy input to ensure correct sorting of function calls";
       output Real y;
       external"C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end getTableValueNoDer;
 
     function getDerTableValue
@@ -90,7 +90,7 @@
       input Real der_u;
       output Real der_y;
       external"C" der_y = ModelicaStandardTables_CombiTable1D_getDerValue(tableID, icol, u, der_u)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end getDerTableValue;
 
   initial algorithm
@@ -351,7 +351,7 @@
         "= true: Print info message; = false: No info message";
       output Real readSuccess "Table read success";
       external"C" readSuccess = ModelicaStandardTables_CombiTable1D_read(tableID, forceRead, verboseRead)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
       annotation(__ModelicaAssociation_Impure=true);
     end readTableData;
 
@@ -364,7 +364,7 @@
         "Dummy input to ensure correct sorting of function calls";
       output Real y;
       external"C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
       annotation (derivative(noDerivative=tableAvailable) = getDerTableValue);
     end getTableValue;
 
@@ -378,7 +378,7 @@
         "Dummy input to ensure correct sorting of function calls";
       output Real y;
       external"C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end getTableValueNoDer;
 
     function getDerTableValue
@@ -392,7 +392,7 @@
       input Real der_u;
       output Real der_y;
       external"C" der_y = ModelicaStandardTables_CombiTable1D_getDerValue(tableID, icol, u, der_u)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end getDerTableValue;
 
   initial algorithm
@@ -648,7 +648,7 @@
         "= true: Print info message; = false: No info message";
       output Real readSuccess "Table read success";
       external"C" readSuccess = ModelicaStandardTables_CombiTable2D_read(tableID, forceRead, verboseRead)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
       annotation(__ModelicaAssociation_Impure=true);
     end readTableData;
 
@@ -661,7 +661,7 @@
         "Dummy input to ensure correct sorting of function calls";
       output Real y;
       external"C" y = ModelicaStandardTables_CombiTable2D_getValue(tableID, u1, u2)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
       annotation (derivative(noDerivative=tableAvailable) = getDerTableValue);
     end getTableValue;
 
@@ -675,7 +675,7 @@
         "Dummy input to ensure correct sorting of function calls";
       output Real y;
       external"C" y = ModelicaStandardTables_CombiTable2D_getValue(tableID, u1, u2)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end getTableValueNoDer;
 
     function getDerTableValue
@@ -690,7 +690,7 @@
       input Real der_u2;
       output Real der_y;
       external"C" der_y = ModelicaStandardTables_CombiTable2D_getDerValue(tableID, u1, u2, der_u1, der_u2)
-        annotation (Library={"ModelicaStandardTables", "ModelicaMatIO", "zlib"});
+        annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
     end getDerTableValue;
 
   initial algorithm
Index: Modelica/Resources/C-Sources/_readme.txt
===================================================================
--- Modelica/Resources/C-Sources/_readme.txt	(revision 10440)
+++ Modelica/Resources/C-Sources/_readme.txt	(working copy)
@@ -1,44 +1,54 @@
-All *.c files in this directory should be compiled by a tool vendor
-to the following object libraries
-
-- ModelicaExternalC (.lib, .dll, .a, .so, depending on tool and OS) containing:
-  ModelicaFFT.c
-  ModelicaInternal.c
-  ModelicaRandom.c
-  ModelicaStrings.c
-  win32_dirent.c (for Visual C++ on Windows)
-
-- ModelicaIO (.lib, .dll, .a, .so, depending on tool and OS) containing:
-  ModelicaIO.c
-
-- ModelicaMatIO (.lib, .dll, .a, .so, depending on tool and OS) containing:
-  ModelicaMatIO.c
-
-- ModelicaStandardTables (.lib, .dll, .a, .so, depending on tool and OS) containing:
-  ModelicaStandardTables.c
-
-- zlib (.lib, .dll, .a, .so, depending on tool and OS) containing:
-  zlib/*.c
-
-When the library annotation "ModelicaExternalC", "ModelicaIO" or
-"ModelicaStandardTables" is utilized in an external Modelica function, then the
-respective object library should be provided by the linker or should be
-dynamically linked to the simulation environment.
-
-For backwards-compatibility with the Modelica Standard Library (MSL) v3.2.1, a
-tool vendor supporting both MSL v3.2.1 and v3.2.2 has to provide the library
-"ModelicaStandardTables" in such a way that the required library dependencies
-(i.e., libraries "ModelicaMatIO" and "zlib") are automatically resolved. For
-instance, this can be achieved by building shared object libraries (.dll, .so)
-and dynamically linking library "ModelicaStandardTables" to "ModelicaMatIO" and
-"ModelicaMatIO" to "zlib".
-
-Build projects for the object libraries are provided under
-   ../BuildProjects
-
-Additionally, a tool vendor has to provide library "lapack"
-(>= v3.1; download from http://www.netlib.org/lapack)
-and this library should be used in the linker when a model is compiled
-that uses this library in its library annotation.
-
-February 29, 2016.
+All *.c files in this directory should be compiled by a tool vendor
+to the following object libraries
+
+- ModelicaExternalC (.lib, .dll, .a, .so, depending on tool and OS) containing:
+  ModelicaFFT.c
+  ModelicaInternal.c
+  ModelicaRandom.c
+  ModelicaStrings.c
+  win32_dirent.c (for Visual C++ on Windows)
+
+- ModelicaIO (.lib, .dll, .a, .so, depending on tool and OS) containing:
+  ModelicaIO.c
+
+- ModelicaMatIO (.lib, .dll, .a, .so, depending on tool and OS) containing:
+  ModelicaMatIO.c
+
+- ModelicaStandardTables (.lib, .dll, .a, .so, depending on tool and OS) containing:
+  ModelicaStandardTables.c
+
+- zlib (.lib, .dll, .a, .so, depending on tool and OS) containing:
+  zlib/*.c
+
+When the library annotation "ModelicaExternalC", "ModelicaIO" or
+"ModelicaStandardTables" is utilized in an external Modelica function, then the
+respective object library should be provided by the linker or should be
+dynamically linked to the simulation environment.
+
+For backwards-compatibility with the Modelica Standard Library (MSL) v3.2.1, a
+tool vendor supporting MSL v3.2.1 and later releases has to provide the library
+"ModelicaStandardTables" in such a way that the required library dependencies
+(i.e., libraries "ModelicaIO", "ModelicaMatIO" and "zlib") are automatically
+resolved. For instance, this can be achieved by building shared object
+libraries (.dll, .so) and dynamically linking library "ModelicaStandardTables" to
+"ModelicaIO", "ModelicaIO" to "ModelicaMatIO" and "ModelicaMatIO" to "zlib".
+
+On Windows, when compiling libraries (.dll, .lib) or executables (.exe) with
+C sources including gconstructor.h, particularly, projects that build
+ModelicaInternal.c or ModelicaStandardTables.c, the following (optimization)
+options shall be applied in the Release configuration of Visual Studio 2013, 2015
+or 2017:
+- Compiler: /Zc:inline (Remove unreferenced COMDAT) must not be set. Either do not
+  set this option at all or explicitly set /Zc:inline- to unset
+- Linker: /OPT:NOREF (Keep unreferenced functions) should be set, in case
+  /GL (Whole Program Optimization) and /LTCG (Link-time Code Generation) are set
+
+Build projects for the object libraries are provided under
+  ../BuildProjects
+
+Additionally, a tool vendor has to provide library "lapack"
+(>= v3.1; download from http://www.netlib.org/lapack)
+and this library should be used in the linker when a model is compiled
+that uses this library in its library annotation.
+
+April 05, 2017.
Index: Modelica/Resources/C-Sources/gconstructor.h
===================================================================
--- Modelica/Resources/C-Sources/gconstructor.h	(revision 10440)
+++ Modelica/Resources/C-Sources/gconstructor.h	(working copy)
@@ -1,4 +1,5 @@
-/*
+/* gconstructor.h - Module constructor and destructor helper header
+
   If G_HAS_CONSTRUCTORS is true then the compiler support *both* constructors and
   destructors, in a sane way, including e.g. on library unload. If not you're on
   your own.
@@ -16,31 +17,62 @@
 
 */
 
-#if  __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
+#ifndef G_CONSTRUCTOR_H_
+#define G_CONSTRUCTOR_H_
 
+#if defined(__cplusplus)
+
 #define G_HAS_CONSTRUCTORS 1
 
+#define G_DEFINE_CONSTRUCTOR(_func) \
+  static void _func(void); \
+  struct _func ## _wrapper_struct { _func ## _wrapper_struct() { _func(); } }; \
+  static _func ## _wrapper_struct _func ## _wrapper;
+
+#define G_DEFINE_DESTRUCTOR(_func) \
+  static void _func(void); \
+  struct _func ## _wrapper_struct2 { ~_func ## _wrapper_struct2() { _func(); } }; \
+  static _func ## _wrapper_struct2 _func ## _wrapper2;
+
+#elif (defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7))) || \
+       defined(__clang__)
+
+#define G_HAS_CONSTRUCTORS 1
+
 #define G_DEFINE_CONSTRUCTOR(_func) static void __attribute__((constructor)) _func (void);
 #define G_DEFINE_DESTRUCTOR(_func) static void __attribute__((destructor)) _func (void);
 
-#elif defined (_MSC_VER) && (_MSC_VER >= 1500)
+#elif defined(_MSC_VER) && (_MSC_VER >= 1500)
 /* Visual Studio 2008 and later has _pragma */
 
 #define G_HAS_CONSTRUCTORS 1
 
-#define G_DEFINE_CONSTRUCTOR(_func) \
+#ifdef _WIN64
+#define G_MSVC_SYMBOL_PREFIX ""
+#else
+#define G_MSVC_SYMBOL_PREFIX "_"
+#endif
+
+#define G_DEFINE_CONSTRUCTOR(_func) G_MSVC_CTOR (_func, G_MSVC_SYMBOL_PREFIX)
+#define G_DEFINE_DESTRUCTOR(_func) G_MSVC_DTOR (_func, G_MSVC_SYMBOL_PREFIX)
+
+#define G_MSVC_CTOR(_func,_sym_prefix) \
   static void _func(void); \
-  static int _func ## _wrapper(void) { _func(); return 0; } \
+  extern int (* _array ## _func)(void); \
+  int _func ## _wrapper(void) { _func(); return _array ## _func == NULL; } \
+  __pragma(comment(linker,"/include:" _sym_prefix # _func "_wrapper")) \
   __pragma(section(".CRT$XCU",read)) \
-  __declspec(allocate(".CRT$XCU")) static int (* _array ## _func)(void) = _func ## _wrapper;
+  __declspec(allocate(".CRT$XCU")) int (* _array ## _func)(void) = _func ## _wrapper;
 
-#define G_DEFINE_DESTRUCTOR(_func) \
+#define G_MSVC_DTOR(_func,_sym_prefix) \
   static void _func(void); \
-  static int _func ## _constructor(void) { atexit (_func); return 0; } \
+  extern int (* _array ## _func)(void); \
+  int _func ## _constructor(void) { atexit (_func); return _array ## _func == NULL; } \
+   __pragma(comment(linker,"/include:" _sym_prefix # _func "_constructor")) \
   __pragma(section(".CRT$XCU",read)) \
-  __declspec(allocate(".CRT$XCU")) static int (* _array ## _func)(void) = _func ## _constructor;
+  __declspec(allocate(".CRT$XCU")) int (* _array ## _func)(void) = _func ## _constructor;
 
-#elif defined (_MSC_VER) && (_MSC_VER >= 1400)
+#elif defined(_MSC_VER) && (_MSC_VER >= 1400)
 
 #define G_HAS_CONSTRUCTORS 1
 
@@ -88,3 +120,5 @@
 /* constructors not supported for this compiler */
 
 #endif
+
+#endif
Index: Modelica/Resources/C-Sources/ModelicaFFT.c
===================================================================
--- Modelica/Resources/C-Sources/ModelicaFFT.c	(revision 10440)
+++ Modelica/Resources/C-Sources/ModelicaFFT.c	(working copy)
@@ -1,6 +1,6 @@
 /* ModelicaFFT.c - FFT functions
 
-   Copyright (C) 2015-2016, Modelica Association and DLR
+   Copyright (C) 2015-2017, Modelica Association and DLR
    Copyright (C) 2003-2010, Mark Borgerding
    All rights reserved.
 
@@ -30,20 +30,8 @@
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-/* Adapted to the needs of the Modelica Standard Library library:
+/* Adapted to the needs of the Modelica Standard Library:
 
-   The functions in this file are non-portable. The following #define's are used
-   to define the system calls of the operating system
-
-   __GNUC__       : GNU C compiler
-   MODELICA_EXPORT: Prefix used for function calls. If not defined, blank is used
-                    Useful definitions:
-                    - "static" that is all functions become static
-                      (useful if file is included with other C-sources for an
-                       embedded system)
-                    - "__declspec(dllexport)" if included in a DLL and the
-                      functions shall be visible outside of the DLL
-
    Release Notes:
       Dec. 02, 2015: by Martin Otter, DLR
                      Combined the C- and Header files of Kiss-FFT as needed for MSL
@@ -54,18 +42,11 @@
                      the function is left)
 */
 
-#ifndef MRKISS_FTR_H
-#define MRKISS_FTR_H
-
+#include "ModelicaFFT.h"
 #include <math.h>
 #include <limits.h>
-#include <stdlib.h>
 #include <string.h>
 
-#if !defined(MODELICA_EXPORT)
-#   define MODELICA_EXPORT
-#endif
-
 #define MRKISS_FFT_TMP_ALLOC malloc
 #define MRKISS_FFT_TMP_FREE free
 
@@ -96,24 +77,6 @@
 };
 typedef struct mrkiss_fftr_state* mrkiss_fftr_cfg;
 
-/*
- * Non-null pointers need to be passed to external functions.
- *
- * The following macros handle nonnull attributes for GNU C and Microsoft SAL.
- */
-#if defined(__GNUC__)
-#define MODELICA_NONNULLATTR __attribute__((nonnull))
-#else
-#define MODELICA_NONNULLATTR
-#endif
-#if !defined(__ATTR_SAL)
-#define _In_
-#define _Out_
-#endif
-
-MODELICA_EXPORT int ModelicaFFT_kiss_fftr(_In_ double u[], size_t nu, _In_ double work[], size_t nwork,
-    _Out_ double *amplitudes, _Out_ double *phases) MODELICA_NONNULLATTR;
-
 /* include from _kiss_fft_guts.h ------------------------------------------ */
 
 /*
@@ -372,7 +335,7 @@
     int m,
     int p
 ) {
-    int u,k,q1,q;
+    int u,q1,q;
     mrkiss_fft_cpx * twiddles = st->twiddles;
     mrkiss_fft_cpx t;
     int Norig = st->nfft;
@@ -380,7 +343,7 @@
     mrkiss_fft_cpx * scratch = (mrkiss_fft_cpx*)MRKISS_FFT_TMP_ALLOC(sizeof(mrkiss_fft_cpx)*p);
 
     for ( u=0; u<m; ++u ) {
-        k=u;
+        int k=u;
         for ( q1=0 ; q1<p ; ++q1 ) {
             scratch[q1] = Fout[ k  ];
             C_FIXDIV(scratch[q1],p);
@@ -555,8 +518,8 @@
     }
 }
 
-MODELICA_EXPORT int ModelicaFFT_kiss_fftr(double u[], size_t nu, double work[], size_t nwork,
-        double *amplitudes, double *phases) {
+int ModelicaFFT_kiss_fftr(_In_ double* u, size_t nu, _In_ double* work, size_t nwork,
+                          _Out_ double *amplitudes, _Out_ double *phases) {
 
     /* Compute real FFT with mrkiss_fftr
        -> u[nu]        : Real data at sample points; nu must be even
@@ -604,5 +567,3 @@
     }
     return 0;
 }
-
-#endif
Index: Modelica/Resources/C-Sources/ModelicaFFT.h
===================================================================
--- Modelica/Resources/C-Sources/ModelicaFFT.h	(nonexistent)
+++ Modelica/Resources/C-Sources/ModelicaFFT.h	(working copy)
@@ -0,0 +1,72 @@
+/* ModelicaFFT.h - FFT functions header
+
+   Copyright (C) 2015-2017, Modelica Association and DLR
+   Copyright (C) 2003-2010, Mark Borgerding
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   1. Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+   3. Neither the author nor the names of any contributors may be used to
+      endorse or promote products derived from this software without specific
+      prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/* The following #define's are available.
+
+   MODELICA_EXPORT: Prefix used for function calls. If not defined, blank is used
+                    Useful definition:
+                    - "__declspec(dllexport)" if included in a DLL and the
+                      functions shall be visible outside of the DLL
+*/
+
+#ifndef MODELICA_FFT_H_
+#define MODELICA_FFT_H_
+
+#include <stdlib.h>
+
+#if !defined(MODELICA_EXPORT)
+#if defined(__cplusplus)
+#define MODELICA_EXPORT extern "C"
+#else
+#define MODELICA_EXPORT
+#endif
+#endif
+
+/*
+ * Non-null pointers need to be passed to external functions.
+ *
+ * The following macros handle nonnull attributes for GNU C and Microsoft SAL.
+ */
+#if defined(__GNUC__)
+#define MODELICA_NONNULLATTR __attribute__((nonnull))
+#else
+#define MODELICA_NONNULLATTR
+#endif
+#if !defined(__ATTR_SAL)
+#define _In_
+#define _Out_
+#endif
+
+MODELICA_EXPORT int ModelicaFFT_kiss_fftr(_In_ double* u, size_t nu, _In_ double* work, size_t nwork,
+    _Out_ double *amplitudes, _Out_ double *phases) MODELICA_NONNULLATTR;
+
+#endif
Index: Modelica/Resources/C-Sources/ModelicaInternal.c
===================================================================
--- Modelica/Resources/C-Sources/ModelicaInternal.c	(revision 10440)
+++ Modelica/Resources/C-Sources/ModelicaInternal.c	(working copy)
@@ -1,6 +1,6 @@
 /* ModelicaInternal.c - External functions for Modelica.Utilities
 
-   Copyright (C) 2002-2016, Modelica Association and DLR
+   Copyright (C) 2002-2017, Modelica Association and DLR
    All rights reserved.
 
    Redistribution and use in source and binary forms, with or without
@@ -25,29 +25,23 @@
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-/* The functions in this file are mostly non-portable. The following #define's
-   are used to define the system calls of the operating system
+/* Release Notes:
+      Apr. 09, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Fixed macOS support of ModelicaInternal_setenv
+                     (ticket #2235)
 
-   _WIN32         : System calls of Windows'95, Windows'NT
-                    (Note, that these system calls allow both '/' and '\'
-                    as directory separator for input arguments. As return
-                    argument '\' is used).
-                    All system calls are from the library libc.a.
-   _POSIX_        : System calls of POSIX
-   _MSC_VER       : Microsoft Visual C++
-   __GNUC__       : GNU C compiler
-   NO_FILE_SYSTEM : A file system is not present (e.g. on dSPACE or xPC).
-   NO_PID         : Function getpid is not present (e.g. on dSPACE)
-   NO_TIME        : Function gettimeofday is not present (e.g. on dSPACE)
-   MODELICA_EXPORT: Prefix used for function calls. If not defined, blank is used
-                    Useful definitions:
-                    - "static" that is all functions become static
-                      (useful if file is included with other C-sources for an
-                       embedded system)
-                    - "__declspec(dllexport)" if included in a DLL and the
-                      functions shall be visible outside of the DLL
+      Mar. 27, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Replaced localtime by re-entrant function
 
-   Release Notes:
+      Feb. 26, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Fixed definition of uthash_fatal, called by HASH_ADD_KEYPTR in
+                     function CacheFileForReading (ticket #2097)
+
+      Jan. 31, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Fixed WIN32 support of a directory name with a trailing
+                     forward/backward slash character in ModelicaInternal_stat
+                     (ticket #1976)
+
       Mar. 02, 2016: by Thomas Beutlich, ITI GmbH
                      Fixed repeated opening of cached file in case of line miss in
                      ModelicaStreams_openFileForReading (ticket #1939)
@@ -97,7 +91,7 @@
                      Added missing implementations, merged code from previous
                      ModelicaFiles and clean-up of code
 
-      Sep. 09, 2004: by Dag Bruck, Dynasim AB
+      Sep. 09, 2004: by Dag Brueck, Dynasim AB
                      Further implementation and clean-up of code
 
       Aug. 24, 2004: by Martin Otter, DLR
@@ -110,24 +104,21 @@
                      ModelicaInternal_getFullPath
 */
 
-#if !defined(MODELICA_EXPORT)
-  #define MODELICA_EXPORT
-#endif
-
+#include "ModelicaInternal.h"
 #include <string.h>
 #include "ModelicaUtilities.h"
 
-/* The standard way to detect posix is to check _POSIX_VERSION,
+/* The standard way to detect POSIX is to check _POSIX_VERSION,
  * which is defined in <unistd.h>
  */
 #if defined(__unix__) || defined(__linux__) || defined(__APPLE_CC__)
   #include <unistd.h>
 #endif
-
 #if !defined(_POSIX_) && defined(_POSIX_VERSION)
   #define _POSIX_ 1
 #endif
 
+MODELICA_NORETURN static void ModelicaNotExistError(const char* name) MODELICA_NORETURNATTR;
 static void ModelicaNotExistError(const char* name) {
   /* Print error message if a function is not implemented */
     ModelicaFormatError("C-Function \"%s\" is called\n"
@@ -137,50 +128,60 @@
 }
 
 #ifdef NO_FILE_SYSTEM
-MODELICA_EXPORT void ModelicaInternal_mkdir(const char* directoryName) {
+void ModelicaInternal_mkdir(_In_z_ const char* directoryName) {
     ModelicaNotExistError("ModelicaInternal_mkdir"); }
-MODELICA_EXPORT void ModelicaInternal_rmdir(const char* directoryName) {
+void ModelicaInternal_rmdir(_In_z_ const char* directoryName) {
     ModelicaNotExistError("ModelicaInternal_rmdir"); }
-MODELICA_EXPORT int  ModelicaInternal_stat(const char* name) {
+int ModelicaInternal_stat(_In_z_ const char* name) {
     ModelicaNotExistError("ModelicaInternal_stat"); return 0; }
-MODELICA_EXPORT void ModelicaInternal_rename(const char* oldName, const char* newName)  {
+void ModelicaInternal_rename(_In_z_ const char* oldName,
+    _In_z_ const char* newName) {
     ModelicaNotExistError("ModelicaInternal_rename"); }
-MODELICA_EXPORT void ModelicaInternal_removeFile(const char* file) {
+void ModelicaInternal_removeFile(_In_z_ const char* file) {
     ModelicaNotExistError("ModelicaInternal_removeFile"); }
-MODELICA_EXPORT void ModelicaInternal_copyFile(const char* oldFile, const char* newFile) {
+void ModelicaInternal_copyFile(_In_z_ const char* oldFile,
+    _In_z_ const char* newFile) {
     ModelicaNotExistError("ModelicaInternal_copyFile"); }
-MODELICA_EXPORT void ModelicaInternal_readDirectory(const char* directory, int nFiles, const char* files[]) {
+void ModelicaInternal_readDirectory(_In_z_ const char* directory,
+    int nFiles, _Out_ const char** files) {
     ModelicaNotExistError("ModelicaInternal_readDirectory"); }
-MODELICA_EXPORT int  ModelicaInternal_getNumberOfFiles(const char* directory) {
+int ModelicaInternal_getNumberOfFiles(_In_z_ const char* directory) {
     ModelicaNotExistError("ModelicaInternal_getNumberOfFiles"); return 0; }
-MODELICA_EXPORT const char* ModelicaInternal_fullPathName(const char* name) {
-    ModelicaNotExistError("ModelicaInternal_fullPathName"); return 0; }
-MODELICA_EXPORT const char* ModelicaInternal_temporaryFileName(void) {
-    ModelicaNotExistError("ModelicaInternal_temporaryFileName"); return 0; }
-MODELICA_EXPORT void ModelicaInternal_print(const char* string, const char* fileName) {
+const char* ModelicaInternal_fullPathName(_In_z_ const char* name) {
+    ModelicaNotExistError("ModelicaInternal_fullPathName"); return NULL; }
+const char* ModelicaInternal_temporaryFileName(void) {
+    ModelicaNotExistError("ModelicaInternal_temporaryFileName"); return NULL; }
+void ModelicaStreams_closeFile(_In_z_ const char* fileName) {
+    ModelicaNotExistError("ModelicaStreams_closeFile"); }
+void ModelicaInternal_print(_In_z_ const char* string,
+    _In_z_ const char* fileName) {
     if ( fileName[0] == '\0' ) {
       /* Write string to terminal */
         ModelicaFormatMessage("%s\n", string);
     }
     return; }
-MODELICA_EXPORT int  ModelicaInternal_countLines(const char* fileName) {
+int ModelicaInternal_countLines(_In_z_ const char* fileName) {
     ModelicaNotExistError("ModelicaInternal_countLines"); return 0; }
-MODELICA_EXPORT void ModelicaInternal_readFile(const char* fileName, const char* string[], size_t nLines) {
+void ModelicaInternal_readFile(_In_z_ const char* fileName,
+    _Out_ const char** string, size_t nLines) {
     ModelicaNotExistError("ModelicaInternal_readFile"); }
-MODELICA_EXPORT const char* ModelicaInternal_readLine(const char* fileName, int lineNumber, int* endOfFile) {
-    ModelicaNotExistError("ModelicaInternal_readLine"); return 0; }
-MODELICA_EXPORT void ModelicaInternal_chdir(const char* directoryName) {
+const char* ModelicaInternal_readLine(_In_z_ const char* fileName,
+    int lineNumber, _Out_ int* endOfFile) {
+    ModelicaNotExistError("ModelicaInternal_readLine"); return NULL; }
+void ModelicaInternal_chdir(_In_z_ const char* directoryName) {
     ModelicaNotExistError("ModelicaInternal_chdir"); }
-MODELICA_EXPORT const char* ModelicaInternal_getcwd(int dummy) {
-    ModelicaNotExistError("ModelicaInternal_getcwd"); return 0; }
-MODELICA_EXPORT void ModelicaInternal_getenv(const char* name, int convertToSlash, const char** content, int* exist) {
+const char* ModelicaInternal_getcwd(int dummy) {
+    ModelicaNotExistError("ModelicaInternal_getcwd"); return NULL; }
+void ModelicaInternal_getenv(_In_z_ const char* name, int convertToSlash,
+    _Out_ const char** content, _Out_ int* exist) {
     ModelicaNotExistError("ModelicaInternal_getenv"); }
-MODELICA_EXPORT void ModelicaInternal_setenv(const char* name, const char* value, int convertFromSlash) {
+void ModelicaInternal_setenv(_In_z_ const char* name,
+    _In_z_ const char* value, int convertFromSlash) {
     ModelicaNotExistError("ModelicaInternal_setenv"); }
 #else
 
-#define uthash_fatal(msg) ModelicaFormatMessage("Error: %s\n", msg); break
 #include "uthash.h"
+#undef uthash_fatal /* Ensure that nowhere in this file uses uthash_fatal by accident */
 #include "gconstructor.h"
 
 #include <stdio.h>
@@ -214,62 +215,6 @@
   #include <sys/stat.h>
 #endif
 
-/*
- * Non-null pointers and esp. null-terminated strings need to be passed to
- * external functions.
- *
- * The following macros handle nonnull attributes for GNU C and Microsoft SAL.
- */
-#if defined(__GNUC__)
-#define MODELICA_NONNULLATTR __attribute__((nonnull))
-#if defined(__GNUC_MINOR__) && (__GNUC__ > 3 && __GNUC_MINOR__ > 8)
-#define MODELICA_RETURNNONNULLATTR __attribute__((returns_nonnull))
-#else
-#define MODELICA_RETURNNONNULLATTR
-#endif
-#elif defined(__ATTR_SAL)
-#define MODELICA_NONNULLATTR
-#define MODELICA_RETURNNONNULLATTR _Ret_z_ /* _Ret_notnull_ and null-terminated */
-#else
-#define MODELICA_NONNULLATTR
-#define MODELICA_RETURNNONNULLATTR
-#endif
-#if !defined(__ATTR_SAL)
-#define _In_z_
-#define _Out_
-#endif
-
-MODELICA_EXPORT void ModelicaInternal_mkdir(_In_z_ const char* directoryName) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaInternal_rmdir(_In_z_ const char* directoryName) MODELICA_NONNULLATTR;
-MODELICA_EXPORT int ModelicaInternal_stat(_In_z_ const char* name) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaInternal_rename(_In_z_ const char* oldName,
-    _In_z_ const char* newName) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaInternal_removeFile(_In_z_ const char* file) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaInternal_copyFile(_In_z_ const char* oldFile,
-    _In_z_ const char* newFile) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaInternal_readDirectory(_In_z_ const char* directory, int nFiles,
-    _Out_ const char** files) MODELICA_NONNULLATTR;
-MODELICA_EXPORT int ModelicaInternal_getNumberOfFiles(_In_z_ const char* directory) MODELICA_NONNULLATTR;
-MODELICA_EXPORT MODELICA_RETURNNONNULLATTR const char* ModelicaInternal_fullPathName(
-    _In_z_ const char* name) MODELICA_NONNULLATTR;
-MODELICA_EXPORT MODELICA_RETURNNONNULLATTR const char* ModelicaInternal_temporaryFileName(void);
-MODELICA_EXPORT void ModelicaStreams_closeFile(_In_z_ const char* fileName) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaInternal_print(_In_z_ const char* string,
-    _In_z_ const char* fileName) MODELICA_NONNULLATTR;
-MODELICA_EXPORT int ModelicaInternal_countLines(_In_z_ const char* fileName) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaInternal_readFile(_In_z_ const char* fileName,
-    _Out_ const char* string[], size_t nLines) MODELICA_NONNULLATTR;
-MODELICA_EXPORT MODELICA_RETURNNONNULLATTR const char* ModelicaInternal_readLine(_In_z_ const char* fileName,
-    int lineNumber, _Out_ int* endOfFile) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaInternal_chdir(_In_z_ const char* directoryName) MODELICA_NONNULLATTR;
-MODELICA_EXPORT MODELICA_RETURNNONNULLATTR const char* ModelicaInternal_getcwd(int dummy);
-MODELICA_EXPORT void ModelicaInternal_getenv(_In_z_ const char* name, int convertToSlash,
-    _Out_ const char** content, _Out_ int* exist) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaInternal_setenv(_In_z_ const char* name,
-    _In_z_ const char* value, int convertFromSlash) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaInternal_getTime(_Out_ int* ms, _Out_ int* sec, _Out_ int* min, _Out_ int* hour,
-    _Out_ int* mday, _Out_ int* mon, _Out_ int* year) MODELICA_NONNULLATTR;
-
 #if PATH_MAX > 1024
 #define BUFFER_LENGTH PATH_MAX
 #else
@@ -313,7 +258,7 @@
 
 /* --------------------- Modelica_Utilities.Internal --------------------------------- */
 
-MODELICA_EXPORT void ModelicaInternal_mkdir(const char* directoryName) {
+void ModelicaInternal_mkdir(_In_z_ const char* directoryName) {
     /* Create directory */
 #if defined(__WATCOMC__) || defined(__LCC__)
     int result = mkdir(directoryName);
@@ -322,17 +267,17 @@
 #elif defined(_POSIX_) || defined(__GNUC__)
     int result = mkdir(directoryName, S_IRUSR | S_IWUSR | S_IXUSR);
 #else
-    int result = -1;
-    ModelicaNotExistError("ModelicaInternal_mkdir");
+   ModelicaNotExistError("ModelicaInternal_mkdir");
 #endif
-
+#if defined(__WATCOMC__) || defined(__LCC__) || defined(__BORLANDC__) || defined(_WIN32) || defined(_POSIX_) || defined(__GNUC__)
     if (result != 0) {
         ModelicaFormatError("Not possible to create new directory\n"
             "\"%s\":\n%s", directoryName, strerror(errno));
     }
+#endif
 }
 
-MODELICA_EXPORT void ModelicaInternal_rmdir(const char* directoryName) {
+void ModelicaInternal_rmdir(_In_z_ const char* directoryName) {
     /* Remove directory */
 #if defined(__WATCOMC__) || defined(__LCC__) || defined(_POSIX_) || defined(__GNUC__)
     int result = rmdir(directoryName);
@@ -339,47 +284,50 @@
 #elif defined(__BORLANDC__) || defined(_WIN32)
     int result = _rmdir(directoryName);
 #else
-    int result = -1;
     ModelicaNotExistError("ModelicaInternal_rmdir");
 #endif
-
+#if defined(__WATCOMC__) || defined(__LCC__) || defined(__BORLANDC__) || defined(_WIN32) || defined(_POSIX_) || defined(__GNUC__)
     if (result != 0) {
         ModelicaFormatError("Not possible to remove directory\n"
             "\"%s\":\n%s", directoryName, strerror(errno));
     }
+#endif
 }
 
-MODELICA_EXPORT int ModelicaInternal_stat(const char* name) {
+static ModelicaFileType Internal_stat(_In_z_ const char* name) {
     /* Inquire type of file */
     ModelicaFileType type = FileType_NoFile;
-
-#if defined(__WATCOMC__) || defined(__BORLANDC__)
+#if defined(_WIN32)
     struct _stat fileInfo;
-    if ( _stat(name, &fileInfo) != 0 ) {
-        type = FileType_NoFile;
-    }
-    else if ( fileInfo.st_mode & S_IFREG ) {
-        type = FileType_RegularFile;
-    }
-    else if ( fileInfo.st_mode & S_IFDIR ) {
-        type = FileType_Directory;
-    }
-    else {
-        type = FileType_SpecialFile;
-    }
-#elif defined(_WIN32)
-    struct _stat fileInfo;
-    int statReturn;
-    statReturn=_stat(name, &fileInfo);
-    if (statReturn!=0) {
-        /* For some reason _stat requires a:\ and a:\test1 and fails on a: and a:\test1\ */
-        /* It could be handled in the Modelica code, but seems better to have here */
-        if (strpbrk(name,"/\\")==0 && strchr(name,':')!=0 && strchr(name,':')[1]==0 && (strchr(name,':')-name)<40) {
-            char name2[100];
-            strcpy(name2,name);
-            strcat(name2,"\\");
-            statReturn=_stat(name2, &fileInfo);
+    int statReturn = _stat(name, &fileInfo);
+    if (0 != statReturn) {
+        /* For some reason _stat requires "a:\" and "a:\test1" but fails
+         * on "a:" and "a:\test1\", repectively. It could be handled in the
+         * Modelica code, but seems better to have it here.
+         */
+        const char* firstSlash = strpbrk(name, "/\\");
+        const char* firstColon = strchr(name, ':');
+        const char c = (NULL != firstColon) ? firstColon[1] : '\0';
+        size_t len = strlen(name);
+        if (NULL == firstSlash && NULL != firstColon && '\0' == c) {
+            char* nameTmp = (char*)malloc((len + 2)*(sizeof(char)));
+            if (NULL != nameTmp) {
+                strcpy(nameTmp, name);
+                strcat(nameTmp, "\\");
+                statReturn = _stat(nameTmp, &fileInfo);
+                free(nameTmp);
+            }
         }
+        else if (NULL != firstSlash && len > 1 &&
+            ('/' == name[len - 1] || '\\' == name[len - 1])) {
+            char* nameTmp = (char*)malloc(len*(sizeof(char)));
+            if (NULL != nameTmp) {
+                strncpy(nameTmp, name, len - 1);
+                nameTmp[len - 1] = '\0';
+                statReturn = _stat(nameTmp, &fileInfo);
+                free(nameTmp);
+            }
+        }
     }
     if ( statReturn != 0 ) {
         type = FileType_NoFile;
@@ -396,7 +344,7 @@
 #elif defined(_POSIX_) || defined(__GNUC__)
     struct stat fileInfo;
     int statReturn;
-    statReturn=stat(name, &fileInfo);
+    statReturn = stat(name, &fileInfo);
     if ( statReturn != 0 ) {
         type = FileType_NoFile;
     }
@@ -409,13 +357,22 @@
     else {
         type = FileType_SpecialFile;
     }
+#endif
+    return type;
+}
+
+int ModelicaInternal_stat(_In_z_ const char* name) {
+#if defined(_WIN32) || defined(_POSIX_) || defined(__GNUC__)
+    ModelicaFileType type = Internal_stat(name);
 #else
+    ModelicaFileType type = FileType_NoFile;
     ModelicaNotExistError("ModelicaInternal_stat");
 #endif
     return type;
 }
 
-MODELICA_EXPORT void ModelicaInternal_rename(const char* oldName, const char* newName) {
+void ModelicaInternal_rename(_In_z_ const char* oldName,
+                             _In_z_ const char* newName) {
     /* Change the name of a file or of a directory */
     if ( rename(oldName, newName) != 0 ) {
         ModelicaFormatError("renaming \"%s\" to \"%s\" failed:\n%s",
@@ -423,7 +380,7 @@
     }
 }
 
-MODELICA_EXPORT void ModelicaInternal_removeFile(const char* file) {
+void ModelicaInternal_removeFile(_In_z_ const char* file) {
     /* Remove file */
     if ( remove(file) != 0 ) {
         ModelicaFormatError("Not possible to remove file \"%s\":\n%s",
@@ -431,7 +388,8 @@
     }
 }
 
-MODELICA_EXPORT void ModelicaInternal_copyFile(const char* oldFile, const char* newFile) {
+void ModelicaInternal_copyFile(_In_z_ const char* oldFile,
+                               _In_z_ const char* newFile) {
     /* Copy file */
 #ifdef _WIN32
     const char* modeOld = "rb";
@@ -446,7 +404,7 @@
     int c;
 
     /* Check file existence */
-    type = (ModelicaFileType) ModelicaInternal_stat(oldFile);
+    type = Internal_stat(oldFile);
     if ( type == FileType_NoFile ) {
         ModelicaFormatError("\"%s\" cannot be copied\nbecause it does not exist", oldFile);
         return;
@@ -460,7 +418,7 @@
             "because it is not a regular file", oldFile);
         return;
     }
-    type = (ModelicaFileType) ModelicaInternal_stat(newFile);
+    type = Internal_stat(newFile);
     if ( type != FileType_NoFile ) {
         ModelicaFormatError("\"%s\" cannot be copied\nbecause the target "
             "\"%s\" exists", oldFile, newFile);
@@ -487,8 +445,8 @@
     fclose(fpNew);
 }
 
-MODELICA_EXPORT void ModelicaInternal_readDirectory(const char* directory, int nFiles,
-                                           const char** files) {
+void ModelicaInternal_readDirectory(_In_z_ const char* directory, int nFiles,
+                                    _Out_ const char** files) {
     /* Get all file and directory names in a directory in any order
        (must be very careful, to call closedir if an error occurs)
     */
@@ -555,8 +513,7 @@
             "Less files (= %d) found as defined by argument nNames (= %d)",
              directory, iFiles, nFiles);
     }
-
-    if ( closedir(pdir) != 0 ) {
+    else if ( closedir(pdir) != 0 ) {
         ModelicaFormatError("Not possible to get file names of \"%s\":\n",
             directory, strerror(errno));
     }
@@ -566,7 +523,7 @@
 #endif
 }
 
-MODELICA_EXPORT int ModelicaInternal_getNumberOfFiles(const char* directory) {
+int ModelicaInternal_getNumberOfFiles(_In_z_ const char* directory) {
     /* Get number of files and directories in a directory */
 #if defined(__WATCOMC__) || defined(__BORLANDC__) || defined(_WIN32) || defined(_POSIX_) || defined(__GNUC__)
     int nFiles = 0;
@@ -606,7 +563,7 @@
 
 /* --------------------- Modelica_Utilities.Files ------------------------------------- */
 
-MODELICA_EXPORT const char* ModelicaInternal_fullPathName(const char* name) {
+_Ret_z_ const char* ModelicaInternal_fullPathName(_In_z_ const char* name) {
     /* Get full path name of file or directory */
 
 #if defined(_WIN32) || (_BSD_SOURCE || _XOPEN_SOURCE >= 500 || _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED || (_POSIX_VERSION >= 200112L))
@@ -650,8 +607,8 @@
     return fullName;
 }
 
-MODELICA_EXPORT const char* ModelicaInternal_temporaryFileName(void) {
-    /* Get full path name of a temporary */
+_Ret_z_ const char* ModelicaInternal_temporaryFileName(void) {
+    /* Get full path name of a temporary file name which does not exist */
     char* fullName;
 
     char* tempName = tmpnam(NULL);
@@ -702,7 +659,7 @@
 #if !defined(WIN32_LEAN_AND_MEAN)
 #define WIN32_LEAN_AND_MEAN
 #endif
-#include <Windows.h>
+#include <windows.h>
 static CRITICAL_SECTION cs;
 #ifdef G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA
 #pragma G_DEFINE_CONSTRUCTOR_PRAGMA_ARGS(initializeCS)
@@ -726,6 +683,12 @@
 #endif
 
 static void CacheFileForReading(FILE* fp, const char* fileName, int line) {
+#define uthash_fatal(msg) do { \
+    MUTEX_UNLOCK(); \
+    ModelicaFormatMessage("Error in uthash: %s\n" \
+        "Hash table for file cache may be left in corrupt state.\n", msg); \
+    return; \
+} while (0)
     FileCache* fv;
     if (fileName == NULL) {
         /* Do not add, close file */
@@ -751,9 +714,13 @@
                 fv->line = line;
                 HASH_ADD_KEYPTR(hh, fileCache, key, (unsigned)strlen(key), fv);
             }
+            else {
+                free(fv);
+            }
         }
     }
     MUTEX_UNLOCK();
+#undef uthash_fatal
 }
 
 static void CloseCachedFile(const char* fileName) {
@@ -822,7 +789,7 @@
     return fp;
 }
 
-MODELICA_EXPORT void ModelicaStreams_closeFile(const char* fileName) {
+void ModelicaStreams_closeFile(_In_z_ const char* fileName) {
     /* Close file */
     CloseCachedFile(fileName); /* Closes it */
 }
@@ -849,7 +816,8 @@
 
 /* --------------------- Modelica_Utilities.Streams ----------------------------------- */
 
-MODELICA_EXPORT void ModelicaInternal_print(const char* string, const char* fileName) {
+void ModelicaInternal_print(_In_z_ const char* string,
+                            _In_z_ const char* fileName) {
     /* Write string to terminal or to file */
     if ( fileName[0] == '\0' ) {
         /* Write string to terminal */
@@ -874,7 +842,7 @@
     }
 }
 
-MODELICA_EXPORT int ModelicaInternal_countLines(const char* fileName) {
+int ModelicaInternal_countLines(_In_z_ const char* fileName) {
     /* Get number of lines of a file */
     int c;
     int nLines = 0;
@@ -897,7 +865,8 @@
     return nLines;
 }
 
-MODELICA_EXPORT void ModelicaInternal_readFile(const char* fileName, const char* string[], size_t nLines) {
+void ModelicaInternal_readFile(_In_z_ const char* fileName,
+                               _Out_ const char** string, size_t nLines) {
     /* Read file into string vector string[nLines] */
     FILE* fp = ModelicaStreams_openFileForReading(fileName, 0);
     char* line;
@@ -958,7 +927,8 @@
     fclose(fp);
 }
 
-MODELICA_EXPORT const char* ModelicaInternal_readLine(const char* fileName, int lineNumber, int* endOfFile) {
+_Ret_z_ const char* ModelicaInternal_readLine(_In_z_ const char* fileName,
+                                      int lineNumber, _Out_ int* endOfFile) {
     /* Read line lineNumber from file fileName */
     FILE* fp = ModelicaStreams_openFileForReading(fileName, lineNumber - 1);
     char* line;
@@ -1032,7 +1002,7 @@
 
 /* --------------------- Modelica_Utilities.System ------------------------------------ */
 
-MODELICA_EXPORT void ModelicaInternal_chdir(const char* directoryName) {
+void ModelicaInternal_chdir(_In_z_ const char* directoryName) {
     /* Change current working directory */
 #if defined(__WATCOMC__) || defined(__LCC__)
     int result = chdir(directoryName);
@@ -1043,17 +1013,17 @@
 #elif defined(_POSIX_) || defined(__GNUC__)
     int result = chdir(directoryName);
 #else
-    int result = -1;
     ModelicaNotExistError("ModelicaInternal_chdir");
 #endif
-
+#if defined(__WATCOMC__) || defined(__LCC__) || defined(__BORLANDC__) || defined(_WIN32) || defined(_POSIX_) || defined(__GNUC__)
     if (result != 0) {
         ModelicaFormatError("Not possible to change current working directory to\n"
             "\"%s\":\n%s", directoryName, strerror(errno));
     }
+#endif
 }
 
-MODELICA_EXPORT const char* ModelicaInternal_getcwd(int dummy) {
+_Ret_z_ const char* ModelicaInternal_getcwd(int dummy) {
     const char* cwd;
     char* directory;
 
@@ -1067,13 +1037,13 @@
     ModelicaNotExistError("ModelicaInternal_getcwd");
     cwd = "";
 #endif
-
+#if defined(__WATCOMC__) || defined(__BORLANDC__) || defined(_WIN32) || defined(_POSIX_) || defined(__GNUC__)
     if (cwd == NULL) {
         ModelicaFormatError("Not possible to get current working directory:\n%s",
             strerror(errno));
         cwd = "";
     }
-
+#endif
     directory = ModelicaAllocateString(strlen(cwd));
     strcpy(directory, cwd);
     ModelicaConvertToUnixDirectorySeparator(directory);
@@ -1080,7 +1050,8 @@
     return directory;
 }
 
-MODELICA_EXPORT void ModelicaInternal_getenv(const char* name, int convertToSlash, const char** content, int* exist) {
+void ModelicaInternal_getenv(_In_z_ const char* name, int convertToSlash,
+                             _Out_ const char** content, _Out_ int* exist) {
     /* Get content of environment variable */
     char* result;
 #if defined(_MSC_VER) && _MSC_VER >= 1400
@@ -1089,17 +1060,12 @@
     errno_t err = _dupenv_s(&value, &len, name);
     if (err) {
         value = NULL;
-        ModelicaFormatError("Not possible to get environment variable:\n%s", strerror(err));
     }
 #else
     char* value = getenv(name);
 #endif
 
-#if defined(_MSC_VER) && _MSC_VER >= 1400
-    if (value == NULL && len == 0 && err == 0) {
-#else
     if (value == NULL) {
-#endif
         result = ModelicaAllocateString(0);
         result[0] = '\0';
         *exist = 0;
@@ -1129,40 +1095,105 @@
     *content = result;
 }
 
-MODELICA_EXPORT void ModelicaInternal_setenv(const char* name, const char* value, int convertFromSlash) {
-#if defined(__WATCOMC__) || defined(__BORLANDC__) || defined(_WIN32) || defined(_POSIX_) || defined(__GNUC__)
-    char localbuf[BUFFER_LENGTH];
-    if (strlen(name) + strlen(value) + 1 > sizeof(localbuf)) {
+#if !defined(_MSC_VER) && !defined(__WATCOMC__) && !defined(__BORLANDC__) && !defined(_WIN32) && defined(_POSIX_) && _POSIX_VERSION < 200112L
+static char envBuf[BUFFER_LENGTH];
+#endif
+
+void ModelicaInternal_setenv(_In_z_ const char* name,
+                             _In_z_ const char* value, int convertFromSlash) {
+    /* Set environment variable */
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+    errno_t err;
+    if (1 == convertFromSlash) {
+        char* buf = (char*)malloc((strlen(value) + 1)*sizeof(char));
+        if (NULL != buf) {
+            strcpy(buf, value);
+            ModelicaConvertFromUnixDirectorySeparator(buf);
+            err = _putenv_s(name, buf);
+            free(buf);
+        }
+        else {
+            ModelicaError("Memory allocation error\n");
+        }
+    }
+    else {
+        err = _putenv_s(name, value);
+    }
+    if (0 != err) {
+        ModelicaFormatError("Not possible to set environment variable:\n%s",
+        strerror(err));
+    }
+#elif defined(__WATCOMC__) || defined(__BORLANDC__) || defined(_WIN32)
+    char* buf = (char*)malloc((strlen(name) + strlen(value) + 2)*sizeof(char));
+    if (NULL != buf) {
+        int result;
+
+        strcpy(buf, name);
+        strcat(buf, "=");
+        strcat(buf, value);
+
+        if (1 == convertFromSlash) {
+            ModelicaConvertFromUnixDirectorySeparator(&buf[strlen(name) + 1]);
+        }
+#if defined(__WATCOMC__) || defined(__BORLANDC__)
+        result = putenv(buf);
+#else
+        result = _putenv(buf);
+#endif
+        free(buf);
+        if (0 != result) {
+            ModelicaFormatError("Environment variable\n"
+                "\"%s\"=\"%s\"\n"
+                "cannot be set: %s", name, value, strerror(errno));
+        }
+    }
+    else {
+        ModelicaError("Memory allocation error\n");
+    }
+#elif defined(_POSIX_) && _POSIX_VERSION >= 200112L
+    int result;
+    if (1 == convertFromSlash) {
+        char* buf = (char*)malloc((strlen(value) + 1)*sizeof(char));
+        if (NULL != buf) {
+            strcpy(buf, value);
+            ModelicaConvertFromUnixDirectorySeparator(buf);
+            result = setenv(name, buf, 1);
+            free(buf);
+        }
+        else {
+            ModelicaError("Memory allocation error\n");
+        }
+    }
+    else {
+        result = setenv(name, value, 1);
+    }
+    if (0 != result) {
+        ModelicaFormatError("Not possible to set environment variable:\n%s",
+        strerror(errno));
+    }
+#elif defined(_POSIX_)
+    /* Restriction: This legacy implementation only works on exactly one
+       environment variable since a single buffer is used. */
+    if (strlen(name) + strlen(value) + 2 > sizeof(envBuf)) {
         ModelicaFormatError("Environment variable\n"
             "\"%s\"=\"%s\"\n"
             "cannot be set, because the internal buffer\n"
             "in file \"ModelicaInternal.c\" is too small (= %d)",
-            name, value, sizeof(localbuf));
+            name, value, sizeof(envBuf));
     }
+    strcpy(envBuf, name);
+    strcat(envBuf, "=");
+    strcat(envBuf, value);
 
-    strcpy(localbuf, name);
-    strcat(localbuf, "=");
-    strcat(localbuf, value);
-
-    if ( convertFromSlash == 1 ) {
-        ModelicaConvertFromUnixDirectorySeparator(&localbuf[strlen(name) + 1]);
+    if (1 == convertFromSlash) {
+        ModelicaConvertFromUnixDirectorySeparator(&envBuf[strlen(name) + 1]);
     }
-#endif
 
-    /* Set environment variable */
-#if defined(__WATCOMC__) || defined(__BORLANDC__) || defined(_POSIX_) || defined(__GNUC__)
-    if (putenv(localbuf) != 0) {
+    if (putenv(envBuf) != 0) {
         ModelicaFormatError("Environment variable\n"
             "\"%s\"=\"%s\"\n"
             "cannot be set: %s", name, value, strerror(errno));
     }
-
-#elif defined(_WIN32)
-    if (_putenv(localbuf) != 0) {
-        ModelicaFormatError("Environment variable\n"
-            "\"%s\"=\"%s\"\n"
-            "cannot be set: %s", name, value, strerror(errno));
-    }
 #else
     ModelicaNotExistError("ModelicaInternal_setenv");
 #endif
@@ -1191,7 +1222,7 @@
   #endif
 #endif
 
-MODELICA_EXPORT int ModelicaInternal_getpid(void) {
+int ModelicaInternal_getpid(void) {
 #if defined(NO_PID)
     return 0;
 #else
@@ -1203,7 +1234,8 @@
 #endif
 }
 
-MODELICA_EXPORT void ModelicaInternal_getTime(int* ms, int* sec, int* min, int* hour, int* mday, int* mon, int* year) {
+void ModelicaInternal_getTime(_Out_ int* ms, _Out_ int* sec, _Out_ int* min, _Out_ int* hour,
+                              _Out_ int* mday, _Out_ int* mon, _Out_ int* year) {
 #if defined(NO_TIME)
     *ms   = 0;
     *sec  = 0;
@@ -1216,9 +1248,19 @@
     struct tm* tlocal;
     time_t calendarTime;
     int ms0;
+#if defined(_POSIX_) || (defined(_MSC_VER) && _MSC_VER >= 1400)
+    struct tm tres;
+#endif
 
     time( &calendarTime );               /* Retrieve sec time */
-    tlocal = localtime( &calendarTime ); /* Time fields in local time zone */
+#if defined(_POSIX_)
+    tlocal = localtime_r(&calendarTime, &tres); /* Time fields in local time zone */
+#elif defined(_MSC_VER) && _MSC_VER >= 1400
+    localtime_s(&tres, &calendarTime);          /* Time fields in local time zone */
+    tlocal = &tres;
+#else
+    tlocal = localtime( &calendarTime );        /* Time fields in local time zone */
+#endif
 
     /* Get millisecond resolution depending on platform */
 #if defined(_WIN32)
@@ -1241,7 +1283,7 @@
     {
         struct timeval tv;
         gettimeofday(&tv, NULL);
-        ms0 = tv.tv_usec/1000; /* Convert microseconds to milliseconds */
+        ms0 = (int)(tv.tv_usec/1000); /* Convert microseconds to milliseconds */
     }
 #endif
 
Index: Modelica/Resources/C-Sources/ModelicaInternal.h
===================================================================
--- Modelica/Resources/C-Sources/ModelicaInternal.h	(nonexistent)
+++ Modelica/Resources/C-Sources/ModelicaInternal.h	(working copy)
@@ -0,0 +1,110 @@
+/* ModelicaInternal.h - External functions header for Modelica.Utilities
+
+   Copyright (C) 2002-2017, Modelica Association and DLR
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   1. Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/* The following #define's are available.
+
+   NO_FILE_SYSTEM : A file system is not present (e.g. on dSPACE or xPC).
+   NO_PID         : Function getpid is not present (e.g. on dSPACE)
+   NO_TIME        : Function gettimeofday is not present (e.g. on dSPACE)
+   MODELICA_EXPORT: Prefix used for function calls. If not defined, blank is used
+                    Useful definition:
+                    - "__declspec(dllexport)" if included in a DLL and the
+                      functions shall be visible outside of the DLL
+*/
+
+#ifndef MODELICA_INTERNAL_H_
+#define MODELICA_INTERNAL_H_
+
+#include <stdlib.h>
+
+#if !defined(MODELICA_EXPORT)
+#if defined(__cplusplus)
+#define MODELICA_EXPORT extern "C"
+#else
+#define MODELICA_EXPORT
+#endif
+#endif
+
+/*
+ * Non-null pointers and esp. null-terminated strings need to be passed to
+ * external functions.
+ *
+ * The following macros handle nonnull attributes for GNU C and Microsoft SAL.
+ */
+#if defined(__GNUC__)
+#define MODELICA_NONNULLATTR __attribute__((nonnull))
+#if defined(__GNUC_MINOR__) && (__GNUC__ > 3 && __GNUC_MINOR__ > 8)
+#define MODELICA_RETURNNONNULLATTR __attribute__((returns_nonnull))
+#else
+#define MODELICA_RETURNNONNULLATTR
+#endif
+#elif defined(__ATTR_SAL)
+#define MODELICA_NONNULLATTR
+#define MODELICA_RETURNNONNULLATTR _Ret_z_ /* _Ret_notnull_ and null-terminated */
+#else
+#define MODELICA_NONNULLATTR
+#define MODELICA_RETURNNONNULLATTR
+#endif
+#if !defined(__ATTR_SAL)
+#define _In_z_
+#define _Out_
+#define _Ret_z_
+#endif
+
+MODELICA_EXPORT void ModelicaInternal_mkdir(_In_z_ const char* directoryName) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaInternal_rmdir(_In_z_ const char* directoryName) MODELICA_NONNULLATTR;
+MODELICA_EXPORT int ModelicaInternal_stat(_In_z_ const char* name) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaInternal_rename(_In_z_ const char* oldName,
+    _In_z_ const char* newName) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaInternal_removeFile(_In_z_ const char* file) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaInternal_copyFile(_In_z_ const char* oldFile,
+    _In_z_ const char* newFile) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaInternal_readDirectory(_In_z_ const char* directory, int nFiles,
+    _Out_ const char** files) MODELICA_NONNULLATTR;
+MODELICA_EXPORT int ModelicaInternal_getNumberOfFiles(_In_z_ const char* directory) MODELICA_NONNULLATTR;
+MODELICA_EXPORT MODELICA_RETURNNONNULLATTR const char* ModelicaInternal_fullPathName(
+    _In_z_ const char* name) MODELICA_NONNULLATTR;
+MODELICA_EXPORT MODELICA_RETURNNONNULLATTR const char* ModelicaInternal_temporaryFileName(void);
+MODELICA_EXPORT void ModelicaStreams_closeFile(_In_z_ const char* fileName) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaInternal_print(_In_z_ const char* string,
+    _In_z_ const char* fileName) MODELICA_NONNULLATTR;
+MODELICA_EXPORT int ModelicaInternal_countLines(_In_z_ const char* fileName) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaInternal_readFile(_In_z_ const char* fileName,
+    _Out_ const char** string, size_t nLines) MODELICA_NONNULLATTR;
+MODELICA_EXPORT MODELICA_RETURNNONNULLATTR const char* ModelicaInternal_readLine(_In_z_ const char* fileName,
+    int lineNumber, _Out_ int* endOfFile) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaInternal_chdir(_In_z_ const char* directoryName) MODELICA_NONNULLATTR;
+MODELICA_EXPORT MODELICA_RETURNNONNULLATTR const char* ModelicaInternal_getcwd(int dummy);
+MODELICA_EXPORT void ModelicaInternal_getenv(_In_z_ const char* name, int convertToSlash,
+    _Out_ const char** content, _Out_ int* exist) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaInternal_setenv(_In_z_ const char* name,
+    _In_z_ const char* value, int convertFromSlash) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaInternal_getTime(_Out_ int* ms, _Out_ int* sec, _Out_ int* min, _Out_ int* hour,
+    _Out_ int* mday, _Out_ int* mon, _Out_ int* year) MODELICA_NONNULLATTR;
+MODELICA_EXPORT int ModelicaInternal_getpid(void);
+
+#endif
Index: Modelica/Resources/C-Sources/ModelicaIO.c
===================================================================
--- Modelica/Resources/C-Sources/ModelicaIO.c	(revision 10440)
+++ Modelica/Resources/C-Sources/ModelicaIO.c	(working copy)
@@ -1,6 +1,6 @@
 /* ModelicaIO.c - Array I/O functions
 
-   Copyright (C) 2016, Modelica Association
+   Copyright (C) 2016-2017, Modelica Association and ESI ITI GmbH
    All rights reserved.
 
    Redistribution and use in source and binary forms, with or without
@@ -25,33 +25,58 @@
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-/* The functions in this file are non-portable. The following #define's are used
-   to define the system calls of the operating system
+/* Definition of interface to external functions for array I/O
+   in the Modelica Standard Library:
 
-   __GNUC__       : GNU C compiler
-   NO_FILE_SYSTEM : A file system is not present (e.g. on dSPACE or xPC).
-   MODELICA_EXPORT: Prefix used for function calls. If not defined, blank is used
-                    Useful definitions:
-                    - "static" that is all functions become static
-                      (useful if file is included with other C-sources for an
-                       embedded system)
-                    - "__declspec(dllexport)" if included in a DLL and the
-                      functions shall be visible outside of the DLL
+      Modelica.Utilities.Streams.readMatrixSize
+      Modelica.Utilities.Streams.readRealMatrix
+      Modelica.Utilities.Streams.writeRealMatrix
 
    Release Notes:
+      Apr. 12, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Improved error messages if reading struct arrays from
+                     MATLAB MAT-file fails (ticket #2105)
+
+      Mar. 08, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added ModelicaIO_readRealTable from ModelicaStandardTables
+                     (ticket #2192)
+
+      Feb. 07, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added support for reading integer and single-precision
+                     variable classes of MATLAB MAT-files (ticket #2106)
+
+      Jan. 31, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added diagnostic message for (supported) partial read of table
+                     from ASCII text file (ticket #2151)
+
+      Jan. 07, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Replaced strtok by re-entrant string tokenize function
+                     (ticket #1153)
+
+      Nov. 23, 2016: by Martin Sjoelund, SICS East Swedish ICT AB
+                     Added NO_LOCALE define flag, in case the OS does
+                     not have this (for example when using GCC compiler,
+                     but not libc). Also added autoconf detection for
+                     this flag, NO_PID, NO_TIME, and NO_FILE_SYSTEM
+
+      Nov. 21, 2016: by Thomas Beutlich, ESI ITI GmbH
+                     Fixed error handling if a variable cannot be found in a
+                     MATLAB MAT-file (ticket #2119)
+
       Mar. 03, 2016: by Thomas Beutlich, ITI GmbH and Martin Otter, DLR
                      Implemented a first version (ticket #1856)
 */
 
-#if !defined(MODELICA_EXPORT)
-  #define MODELICA_EXPORT
+#if defined(__gnu_linux__) && !defined(NO_FILE_SYSTEM)
+#define _GNU_SOURCE 1
 #endif
 
-#include <stdlib.h>
+#include "ModelicaIO.h"
 #include <string.h>
 #include "ModelicaUtilities.h"
 
 #ifdef NO_FILE_SYSTEM
+MODELICA_NORETURN static void ModelicaNotExistError(const char* name) MODELICA_NORETURNATTR;
 static void ModelicaNotExistError(const char* name) {
   /* Print error message if a function is not implemented */
     ModelicaFormatError("C-Function \"%s\" is called "
@@ -60,277 +85,182 @@
         "as for dSPACE or xPC systems)\n", name);
 }
 
-MODELICA_EXPORT void ModelicaIO_readMatrixSizes(const char* fileName,
-    const char* varName, int* dim) {
+void ModelicaIO_readMatrixSizes(_In_z_ const char* fileName,
+    _In_z_ const char* matrixName, _Out_ int* dim) {
     ModelicaNotExistError("ModelicaIO_readMatrixSizes"); }
-MODELICA_EXPORT void ModelicaIO_readRealMatrix(const char* fileName,
-    const char* varName, double* a, size_t m, size_t n, int verbose) {
+void ModelicaIO_readRealMatrix(_In_z_ const char* fileName,
+    _In_z_ const char* matrixName, _Out_ double* matrix, size_t m, size_t n,
+    int verbose) {
     ModelicaNotExistError("ModelicaIO_readRealMatrix"); }
-MODELICA_EXPORT int ModelicaIO_writeRealMatrix(const char* fileName,
-    const char* varName, double* a, size_t m, size_t n, int append, const char* version) {
+int ModelicaIO_writeRealMatrix(_In_z_ const char* fileName,
+    _In_z_ const char* matrixName, _In_ double* matrix, size_t m, size_t n,
+    int append, _In_z_ const char* version) {
     ModelicaNotExistError("ModelicaIO_writeRealMatrix"); return 0; }
+double* ModelicaIO_readRealTable(_In_z_ const char* fileName,
+    _In_z_ const char* matrixName, _Out_ size_t* m, _Out_ size_t* n,
+    int verbose) {
+    ModelicaNotExistError("ModelicaIO_readRealTable"); return NULL; }
 #else
 
 #include <stdio.h>
-#include "ModelicaIO.h"
+#if !defined(NO_LOCALE)
+#include <locale.h>
+#endif
 #include "ModelicaMatIO.h"
 
-static void transpose(double* table, size_t nRow, size_t nCol) {
-  /* Reference:
+/* The standard way to detect POSIX is to check _POSIX_VERSION,
+ * which is defined in <unistd.h>
+ */
+#if defined(__unix__) || defined(__linux__) || defined(__APPLE_CC__)
+#include <unistd.h>
+#endif
+#if !defined(_POSIX_) && defined(_POSIX_VERSION)
+#define _POSIX_ 1
+#endif
 
-     Cycle-based in-place array transposition
-     (http://en.wikipedia.org/wiki/In-place_matrix_transposition#Non-square_matrices:_Following_the_cycles)
-  */
+/* Use re-entrant string tokenize function if available */
+#if defined(_POSIX_)
+#elif defined(_MSC_VER) && _MSC_VER >= 1400
+#define strtok_r(str, delim, saveptr) strtok_s((str), (delim), (saveptr))
+#else
+#define strtok_r(str, delim, saveptr) strtok((str), (delim))
+#endif
 
-    size_t i;
-    for (i = 1; i < nRow*nCol - 1; i++) {
-        size_t x = nRow*(i % nCol) + i/nCol; /* predecessor of i in the cycle */
-        /* Continue if cycle is of length one or predecessor already was visited */
-        if (x <= i) {
-            continue;
-        }
-        /* Continue if cycle already was visited */
-        while (x > i) {
-            x = nRow*(x % nCol) + x/nCol;
-        }
-        if (x < i) {
-            continue;
-        }
-        {
-            double tmp = table[i];
-            size_t s = i; /* start index in the cycle */
-            x = nRow*(i % nCol) + i/nCol; /* predecessor of i in the cycle */
-            while (x != i) {
-                table[s] = table[x];
-                s = x;
-                x = nRow*(x % nCol) + x/nCol;
-            }
-            table[s] = tmp;
-        }
-    }
-}
+#if !defined(LINE_BUFFER_LENGTH)
+#define LINE_BUFFER_LENGTH (64)
+#endif
+#if !defined(MATLAB_NAME_LENGTH_MAX)
+#define MATLAB_NAME_LENGTH_MAX (64)
+#endif
 
-MODELICA_EXPORT void ModelicaIO_readMatrixSizes(const char* fileName,
-    const char* varName, int* dim) {
-    mat_t* mat;
-    matvar_t* matvar;
-    matvar_t* matvarRoot;
-    char* varNameCopy;
-    char* token;
+typedef struct MatIO {
+    mat_t* mat; /* Pointer to MAT-file */
+    matvar_t* matvar; /* Pointer to MAT-file variable for data */
+    matvar_t* matvarRoot; /* Pointer to MAT-file variable for free */
+} MatIO;
 
-    varNameCopy = (char*)malloc((strlen(varName) + 1)*sizeof(char));
-    if (varNameCopy != NULL) {
-        strcpy(varNameCopy, varName);
-    }
-    else {
-        dim[0] = 0;
-        dim[1] = 0;
-        ModelicaError("Memory allocation error\n");
-        return;
-    }
+static double* readMatTable(_In_z_ const char* fileName, _In_z_ const char* tableName,
+                            _Out_ size_t* m, _Out_ size_t* n) MODELICA_NONNULLATTR;
+  /* Read a table from a MATLAB MAT-file using MatIO functions
 
-    mat = Mat_Open(fileName, (int)MAT_ACC_RDONLY);
-    if (mat == NULL) {
-        dim[0] = 0;
-        dim[1] = 0;
-        free(varNameCopy);
-        ModelicaFormatError("Not possible to open file \"%s\": "
-            "No such file or directory\n", fileName);
-        return;
-    }
+     <- RETURN: Pointer to array (row-wise storage) of table values
+  */
 
-    token = strtok(varNameCopy, ".");
-    matvarRoot = Mat_VarReadInfo(mat, token == NULL ? varName : token);
-    if (matvarRoot == NULL) {
-        dim[0] = 0;
-        dim[1] = 0;
-        free(varNameCopy);
-        (void)Mat_Close(mat);
-        ModelicaFormatError(
-            "Variable \"%s\" not found on file \"%s\".\n",
-            token == NULL ? varName : token, fileName);
-        return;
-    }
+static void readMatIO(_In_z_ const char* fileName, _In_z_ const char* matrixName,
+                      _Inout_ MatIO* matio);
+  /* Read a variable from a MATLAB MAT-file using MatIO functions */
 
-    matvar = matvarRoot;
-    token = strtok(NULL, ".");
-    /* Get field while matvar is of struct class and of 1x1 size */
-    while (token != NULL && matvar != NULL &&
-        matvar->class_type == MAT_C_STRUCT && matvar->rank == 2 &&
-        matvar->dims[0] == 1 && matvar->dims[1] == 1) {
-        matvar = Mat_VarGetStructField(matvar, (void*)token, MAT_BY_NAME, 0);
-        token = strtok(NULL, ".");
-    }
-    free(varNameCopy);
+static void readRealMatIO(_In_z_ const char* fileName, _In_z_ const char* matrixName,
+                          _Inout_ MatIO* matio);
+  /* Read a real variable from a MATLAB MAT-file using MatIO functions */
 
-    if (matvar == NULL) {
-        Mat_VarFree(matvarRoot);
-        (void)Mat_Close(mat);
-        ModelicaFormatError(
-            "Matrix \"%s\" not found on file \"%s\".\n", varName, fileName);
-        return;
-    }
+static double* readTxtTable(_In_z_ const char* fileName, _In_z_ const char* tableName,
+                            _Out_ size_t* m, _Out_ size_t* n) MODELICA_NONNULLATTR;
+  /* Read a table from an ASCII text file
 
-    /* Check if matvar is a matrix */
-    if (matvar->rank != 2) {
-        dim[0] = 0;
-        dim[1] = 0;
-        Mat_VarFree(matvarRoot);
-        (void)Mat_Close(mat);
-        ModelicaFormatError(
-            "Array \"%s\" has not the required rank 2.\n", varName);
-        return;
-    }
+     <- RETURN: Pointer to array (row-wise storage) of table values
+  */
 
-    dim[0] = (int)matvar->dims[0];
-    dim[1] = (int)matvar->dims[1];
+static int readLine(_In_ char** buf, _In_ int* bufLen, _In_ FILE* fp) MODELICA_NONNULLATTR;
+  /* Read line (of unknown and arbitrary length) from an ASCII text file */
 
-    Mat_VarFree(matvarRoot);
-    (void)Mat_Close(mat);
-}
+static int IsNumber(char* token);
+  /*  Check, whether a token represents a floating-point number */
 
-MODELICA_EXPORT void ModelicaIO_readRealMatrix(const char* fileName,
-    const char* varName, double* a, size_t m, size_t n, int verbose) {
-    mat_t* mat;
-    matvar_t* matvar;
-    matvar_t* matvarRoot;
-    size_t nRow, nCol;
-    int tableReadError = 0;
-    char* varNameCopy;
-    char* token;
+static void transpose(_Inout_ double* table, size_t nRow, size_t nCol) MODELICA_NONNULLATTR;
+  /* Cycle-based in-place array transposition */
 
-    if (verbose == 1) {
-        /* Print info message, that matrix / file is loading */
-        ModelicaFormatMessage("... loading \"%s\" from \"%s\"\n",
-            varName, fileName);
-    }
+void ModelicaIO_readMatrixSizes(_In_z_ const char* fileName,
+                                _In_z_ const char* matrixName,
+                                _Out_ int* dim) {
+    MatIO matio = {NULL, NULL, NULL};
 
-    varNameCopy = (char*)malloc((strlen(varName) + 1)*sizeof(char));
-    if (varNameCopy != NULL) {
-        strcpy(varNameCopy, varName);
-    }
-    else {
-        ModelicaError("Memory allocation error\n");
-        return;
-    }
+    dim[0] = 0;
+    dim[1] = 0;
 
-    mat = Mat_Open(fileName, (int)MAT_ACC_RDONLY);
-    if (mat == NULL) {
-        free(varNameCopy);
-        ModelicaFormatError("Not possible to open file \"%s\": "
-            "No such file or directory\n", fileName);
-        return;
-    }
+    readRealMatIO(fileName, matrixName, &matio);
+    if (NULL != matio.matvar) {
+        matvar_t* matvar = matio.matvar;
 
-    token = strtok(varNameCopy, ".");
-    matvarRoot = Mat_VarReadInfo(mat, token == NULL ? varName : token);
-    if (matvarRoot == NULL) {
-        free(varNameCopy);
-        (void)Mat_Close(mat);
-        ModelicaFormatError(
-            "Variable \"%s\" not found on file \"%s\".\n",
-            token == NULL ? varName : token, fileName);
-        return;
+        dim[0] = (int)matvar->dims[0];
+        dim[1] = (int)matvar->dims[1];
     }
 
-    matvar = matvarRoot;
-    token = strtok(NULL, ".");
-    /* Get field while matvar is of struct class and of 1x1 size */
-    while (token != NULL && matvar != NULL &&
-        matvar->class_type == MAT_C_STRUCT && matvar->rank == 2 &&
-        matvar->dims[0] == 1 && matvar->dims[1] == 1) {
-        matvar = Mat_VarGetStructField(matvar, (void*)token, MAT_BY_NAME, 0);
-        token = strtok(NULL, ".");
-    }
-    free(varNameCopy);
+    Mat_VarFree(matio.matvarRoot);
+    (void)Mat_Close(matio.mat);
+}
 
-    if (matvar == NULL) {
-        Mat_VarFree(matvarRoot);
-        (void)Mat_Close(mat);
-        ModelicaFormatError(
-            "Matrix \"%s\" not found on file \"%s\".\n", varName, fileName);
-        return;
-    }
+void ModelicaIO_readRealMatrix(_In_z_ const char* fileName,
+                               _In_z_ const char* matrixName,
+                               _Inout_ double* matrix, size_t m, size_t n,
+                               int verbose) {
+    MatIO matio = {NULL, NULL, NULL};
+    int readError = 0;
 
-    /* Check if matvar is a matrix */
-    if (matvar->rank != 2) {
-        Mat_VarFree(matvarRoot);
-        (void)Mat_Close(mat);
-        ModelicaFormatError(
-            "Array \"%s\" has not the required rank 2.\n", varName);
-        return;
+    if (verbose == 1) {
+        /* Print info message, that matrix / file is loading */
+        ModelicaFormatMessage("... loading \"%s\" from \"%s\"\n",
+            matrixName, fileName);
     }
 
-    /* Check if matvar is of double precision class (and thus non-sparse) */
-    if (matvar->class_type != MAT_C_DOUBLE) {
-        Mat_VarFree(matvarRoot);
-        (void)Mat_Close(mat);
-        ModelicaFormatError("2D array \"%s\" has not the required "
-            "double precision class.\n", varName);
-        return;
-    }
+    readRealMatIO(fileName, matrixName, &matio);
+    if (NULL != matio.matvar) {
+        matvar_t* matvar = matio.matvar;
 
-    /* Check if matvar is purely real-valued */
-    if (matvar->isComplex) {
-        Mat_VarFree(matvarRoot);
-        (void)Mat_Close(mat);
-        ModelicaFormatError("2D array \"%s\" must not be complex.\n",
-            varName);
-        return;
-    }
+        /* Check if number of rows matches */
+        if (m != matvar->dims[0]) {
+            Mat_VarFree(matio.matvarRoot);
+            (void)Mat_Close(matio.mat);
+            ModelicaFormatError(
+                "Cannot read %lu rows of array \"%s(%lu,%lu)\" "
+                "from file \"%s\"\n", (unsigned long)m, matrixName,
+                (unsigned long)matvar->dims[0], (unsigned long)matvar->dims[1],
+                fileName);
+            return;
+        }
 
-    nRow = matvar->dims[0];
-    nCol = matvar->dims[1];
+        /* Check if number of columns matches */
+        if (n != matvar->dims[1]) {
+            Mat_VarFree(matio.matvarRoot);
+            (void)Mat_Close(matio.mat);
+            ModelicaFormatError(
+                "Cannot read %lu columns of array \"%s(%lu,%lu)\" "
+                "from file \"%s\"\n", (unsigned long)n, matrixName,
+                (unsigned long)matvar->dims[0], (unsigned long)matvar->dims[1],
+                fileName);
+            return;
+        }
 
-    /* Check if number of rows matches */
-    if (m != nRow) {
-        Mat_VarFree(matvarRoot);
-        (void)Mat_Close(mat);
-        ModelicaFormatError(
-            "Cannot read %lu rows of array \"%s(%lu,%lu)\" "
-            "from file \"%s\"\n", (unsigned long)m, varName,
-            (unsigned long)nRow, (unsigned long)nCol, fileName);
-        return;
+        {
+            int start[2] = {0, 0};
+            int stride[2] = {1, 1};
+            int edge[2];
+            edge[0] = (int)matvar->dims[0];
+            edge[1] = (int)matvar->dims[1];
+            readError = Mat_VarReadData(matio.mat, matvar, matrix, start, stride, edge);
+        }
     }
 
-    /* Check if number of columns matches */
-    if (n != nCol) {
-        Mat_VarFree(matvarRoot);
-        (void)Mat_Close(mat);
-        ModelicaFormatError(
-            "Cannot read %lu columns of array \"%s(%lu,%lu)\" "
-            "from file \"%s\"\n", (unsigned long)n, varName,
-            (unsigned long)nRow, (unsigned long)nCol, fileName);
-        return;
-    }
+    Mat_VarFree(matio.matvarRoot);
+    (void)Mat_Close(matio.mat);
 
-    {
-        int start[2] = {0, 0};
-        int stride[2] = {1, 1};
-        int edge[2];
-        edge[0] = (int)nRow;
-        edge[1] = (int)nCol;
-        tableReadError = Mat_VarReadData(mat, matvar, a, start, stride, edge);
-    }
-
-    Mat_VarFree(matvarRoot);
-    (void)Mat_Close(mat);
-
-    if (tableReadError == 0) {
+    if (readError == 0 && NULL != matrix) {
         /* Array is stored column-wise -> need to transpose */
-        transpose(a, nRow, nCol);
+        transpose(matrix, m, n);
     }
     else {
         ModelicaFormatError(
             "Error when reading numeric data of matrix \"%s(%lu,%lu)\" "
-            "from file \"%s\"\n", varName, (unsigned long)nRow,
-            (unsigned long)nCol, fileName);
-        return;
+            "from file \"%s\"\n", matrixName, (unsigned long)m,
+            (unsigned long)n, fileName);
     }
 }
 
-MODELICA_EXPORT int ModelicaIO_writeRealMatrix(const char* fileName,
-    const char* varName, double* a, size_t m, size_t n, int append, const char* version) {
+int ModelicaIO_writeRealMatrix(_In_z_ const char* fileName,
+                               _In_z_ const char* matrixName,
+                               _In_ double* matrix, size_t m, size_t n,
+                               int append,
+                               _In_z_ const char* version) {
     int status;
     mat_t* mat;
     matvar_t* matvar;
@@ -360,15 +290,15 @@
         matc = MAT_COMPRESSION_NONE;
     }
 
-    if ( append == 0 ) {
+    if (append == 0) {
         mat = Mat_CreateVer(fileName, NULL, matv);
-        if (mat == NULL) {
+        if (NULL == mat) {
             ModelicaFormatError("Not possible to newly create file \"%s\"\n(maybe version 7.3 not supported)\n", fileName);
             return 0;
         }
     } else {
         mat = Mat_Open(fileName, (int)MAT_ACC_RDWR | matv);
-        if (mat == NULL) {
+        if (NULL == mat) {
             ModelicaFormatError("Not possible to open file \"%s\"\n", fileName);
             return 0;
         }
@@ -376,30 +306,749 @@
 
     /* MAT file array is stored column-wise -> need to transpose */
     aT = (double*)malloc(m*n*sizeof(double));
-    if (aT == NULL) {
+    if (NULL == aT) {
         (void)Mat_Close(mat);
         ModelicaError("Memory allocation error\n");
         return 0;
     }
-    memcpy(aT, a, m*n*sizeof(double));
+    memcpy(aT, matrix, m*n*sizeof(double));
     transpose(aT, n, m);
 
     if (append != 0) {
-        (void)Mat_VarDelete(mat, varName);
+        (void)Mat_VarDelete(mat, matrixName);
     }
 
     dims[0] = m;
     dims[1] = n;
-    matvar = Mat_VarCreate(varName, MAT_C_DOUBLE, MAT_T_DOUBLE, 2, dims, aT, MAT_F_DONT_COPY_DATA);
+    matvar = Mat_VarCreate(matrixName, MAT_C_DOUBLE, MAT_T_DOUBLE, 2, dims, aT, MAT_F_DONT_COPY_DATA);
     status = Mat_VarWrite(mat, matvar, matc);
     Mat_VarFree(matvar);
     (void)Mat_Close(mat);
     free(aT);
     if (status != 0) {
-        ModelicaFormatError("Cannot write variable \"%s\" to \"%s\"\n", varName, fileName);
+        ModelicaFormatError("Cannot write variable \"%s\" to \"%s\"\n", matrixName, fileName);
         return 0;
     }
     return 1;
 }
 
+double* ModelicaIO_readRealTable(_In_z_ const char* fileName,
+                                 _In_z_ const char* tableName,
+                                 _Out_ size_t* m, _Out_ size_t* n,
+                                 int verbose) {
+    double* table = NULL;
+    const char* ext;
+    int isMatExt = 0;
+
+    /* Table file can be either ASCII text or binary MATLAB MAT-file */
+    ext = strrchr(fileName, '.');
+    if (NULL != ext) {
+        if (0 == strncmp(ext, ".mat", 4) ||
+            0 == strncmp(ext, ".MAT", 4)) {
+            isMatExt = 1;
+        }
+    }
+
+    if (verbose == 1) {
+        /* Print info message, that table / file is loading */
+        ModelicaFormatMessage("... loading \"%s\" from \"%s\"\n",
+            tableName, fileName);
+    }
+
+    if (isMatExt == 1) {
+        table = readMatTable(fileName, tableName, m, n);
+    }
+    else {
+        table = readTxtTable(fileName, tableName, m, n);
+    }
+    return table;
+}
+
+static double* readMatTable(_In_z_ const char* fileName, _In_z_ const char* tableName,
+                            _Out_ size_t* m, _Out_ size_t* n) {
+    double* table = NULL;
+    MatIO matio = {NULL, NULL, NULL};
+    int readError = 0;
+
+    *m = 0;
+    *n = 0;
+
+    readRealMatIO(fileName, tableName, &matio);
+    if (NULL != matio.matvar) {
+        matvar_t* matvar = matio.matvar;
+
+        table = (double*)malloc(matvar->dims[0]*matvar->dims[1]*sizeof(double));
+        if (NULL == table) {
+            Mat_VarFree(matio.matvarRoot);
+            (void)Mat_Close(matio.mat);
+            ModelicaError("Memory allocation error\n");
+            return NULL;
+        }
+
+        {
+            int start[2] = {0, 0};
+            int stride[2] = {1, 1};
+            int edge[2];
+            edge[0] = (int)matvar->dims[0];
+            edge[1] = (int)matvar->dims[1];
+            readError = Mat_VarReadData(matio.mat, matvar, table, start, stride, edge);
+            *m = matvar->dims[0];
+            *n = matvar->dims[1];
+        }
+    }
+
+    Mat_VarFree(matio.matvarRoot);
+    (void)Mat_Close(matio.mat);
+
+    if (readError == 0 && NULL != table) {
+        /* Array is stored column-wise -> need to transpose */
+        transpose(table, *m, *n);
+    }
+    else {
+        size_t dim[2];
+
+        dim[0] = *m;
+        dim[1] = *n;
+        *m = 0;
+        *n = 0;
+        free(table);
+        table = NULL;
+        ModelicaFormatError(
+            "Error when reading numeric data of matrix \"%s(%lu,%lu)\" "
+            "from file \"%s\"\n", tableName, (unsigned long)dim[0],
+            (unsigned long)dim[1], fileName);
+    }
+    return table;
+}
+
+static void readMatIO(_In_z_ const char* fileName,
+                      _In_z_ const char* matrixName, _Inout_ MatIO* matio) {
+    mat_t* mat;
+    matvar_t* matvar;
+    matvar_t* matvarRoot;
+    char* matrixNameCopy;
+    char* token;
+#if defined(_POSIX_) || (defined(_MSC_VER) && _MSC_VER >= 1400)
+    char* nextToken = NULL;
 #endif
+    char* prevToken;
+    int err = 0;
+
+    matrixNameCopy = (char*)malloc((strlen(matrixName) + 1)*sizeof(char));
+    if (NULL != matrixNameCopy) {
+        strcpy(matrixNameCopy, matrixName);
+    }
+    else {
+        ModelicaError("Memory allocation error\n");
+        return;
+    }
+
+    mat = Mat_Open(fileName, (int)MAT_ACC_RDONLY);
+    if (NULL == mat) {
+        free(matrixNameCopy);
+        ModelicaFormatError("Not possible to open file \"%s\": "
+            "No such file or directory\n", fileName);
+        return;
+    }
+
+    token = strtok_r(matrixNameCopy, ".", &nextToken);
+    matvarRoot = Mat_VarReadInfo(mat, NULL == token ? matrixName : token);
+    if (NULL == matvarRoot) {
+        (void)Mat_Close(mat);
+        if (NULL == token) {
+            free(matrixNameCopy);
+            ModelicaFormatError(
+                "Variable \"%s\" not found on file \"%s\".\n",
+                matrixName, fileName);
+        }
+        else {
+            char matrixNameBuf[MATLAB_NAME_LENGTH_MAX];
+            char dots[4];
+            if (strlen(token) > MATLAB_NAME_LENGTH_MAX - 1) {
+                strncpy(matrixNameBuf, token, MATLAB_NAME_LENGTH_MAX - 1);
+                matrixNameBuf[MATLAB_NAME_LENGTH_MAX - 1] = '\0';
+                strcpy(dots, "...");
+            }
+            else {
+                strcpy(matrixNameBuf, token);
+                dots[0] = '\0';
+            }
+            free(matrixNameCopy);
+            ModelicaFormatError(
+                "Variable \"%s%s\" not found on file \"%s\".\n",
+                matrixNameBuf, dots, fileName);
+        }
+        return;
+    }
+
+    matvar = matvarRoot;
+    prevToken = token;
+    token = strtok_r(NULL, ".", &nextToken);
+    /* Get field while matvar is of struct class and of 1x1 size */
+    while (NULL != token && NULL != matvar) {
+        if (matvar->class_type == MAT_C_STRUCT && matvar->rank == 2 &&
+            matvar->dims[0] == 1 && matvar->dims[1] == 1) {
+            matvar = Mat_VarGetStructField(matvar, (void*)token, MAT_BY_NAME, 0);
+            token = strtok_r(NULL, ".", &nextToken);
+        }
+        else if (matvar->class_type != MAT_C_STRUCT) {
+            err = 1;
+            matvar = NULL;
+            break;
+        }
+        else if (matvar->rank != 2) {
+            err = 2;
+            matvar = NULL;
+            break;
+        }
+        else if (matvar->dims[0] != 1 || matvar->dims[2] != 1) {
+            err = 3;
+            matvar = NULL;
+            break;
+        }
+    }
+
+    if (NULL == matvar) {
+        Mat_VarFree(matvarRoot);
+        (void)Mat_Close(mat);
+        if (NULL != token) {
+            char matrixNameBuf[MATLAB_NAME_LENGTH_MAX];
+            char dots[4];
+            if (strlen(prevToken) > MATLAB_NAME_LENGTH_MAX - 1) {
+                strncpy(matrixNameBuf, prevToken, MATLAB_NAME_LENGTH_MAX - 1);
+                matrixNameBuf[MATLAB_NAME_LENGTH_MAX - 1] = '\0';
+                strcpy(dots, "...");
+            }
+            else {
+                strcpy(matrixNameBuf, prevToken);
+                dots[0] = '\0';
+            }
+            free(matrixNameCopy);
+            if (1 == err) {
+                ModelicaFormatError(
+                    "Variable \"%s%s\" of \"%s\" is not a struct array.\n",
+                    matrixNameBuf, dots, matrixName);
+            }
+            else if (2 == err) {
+                ModelicaFormatError(
+                    "Variable \"%s%s\" of \"%s\" is not a struct array "
+                    "of rank 2.\n",  matrixNameBuf, dots, matrixName);
+            }
+            else if (3 == err) {
+                ModelicaFormatError(
+                    "Variable \"%s%s\" of \"%s\" is not a 1x1 struct array.\n",
+                    matrixNameBuf, dots, matrixName);
+            }
+        }
+        else {
+            free(matrixNameCopy);
+            ModelicaFormatError(
+                "Variable \"%s\" not found on file \"%s\".\n", matrixName, fileName);
+        }
+        return;
+    }
+    free(matrixNameCopy);
+
+    /* Check if matvar is a matrix */
+    if (matvar->rank != 2) {
+        Mat_VarFree(matvarRoot);
+        (void)Mat_Close(mat);
+        ModelicaFormatError(
+            "Variable \"%s\" is not of rank 2.\n", matrixName);
+        return;
+    }
+
+    /* Set output fields for MatIO structure */
+    matio->mat = mat;
+    matio->matvar = matvar;
+    matio->matvarRoot = matvarRoot;
+}
+
+static void readRealMatIO(_In_z_ const char* fileName,
+                          _In_z_ const char* matrixName, _Inout_ MatIO* matio) {
+    readMatIO(fileName, matrixName, matio);
+    if (NULL != matio->matvar) {
+        matvar_t* matvar = matio->matvar;
+
+        /* Check if variable class of matvar is numeric (and thus non-sparse) */
+        if (matvar->class_type != MAT_C_DOUBLE && matvar->class_type != MAT_C_SINGLE &&
+            matvar->class_type != MAT_C_INT8 && matvar->class_type != MAT_C_UINT8 &&
+            matvar->class_type != MAT_C_INT16 && matvar->class_type != MAT_C_UINT16 &&
+            matvar->class_type != MAT_C_INT32 && matvar->class_type != MAT_C_UINT32 &&
+            matvar->class_type != MAT_C_INT64 && matvar->class_type != MAT_C_UINT64) {
+            Mat_VarFree(matio->matvarRoot);
+            (void)Mat_Close(matio->mat);
+            ModelicaFormatError("Matrix \"%s\" is not a "
+                "numeric array.\n", matrixName);
+            return;
+        }
+        matvar->class_type = MAT_C_DOUBLE;
+
+        /* Check if matvar is purely real-valued */
+        if (matvar->isComplex) {
+            Mat_VarFree(matio->matvarRoot);
+            (void)Mat_Close(matio->mat);
+            ModelicaFormatError("Matrix \"%s\" must not be complex.\n",
+                matrixName);
+            return;
+        }
+    }
+}
+
+static int IsNumber(char* token) {
+    int foundExponentSign = 0;
+    int foundExponent = 0;
+    int foundDec = 0;
+    int isNumber = 1;
+    int k = 0;
+
+    if (token[0] == '-' || token[0] == '+') {
+        k = 1;
+    }
+    else {
+        k = 0;
+    }
+    while (token[k] != '\0') {
+        if (token[k] >= '0' && token[k] <= '9') {
+            k++;
+        }
+        else if (token[k] == '.' && foundDec == 0 &&
+            foundExponent == 0 && foundExponentSign == 0) {
+            foundDec = 1;
+            k++;
+        }
+        else if ((token[k] == 'e' || token[k] == 'E') &&
+            foundExponent == 0) {
+            foundExponent = 1;
+            k++;
+        }
+        else if ((token[k] == '-' || token[k] == '+') &&
+            foundExponent == 1 && foundExponentSign == 0) {
+            foundExponentSign = 1;
+            k++;
+        }
+        else {
+            isNumber = 0;
+            break;
+        }
+    }
+    return isNumber;
+}
+
+static double* readTxtTable(_In_z_ const char* fileName, _In_z_ const char* tableName,
+                            _Out_ size_t* m, _Out_ size_t* n) {
+#define DELIM_TABLE_HEADER " \t(,)\r"
+#define DELIM_TABLE_NUMBER " \t,;\r"
+    double* table = NULL;
+    char* buf;
+    int bufLen = LINE_BUFFER_LENGTH;
+    FILE* fp;
+    int foundTable = 0;
+    int readError;
+    unsigned long nRow = 0;
+    unsigned long nCol = 0;
+    unsigned long lineNo = 1;
+#if defined(NO_LOCALE)
+    const char * const dec = ".";
+#elif defined(_MSC_VER) && _MSC_VER >= 1400
+    _locale_t loc;
+#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
+    locale_t loc;
+#else
+    char* dec;
+#endif
+
+    fp = fopen(fileName, "r");
+    if (NULL == fp) {
+        ModelicaFormatError("Not possible to open file \"%s\": "
+            "No such file or directory\n", fileName);
+        return NULL;
+    }
+
+    buf = (char*)malloc(LINE_BUFFER_LENGTH*sizeof(char));
+    if (NULL == buf) {
+        fclose(fp);
+        ModelicaError("Memory allocation error\n");
+        return NULL;
+    }
+
+    /* Read file header */
+    if ((readError = readLine(&buf, &bufLen, fp)) != 0) {
+        free(buf);
+        fclose(fp);
+        if (readError < 0) {
+            ModelicaFormatError(
+                "Error reading first line from file \"%s\": "
+                "End-Of-File reached.\n", fileName);
+        }
+        return NULL;
+    }
+
+    /* Expected file header format: "#1" */
+    if (0 != strncmp(buf, "#1", 2)) {
+        size_t len = strlen(buf);
+        fclose(fp);
+        if (len == 0) {
+            free(buf);
+            ModelicaFormatError(
+                "Error reading format and version information in first "
+                "line of file \"%s\": \"#1\" expected.\n", fileName);
+        }
+        else if (len == 1) {
+            char c0 = buf[0];
+            free(buf);
+            ModelicaFormatError(
+                "Error reading format and version information in first "
+                "line of file \"%s\": \"#1\" expected, but \"%c\" found.\n",
+                fileName, c0);
+        }
+        else {
+            char c0 = buf[0];
+            char c1 = buf[1];
+            free(buf);
+            ModelicaFormatError(
+                "Error reading format and version information in first "
+                "line of file \"%s\": \"#1\" expected, but \"%c%c\" "
+                "found.\n", fileName, c0, c1);
+        }
+        return NULL;
+    }
+
+#if defined(NO_LOCALE)
+#elif defined(_MSC_VER) && _MSC_VER >= 1400
+    loc = _create_locale(LC_NUMERIC, "C");
+#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
+    loc = newlocale(LC_NUMERIC, "C", NULL);
+#else
+    dec = localeconv()->decimal_point;
+#endif
+
+    /* Loop over lines of file */
+    while (readLine(&buf, &bufLen, fp) == 0) {
+        char* token;
+        char* endptr;
+#if defined(_POSIX_) || (defined(_MSC_VER) && _MSC_VER >= 1400)
+        char* nextToken = NULL;
+#endif
+
+        lineNo++;
+        /* Expected table header format: "dataType tableName(nRow,nCol)" */
+        token = strtok_r(buf, DELIM_TABLE_HEADER, &nextToken);
+        if (NULL == token) {
+            continue;
+        }
+        if ((0 != strcmp(token, "double")) && (0 != strcmp(token, "float"))) {
+            continue;
+        }
+        token = strtok_r(NULL, DELIM_TABLE_HEADER, &nextToken);
+        if (NULL == token) {
+            continue;
+        }
+        if (0 == strcmp(token, tableName)) {
+            foundTable = 1;
+        }
+        else {
+            continue;
+        }
+        token = strtok_r(NULL, DELIM_TABLE_HEADER, &nextToken);
+        if (NULL == token) {
+            continue;
+        }
+#if !defined(NO_LOCALE) && (defined(_MSC_VER) && _MSC_VER >= 1400)
+        nRow = (unsigned long)_strtol_l(token, &endptr, 10, loc);
+#elif !defined(NO_LOCALE) && (defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3))
+        nRow = (unsigned long)strtol_l(token, &endptr, 10, loc);
+#else
+        nRow = (unsigned long)strtol(token, &endptr, 10);
+#endif
+        if (*endptr != 0) {
+            continue;
+        }
+        token = strtok_r(NULL, DELIM_TABLE_HEADER, &nextToken);
+        if (NULL == token) {
+            continue;
+        }
+#if !defined(NO_LOCALE) && (defined(_MSC_VER) && _MSC_VER >= 1400)
+        nCol = (unsigned long)_strtol_l(token, &endptr, 10, loc);
+#elif !defined(NO_LOCALE) && (defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3))
+        nCol = (unsigned long)strtol_l(token, &endptr, 10, loc);
+#else
+        nCol = (unsigned long)strtol(token, &endptr, 10);
+#endif
+        if (*endptr != 0) {
+            continue;
+        }
+
+        { /* foundTable == 1 */
+            size_t i = 0;
+            size_t j = 0;
+
+            table = (double*)malloc(nRow*nCol*sizeof(double));
+            if (NULL == table) {
+                *m = 0;
+                *n = 0;
+                free(buf);
+                fclose(fp);
+#if defined(NO_LOCALE)
+#elif defined(_MSC_VER) && _MSC_VER >= 1400
+                _free_locale(loc);
+#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
+                freelocale(loc);
+#endif
+                ModelicaError("Memory allocation error\n");
+                return table;
+            }
+
+            /* Loop over rows and store table row-wise */
+            while (readError == 0 && i < nRow) {
+                int k = 0;
+
+                lineNo++;
+                if ((readError = readLine(&buf, &bufLen, fp)) != 0) {
+                    break;
+                }
+                /* Ignore leading white space */
+                while (k < bufLen - 1) {
+                    if (buf[k] != ' ' && buf[k] != '\t') {
+                        break;
+                    }
+                    k++;
+                }
+                if (buf[k] == '\0' || buf[k] == '#') {
+                    /* Skip empty or comment line */
+                    continue;
+                }
+#if defined(_POSIX_) || (defined(_MSC_VER) && _MSC_VER >= 1400)
+                nextToken = NULL;
+#endif
+                token = strtok_r(&buf[k], DELIM_TABLE_NUMBER, &nextToken);
+                while (NULL != token && i < nRow && j < nCol) {
+                    if (token[0] == '#') {
+                        /* Skip trailing comment line */
+                        break;
+                    }
+#if !defined(NO_LOCALE) && (defined(_MSC_VER) && _MSC_VER >= 1400)
+                    table[i*nCol + j] = _strtod_l(token, &endptr, loc);
+                    if (*endptr != 0) {
+                        readError = 1;
+                    }
+#elif !defined(NO_LOCALE) && (defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3))
+                    table[i*nCol + j] = strtod_l(token, &endptr, loc);
+                    if (*endptr != 0) {
+                        readError = 1;
+                    }
+#else
+                    if (*dec == '.') {
+                        table[i*nCol + j] = strtod(token, &endptr);
+                    }
+                    else if (NULL == strchr(token, '.')) {
+                        table[i*nCol + j] = strtod(token, &endptr);
+                    }
+                    else {
+                        char* token2 = (char*)malloc(
+                            (strlen(token) + 1)*sizeof(char));
+                        if (NULL != token2) {
+                            char* p;
+                            strcpy(token2, token);
+                            p = strchr(token2, '.');
+                            *p = *dec;
+                            table[i*nCol + j] = strtod(token2, &endptr);
+                            if (*endptr != 0) {
+                                readError = 1;
+                            }
+                            free(token2);
+                        }
+                        else {
+                            *m = 0;
+                            *n = 0;
+                            free(buf);
+                            fclose(fp);
+                            readError = 1;
+                            ModelicaError("Memory allocation error\n");
+                            break;
+                        }
+                    }
+#endif
+                    if (++j == nCol) {
+                        i++; /* Increment row index */
+                        j = 0; /* Reset column index */
+                    }
+                    if (readError == 0) {
+                        token = strtok_r(NULL, DELIM_TABLE_NUMBER, &nextToken);
+                        continue;
+                    }
+                    else {
+                        break;
+                    }
+                }
+                /* Check for trailing non-comment character */
+                if (NULL != token && token[0] != '#') {
+                    readError = 1;
+                    /* Check for trailing number (on same line) */
+                    if (i == nRow && 1 == IsNumber(token)) {
+                        readError = 2;
+                    }
+                    break;
+                }
+                /* Extra check for partial table read */
+                else if (NULL == token && 0 == readError && i == nRow) {
+                    unsigned long lineNoPartial = lineNo;
+                    int tableReadPartial = 0;
+                    while (readLine(&buf, &bufLen, fp) == 0) {
+                        lineNoPartial++;
+                        /* Ignore leading white space */
+                        while (k < bufLen - 1) {
+                            if (buf[k] != ' ' && buf[k] != '\t') {
+                                break;
+                            }
+                            k++;
+                        }
+                        if (buf[k] == '\0' || buf[k] == '#') {
+                            /* Skip empty or comment line */
+                            continue;
+                        }
+#if defined(_POSIX_) || (defined(_MSC_VER) && _MSC_VER >= 1400)
+                        nextToken = NULL;
+#endif
+                        token = strtok_r(&buf[k], DELIM_TABLE_NUMBER, &nextToken);
+                        if (NULL != token) {
+                            if (1 == IsNumber(token)) {
+                                tableReadPartial = 1;
+                            }
+                            /* Else, it is not a number: No further check
+                               is performed, if legal or not
+                            */
+                        }
+                        break;
+                    }
+                    if (1 == tableReadPartial) {
+                        ModelicaFormatMessage(
+                            "The table dimensions of matrix \"%s(%lu,%lu)\" from file "
+                            "\"%s\" do not match the actual table size (line %lu).\n",
+                            tableName, nRow, nCol, fileName, lineNoPartial);
+                    }
+                    break;
+                }
+            }
+            break;
+        }
+    }
+
+    free(buf);
+    fclose(fp);
+#if defined(NO_LOCALE)
+#elif defined(_MSC_VER) && _MSC_VER >= 1400
+    _free_locale(loc);
+#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
+    freelocale(loc);
+#endif
+    if (foundTable == 0) {
+        ModelicaFormatError(
+            "Table matrix \"%s\" not found on file \"%s\".\n",
+            tableName, fileName);
+        return table;
+    }
+
+    if (readError == 0) {
+        *m = (size_t)nRow;
+        *n = (size_t)nCol;
+    }
+    else {
+        free(table);
+        table = NULL;
+        *m = 0;
+        *n = 0;
+        if (readError == EOF) {
+            ModelicaFormatError(
+                "End-of-file reached when reading numeric data of matrix "
+                "\"%s(%lu,%lu)\" from file \"%s\"\n", tableName, nRow,
+                nCol, fileName);
+        }
+        else if (readError == 2) {
+            ModelicaFormatError(
+                "The table dimensions of matrix \"%s(%lu,%lu)\" from file "
+                "\"%s\" do not match the actual table size (line %lu).\n",
+                tableName, nRow, nCol, fileName, lineNo);
+        }
+        else {
+            ModelicaFormatError(
+                "Error in line %lu when reading numeric data of matrix "
+                "\"%s(%lu,%lu)\" from file \"%s\"\n", lineNo, tableName,
+                nRow, nCol, fileName);
+        }
+    }
+    return table;
+#undef DELIM_TABLE_HEADER
+#undef DELIM_TABLE_NUMBER
+}
+
+static int readLine(_In_ char** buf, _In_ int* bufLen, _In_ FILE* fp) {
+    char* offset;
+    int oldBufLen;
+
+    if (fgets(*buf, *bufLen, fp) == NULL) {
+        return EOF;
+    }
+
+    do {
+        char* p;
+        char* tmp;
+
+        if ((p = strchr(*buf, '\n')) != NULL) {
+            *p = '\0';
+            return 0;
+        }
+
+        oldBufLen = *bufLen;
+        *bufLen *= 2;
+        tmp = (char*)realloc(*buf, (size_t)*bufLen);
+        if (NULL == tmp) {
+            fclose(fp);
+            free(*buf);
+            ModelicaError("Memory allocation error\n");
+            return 1;
+        }
+        *buf = tmp;
+        offset = &((*buf)[oldBufLen - 1]);
+
+    } while (fgets(offset, oldBufLen + 1, fp));
+
+    return 0;
+}
+
+static void transpose(_Inout_ double* table, size_t nRow, size_t nCol) {
+  /* Reference:
+
+     Cycle-based in-place array transposition
+     (http://en.wikipedia.org/wiki/In-place_matrix_transposition#Non-square_matrices:_Following_the_cycles)
+  */
+
+    size_t i;
+    for (i = 1; i < nRow*nCol - 1; i++) {
+        size_t x = nRow*(i % nCol) + i/nCol; /* predecessor of i in the cycle */
+        /* Continue if cycle is of length one or predecessor already was visited */
+        if (x <= i) {
+            continue;
+        }
+        /* Continue if cycle already was visited */
+        while (x > i) {
+            x = nRow*(x % nCol) + x/nCol;
+        }
+        if (x < i) {
+            continue;
+        }
+        {
+            double tmp = table[i];
+            size_t s = i; /* start index in the cycle */
+            x = nRow*(i % nCol) + i/nCol; /* predecessor of i in the cycle */
+            while (x != i) {
+                table[s] = table[x];
+                s = x;
+                x = nRow*(x % nCol) + x/nCol;
+            }
+            table[s] = tmp;
+        }
+    }
+}
+
+#endif
Index: Modelica/Resources/C-Sources/ModelicaIO.h
===================================================================
--- Modelica/Resources/C-Sources/ModelicaIO.h	(revision 10440)
+++ Modelica/Resources/C-Sources/ModelicaIO.h	(working copy)
@@ -1,6 +1,6 @@
 /* ModelicaIO.h - Array I/O functions header
 
-   Copyright (C) 2016, Modelica Association
+   Copyright (C) 2016-2017, Modelica Association and ESI ITI GmbH
    All rights reserved.
 
    Redistribution and use in source and binary forms, with or without
@@ -25,23 +25,43 @@
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-/* Definition of interface to external functions for array I/O
-   in the Modelica Standard Library:
+/* The following #define's are available.
 
-      Modelica.Utilities.Streams.readMatrixSize
-      Modelica.Utilities.Streams.readRealMatrix
-      Modelica.Utilities.Streams.writeRealMatrix
+   NO_FILE_SYSTEM : A file system is not present (e.g. on dSPACE or xPC).
+   NO_LOCALE      : locale.h is not present (e.g. on AVR).
+   MODELICA_EXPORT: Prefix used for function calls. If not defined, blank is used
+                    Useful definition:
+                    - "__declspec(dllexport)" if included in a DLL and the
+                      functions shall be visible outside of the DLL
 
    Release Notes:
+      Mar. 08, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added ModelicaIO_readRealTable from ModelicaStandardTables
+                     (ticket #2192)
+
       Mar. 03, 2016: by Thomas Beutlich, ITI GmbH and Martin Otter, DLR
                      Implemented a first version (ticket #1856)
 */
 
-#if !defined(MODELICAIO_H)
-#define MODELICAIO_H
+#ifndef MODELICA_IO_H_
+#define MODELICA_IO_H_
 
 #include <stdlib.h>
 
+#if !defined(MODELICA_EXPORT)
+#if defined(__cplusplus)
+#define MODELICA_EXPORT extern "C"
+#else
+#define MODELICA_EXPORT
+#endif
+#endif
+
+/*
+ * Non-null pointers and esp. null-terminated strings need to be passed to
+ * external functions.
+ *
+ * The following macros handle nonnull attributes for GNU C and Microsoft SAL.
+ */
 #if defined(__GNUC__)
 #define MODELICA_NONNULLATTR __attribute__((nonnull))
 #else
@@ -50,11 +70,70 @@
 #if !defined(__ATTR_SAL)
 #define _In_
 #define _In_z_
+#define _Inout_
 #define _Out_
 #endif
 
-void ModelicaIO_readMatrixSizes(_In_z_ const char* fileName, _In_z_ const char* arrayName, _Out_ int* dim) MODELICA_NONNULLATTR;
-void ModelicaIO_readRealMatrix(_In_z_ const char* fileName, _In_z_ const char* arrayName, _Out_ double* a, size_t m, size_t n, int verbose) MODELICA_NONNULLATTR;
-int  ModelicaIO_writeRealMatrix(_In_z_ const char* fileName, _In_z_ const char* arrayName, _In_ double* a, size_t m, size_t n, int append, _In_z_ const char* version) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaIO_readMatrixSizes(_In_z_ const char* fileName,
+                                _In_z_ const char* matrixName,
+                                _Out_ int* dim) MODELICA_NONNULLATTR;
+  /* Read matrix dimensions from file
 
+     -> fileName: Name of file
+     -> matrixName: Name of matrix
+     -> dim: Output array for number of rows and columns
+  */
+
+MODELICA_EXPORT void ModelicaIO_readRealMatrix(_In_z_ const char* fileName,
+                               _In_z_ const char* matrixName,
+                               _Inout_ double* matrix, size_t m, size_t n,
+                               int verbose) MODELICA_NONNULLATTR;
+  /* Read matrix from file
+
+     -> fileName: Name of file
+     -> matrixName: Name of matrix
+     -> matrix: Output array of dimensions m by n
+     -> m: Number of rows
+     -> n: Number of columns
+     -> verbose: Print message that file is loading
+  */
+
+MODELICA_EXPORT int ModelicaIO_writeRealMatrix(_In_z_ const char* fileName,
+                               _In_z_ const char* matrixName,
+                               _In_ double* matrix, size_t m, size_t n,
+                               int append,
+                               _In_z_ const char* version) MODELICA_NONNULLATTR;
+  /* Write matrix to file
+
+     -> fileName: Name of file
+     -> matrixName: Name of matrix
+     -> matrix: Input array of dimensions m by n
+     -> m: Number of rows
+     -> n: Number of columns
+     -> append: File append flag
+                = 1: if matrix is to be appended to (existing) file,
+                = 0: if file is to be newly created
+     -> version: Desired file version
+                 = "4": MATLAB MAT-file of version 4
+                 = "6": MATLAB MAT-file of version 6
+                 = "7": MATLAB MAT-file of version 7
+                 = "7.3": MATLAB MAT-file of version 7.3
+  */
+
+MODELICA_EXPORT double* ModelicaIO_readRealTable(_In_z_ const char* fileName,
+                                 _In_z_ const char* tableName,
+                                 _Out_ size_t* m, _Out_ size_t* n,
+                                 int verbose) MODELICA_NONNULLATTR;
+  /* Read matrix and its dimensions from file
+     Note: Only called from ModelicaStandardTables, but impossible to be called
+     from a Modelica environment
+
+     -> fileName: Name of file
+     -> matrixName: Name of matrix
+     -> m: Number of rows
+     -> n: Number of columns
+     -> verbose: Print message that file is loading
+     <- RETURN: Array of dimensions m by n
+  */
+
 #endif
Index: Modelica/Resources/C-Sources/ModelicaMatIO.c
===================================================================
--- Modelica/Resources/C-Sources/ModelicaMatIO.c	(revision 10440)
+++ Modelica/Resources/C-Sources/ModelicaMatIO.c	(working copy)
@@ -1,6 +1,6 @@
 /* ModelicaMatIO.c - MAT file I/O functions
 
-   Copyright (C) 2013-2016, Christopher C. Hulbert, Modelica Association, and ITI GmbH
+   Copyright (C) 2013-2017, Christopher C. Hulbert, Modelica Association, and ESI ITI GmbH
    Copyright (C) 2005-2013, Christopher C. Hulbert
    All rights reserved.
 
@@ -26,8 +26,7 @@
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-/*
-   This file was created by concatenation of the following C source files of the
+/* This file was created by concatenation of the following C source files of the
    MAT file I/O library from <http://sourceforge.net/projects/matio/>:
 
    endian.c
@@ -43,19 +42,18 @@
    matvar_struct.c
 */
 
-/*
-   By default v4 and v6 MAT-files are supported. The v7 and v7.3 MAT-file
+/* By default v4 and v6 MAT-files are supported. The v7 and v7.3 MAT-file
    formats require additional preprocessor options and third-party libraries.
    The following #define's are available.
 
    NO_FILE_SYSTEM: A file system is not present (e.g. on dSPACE or xPC).
+   NO_LOCALE     : locale.h is not present (e.g. on AVR).
    HAVE_ZLIB=1   : Enables the support of v7 MAT-files
                    The zlib (>= v1.2.3) library is required.
    HAVE_HDF5=1   : Enables the support of v7.3 MAT-files
-                   The hdf5 (>= v1.8) and szip libraries are required.
+                   The hdf5 (>= v1.8) library is required.
 */
 
-#include "ModelicaUtilities.h"
 #if !defined(NO_FILE_SYSTEM)
 #if defined(__gnu_linux__)
 #define _GNU_SOURCE 1
@@ -63,6 +61,7 @@
 #define __USE_MINGW_ANSI_STDIO 1
 #endif
 #include <stdarg.h>
+#include "ModelicaUtilities.h"
 
 /* -------------------------------
  * ---------- endian.c
@@ -76,10 +75,10 @@
 #define MATIO_PRIVATE_H
 
 /* Extended sparse matrix data types */
-#define EXTENDED_SPARSE 1
+/* #undef EXTENDED_SPARSE */
 
 /* Define to 1 if you have the `asprintf' function. */
-#if defined(__CYGWIN__)
+#if defined(__CYGWIN__) || defined(__gnu_linux__)
 #define HAVE_ASPRINTF 1
 #else
 #undef HAVE_ASPRINTF
@@ -115,11 +114,13 @@
 #undef HAVE_INTTYPES_H
 #endif
 
+#if !defined(NO_LOCALE)
 /* Define to 1 if you have the `localeconv' function. */
 #define HAVE_LOCALECONV 1
 
 /* Define to 1 if you have the <locale.h> header file. */
 #define HAVE_LOCALE_H 1
+#endif
 
 /* Define to 1 if the system has the type `long double'. */
 #if defined (_WIN32)
@@ -226,7 +227,7 @@
 #endif
 
 /* Define to 1 if you have the `vasprintf' function. */
-#if defined(__CYGWIN__)
+#if defined(__CYGWIN__) || defined(__gnu_linux__)
 #define HAVE_VASPRINTF 1
 #else
 #undef HAVE_VASPRINTF
@@ -312,17 +313,18 @@
  * @endif
  */
 struct _mat_t {
-    void *fp;               /**< File pointer for the MAT file */
-    char *header;           /**< MAT File header string */
-    char *subsys_offset;    /**< Offset */
-    char *filename;         /**< Filename of the MAT file */
-    int   version;          /**< MAT File version */
-    int   byteswap;         /**< 1 if byte swapping is required, 0 otherwise */
-    int   mode;             /**< Access mode */
-    long  bof;              /**< Beginning of file not including any header */
-    long  next_index;       /**< Index/File position of next variable to read */
-    long  num_datasets;     /**< Number of datasets in the file */
-    hid_t refs_id;          /**< Id of the /#refs# group in HDF5 */
+    void  *fp;              /**< File pointer for the MAT file */
+    char  *header;          /**< MAT File header string */
+    char  *subsys_offset;   /**< Offset */
+    char  *filename;        /**< Filename of the MAT file */
+    int    version;         /**< MAT File version */
+    int    byteswap;        /**< 1 if byte swapping is required, 0 otherwise */
+    int    mode;            /**< Access mode */
+    long   bof;             /**< Beginning of file not including any header */
+    size_t next_index;      /**< Index/File position of next variable to read */
+    size_t num_datasets;    /**< Number of datasets in the file */
+    hid_t  refs_id;         /**< Id of the /#refs# group in HDF5 */
+    char **dir;             /**< Names of the datasets in the file */
 };
 
 /** @if mat_devman
@@ -345,33 +347,33 @@
 #endif
 };
 
-/*    snprintf.c    */
+/* snprintf.c */
 #if !HAVE_VSNPRINTF
-int rpl_vsnprintf(char *, size_t, const char *, va_list);
+static int rpl_vsnprintf(char *, size_t, const char *, va_list);
 #define mat_vsnprintf rpl_vsnprintf
 #else
 #define mat_vsnprintf vsnprintf
-#endif  /* !HAVE_VSNPRINTF */
+#endif /* !HAVE_VSNPRINTF */
 #if !HAVE_SNPRINTF
-int rpl_snprintf(char *, size_t, const char *, ...);
+static int rpl_snprintf(char *, size_t, const char *, ...);
 #define mat_snprintf rpl_snprintf
 #else
 #define mat_snprintf snprintf
-#endif  /* !HAVE_SNPRINTF */
+#endif /* !HAVE_SNPRINTF */
 #if !HAVE_VASPRINTF
-int rpl_vasprintf(char **, const char *, va_list);
+static int rpl_vasprintf(char **, const char *, va_list);
 #define mat_vasprintf rpl_vasprintf
 #else
 #define mat_vasprintf vasprintf
-#endif  /* !HAVE_VASPRINTF */
+#endif /* !HAVE_VASPRINTF */
 #if !HAVE_ASPRINTF
-int rpl_asprintf(char **, const char *, ...);
+static int rpl_asprintf(char **, const char *, ...);
 #define mat_asprintf rpl_asprintf
 #else
 #define mat_asprintf asprintf
-#endif  /* !HAVE_ASPRINTF */
+#endif /* !HAVE_ASPRINTF */
 
-/*   endian.c     */
+/* endian.c */
 static double        Mat_doubleSwap(double  *a);
 static float         Mat_floatSwap(float   *a);
 #ifdef HAVE_MATIO_INT64_T
@@ -457,7 +459,7 @@
                enum matio_classes class_type,enum matio_types data_type,
                int rank,size_t *dims,int *start,int *stride,int *edge);
 
-/*   inflate.c    */
+/* inflate.c */
 static size_t InflateSkip(mat_t *mat, z_streamp z, int nbytes);
 static size_t InflateSkip2(mat_t *mat, matvar_t *matvar, int nbytes);
 static size_t InflateSkipData(mat_t *mat,z_streamp z,enum matio_types data_type,int len);
@@ -475,6 +477,9 @@
                int fieldname_length,int padding);
 #endif
 
+/* mat.c */
+static mat_complex_split_t *ComplexMalloc(size_t nbytes);
+
 #endif
 
 /** @brief swap the bytes @c a and @c b
@@ -1697,6 +1702,38 @@
 #include <math.h>
 #include <time.h>
 
+#define READ_DATA(SwapFunc) \
+    do { \
+        if ( mat->byteswap ) { \
+            for ( i = 0; i < len; i++ ) { \
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp); \
+                data[i] = SwapFunc(&v); \
+            } \
+        } else { \
+            for ( i = 0; i < len; i++ ) { \
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp); \
+                data[i] = v; \
+            } \
+        } \
+    } while (0)
+
+#if defined(HAVE_ZLIB)
+#define READ_COMPRESSED_DATA(SwapFunc) \
+    do { \
+        if ( mat->byteswap ) { \
+            for ( i = 0; i < len; i++ ) { \
+                InflateData(mat,z,&v,data_size); \
+                data[i] = SwapFunc(&v); \
+            } \
+        } else { \
+            for ( i = 0; i < len; i++ ) { \
+                InflateData(mat,z,&v,data_size); \
+                data[i] = v; \
+            } \
+        } \
+    } while (0)
+#endif
+
 /*
  * --------------------------------------------------------------------------
  *    Routines to read data of any type into arrays of a specific type
@@ -1720,15 +1757,16 @@
 static int
 ReadDoubleData(mat_t *mat,double *data,enum matio_types data_type,int len)
 {
-    int bytesread = 0, data_size = 0, i;
+    int bytesread = 0, data_size, i;
 
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            data_size = sizeof(double);
             if ( mat->byteswap ) {
                 bytesread += fread(data,data_size,len,(FILE*)mat->fp);
                 for ( i = 0; i < len; i++ ) {
@@ -1741,113 +1779,66 @@
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&i8,data_size,1,(FILE*)mat->fp);
-                data[i] = i8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
+            mat_uint8_t v;
 
-            data_size = sizeof(mat_uint8_t);
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&ui8,data_size,1,(FILE*)mat->fp);
-                data[i] = ui8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
@@ -1876,14 +1867,15 @@
 ReadCompressedDoubleData(mat_t *mat,z_streamp z,double *data,
     enum matio_types data_type,int len)
 {
-    int nBytes = 0, data_size = 0, i;
+    int nBytes = 0, data_size, i;
     union _buf {
-#if SIZEOF_DOUBLE == 8
-        double          d[128];
-#elif SIZEOF_DOUBLE == 16
-        double          d[64];
+        float           f[256];
+#ifdef HAVE_MATIO_INT64_T
+        mat_int64_t   i64[128];
 #endif
-        float           f[256];
+#ifdef HAVE_MATIO_UINT64_T
+        mat_uint64_t ui64[128];
+#endif
         mat_int32_t   i32[256];
         mat_uint32_t ui32[256];
         mat_int16_t   i16[512];
@@ -1892,10 +1884,11 @@
         mat_uint8_t   ui8[1024];
     } buf;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            data_size = sizeof(double);
             if ( mat->byteswap ) {
                 InflateData(mat,z,data,len*data_size);
                 for ( i = 0; i < len; i++ )
@@ -1905,9 +1898,135 @@
             }
             break;
         }
+        case MAT_T_SINGLE:
+        {
+            if ( mat->byteswap ) {
+                if ( len <= 256 ){
+                    InflateData(mat,z,buf.f,len*data_size);
+                    for ( i = 0; i < len; i++ )
+                        data[i] = Mat_floatSwap(buf.f+i);
+                } else {
+                    int j;
+                    len -= 256;
+                    for ( i = 0; i < len; i+=256 ) {
+                        InflateData(mat,z,buf.f,256*data_size);
+                        for ( j = 0; j < 256; j++ )
+                            data[i+j] = Mat_floatSwap(buf.f+j);
+                    }
+                    len = len-(i-256);
+                    InflateData(mat,z,buf.f,len*data_size);
+                    for ( j = 0; j < len; j++ )
+                        data[i+j] = Mat_floatSwap(buf.f+j);
+                }
+            } else {
+                if ( len <= 256 ){
+                    InflateData(mat,z,buf.f,len*data_size);
+                    for ( i = 0; i < len; i++ )
+                        data[i] = buf.f[i];
+                } else {
+                    int j;
+                    len -= 256;
+                    for ( i = 0; i < len; i+=256 ) {
+                        InflateData(mat,z,buf.f,256*data_size);
+                        for ( j = 0; j < 256; j++ )
+                            data[i+j] = buf.f[j];
+                    }
+                    len = len-(i-256);
+                    InflateData(mat,z,buf.f,len*data_size);
+                    for ( j = 0; j < len; j++ )
+                        data[i+j] = buf.f[j];
+                }
+            }
+            break;
+        }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            if ( mat->byteswap ) {
+                if ( len <= 128 ){
+                    InflateData(mat,z,buf.i64,len*data_size);
+                    for ( i = 0; i < len; i++ )
+                        data[i] = Mat_int64Swap(buf.i64+i);
+                } else {
+                    int j;
+                    len -= 128;
+                    for ( i = 0; i < len; i+=128 ) {
+                        InflateData(mat,z,buf.i64,128*data_size);
+                        for ( j = 0; j < 128; j++ )
+                            data[i+j] = Mat_int64Swap(buf.i64+j);
+                    }
+                    len = len-(i-128);
+                    InflateData(mat,z,buf.i64,len*data_size);
+                    for ( j = 0; j < len; j++ )
+                        data[i+j] = Mat_int64Swap(buf.i64+j);
+                }
+            } else {
+                if ( len <= 128 ){
+                    InflateData(mat,z,buf.i64,len*data_size);
+                    for ( i = 0; i < len; i++ )
+                        data[i] = buf.i64[i];
+                } else {
+                    int j;
+                    len -= 128;
+                    for ( i = 0; i < len; i+=128 ) {
+                        InflateData(mat,z,buf.i64,128*data_size);
+                        for ( j = 0; j < 128; j++ )
+                            data[i+j] = buf.i64[j];
+                    }
+                    len = len-(i-128);
+                    InflateData(mat,z,buf.i64,len*data_size);
+                    for ( j = 0; j < len; j++ )
+                        data[i+j] = buf.i64[j];
+                }
+            }
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            if ( mat->byteswap ) {
+                if ( len <= 128 ){
+                    InflateData(mat,z,buf.ui64,len*data_size);
+                    for ( i = 0; i < len; i++ )
+                        data[i] = Mat_uint64Swap(buf.ui64+i);
+                } else {
+                    int j;
+                    len -= 128;
+                    for ( i = 0; i < len; i+=128 ) {
+                        InflateData(mat,z,buf.ui64,128*data_size);
+                        for ( j = 0; j < 128; j++ )
+                            data[i+j] = Mat_uint64Swap(buf.ui64+j);
+                    }
+                    len = len-(i-128);
+                    InflateData(mat,z,buf.ui64,len*data_size);
+                    for ( j = 0; j < len; j++ )
+                        data[i+j] = Mat_uint64Swap(buf.ui64+j);
+                }
+            } else {
+                if ( len <= 128 ){
+                    InflateData(mat,z,buf.ui64,len*data_size);
+                    for ( i = 0; i < len; i++ )
+                        data[i] = buf.ui64[i];
+                } else {
+                    int j;
+                    len -= 128;
+                    for ( i = 0; i < len; i+=128 ) {
+                        InflateData(mat,z,buf.ui64,128*data_size);
+                        for ( j = 0; j < 128; j++ )
+                            data[i+j] = buf.ui64[j];
+                    }
+                    len = len-(i-128);
+                    InflateData(mat,z,buf.ui64,len*data_size);
+                    for ( j = 0; j < len; j++ )
+                        data[i+j] = buf.ui64[j];
+                }
+            }
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            data_size = sizeof(mat_int32_t);
             if ( mat->byteswap ) {
                 if ( len <= 256 ){
                     InflateData(mat,z,buf.i32,len*data_size);
@@ -1949,7 +2068,6 @@
         }
         case MAT_T_UINT32:
         {
-            data_size = sizeof(mat_uint32_t);
             if ( mat->byteswap ) {
                 if ( len <= 256 ){
                     InflateData(mat,z,buf.ui32,len*data_size);
@@ -1991,7 +2109,6 @@
         }
         case MAT_T_INT16:
         {
-            data_size = sizeof(mat_int16_t);
             if ( mat->byteswap ) {
                 if ( len <= 512 ){
                     InflateData(mat,z,buf.i16,len*data_size);
@@ -2033,7 +2150,6 @@
         }
         case MAT_T_UINT16:
         {
-            data_size = sizeof(mat_uint16_t);
             if ( mat->byteswap ) {
                 if ( len <= 512 ){
                     InflateData(mat,z,buf.ui16,len*data_size);
@@ -2075,7 +2191,6 @@
         }
         case MAT_T_UINT8:
         {
-            data_size = sizeof(mat_uint8_t);
             if ( len <= 1024 ) {
                 InflateData(mat,z,buf.ui8,len*data_size);
                 for ( i = 0; i < len; i++ )
@@ -2097,7 +2212,6 @@
         }
         case MAT_T_INT8:
         {
-            data_size = sizeof(mat_int8_t);
             if ( len <= 1024 ) {
                 InflateData(mat,z,buf.i8,len*data_size);
                 for ( i = 0; i < len; i++ )
@@ -2140,139 +2254,82 @@
 static int
 ReadSingleData(mat_t *mat,float *data,enum matio_types data_type,int len)
 {
-    int bytesread = 0, data_size = 0, i;
+    int bytesread = 0, data_size, i;
 
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&i8,data_size,1,(FILE*)mat->fp);
-                data[i] = i8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
+            mat_uint8_t v;
 
-            data_size = sizeof(mat_uint8_t);
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&ui8,data_size,1,(FILE*)mat->fp);
-                data[i] = ui8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
@@ -2301,138 +2358,81 @@
 ReadCompressedSingleData(mat_t *mat,z_streamp z,float *data,
     enum matio_types data_type,int len)
 {
-    int nBytes = 0, data_size = 0, i;
+    int nBytes = 0, data_size, i;
 
     if ( (mat == NULL) || (data == NULL) || (z == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_COMPRESSED_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,data+i,data_size);
-                }
-            }
+            float v;
+            READ_COMPRESSED_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_COMPRESSED_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_COMPRESSED_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_COMPRESSED_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_COMPRESSED_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_COMPRESSED_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_COMPRESSED_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
-
-            data_size = sizeof(mat_uint8_t);
+            mat_uint8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&ui8,data_size);
-                data[i] = ui8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&i8,data_size);
-                data[i] = i8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
@@ -2461,177 +2461,80 @@
 static int
 ReadInt64Data(mat_t *mat,mat_int64_t *data,enum matio_types data_type,int len)
 {
-    int bytesread = 0, data_size = 0, i;
+    int bytesread = 0, data_size, i;
 
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_DATA(Mat_floatSwap);
             break;
         }
         case MAT_T_INT64:
         {
-            mat_int64_t i64;
-
-            data_size = sizeof(mat_int64_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i64,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int64Swap(&i64);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i64,data_size,1,(FILE*)mat->fp);
-                    data[i] = i64;
-                }
-            }
+            mat_int64_t v;
+            READ_DATA(Mat_int64Swap);
             break;
         }
 #ifdef HAVE_MATIO_UINT64_T
         case MAT_T_UINT64:
         {
-            mat_uint64_t ui64;
-
-            data_size = sizeof(mat_uint64_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui64,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint64Swap(&ui64);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui64,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui64;
-                }
-            }
+            mat_uint64_t v;
+            READ_DATA(Mat_uint64Swap);
             break;
         }
 #endif /* HAVE_MATIO_UINT64_T */
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&i8,data_size,1,(FILE*)mat->fp);
-                data[i] = i8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
+            mat_uint8_t v;
 
-            data_size = sizeof(mat_uint8_t);
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&ui8,data_size,1,(FILE*)mat->fp);
-                data[i] = ui8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
@@ -2661,175 +2564,79 @@
 ReadCompressedInt64Data(mat_t *mat,z_streamp z,mat_int64_t *data,
     enum matio_types data_type,int len)
 {
-    int nBytes = 0, data_size = 0, i;
+    int nBytes = 0, data_size, i;
 
     if ( (mat == NULL) || (data == NULL) || (z == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_COMPRESSED_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_COMPRESSED_DATA(Mat_floatSwap);
             break;
         }
         case MAT_T_INT64:
         {
-            mat_int64_t i64;
-
-            data_size = sizeof(mat_int64_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i64,data_size);
-                    data[i] = Mat_int64Swap(&i64);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i64,data_size);
-                    data[i] = i64;
-                }
-            }
+            mat_int64_t v;
+            READ_COMPRESSED_DATA(Mat_int64Swap);
             break;
         }
+#ifdef HAVE_MATIO_UINT64_T
         case MAT_T_UINT64:
         {
-            mat_uint64_t ui64;
-
-            data_size = sizeof(mat_uint64_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui64,data_size);
-                    data[i] = Mat_uint64Swap(&ui64);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui64,data_size);
-                    data[i] = ui64;
-                }
-            }
+            mat_uint64_t v;
+            READ_COMPRESSED_DATA(Mat_uint64Swap);
             break;
         }
+#endif /* HAVE_MATIO_UINT64_T */
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_COMPRESSED_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_COMPRESSED_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_COMPRESSED_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_COMPRESSED_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
-
-            data_size = sizeof(mat_uint8_t);
+            mat_uint8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&ui8,data_size);
-                data[i] = ui8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&i8,data_size);
-                data[i] = i8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
@@ -2859,177 +2666,80 @@
 static int
 ReadUInt64Data(mat_t *mat,mat_uint64_t *data,enum matio_types data_type,int len)
 {
-    int bytesread = 0, data_size = 0, i;
+    int bytesread = 0, data_size, i;
 
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_DATA(Mat_floatSwap);
             break;
         }
 #ifdef HAVE_MATIO_INT64_T
         case MAT_T_INT64:
         {
-            mat_int64_t i64;
-
-            data_size = sizeof(mat_int64_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i64,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int64Swap(&i64);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i64,data_size,1,(FILE*)mat->fp);
-                    data[i] = i64;
-                }
-            }
+            mat_int64_t v;
+            READ_DATA(Mat_int64Swap);
             break;
         }
 #endif /* HAVE_MATIO_INT64_T */
         case MAT_T_UINT64:
         {
-            mat_uint64_t ui64;
-
-            data_size = sizeof(mat_uint64_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui64,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint64Swap(&ui64);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui64,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui64;
-                }
-            }
+            mat_uint64_t v;
+            READ_DATA(Mat_uint64Swap);
             break;
         }
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&i8,data_size,1,(FILE*)mat->fp);
-                data[i] = i8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
+            mat_uint8_t v;
 
-            data_size = sizeof(mat_uint8_t);
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&ui8,data_size,1,(FILE*)mat->fp);
-                data[i] = ui8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
@@ -3059,175 +2769,79 @@
 ReadCompressedUInt64Data(mat_t *mat,z_streamp z,mat_uint64_t *data,
     enum matio_types data_type,int len)
 {
-    int nBytes = 0, data_size = 0, i;
+    int nBytes = 0, data_size, i;
 
     if ( (mat == NULL) || (data == NULL) || (z == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_COMPRESSED_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_COMPRESSED_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
         case MAT_T_INT64:
         {
-            mat_int64_t i64;
-
-            data_size = sizeof(mat_int64_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i64,data_size);
-                    data[i] = Mat_int64Swap(&i64);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i64,data_size);
-                    data[i] = i64;
-                }
-            }
+            mat_int64_t v;
+            READ_COMPRESSED_DATA(Mat_int64Swap);
             break;
         }
+#endif /* HAVE_MATIO_INT64_T */
         case MAT_T_UINT64:
         {
-            mat_uint64_t ui64;
-
-            data_size = sizeof(mat_uint64_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui64,data_size);
-                    data[i] = Mat_uint64Swap(&ui64);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui64,data_size);
-                    data[i] = ui64;
-                }
-            }
+            mat_uint64_t v;
+            READ_COMPRESSED_DATA(Mat_uint64Swap);
             break;
         }
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_COMPRESSED_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_COMPRESSED_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_COMPRESSED_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_COMPRESSED_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
-
-            data_size = sizeof(mat_uint8_t);
+            mat_uint8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&ui8,data_size);
-                data[i] = ui8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&i8,data_size);
-                data[i] = i8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
@@ -3256,139 +2870,82 @@
 static int
 ReadInt32Data(mat_t *mat,mat_int32_t *data,enum matio_types data_type,int len)
 {
-    int bytesread = 0, data_size = 0, i;
+    int bytesread = 0, data_size, i;
 
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&i8,data_size,1,(FILE*)mat->fp);
-                data[i] = i8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
+            mat_uint8_t v;
 
-            data_size = sizeof(mat_uint8_t);
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&ui8,data_size,1,(FILE*)mat->fp);
-                data[i] = ui8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
@@ -3418,139 +2975,81 @@
 ReadCompressedInt32Data(mat_t *mat,z_streamp z,mat_int32_t *data,
     enum matio_types data_type,int len)
 {
-    int nBytes = 0, data_size = 0, i;
+    int nBytes = 0, data_size, i;
 
     if ( (mat == NULL) || (data == NULL) || (z == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_COMPRESSED_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_COMPRESSED_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_COMPRESSED_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_COMPRESSED_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_COMPRESSED_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_COMPRESSED_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_COMPRESSED_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_COMPRESSED_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
-
-            data_size = sizeof(mat_uint8_t);
+            mat_uint8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&ui8,data_size);
-                data[i] = ui8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&i8,data_size);
-                data[i] = i8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
@@ -3578,139 +3077,82 @@
 static int
 ReadUInt32Data(mat_t *mat,mat_uint32_t *data,enum matio_types data_type,int len)
 {
-    int bytesread = 0, data_size = 0, i;
+    int bytesread = 0, data_size, i;
 
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&i8,data_size,1,(FILE*)mat->fp);
-                data[i] = i8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
+            mat_uint8_t v;
 
-            data_size = sizeof(mat_uint8_t);
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&ui8,data_size,1,(FILE*)mat->fp);
-                data[i] = ui8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
@@ -3740,139 +3182,81 @@
 ReadCompressedUInt32Data(mat_t *mat,z_streamp z,mat_uint32_t *data,
     enum matio_types data_type,int len)
 {
-    int nBytes = 0, data_size = 0, i;
+    int nBytes = 0, data_size, i;
 
     if ( (mat == NULL) || (data == NULL) || (z == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_COMPRESSED_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_COMPRESSED_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_COMPRESSED_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_COMPRESSED_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_COMPRESSED_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_COMPRESSED_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_COMPRESSED_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_COMPRESSED_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
-
-            data_size = sizeof(mat_uint8_t);
+            mat_uint8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&ui8,data_size);
-                data[i] = ui8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&i8,data_size);
-                data[i] = i8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
@@ -3900,139 +3284,82 @@
 static int
 ReadInt16Data(mat_t *mat,mat_int16_t *data,enum matio_types data_type,int len)
 {
-    int bytesread = 0, data_size = 0, i;
+    int bytesread = 0, data_size, i;
 
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&i8,data_size,1,(FILE*)mat->fp);
-                data[i] = i8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
+            mat_uint8_t v;
 
-            data_size = sizeof(mat_uint8_t);
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&ui8,data_size,1,(FILE*)mat->fp);
-                data[i] = ui8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
@@ -4062,139 +3389,81 @@
 ReadCompressedInt16Data(mat_t *mat,z_streamp z,mat_int16_t *data,
     enum matio_types data_type,int len)
 {
-    int nBytes = 0, data_size = 0, i;
+    int nBytes = 0, data_size, i;
 
     if ( (mat == NULL) || (data == NULL) || (z == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_COMPRESSED_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_COMPRESSED_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_COMPRESSED_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_COMPRESSED_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_COMPRESSED_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_COMPRESSED_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_COMPRESSED_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_COMPRESSED_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
-
-            data_size = sizeof(mat_uint8_t);
+            mat_uint8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&ui8,data_size);
-                data[i] = ui8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&i8,data_size);
-                data[i] = i8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
@@ -4222,139 +3491,82 @@
 static int
 ReadUInt16Data(mat_t *mat,mat_uint16_t *data,enum matio_types data_type,int len)
 {
-    int bytesread = 0, data_size = 0, i;
+    int bytesread = 0, data_size, i;
 
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&i8,data_size,1,(FILE*)mat->fp);
-                data[i] = i8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
+            mat_uint8_t v;
 
-            data_size = sizeof(mat_uint8_t);
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&ui8,data_size,1,(FILE*)mat->fp);
-                data[i] = ui8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
@@ -4384,139 +3596,81 @@
 ReadCompressedUInt16Data(mat_t *mat,z_streamp z,mat_uint16_t *data,
     enum matio_types data_type,int len)
 {
-    int nBytes = 0, data_size = 0, i;
+    int nBytes = 0, data_size, i;
 
     if ( (mat == NULL) || (data == NULL) || (z == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_COMPRESSED_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_COMPRESSED_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_COMPRESSED_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_COMPRESSED_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_COMPRESSED_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_COMPRESSED_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_COMPRESSED_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_COMPRESSED_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
-
-            data_size = sizeof(mat_uint8_t);
+            mat_uint8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&ui8,data_size);
-                data[i] = ui8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&i8,data_size);
-                data[i] = i8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
@@ -4544,139 +3698,82 @@
 static int
 ReadInt8Data(mat_t *mat,mat_int8_t *data,enum matio_types data_type,int len)
 {
-    int bytesread = 0, data_size = 0, i;
+    int bytesread = 0, data_size, i;
 
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&i8,data_size,1,(FILE*)mat->fp);
-                data[i] = i8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
+            mat_uint8_t v;
 
-            data_size = sizeof(mat_uint8_t);
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&ui8,data_size,1,(FILE*)mat->fp);
-                data[i] = ui8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
@@ -4706,139 +3803,81 @@
 ReadCompressedInt8Data(mat_t *mat,z_streamp z,mat_int8_t *data,
     enum matio_types data_type,int len)
 {
-    int nBytes = 0, data_size = 0, i;
+    int nBytes = 0, data_size, i;
 
     if ( (mat == NULL) || (data == NULL) || (z == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_COMPRESSED_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_COMPRESSED_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_COMPRESSED_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_COMPRESSED_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_COMPRESSED_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_COMPRESSED_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_COMPRESSED_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_COMPRESSED_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
-
-            data_size = sizeof(mat_uint8_t);
+            mat_uint8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&ui8,data_size);
-                data[i] = ui8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&i8,data_size);
-                data[i] = i8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
@@ -4866,139 +3905,82 @@
 static int
 ReadUInt8Data(mat_t *mat,mat_uint8_t *data,enum matio_types data_type,int len)
 {
-    int bytesread = 0, data_size = 0, i;
+    int bytesread = 0, data_size, i;
 
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&d,data_size,1,(FILE*)mat->fp);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&f,data_size,1,(FILE*)mat->fp);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i32,data_size,1,(FILE*)mat->fp);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui32,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&i16,data_size,1,(FILE*)mat->fp);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    bytesread += fread(&ui16,data_size,1,(FILE*)mat->fp);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&i8,data_size,1,(FILE*)mat->fp);
-                data[i] = i8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
+            mat_uint8_t v;
 
-            data_size = sizeof(mat_uint8_t);
             for ( i = 0; i < len; i++ ) {
-                bytesread += fread(&ui8,data_size,1,(FILE*)mat->fp);
-                data[i] = ui8;
+                bytesread += fread(&v,data_size,1,(FILE*)mat->fp);
+                data[i] = v;
             }
             break;
         }
@@ -5028,139 +4010,81 @@
 ReadCompressedUInt8Data(mat_t *mat,z_streamp z,mat_uint8_t *data,
     enum matio_types data_type,int len)
 {
-    int nBytes = 0, data_size = 0, i;
+    int nBytes = 0, data_size, i;
 
     if ( (mat == NULL) || (data == NULL) || (z == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
-            double d;
-
-            data_size = sizeof(double);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = Mat_doubleSwap(&d);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&d,data_size);
-                    data[i] = d;
-                }
-            }
+            double v;
+            READ_COMPRESSED_DATA(Mat_doubleSwap);
             break;
         }
         case MAT_T_SINGLE:
         {
-            float f;
-
-            data_size = sizeof(float);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = Mat_floatSwap(&f);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&f,data_size);
-                    data[i] = f;
-                }
-            }
+            float v;
+            READ_COMPRESSED_DATA(Mat_floatSwap);
             break;
         }
+#ifdef HAVE_MATIO_INT64_T
+        case MAT_T_INT64:
+        {
+            mat_int64_t v;
+            READ_COMPRESSED_DATA(Mat_int64Swap);
+            break;
+        }
+#endif
+#ifdef HAVE_MATIO_UINT64_T
+        case MAT_T_UINT64:
+        {
+            mat_uint64_t v;
+            READ_COMPRESSED_DATA(Mat_uint64Swap);
+            break;
+        }
+#endif
         case MAT_T_INT32:
         {
-            mat_int32_t i32;
-
-            data_size = sizeof(mat_int32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = Mat_int32Swap(&i32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i32,data_size);
-                    data[i] = i32;
-                }
-            }
+            mat_int32_t v;
+            READ_COMPRESSED_DATA(Mat_int32Swap);
             break;
         }
         case MAT_T_UINT32:
         {
-            mat_uint32_t ui32;
-
-            data_size = sizeof(mat_uint32_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = Mat_uint32Swap(&ui32);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui32,data_size);
-                    data[i] = ui32;
-                }
-            }
+            mat_uint32_t v;
+            READ_COMPRESSED_DATA(Mat_uint32Swap);
             break;
         }
         case MAT_T_INT16:
         {
-            mat_int16_t i16;
-
-            data_size = sizeof(mat_int16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = Mat_int16Swap(&i16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&i16,data_size);
-                    data[i] = i16;
-                }
-            }
+            mat_int16_t v;
+            READ_COMPRESSED_DATA(Mat_int16Swap);
             break;
         }
         case MAT_T_UINT16:
         {
-            mat_uint16_t ui16;
-
-            data_size = sizeof(mat_uint16_t);
-            if ( mat->byteswap ) {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = Mat_uint16Swap(&ui16);
-                }
-            } else {
-                for ( i = 0; i < len; i++ ) {
-                    InflateData(mat,z,&ui16,data_size);
-                    data[i] = ui16;
-                }
-            }
+            mat_uint16_t v;
+            READ_COMPRESSED_DATA(Mat_uint16Swap);
             break;
         }
         case MAT_T_UINT8:
         {
-            mat_uint8_t ui8;
-
-            data_size = sizeof(mat_uint8_t);
+            mat_uint8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&ui8,data_size);
-                data[i] = ui8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
         case MAT_T_INT8:
         {
-            mat_int8_t i8;
-
-            data_size = sizeof(mat_int8_t);
+            mat_int8_t v;
             for ( i = 0; i < len; i++ ) {
-                InflateData(mat,z,&i8,data_size);
-                data[i] = i8;
+                InflateData(mat,z,&v,data_size);
+                data[i] = v;
             }
             break;
         }
@@ -5172,7 +4096,11 @@
 }
 #endif
 
+#undef READ_DATA
 #if defined(HAVE_ZLIB)
+#undef READ_COMPRESSED_DATA
+#endif
+#if defined(HAVE_ZLIB)
 /** @brief Reads data of type @c data_type into a char type
  *
  * Reads from the MAT file @c len compressed elements of data type @c data_type
@@ -5197,10 +4125,6 @@
 
     switch ( data_type ) {
         case MAT_T_UTF8:
-            data_size = 1;
-            for ( i = 0; i < len; i++ )
-                InflateData(mat,z,data+i,data_size);
-            break;
         case MAT_T_INT8:
         case MAT_T_UINT8:
             data_size = 1;
@@ -5207,6 +4131,7 @@
             for ( i = 0; i < len; i++ )
                 InflateData(mat,z,data+i,data_size);
             break;
+        case MAT_T_UTF16:
         case MAT_T_INT16:
         case MAT_T_UINT16:
         {
@@ -5227,7 +4152,8 @@
             break;
         }
         default:
-            printf("Character data not supported type: %d",data_type);
+            Mat_Warning("ReadCompressedCharData: %d is not a supported data "
+                "type for character data", data_type);
             break;
     }
     nBytes = len*data_size;
@@ -5245,14 +4171,12 @@
 
     switch ( data_type ) {
         case MAT_T_UTF8:
-            for ( i = 0; i < len; i++ )
-                bytesread += fread(data+i,1,1,(FILE*)mat->fp);
-            break;
         case MAT_T_INT8:
         case MAT_T_UINT8:
             for ( i = 0; i < len; i++ )
                 bytesread += fread(data+i,1,1,(FILE*)mat->fp);
             break;
+        case MAT_T_UTF16:
         case MAT_T_INT16:
         case MAT_T_UINT16:
         {
@@ -5272,7 +4196,8 @@
             break;
         }
         default:
-            printf("Character data not supported type: %d",data_type);
+            Mat_Warning("ReadCharData: %d is not a supported data type for ",
+                "character data", data_type);
             break;
     }
     bytesread *= data_size;
@@ -5385,6 +4310,7 @@
     }
 
     data_size = Mat_SizeOf(data_type);
+
     switch ( class_type ) {
         case MAT_C_DOUBLE:
         {
@@ -5674,8 +4600,8 @@
 
     data_size = Mat_SizeOf(data_type);
     (void)fseek((FILE*)mat->fp,start*data_size,SEEK_CUR);
+    stride = data_size*(stride-1);
 
-    stride = data_size*(stride-1);
     switch ( class_type ) {
         case MAT_C_DOUBLE:
         {
@@ -6561,7 +5487,7 @@
 static UINTMAX_T myround(LDOUBLE);
 static LDOUBLE mypow10(int);
 
-int
+static int
 rpl_vsnprintf(char *str, size_t size, const char *format, va_list args)
 {
     LDOUBLE fvalue;
@@ -7521,7 +6447,7 @@
 }
 #endif  /* NEED_MYMEMCPY */
 
-int
+static int
 rpl_vasprintf(char **ret, const char *format, va_list ap)
 {
     size_t size;
@@ -7547,10 +6473,10 @@
 
 #if !HAVE_SNPRINTF
 #if HAVE_STDARG_H
-int
+static int
 rpl_snprintf(char *str, size_t size, const char *format, ...)
 #else
-int
+static int
 rpl_snprintf(va_alist) va_dcl
 #endif  /* HAVE_STDARG_H */
 {
@@ -7578,10 +6504,10 @@
 
 #if !HAVE_ASPRINTF
 #if HAVE_STDARG_H
-int
+static int
 rpl_asprintf(char **ret, const char *format, ...)
 #else
-int
+static int
 rpl_asprintf(va_alist) va_dcl
 #endif  /* HAVE_STDARG_H */
 {
@@ -7632,9 +6558,9 @@
 #ifndef MAT5_H
 #define MAT5_H
 
+#if defined(HAVE_ZLIB)
 static size_t GetStructFieldBufSize(matvar_t *matvar);
 static size_t GetCellArrayFieldBufSize(matvar_t *matvar);
-#if defined(HAVE_ZLIB)
 static size_t GetMatrixMaxBufSize(matvar_t *matvar);
 static size_t GetEmptyMatrixMaxBufSize(const char *name,int rank);
 #endif
@@ -7666,7 +6592,7 @@
                   int rank,size_t *dims,z_streamp z);
 #endif
 
-/*   mat5.c    */
+/* mat5.c */
 static mat_t *Mat_Create5(const char *matname,const char *hdr_str);
 
 static matvar_t *Mat_VarReadNextInfo5( mat_t *mat );
@@ -7729,6 +6655,12 @@
 #   define SIZE_T_FMTSTR "zu"
 #endif
 
+/*
+ *===================================================================
+ *                 Private Functions
+ *===================================================================
+ */
+
 static void
 ReadData(mat_t *mat, matvar_t *matvar)
 {
@@ -7812,10 +6744,32 @@
     }
 }
 
+static mat_complex_split_t *
+ComplexMalloc(size_t nbytes)
+{
+    mat_complex_split_t *complex_data = malloc(sizeof(*complex_data));
+    if ( NULL != complex_data ) {
+        complex_data->Re = malloc(nbytes);
+        if ( NULL != complex_data->Re ) {
+            complex_data->Im = malloc(nbytes);
+            if ( NULL == complex_data->Im ) {
+                free(complex_data->Re);
+                free(complex_data);
+                complex_data = NULL;
+            }
+        }
+        else {
+            free(complex_data);
+            complex_data = NULL;
+        }
+    }
+    return complex_data;
+}
+
 /*
- *====================================================================
+ *===================================================================
  *                 Public Functions
- *====================================================================
+ *===================================================================
  */
 
 /** @brief Get the version of the library
@@ -7854,7 +6808,7 @@
 mat_t *
 Mat_CreateVer(const char *matname,const char *hdr_str,enum mat_ft mat_file_ver)
 {
-    mat_t *mat = NULL;
+    mat_t *mat;
 
     switch ( mat_file_ver ) {
         case MAT_FT_MAT4:
@@ -7866,9 +6820,12 @@
         case MAT_FT_MAT73:
 #if defined(HAVE_HDF5)
             mat = Mat_Create73(matname,hdr_str);
+#else
+            mat = NULL;
 #endif
             break;
         default:
+            mat = NULL;
             break;
     }
 
@@ -7931,9 +6888,11 @@
         return NULL;
     }
     mat->filename      = NULL;
+    mat->version       = 0;
     mat->byteswap      = 0;
-    mat->version       = 0;
+    mat->num_datasets  = 0;
     mat->refs_id       = -1;
+    mat->dir           = NULL;
 
     bytesread += fread(mat->header,1,116,fp);
     mat->header[116] = '\0';
@@ -8009,7 +6968,6 @@
     if ( mat->version == 0x0200 ) {
         fclose((FILE*)mat->fp);
 #if defined(HAVE_HDF5)
-
         mat->fp = malloc(sizeof(hid_t));
 
         if ( (mode & 0x01) == MAT_ACC_RDONLY )
@@ -8018,9 +6976,9 @@
             *(hid_t*)mat->fp=H5Fopen(mat->filename,H5F_ACC_RDWR,H5P_DEFAULT);
 
         if ( -1 < *(hid_t*)mat->fp ) {
-            H5G_info_t group_info;
+            H5G_info_t group_info = {0};
             H5Gget_info(*(hid_t*)mat->fp, &group_info);
-            mat->num_datasets = group_info.nlinks;
+            mat->num_datasets = (size_t)group_info.nlinks;
             mat->refs_id      = -1;
         }
 #else
@@ -8055,14 +7013,22 @@
             mat->fp = NULL;
         }
 #endif
-        if ( mat->fp )
+        if ( NULL != mat->fp )
             fclose((FILE*)mat->fp);
-        if ( mat->header )
+        if ( NULL != mat->header )
             free(mat->header);
-        if ( mat->subsys_offset )
+        if ( NULL != mat->subsys_offset )
             free(mat->subsys_offset);
-        if ( mat->filename )
+        if ( NULL != mat->filename )
             free(mat->filename);
+        if ( NULL != mat->dir ) {
+            size_t i;
+            for ( i = 0; i < mat->num_datasets; i++ ) {
+                if ( NULL != mat->dir[i] )
+                    free(mat->dir[i]);
+            }
+            free(mat->dir);
+        }
         free(mat);
     }
     return 0;
@@ -8072,15 +7038,15 @@
  *
  * Gets the filename for the given MAT file
  * @ingroup MAT
- * @param matfp Pointer to the MAT file
+ * @param mat Pointer to the MAT file
  * @return MAT filename
  */
 const char *
-Mat_GetFilename(mat_t *matfp)
+Mat_GetFilename(mat_t *mat)
 {
     const char *filename = NULL;
-    if ( NULL != matfp )
-        filename = matfp->filename;
+    if ( NULL != mat )
+        filename = mat->filename;
     return filename;
 }
 
@@ -8088,18 +7054,113 @@
  *
  * Gets the version of the given MAT file
  * @ingroup MAT
- * @param matfp Pointer to the MAT file
+ * @param mat Pointer to the MAT file
  * @return MAT file version
  */
 enum mat_ft
-Mat_GetVersion(mat_t *matfp)
+Mat_GetVersion(mat_t *mat)
 {
     enum mat_ft file_type = MAT_FT_UNDEFINED;
-    if ( NULL != matfp )
-        file_type = (enum mat_ft)matfp->version;
+    if ( NULL != mat )
+        file_type = (enum mat_ft)mat->version;
     return file_type;
 }
 
+/** @brief Gets a list of the variables of a MAT file
+ *
+ * Gets a list of the variables of a MAT file
+ * @ingroup MAT
+ * @param mat Pointer to the MAT file
+ * @param[out] n Number of variables in the given MAT file
+ * @return Array of variable names
+ */
+char **
+Mat_GetDir(mat_t *mat, size_t *n)
+{
+    char ** dir = NULL;
+
+    if ( NULL == n )
+        return dir;
+
+    if ( NULL == mat ) {
+        *n = 0;
+        return dir;
+    }
+
+    if ( NULL == mat->dir ) {
+        matvar_t *matvar = NULL;
+
+        if ( mat->version == MAT_FT_MAT73 ) {
+            size_t i = 0;
+            size_t fpos = mat->next_index;
+            if ( mat->num_datasets == 0) {
+                *n = 0;
+                return dir;
+            }
+            mat->dir = calloc(mat->num_datasets, sizeof(char*));
+            if ( NULL == mat->dir) {
+                *n = 0;
+                Mat_Critical("Couldn't allocate memory for the directory");
+                return dir;
+            }
+            mat->next_index = 0;
+            while ( mat->next_index < mat->num_datasets ) {
+                matvar = Mat_VarReadNextInfo(mat);
+                if ( NULL != matvar ) {
+                    if ( NULL != matvar->name ) {
+                        mat->dir[i++] = strdup_printf("%s",
+                            matvar->name);
+                    }
+                    Mat_VarFree(matvar);
+                } else {
+                    Mat_Critical("An error occurred in reading the MAT file");
+                    break;
+                }
+            }
+            mat->next_index = fpos;
+            *n = i;
+        } else {
+            long fpos = ftell((FILE*)mat->fp);
+            if ( fpos == -1L ) {
+                *n = 0;
+                Mat_Critical("Couldn't determine file position");
+                return dir;
+            }
+            (void)fseek((FILE*)mat->fp,mat->bof,SEEK_SET);
+            mat->num_datasets = 0;
+            do {
+                matvar = Mat_VarReadNextInfo(mat);
+                if ( NULL != matvar ) {
+                    if ( NULL != matvar->name ) {
+                        if ( NULL == mat->dir ) {
+                            dir = malloc(sizeof(char*));
+                        } else {
+                            dir = realloc(mat->dir,
+                                (mat->num_datasets + 1)*(sizeof(char*)));
+                        }
+                        if ( NULL != dir ) {
+                            mat->dir = dir;
+                            mat->dir[mat->num_datasets++] =
+                                strdup_printf("%s", matvar->name);
+                        } else {
+                            Mat_Critical("Couldn't allocate memory for the directory");
+                            break;
+                        }
+                    }
+                    Mat_VarFree(matvar);
+                } else if (!feof((FILE *)mat->fp)) {
+                    Mat_Critical("An error occurred in reading the MAT file");
+                    break;
+                }
+            } while ( !feof((FILE *)mat->fp) );
+            (void)fseek((FILE*)mat->fp,fpos,SEEK_SET);
+            *n = mat->num_datasets;
+        }
+    }
+    dir = mat->dir;
+    return dir;
+}
+
 /** @brief Rewinds a Matlab MAT file to the first variable
  *
  * Rewinds a Matlab MAT file to the first variable
@@ -8113,12 +7174,12 @@
     int err = 0;
 
     switch ( mat->version ) {
+        case MAT_FT_MAT5:
+            (void)fseek((FILE*)mat->fp,128L,SEEK_SET);
+            break;
         case MAT_FT_MAT73:
             mat->next_index = 0;
             break;
-        case MAT_FT_MAT5:
-            (void)fseek((FILE*)mat->fp,128L,SEEK_SET);
-            break;
         case MAT_FT_MAT4:
             (void)fseek((FILE*)mat->fp,0L,SEEK_SET);
             break;
@@ -8126,6 +7187,7 @@
             err = -1;
             break;
     }
+
     return err;
 }
 
@@ -8208,14 +7270,14 @@
             free(matvar);
             matvar = NULL;
         } else {
-            matvar->internal->hdf5_name = NULL;
-            matvar->internal->hdf5_ref  =  0;
-            matvar->internal->id        = -1;
-            matvar->internal->fp = NULL;
+            matvar->internal->hdf5_name  = NULL;
+            matvar->internal->hdf5_ref   =  0;
+            matvar->internal->id         = -1;
             matvar->internal->fpos       = 0;
             matvar->internal->datapos    = 0;
+            matvar->internal->fp         = NULL;
+            matvar->internal->num_fields = 0;
             matvar->internal->fieldnames = NULL;
-            matvar->internal->num_fields = 0;
 #if defined(HAVE_ZLIB)
             matvar->internal->z          = NULL;
             matvar->internal->data       = NULL;
@@ -8286,7 +7348,7 @@
 Mat_VarCreate(const char *name,enum matio_classes class_type,
     enum matio_types data_type,int rank,size_t *dims,void *data,int opt)
 {
-    size_t i, nmemb = 1, nfields = 0, data_size;
+    size_t i, nmemb = 1, data_size;
     matvar_t *matvar = NULL;
 
     if (dims == NULL) return NULL;
@@ -8354,12 +7416,10 @@
             break;
         case MAT_T_STRUCT:
         {
-            matvar_t **fields;
-
             data_size = sizeof(matvar_t **);
             if ( data != NULL ) {
-                fields = (matvar_t**)data;
-                nfields = 0;
+                matvar_t **fields = (matvar_t**)data;
+                size_t nfields = 0;
                 while ( fields[nfields] != NULL )
                     nfields++;
                 if ( nmemb )
@@ -8519,24 +7579,31 @@
         return err;
 
     if ( (tmp_name = mktemp(temp)) != NULL ) {
-        enum mat_ft mat_file_ver = MAT_FT_DEFAULT;
+        enum mat_ft mat_file_ver;
         mat_t *tmp;
 
         switch ( mat->version ) {
+            case 0x0100:
+                mat_file_ver = MAT_FT_MAT5;
+                break;
             case 0x0200:
                 mat_file_ver = MAT_FT_MAT73;
                 break;
-            case 0x0100:
-                mat_file_ver = MAT_FT_MAT5;
-                break;
             case 0x0010:
                 mat_file_ver = MAT_FT_MAT4;
                 break;
+            default:
+                mat_file_ver = MAT_FT_DEFAULT;
+                break;
         }
 
         tmp = Mat_CreateVer(tmp_name,mat->header,mat_file_ver);
         if ( tmp != NULL ) {
             matvar_t *matvar;
+            char **dir;
+            size_t n;
+
+            Mat_Rewind(mat);
             while ( NULL != (matvar = Mat_VarReadNext(mat)) ) {
                 if ( strcmp(matvar->name,name) )
                     Mat_VarWrite(tmp,matvar,matvar->compression);
@@ -8544,9 +7611,12 @@
                     err = 0;
                 Mat_VarFree(matvar);
             }
+            dir = tmp->dir; /* Keep directory for later assignment */
+            tmp->dir = NULL;
+            n = tmp->num_datasets;
             Mat_Close(tmp);
 
-            if (err == 0) {
+            if ( 0 == err ) {
                 char *new_name = strdup_printf("%s",mat->filename);
 #if defined(HAVE_HDF5)
                 if ( mat_file_ver == MAT_FT_MAT73 ) {
@@ -8557,15 +7627,31 @@
                     mat->fp = NULL;
                 }
 #endif
-                if ( mat->fp ) {
+                if ( mat->fp != NULL ) {
                     fclose((FILE*)mat->fp);
                     mat->fp = NULL;
                 }
 
                 if ( (err = mat_copy(tmp_name,new_name)) == -1 ) {
+                    if ( NULL != dir ) {
+                        size_t i;
+                        for ( i = 0; i < n; i++ ) {
+                            if ( dir[i] )
+                                free(dir[i]);
+                        }
+                        free(dir);
+                    }
                     Mat_Critical("Cannot copy file from \"%s\" to \"%s\".",
                         tmp_name, new_name);
                 } else if ( (err = remove(tmp_name)) == -1 ) {
+                    if ( NULL != dir ) {
+                        size_t i;
+                        for ( i = 0; i < n; i++ ) {
+                            if ( dir[i] )
+                                free(dir[i]);
+                        }
+                        free(dir);
+                    }
                     Mat_Critical("Cannot remove file \"%s\".",tmp_name);
                 } else {
                     tmp = Mat_Open(new_name,mat->mode);
@@ -8576,8 +7662,18 @@
                             free(mat->subsys_offset);
                         if ( mat->filename )
                             free(mat->filename);
+                        if ( mat->dir ) {
+                            size_t i;
+                            for ( i = 0; i < mat->num_datasets; i++ ) {
+                                if ( mat->dir[i] )
+                                    free(mat->dir[i]);
+                            }
+                            free(mat->dir);
+                        }
                         memcpy(mat,tmp,sizeof(mat_t));
                         free(tmp);
+                        mat->num_datasets = n;
+                        mat->dir = dir;
                     } else {
                         Mat_Critical("Cannot open file \"%s\".",new_name);
                     }
@@ -8590,6 +7686,7 @@
     } else {
         Mat_Critical("Cannot create a unique file name.");
     }
+
     return err;
 }
 
@@ -8722,27 +7819,21 @@
     if ( !opt ) {
         out->data = in->data;
     } else if ( (in->data != NULL) && (in->class_type == MAT_C_STRUCT) ) {
-        matvar_t **infields, **outfields;
-        int nfields = 0;
-
         out->data = malloc(in->nbytes);
         if ( out->data != NULL && in->data_size > 0 ) {
-            nfields   = in->nbytes / in->data_size;
-            infields  = (matvar_t **)in->data;
-            outfields = (matvar_t **)out->data;
+            int nfields = in->nbytes / in->data_size;
+            matvar_t **infields  = (matvar_t **)in->data;
+            matvar_t **outfields = (matvar_t **)out->data;
             for ( i = 0; i < nfields; i++ ) {
                 outfields[i] = Mat_VarDuplicate(infields[i],opt);
             }
         }
     } else if ( (in->data != NULL) && (in->class_type == MAT_C_CELL) ) {
-        matvar_t **incells, **outcells;
-        int ncells = 0;
-
         out->data = malloc(in->nbytes);
         if ( out->data != NULL && in->data_size > 0 ) {
-            ncells   = in->nbytes / in->data_size;
-            incells  = (matvar_t **)in->data;
-            outcells = (matvar_t **)out->data;
+            int ncells = in->nbytes / in->data_size;
+            matvar_t **incells  = (matvar_t **)in->data;
+            matvar_t **outcells = (matvar_t **)out->data;
             for ( i = 0; i < ncells; i++ ) {
                 outcells[i] = Mat_VarDuplicate(incells[i],opt);
             }
@@ -8778,6 +7869,8 @@
                 out_sparse->data = malloc(in_sparse->ndata*Mat_SizeOf(in->data_type));
                 if ( NULL != out_sparse->data )
                     memcpy(out_sparse->data, in_sparse->data, in_sparse->ndata*Mat_SizeOf(in->data_type));
+            } else {
+                out_sparse->data = NULL;
             }
         }
     } else if ( in->data != NULL ) {
@@ -8813,17 +7906,15 @@
 Mat_VarFree(matvar_t *matvar)
 {
     size_t nmemb = 0, i;
-    if ( !matvar )
+    if ( NULL == matvar )
         return;
-    if ( matvar->dims ) {
+    if ( NULL != matvar->dims ) {
         nmemb = 1;
         for ( i = 0; i < matvar->rank; i++ )
             nmemb *= matvar->dims[i];
         free(matvar->dims);
     }
-    if ( matvar->name )
-        free(matvar->name);
-    if ( matvar->data != NULL) {
+    if ( NULL != matvar->data ) {
         switch (matvar->class_type ) {
             case MAT_C_STRUCT:
                 if ( !matvar->mem_conserve ) {
@@ -8888,6 +7979,7 @@
             case MAT_C_EMPTY:
             case MAT_C_OBJECT:
             case MAT_C_FUNCTION:
+            case MAT_C_OPAQUE:
                 break;
         }
     }
@@ -8971,6 +8063,8 @@
         free(matvar->internal);
         matvar->internal = NULL;
     }
+    if ( NULL != matvar->name )
+        free(matvar->name);
     /* FIXME: Why does this cause a SEGV? */
 #if 0
     memset(matvar,0,sizeof(matvar_t));
@@ -8997,10 +8091,10 @@
 int
 Mat_CalcSingleSubscript(int rank,int *dims,int *subs)
 {
-    int index = 0, i, j, k, err = 0;
+    int index = 0, i, j, err = 0;
 
     for ( i = 0; i < rank; i++ ) {
-        k = subs[i];
+        int k = subs[i];
         if ( k > dims[i] ) {
             err = 1;
             Mat_Critical("Mat_CalcSingleSubscript: index out of bounds");
@@ -9083,13 +8177,13 @@
 int *
 Mat_CalcSubscripts(int rank,int *dims,int index)
 {
-    int i, j, k, *subs;
+    int i, j, *subs;
     double l;
 
     subs = (int*)malloc(rank*sizeof(int));
     l = index;
     for ( i = rank; i--; ) {
-        k = 1;
+        int k = 1;
         for ( j = i; j--; )
             k *= dims[j];
         subs[i] = floor(l / (double)k);
@@ -9149,37 +8243,65 @@
 size_t
 Mat_VarGetSize(matvar_t *matvar)
 {
-    int nmemb, i;
+    int i;
     size_t bytes = 0;
+    size_t overhead = 0;
 
+#if defined(_WIN64) || (defined(__SIZEOF_POINTER__) && (__SIZEOF_POINTER__ == 8)) || (defined(SIZEOF_VOID_P) && (SIZEOF_VOID_P == 8))
+    /* 112 bytes cell/struct overhead for 64-bit system */
+    overhead = 112;
+#elif defined(_WIN32) || (defined(__SIZEOF_POINTER__) && (__SIZEOF_POINTER__ == 4)) || (defined(SIZEOF_VOID_P) && (SIZEOF_VOID_P == 4))
+    /* 60 bytes cell/struct overhead for 32-bit system */
+    overhead = 60;
+#endif
+
     if ( matvar->class_type == MAT_C_STRUCT ) {
-        int nfields;
-        matvar_t **fields;
-
-        nmemb = 1;
+        int nfields = matvar->internal->num_fields;
+        int nmemb = 1;
         for ( i = 0; i < matvar->rank; i++ )
             nmemb *= matvar->dims[i];
-        nfields = matvar->internal->num_fields;
         if ( nmemb*nfields > 0 ) {
-            fields  = (matvar_t**)matvar->data;
-            if ( NULL != fields )
+            matvar_t **fields = (matvar_t**)matvar->data;
+            if ( NULL != fields ) {
+                bytes = nmemb*nfields*overhead;
                 for ( i = 0; i < nmemb*nfields; i++ )
-                    bytes += Mat_VarGetSize(fields[i]);
+                    if ( NULL != fields[i] )
+                        bytes += Mat_VarGetSize(fields[i]);
+            }
         }
+        bytes += 64 /* max field name length */ *nfields;
     } else if ( matvar->class_type == MAT_C_CELL ) {
-        int ncells;
-        matvar_t **cells;
-
-        ncells = matvar->nbytes / matvar->data_size;
-        cells  = (matvar_t**)matvar->data;
-        if ( NULL != cells )
+        matvar_t **cells = (matvar_t**)matvar->data;
+        if ( NULL != cells ) {
+            int ncells = matvar->nbytes / matvar->data_size;
+            bytes = ncells*overhead;
             for ( i = 0; i < ncells; i++ )
-                bytes += Mat_VarGetSize(cells[i]);
+                if ( NULL != cells[i] )
+                    bytes += Mat_VarGetSize(cells[i]);
+        }
+    } else if ( matvar->class_type == MAT_C_SPARSE ) {
+        mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;
+        if ( NULL != sparse ) {
+            bytes = sparse->ndata*Mat_SizeOf(matvar->data_type);
+            if ( matvar->isComplex )
+                bytes *= 2;
+#if defined(_WIN64) || (defined(__SIZEOF_POINTER__) && (__SIZEOF_POINTER__ == 8)) || (defined(SIZEOF_VOID_P) && (SIZEOF_VOID_P == 8))
+            /* 8 byte integers for 64-bit system (as displayed in MATLAB (x64) whos) */
+            bytes += (sparse->nir + sparse->njc)*8;
+#elif defined(_WIN32) || (defined(__SIZEOF_POINTER__) && (__SIZEOF_POINTER__ == 4)) || (defined(SIZEOF_VOID_P) && (SIZEOF_VOID_P == 4))
+            /* 4 byte integers for 32-bit system (as defined by mat_sparse_t) */
+            bytes += (sparse->nir + sparse->njc)*4;
+#endif
+            if ( sparse->ndata == 0 || sparse->nir == 0 || sparse->njc == 0 )
+                bytes += matvar->isLogical ? 1 : 8;
+        }
     } else {
-        nmemb = 1;
+        int nmemb = 1;
         for ( i = 0; i < matvar->rank; i++ )
             nmemb *= matvar->dims[i];
-        bytes += nmemb*Mat_SizeOfClass(matvar->class_type);
+        bytes = nmemb*Mat_SizeOfClass(matvar->class_type);
+        if ( matvar->isComplex )
+            bytes *= 2;
     }
     return bytes;
 }
@@ -9260,6 +8382,8 @@
         }
         return;
     } else if ( matvar->data == NULL || matvar->data_size < 1 ) {
+        if ( printdata )
+            printf("{\n}\n");
         return;
     } else if ( MAT_C_CELL == matvar->class_type ) {
         matvar_t **cells = (matvar_t **)matvar->data;
@@ -9425,6 +8549,9 @@
     }
 
     switch ( mat->version ) {
+        case MAT_FT_MAT5:
+            err = ReadData5(mat,matvar,data,start,stride,edge);
+            break;
         case MAT_FT_MAT73:
 #if defined(HAVE_HDF5)
             err = Mat_VarReadData73(mat,matvar,data,start,stride,edge);
@@ -9432,12 +8559,12 @@
             err = 1;
 #endif
             break;
-        case MAT_FT_MAT5:
-            err = ReadData5(mat,matvar,data,start,stride,edge);
-            break;
         case MAT_FT_MAT4:
             err = ReadData4(mat,matvar,data,start,stride,edge);
             break;
+        default:
+            err = 2;
+            break;
     }
 
     return err;
@@ -9500,6 +8627,9 @@
     }
 
     switch ( mat->version ) {
+        case MAT_FT_MAT5:
+            err = Mat_VarReadDataLinear5(mat,matvar,data,start,stride,edge);
+            break;
         case MAT_FT_MAT73:
 #if defined(HAVE_HDF5)
             err = Mat_VarReadDataLinear73(mat,matvar,data,start,stride,edge);
@@ -9507,12 +8637,12 @@
             err = 1;
 #endif
             break;
-        case MAT_FT_MAT5:
-            err = Mat_VarReadDataLinear5(mat,matvar,data,start,stride,edge);
-            break;
         case MAT_FT_MAT4:
             err = Mat_VarReadDataLinear4(mat,matvar,data,start,stride,edge);
             break;
+        default:
+            err = 2;
+            break;
     }
 
     return err;
@@ -9531,8 +8661,8 @@
 matvar_t *
 Mat_VarReadNextInfo( mat_t *mat )
 {
-    matvar_t *matvar = NULL;
-    if( mat == NULL )
+    matvar_t *matvar;
+    if ( mat == NULL )
         return NULL;
 
     switch ( mat->version ) {
@@ -9542,11 +8672,16 @@
         case MAT_FT_MAT73:
 #if defined(HAVE_HDF5)
             matvar = Mat_VarReadNextInfo73(mat);
+#else
+            matvar = NULL;
 #endif
             break;
         case MAT_FT_MAT4:
             matvar = Mat_VarReadNextInfo4(mat);
             break;
+        default:
+            matvar = NULL;
+            break;
     }
 
     return matvar;
@@ -9566,7 +8701,6 @@
 matvar_t *
 Mat_VarReadInfo( mat_t *mat, const char *name )
 {
-    long fpos;
     matvar_t *matvar = NULL;
 
     if ( (mat == NULL) || (name == NULL) )
@@ -9573,9 +8707,9 @@
         return NULL;
 
     if ( mat->version == MAT_FT_MAT73 ) {
-        fpos = mat->next_index;
+        size_t fpos = mat->next_index;
         mat->next_index = 0;
-        do {
+        while ( NULL == matvar && mat->next_index < mat->num_datasets ) {
             matvar = Mat_VarReadNextInfo(mat);
             if ( matvar != NULL ) {
                 if ( matvar->name == NULL || strcmp(matvar->name,name) ) {
@@ -9586,10 +8720,10 @@
                 Mat_Critical("An error occurred in reading the MAT file");
                 break;
             }
-        } while ( NULL == matvar && mat->next_index < mat->num_datasets );
+        }
         mat->next_index = fpos;
     } else {
-        fpos = ftell((FILE*)mat->fp);
+        long fpos = ftell((FILE*)mat->fp);
         if ( fpos != -1L ) {
             (void)fseek((FILE*)mat->fp,mat->bof,SEEK_SET);
             do {
@@ -9624,7 +8758,6 @@
 matvar_t *
 Mat_VarRead( mat_t *mat, const char *name )
 {
-    long fpos;
     matvar_t *matvar = NULL;
 
     if ( (mat == NULL) || (name == NULL) )
@@ -9631,23 +8764,21 @@
         return NULL;
 
     if ( MAT_FT_MAT73 != mat->version ) {
-        fpos = ftell((FILE*)mat->fp);
+        long fpos = ftell((FILE*)mat->fp);
         if ( fpos == -1L ) {
             Mat_Critical("Couldn't determine file position");
             return NULL;
         }
+        matvar = Mat_VarReadInfo(mat,name);
+        if ( matvar )
+            ReadData(mat,matvar);
+        (void)fseek((FILE*)mat->fp,fpos,SEEK_SET);
     } else {
-        fpos = mat->next_index;
+        size_t fpos = mat->next_index;
         mat->next_index = 0;
-    }
-
-    matvar = Mat_VarReadInfo(mat,name);
-    if ( matvar )
-        ReadData(mat,matvar);
-
-    if ( MAT_FT_MAT73 != mat->version ) {
-        (void)fseek((FILE*)mat->fp,fpos,SEEK_SET);
-    } else {
+        matvar = Mat_VarReadInfo(mat,name);
+        if ( matvar )
+            ReadData(mat,matvar);
         mat->next_index = fpos;
     }
     return matvar;
@@ -9793,24 +8924,71 @@
  * @param mat MAT file to write to
  * @param matvar MAT variable information to write
  * @param compress Whether or not to compress the data
- *        (Only valid for version 5 MAT files and variables with numeric data)
+ *        (Only valid for version 5 and 7.3 MAT files and variables with
+           numeric data)
  * @retval 0 on success
  */
 int
 Mat_VarWrite(mat_t *mat,matvar_t *matvar,enum matio_compression compress)
 {
-    if ( mat == NULL || matvar == NULL )
+    int err;
+
+    if ( NULL == mat || NULL == matvar )
         return -1;
-    else if ( mat->version == MAT_FT_MAT4 )
-        return Mat_VarWrite4(mat,matvar);
-    else if ( mat->version == MAT_FT_MAT5 )
-        return Mat_VarWrite5(mat,matvar,compress);
+
+    if ( NULL == mat->dir) {
+        size_t n = 0;
+        (void)Mat_GetDir(mat, &n);
+    }
+
+    {
+        /* Error if MAT variable already exists in MAT file*/
+        size_t i;
+        for ( i = 0; i < mat->num_datasets; i++ ) {
+            if ( NULL != mat->dir[i] &&
+                0 == strcmp(mat->dir[i], matvar->name) ) {
+                Mat_Critical("Variable %s already exists.", matvar->name);
+                return 1;
+            }
+        }
+    }
+
+    if ( mat->version == MAT_FT_MAT5 )
+        err = Mat_VarWrite5(mat,matvar,compress);
+    else if ( mat->version == MAT_FT_MAT73 )
 #if defined(HAVE_HDF5)
-    else if ( mat->version == MAT_FT_MAT73 )
-        return Mat_VarWrite73(mat,matvar,compress);
+        err = Mat_VarWrite73(mat,matvar,compress);
+#else
+        err = 1;
 #endif
+    else if ( mat->version == MAT_FT_MAT4 )
+        err = Mat_VarWrite4(mat,matvar);
+    else
+        err = 2;
 
-    return 1;
+    if ( err == 0 ) {
+        char **dir;
+        if ( NULL == mat->dir ) {
+            dir = malloc(sizeof(char*));
+        } else {
+            dir = realloc(mat->dir,
+            (mat->num_datasets + 1)*(sizeof(char*)));
+        }
+        if ( NULL != dir ) {
+            mat->dir = dir;
+            if ( NULL != matvar->name ) {
+                mat->dir[mat->num_datasets++] =
+                    strdup_printf("%s", matvar->name);
+            } else {
+                mat->dir[mat->num_datasets++] = NULL;
+            }
+        } else {
+            err = 3;
+            Mat_Critical("Couldn't allocate memory for the directory");
+        }
+    }
+
+    return err;
 }
 
 /* -------------------------------
@@ -9846,33 +9024,8 @@
 {
     FILE *fp = NULL;
     mat_t *mat = NULL;
-    int byteswap;
 
-#if defined(__GLIBC__)
-#if (__BYTE_ORDER == __LITTLE_ENDIAN)
-    byteswap = 0;
-#elif (__BYTE_ORDER == __BIG_ENDIAN)
-    byteswap = 1;
-#else
-    return NULL;
-#endif
-#elif defined(_BIG_ENDIAN) && !defined(_LITTLE_ENDIAN)
-    byteswap = 1;
-#elif defined(_LITTLE_ENDIAN) && !defined(_BIG_ENDIAN)
-    byteswap = 0;
-#elif defined(__sparc) || defined(__sparc__) || defined(_POWER) || defined(__powerpc__) || \
-      defined(__ppc__) || defined(__hpux) || defined(_MIPSEB) || defined(_POWER) || defined(__s390__)
-    byteswap = 1;
-#elif defined(__i386__) || defined(__alpha__) || defined(__ia64) || defined(__ia64__) || \
-      defined(_M_IX86) || defined(_M_IA64) || defined(_M_ALPHA) || defined(__amd64) || \
-      defined(__amd64__) || defined(_M_AMD64) || defined(__x86_64) || defined(__x86_64__) || \
-      defined(_M_X64) || defined(__bfin__)
-    byteswap = 0;
-#else
-    return NULL;
-#endif
-
-    fp = fopen(matname,"wb");
+    fp = fopen(matname,"w+b");
     if ( !fp )
         return NULL;
 
@@ -9883,16 +9036,18 @@
         return NULL;
     }
 
+    mat->fp            = fp;
     mat->header        = NULL;
     mat->subsys_offset = NULL;
-    mat->fp            = fp;
+    mat->filename      = strdup_printf("%s",matname);
     mat->version       = MAT_FT_MAT4;
-    mat->byteswap      = byteswap;
+    mat->byteswap      = 0;
+    mat->mode          = 0;
     mat->bof           = 0;
     mat->next_index    = 0;
+    mat->num_datasets  = 0;
     mat->refs_id       = -1;
-    mat->filename      = strdup_printf("%s",matname);
-    mat->mode          = 0;
+    mat->dir           = NULL;
 
     Mat_Rewind(mat);
 
@@ -9925,9 +9080,6 @@
     if ( NULL == mat || NULL == matvar || NULL == matvar->name || matvar->rank != 2 )
         return -1;
 
-    /* FIXME: SEEK_END is not Guaranteed by the C standard */
-    (void)fseek((FILE*)mat->fp,0,SEEK_END);         /* Always write at end of file */
-
     switch ( matvar->data_type ) {
         case MAT_T_DOUBLE:
             x.type = 0;
@@ -9951,11 +9103,32 @@
             return 2;
     }
 
-    if ( mat->byteswap )
-        x.type += 1000;
+#if defined(__GLIBC__)
+#if (__BYTE_ORDER == __LITTLE_ENDIAN)
+#elif (__BYTE_ORDER == __BIG_ENDIAN)
+    x.type += 1000;
+#else
+    return -1;
+#endif
+#elif defined(_BIG_ENDIAN) && !defined(_LITTLE_ENDIAN)
+    x.type += 1000;
+#elif defined(_LITTLE_ENDIAN) && !defined(_BIG_ENDIAN)
+#elif defined(__sparc) || defined(__sparc__) || defined(_POWER) || defined(__powerpc__) || \
+      defined(__ppc__) || defined(__hpux) || defined(_MIPSEB) || defined(_POWER) || defined(__s390__)
+    x.type += 1000;
+#elif defined(__i386__) || defined(__alpha__) || defined(__ia64) || defined(__ia64__) || \
+      defined(_M_IX86) || defined(_M_IA64) || defined(_M_ALPHA) || defined(__amd64) || \
+      defined(__amd64__) || defined(_M_AMD64) || defined(__x86_64) || defined(__x86_64__) || \
+      defined(_M_X64) || defined(__bfin__)
+#else
+    return -1;
+#endif
 
     x.namelen = (mat_int32_t)strlen(matvar->name) + 1;
 
+    /* FIXME: SEEK_END is not Guaranteed by the C standard */
+    (void)fseek((FILE*)mat->fp,0,SEEK_END);         /* Always write at end of file */
+
     switch ( matvar->class_type ) {
         case MAT_C_CHAR:
             x.type++;
@@ -10087,22 +9260,23 @@
             matvar->data_size = sizeof(double);
             matvar->nbytes    = N*matvar->data_size;
             if ( matvar->isComplex ) {
-                mat_complex_split_t *complex_data;
-
-                complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
-                if ( complex_data != NULL ) {
-                    complex_data->Re = malloc(matvar->nbytes);
-                    complex_data->Im = malloc(matvar->nbytes);
-                    matvar->data     = complex_data;
-                    if ( complex_data->Re != NULL && complex_data->Im != NULL ) {
-                        ReadDoubleData(mat, (double*)complex_data->Re, matvar->data_type, N);
-                        ReadDoubleData(mat, (double*)complex_data->Im, matvar->data_type, N);
-                    }
+                mat_complex_split_t *complex_data = ComplexMalloc(matvar->nbytes);
+                if ( NULL != complex_data ) {
+                    matvar->data = complex_data;
+                    ReadDoubleData(mat, (double*)complex_data->Re, matvar->data_type, N);
+                    ReadDoubleData(mat, (double*)complex_data->Im, matvar->data_type, N);
                 }
+                else {
+                    Mat_Critical("Memory allocation failure");
+                }
             } else {
                 matvar->data = malloc(matvar->nbytes);
-                if ( matvar->data != NULL )
+                if ( NULL != matvar->data ) {
                     ReadDoubleData(mat, (double*)matvar->data, matvar->data_type, N);
+                }
+                else {
+                    Mat_Critical("Memory allocation failure");
+                }
             }
             /* Update data type to match format of matvar->data */
             matvar->data_type = MAT_T_DOUBLE;
@@ -10111,18 +9285,18 @@
             matvar->data_size = 1;
             matvar->nbytes = N;
             matvar->data = malloc(matvar->nbytes);
-            if ( NULL == matvar->data )
+            if ( NULL != matvar->data ) {
+                ReadUInt8Data(mat,(mat_uint8_t*)matvar->data,matvar->data_type,N);
+            }
+            else {
                 Mat_Critical("Memory allocation failure");
-            else
-                ReadUInt8Data(mat,(mat_uint8_t*)matvar->data,matvar->data_type,N);
+            }
             matvar->data_type = MAT_T_UINT8;
             break;
         case MAT_C_SPARSE:
             matvar->data_size = sizeof(mat_sparse_t);
             matvar->data      = malloc(matvar->data_size);
-            if ( matvar->data == NULL )
-                Mat_Critical("Memory allocation failure");
-            else {
+            if ( NULL != matvar->data ) {
                 double tmp;
                 int i;
                 mat_sparse_t* sparse;
@@ -10211,101 +9385,104 @@
                 sparse->ndata = sparse->nir;
                 data_type = matvar->data_type;
                 if ( matvar->isComplex ) {
-                    mat_complex_split_t *complex_data;
-
-                    complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
-                    if ( complex_data != NULL ) {
-                        complex_data->Re = malloc(sparse->ndata*Mat_SizeOf(data_type));
-                        complex_data->Im = malloc(sparse->ndata*Mat_SizeOf(data_type));
-                        sparse->data     = complex_data;
-                        if ( complex_data->Re != NULL && complex_data->Im != NULL ) {
+                    mat_complex_split_t *complex_data =
+                        ComplexMalloc(sparse->ndata*Mat_SizeOf(data_type));
+                    if ( NULL != complex_data ) {
+                        sparse->data = complex_data;
 #if defined(EXTENDED_SPARSE)
-                            switch ( data_type ) {
-                                case MAT_T_DOUBLE:
-                                    ReadDoubleData(mat, (double*)complex_data->Re,
-                                        data_type, sparse->ndata);
-                                    ReadDoubleData(mat, &tmp, data_type, 1);
-                                    ReadDoubleData(mat, (double*)complex_data->Im,
-                                        data_type, sparse->ndata);
-                                    ReadDoubleData(mat, &tmp, data_type, 1);
-                                    break;
-                                case MAT_T_SINGLE:
-                                {
-                                    float tmp2;
-                                    ReadSingleData(mat, (float*)complex_data->Re,
-                                        data_type, sparse->ndata);
-                                    ReadSingleData(mat, &tmp2, data_type, 1);
-                                    ReadSingleData(mat, (float*)complex_data->Im,
-                                        data_type, sparse->ndata);
-                                    ReadSingleData(mat, &tmp2, data_type, 1);
-                                    break;
-                                }
-                                case MAT_T_INT32:
-                                {
-                                    mat_int32_t tmp2;
-                                    ReadInt32Data(mat, (mat_int32_t*)complex_data->Re,
-                                        data_type, sparse->ndata);
-                                    ReadInt32Data(mat, &tmp2, data_type, 1);
-                                    ReadInt32Data(mat, (mat_int32_t*)complex_data->Im,
-                                        data_type, sparse->ndata);
-                                    ReadInt32Data(mat, &tmp2, data_type, 1);
-                                    break;
-                                }
-                                case MAT_T_INT16:
-                                {
-                                    mat_int16_t tmp2;
-                                    ReadInt16Data(mat, (mat_int16_t*)complex_data->Re,
-                                        data_type, sparse->ndata);
-                                    ReadInt16Data(mat, &tmp2, data_type, 1);
-                                    ReadInt16Data(mat, (mat_int16_t*)complex_data->Im,
-                                        data_type, sparse->ndata);
-                                    ReadInt16Data(mat, &tmp2, data_type, 1);
-                                    break;
-                                }
-                                case MAT_T_UINT16:
-                                {
-                                    mat_uint16_t tmp2;
-                                    ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Re,
-                                        data_type, sparse->ndata);
-                                    ReadUInt16Data(mat, &tmp2, data_type, 1);
-                                    ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Im,
-                                        data_type, sparse->ndata);
-                                    ReadUInt16Data(mat, &tmp2, data_type, 1);
-                                    break;
-                                }
-                                case MAT_T_UINT8:
-                                {
-                                    mat_uint8_t tmp2;
-                                    ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Re,
-                                        data_type, sparse->ndata);
-                                    ReadUInt8Data(mat, &tmp2, data_type, 1);
-                                    ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Im,
-                                        data_type, sparse->ndata);
-                                    ReadUInt8Data(mat, &tmp2, data_type, 1);
-                                    break;
-                                }
-                                default:
-                                    free(complex_data->Re);
-                                    free(complex_data->Im);
-                                    free(complex_data);
-                                    free(sparse->jc);
-                                    free(sparse->ir);
-                                    free(matvar->data);
-                                    matvar->data = NULL;
-                                    Mat_Critical("Read4: %d is not a supported data type for ",
-                                        "extended sparse", data_type);
-                                    return;
+                        switch ( data_type ) {
+                            case MAT_T_DOUBLE:
+                                ReadDoubleData(mat, (double*)complex_data->Re,
+                                    data_type, sparse->ndata);
+                                ReadDoubleData(mat, &tmp, data_type, 1);
+                                ReadDoubleData(mat, (double*)complex_data->Im,
+                                    data_type, sparse->ndata);
+                                ReadDoubleData(mat, &tmp, data_type, 1);
+                                break;
+                            case MAT_T_SINGLE:
+                            {
+                                float tmp2;
+                                ReadSingleData(mat, (float*)complex_data->Re,
+                                    data_type, sparse->ndata);
+                                ReadSingleData(mat, &tmp2, data_type, 1);
+                                ReadSingleData(mat, (float*)complex_data->Im,
+                                    data_type, sparse->ndata);
+                                ReadSingleData(mat, &tmp2, data_type, 1);
+                                break;
                             }
+                            case MAT_T_INT32:
+                            {
+                                mat_int32_t tmp2;
+                                ReadInt32Data(mat, (mat_int32_t*)complex_data->Re,
+                                    data_type, sparse->ndata);
+                                ReadInt32Data(mat, &tmp2, data_type, 1);
+                                ReadInt32Data(mat, (mat_int32_t*)complex_data->Im,
+                                    data_type, sparse->ndata);
+                                ReadInt32Data(mat, &tmp2, data_type, 1);
+                                break;
+                            }
+                            case MAT_T_INT16:
+                            {
+                                mat_int16_t tmp2;
+                                ReadInt16Data(mat, (mat_int16_t*)complex_data->Re,
+                                    data_type, sparse->ndata);
+                                ReadInt16Data(mat, &tmp2, data_type, 1);
+                                ReadInt16Data(mat, (mat_int16_t*)complex_data->Im,
+                                    data_type, sparse->ndata);
+                                ReadInt16Data(mat, &tmp2, data_type, 1);
+                                break;
+                            }
+                            case MAT_T_UINT16:
+                            {
+                                mat_uint16_t tmp2;
+                                ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Re,
+                                    data_type, sparse->ndata);
+                                ReadUInt16Data(mat, &tmp2, data_type, 1);
+                                ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Im,
+                                    data_type, sparse->ndata);
+                                ReadUInt16Data(mat, &tmp2, data_type, 1);
+                                break;
+                            }
+                            case MAT_T_UINT8:
+                            {
+                                mat_uint8_t tmp2;
+                                ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Re,
+                                    data_type, sparse->ndata);
+                                ReadUInt8Data(mat, &tmp2, data_type, 1);
+                                ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Im,
+                                    data_type, sparse->ndata);
+                                ReadUInt8Data(mat, &tmp2, data_type, 1);
+                                break;
+                            }
+                            default:
+                                free(complex_data->Re);
+                                free(complex_data->Im);
+                                free(complex_data);
+                                free(sparse->jc);
+                                free(sparse->ir);
+                                free(matvar->data);
+                                matvar->data = NULL;
+                                Mat_Critical("Read4: %d is not a supported data type for ",
+                                    "extended sparse", data_type);
+                                return;
+                        }
 #else
-                            ReadDoubleData(mat, (double*)complex_data->Re,
-                                data_type, sparse->ndata);
-                            ReadDoubleData(mat, &tmp, data_type, 1);
-                            ReadDoubleData(mat, (double*)complex_data->Im,
-                                data_type, sparse->ndata);
-                            ReadDoubleData(mat, &tmp, data_type, 1);
+                        ReadDoubleData(mat, (double*)complex_data->Re,
+                            data_type, sparse->ndata);
+                        ReadDoubleData(mat, &tmp, data_type, 1);
+                        ReadDoubleData(mat, (double*)complex_data->Im,
+                            data_type, sparse->ndata);
+                        ReadDoubleData(mat, &tmp, data_type, 1);
 #endif
-                        }
                     }
+                    else {
+                        free(sparse->jc);
+                        free(sparse->ir);
+                        free(matvar->data);
+                        matvar->data = NULL;
+                        Mat_Critical("Memory allocation failure");
+                        return;
+                    }
                 } else {
                     sparse->data = malloc(sparse->ndata*Mat_SizeOf(data_type));
                     if ( sparse->data != NULL ) {
@@ -10381,6 +9558,9 @@
                 }
                 break;
             }
+            else {
+                Mat_Critical("Memory allocation failure");
+            }
         default:
             Mat_Critical("MAT V4 data type error");
             return;
@@ -10408,28 +9588,16 @@
       int *start,int *stride,int *edge)
 {
     int err = 0;
-    enum matio_classes class_type = MAT_C_EMPTY;
 
     (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
 
     switch( matvar->data_type ) {
         case MAT_T_DOUBLE:
-            class_type = MAT_C_DOUBLE;
-            break;
         case MAT_T_SINGLE:
-            class_type = MAT_C_SINGLE;
-            break;
         case MAT_T_INT32:
-            class_type = MAT_C_INT32;
-            break;
         case MAT_T_INT16:
-            class_type = MAT_C_INT16;
-            break;
         case MAT_T_UINT16:
-            class_type = MAT_C_UINT16;
-            break;
         case MAT_T_UINT8:
-            class_type = MAT_C_UINT8;
             break;
         default:
             return 1;
@@ -10442,16 +9610,16 @@
             err = 1;
         if ( matvar->isComplex ) {
             mat_complex_split_t *cdata = (mat_complex_split_t*)data;
-            long nbytes = edge[0]*edge[1]*Mat_SizeOf(matvar->data_type);
+            long nbytes = matvar->dims[0]*matvar->dims[1]*Mat_SizeOf(matvar->data_type);
 
-            ReadDataSlab2(mat,cdata->Re,class_type,matvar->data_type,
-                    matvar->dims,start,stride,edge);
+            ReadDataSlab2(mat,cdata->Re,matvar->class_type,matvar->data_type,
+                matvar->dims,start,stride,edge);
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos+nbytes,SEEK_SET);
-            ReadDataSlab2(mat,cdata->Im,class_type,
+            ReadDataSlab2(mat,cdata->Im,matvar->class_type,
                 matvar->data_type,matvar->dims,start,stride,edge);
         } else {
-            ReadDataSlab2(mat,data,class_type,matvar->data_type,
-                    matvar->dims,start,stride,edge);
+            ReadDataSlab2(mat,data,matvar->class_type,matvar->data_type,
+                matvar->dims,start,stride,edge);
         }
     } else if ( matvar->isComplex ) {
         int i;
@@ -10459,15 +9627,15 @@
         long nbytes = Mat_SizeOf(matvar->data_type);
 
         for ( i = 0; i < matvar->rank; i++ )
-            nbytes *= edge[i];
+            nbytes *= matvar->dims[i];
 
-        ReadDataSlabN(mat,cdata->Re,class_type,matvar->data_type,
+        ReadDataSlabN(mat,cdata->Re,matvar->class_type,matvar->data_type,
             matvar->rank,matvar->dims,start,stride,edge);
         (void)fseek((FILE*)mat->fp,matvar->internal->datapos+nbytes,SEEK_SET);
-        ReadDataSlabN(mat,cdata->Im,class_type,matvar->data_type,
+        ReadDataSlabN(mat,cdata->Im,matvar->class_type,matvar->data_type,
             matvar->rank,matvar->dims,start,stride,edge);
     } else {
-        ReadDataSlabN(mat,data,class_type,matvar->data_type,
+        ReadDataSlabN(mat,data,matvar->class_type,matvar->data_type,
             matvar->rank,matvar->dims,start,stride,edge);
     }
     return err;
@@ -10730,6 +9898,7 @@
  * -------------------------------------------------------------
  */
 
+#if defined(HAVE_ZLIB)
 /** @brief determines the number of bytes needed to store the given struct field
  *
  * @ingroup mat_internal
@@ -10744,7 +9913,7 @@
     int    nmemb = 1, i;
 
     if ( matvar == NULL )
-        return nBytes;
+        return GetEmptyMatrixMaxBufSize(NULL, 2);
 
     /* Add the Array Flags tag and space to the number of bytes */
     nBytes += tag_size + array_flags_size;
@@ -10789,7 +9958,7 @@
     case MAT_C_CELL:
     {
         matvar_t **cells = (matvar_t**)matvar->data;
-        int i, ncells;
+        int ncells;
 
         if ( matvar->nbytes == 0 || matvar->data_size == 0 )
             break;
@@ -10797,6 +9966,7 @@
         ncells = matvar->nbytes / matvar->data_size;
 
         if ( NULL != cells && ncells > 0 ) {
+            int i;
             for ( i = 0; i < ncells; i++ )
                 nBytes += tag_size + GetCellArrayFieldBufSize(cells[i]);
         }
@@ -10908,7 +10078,7 @@
     case MAT_C_CELL:
     {
         matvar_t **cells = (matvar_t**)matvar->data;
-        int i, ncells;
+        int ncells;
 
         if ( matvar->nbytes == 0 || matvar->data_size == 0 )
             break;
@@ -10916,6 +10086,7 @@
         ncells = matvar->nbytes / matvar->data_size;
 
         if ( NULL != cells && ncells > 0 ) {
+            int i;
             for ( i = 0; i < ncells; i++ )
                 nBytes += tag_size + GetCellArrayFieldBufSize(cells[i]);
         }
@@ -10968,7 +10139,6 @@
     return nBytes;
 }
 
-#if defined(HAVE_ZLIB)
 /** @brief determines the number of bytes needed to store the given variable
  *
  * @ingroup mat_internal
@@ -11080,7 +10250,7 @@
     case MAT_C_CELL:
     {
         matvar_t **cells = (matvar_t**)matvar->data;
-        int i, ncells;
+        int ncells;
 
         if ( matvar->nbytes == 0 || matvar->data_size == 0 )
             break;
@@ -11088,6 +10258,7 @@
         ncells = matvar->nbytes / matvar->data_size;
 
         if ( NULL != cells && ncells > 0 ) {
+            int i;
             for ( i = 0; i < ncells; i++ )
                 nBytes += tag_size + GetCellArrayFieldBufSize(cells[i]);
         }
@@ -11167,7 +10338,7 @@
     size_t err;
     time_t t;
 
-    fp = fopen(matname,"wb");
+    fp = fopen(matname,"w+b");
     if ( !fp )
         return NULL;
 
@@ -11184,8 +10355,11 @@
     mat->version       = 0;
     mat->byteswap      = 0;
     mat->mode          = 0;
-    mat->bof           = 0;
+    mat->bof           = 128;
     mat->next_index    = 0;
+    mat->num_datasets  = 0;
+    mat->refs_id       = -1;
+    mat->dir           = NULL;
 
     t = time(NULL);
     mat->fp       = fp;
@@ -11333,7 +10507,7 @@
     enum matio_types data_type)
 {
     int data_size, data_tag[2], byteswritten = 0;
-    int buf_size = 1024, i;
+    int buf_size = 1024;
     mat_uint8_t   buf[1024], pad[8] = {0,};
 
     if ((mat == NULL) || (mat->fp == NULL))
@@ -11384,6 +10558,7 @@
         {
             mat_uint8_t *ptr;
             mat_uint16_t c;
+            int i;
 
             /* Matlab can't read MAT_C_CHAR as uint8, needs uint16 */
             data_size   = 2;
@@ -11573,12 +10748,13 @@
     if ( (mat == NULL) || (mat->fp == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
             double d = 0.0;
 
-            data_size = sizeof(double);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11590,7 +10766,6 @@
         {
             float f = 0.0;
 
-            data_size = sizeof(float);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11602,7 +10777,6 @@
         {
             mat_int8_t i8 = 0;
 
-            data_size = sizeof(mat_int8_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11614,7 +10788,6 @@
         {
             mat_uint8_t ui8 = 0;
 
-            data_size = sizeof(mat_uint8_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11626,7 +10799,6 @@
         {
             mat_int16_t i16 = 0;
 
-            data_size = sizeof(mat_int16_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11638,7 +10810,6 @@
         {
             mat_uint16_t ui16 = 0;
 
-            data_size = sizeof(mat_uint16_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11650,7 +10821,6 @@
         {
             mat_int32_t i32 = 0;
 
-            data_size = sizeof(mat_int32_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11662,7 +10832,6 @@
         {
             mat_uint32_t ui32 = 0;
 
-            data_size = sizeof(mat_uint32_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11675,7 +10844,6 @@
         {
             mat_int64_t i64 = 0;
 
-            data_size = sizeof(mat_int64_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11689,7 +10857,6 @@
         {
             mat_uint64_t ui64 = 0;
 
-            data_size = sizeof(mat_uint64_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11716,6 +10883,8 @@
     if ( (mat == NULL) || (mat->fp == NULL) )
         return 0;
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
@@ -11723,7 +10892,6 @@
             mat_uint32_t comp_buf[32] = {0,};
             double data_uncomp_buf[4] = {0.0,};
 
-            data_size = sizeof(double);
             nBytes = N*data_size;
             uncomp_buf[0] = data_type;
             uncomp_buf[1] = 0;
@@ -11751,7 +10919,6 @@
         {
             float f = 0.0;
 
-            data_size = sizeof(float);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11763,7 +10930,6 @@
         {
             mat_int8_t i8 = 0;
 
-            data_size = sizeof(mat_int8_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11775,7 +10941,6 @@
         {
             mat_uint8_t ui8 = 0;
 
-            data_size = sizeof(mat_uint8_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11787,7 +10952,6 @@
         {
             mat_int16_t i16 = 0;
 
-            data_size = sizeof(mat_int16_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11799,7 +10963,6 @@
         {
             mat_uint16_t ui16 = 0;
 
-            data_size = sizeof(mat_uint16_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11811,7 +10974,6 @@
         {
             mat_int32_t i32 = 0;
 
-            data_size = sizeof(mat_int32_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11823,7 +10985,6 @@
         {
             mat_uint32_t ui32 = 0;
 
-            data_size = sizeof(mat_uint32_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11836,7 +10997,6 @@
         {
             mat_int64_t i64 = 0;
 
-            data_size = sizeof(mat_int64_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11850,7 +11010,6 @@
         {
             mat_uint64_t ui64 = 0;
 
-            data_size = sizeof(mat_uint64_t);
             nBytes = N*data_size;
             fwrite(&data_type,4,1,(FILE*)mat->fp);
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
@@ -11894,12 +11053,13 @@
         return 0;
     }
 
+    data_size = Mat_SizeOf(data_type);
+
     switch ( data_type ) {
         case MAT_T_DOUBLE:
         {
             double *ptr;
 
-            data_size = sizeof(double);
             ptr = (double *)data;
             row_stride = (stride[0]-1)*data_size;
             col_stride = stride[1]*dims[0]*data_size;
@@ -11930,7 +11090,6 @@
         {
             float *ptr;
 
-            data_size = sizeof(float);
             ptr = (float *)data;
             row_stride = (stride[0]-1)*data_size;
             col_stride = stride[1]*dims[0]*data_size;
@@ -11962,7 +11121,6 @@
         {
             mat_int64_t *ptr;
 
-            data_size = sizeof(mat_int64_t);
             ptr = (mat_int64_t *)data;
             row_stride = (stride[0]-1)*data_size;
             col_stride = stride[1]*dims[0]*data_size;
@@ -11995,7 +11153,6 @@
         {
             mat_uint64_t *ptr;
 
-            data_size = sizeof(mat_uint64_t);
             ptr = (mat_uint64_t *)data;
             row_stride = (stride[0]-1)*data_size;
             col_stride = stride[1]*dims[0]*data_size;
@@ -12027,7 +11184,6 @@
         {
             mat_int32_t *ptr;
 
-            data_size = sizeof(mat_int32_t);
             ptr = (mat_int32_t *)data;
             row_stride = (stride[0]-1)*data_size;
             col_stride = stride[1]*dims[0]*data_size;
@@ -12058,7 +11214,6 @@
         {
             mat_uint32_t *ptr;
 
-            data_size = sizeof(mat_uint32_t);
             ptr = (mat_uint32_t *)data;
             row_stride = (stride[0]-1)*data_size;
             col_stride = stride[1]*dims[0]*data_size;
@@ -12089,7 +11244,6 @@
         {
             mat_int16_t *ptr;
 
-            data_size = sizeof(mat_int16_t);
             ptr = (mat_int16_t *)data;
             row_stride = (stride[0]-1)*data_size;
             col_stride = stride[1]*dims[0]*data_size;
@@ -12120,7 +11274,6 @@
         {
             mat_uint16_t *ptr;
 
-            data_size = sizeof(mat_uint16_t);
             ptr = (mat_uint16_t *)data;
             row_stride = (stride[0]-1)*data_size;
             col_stride = stride[1]*dims[0]*data_size;
@@ -12151,7 +11304,6 @@
         {
             mat_int8_t *ptr;
 
-            data_size = sizeof(mat_int8_t);
             ptr = (mat_int8_t *)data;
             row_stride = (stride[0]-1)*data_size;
             col_stride = stride[1]*dims[0]*data_size;
@@ -12182,7 +11334,6 @@
         {
             mat_uint8_t *ptr;
 
-            data_size = sizeof(mat_uint8_t);
             ptr = (mat_uint8_t *)data;
             row_stride = (stride[0]-1)*data_size;
             col_stride = stride[1]*dims[0]*data_size;
@@ -12385,13 +11536,12 @@
 {
     int nBytes = 0, data_size, data_tag[2], byteswritten = 0;
     int buf_size = 1024;
-    mat_uint8_t   buf[1024], pad[8] = {0,};
+    mat_uint8_t buf[1024], pad[8] = {0,};
 
     if ((mat == NULL) || (mat->fp == NULL))
         return 0;
 
-    data_size = Mat_SizeOf(data_type);
-
+    data_size   = Mat_SizeOf(data_type);
     data_tag[0] = data_type;
     data_tag[1] = data_size*N;
     z->next_in  = ZLIB_BYTE_PTR(data_tag);
@@ -12451,7 +11601,7 @@
     matvar->data_size = sizeof(matvar_t *);
     matvar->nbytes    = ncells*matvar->data_size;
     matvar->data      = malloc(matvar->nbytes);
-    if ( !matvar->data ) {
+    if ( NULL == matvar->data ) {
         Mat_Critical("Couldn't allocate memory for %s->data",matvar->name);
         return bytesread;
     }
@@ -12460,7 +11610,7 @@
     if ( matvar->compression ) {
 #if defined(HAVE_ZLIB)
         mat_uint32_t uncomp_buf[16] = {0,};
-        int      nbytes;
+        int nbytes;
         mat_uint32_t array_flags;
         int err;
 
@@ -12509,13 +11659,13 @@
             /* Array Flags */
             if ( uncomp_buf[0] == MAT_T_UINT32 ) {
                array_flags = uncomp_buf[2];
-               cells[i]->class_type  = CLASS_FROM_ARRAY_FLAGS(array_flags);
-               cells[i]->isComplex   = (array_flags & MAT_F_COMPLEX);
-               cells[i]->isGlobal    = (array_flags & MAT_F_GLOBAL);
-               cells[i]->isLogical   = (array_flags & MAT_F_LOGICAL);
+               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
+               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
+               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
+               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
                if ( cells[i]->class_type == MAT_C_SPARSE ) {
                    /* Need to find a more appropriate place to store nzmax */
-                   cells[i]->nbytes      = uncomp_buf[3];
+                   cells[i]->nbytes = uncomp_buf[3];
                }
             } else {
                 Mat_Critical("Expected MAT_T_UINT32 for Array Tags, got %d",
@@ -12522,95 +11672,97 @@
                                uncomp_buf[0]);
                 bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);
             }
-            bytesread += InflateDimensions(mat,matvar,uncomp_buf);
-            nbytes -= 8;
-            if ( mat->byteswap ) {
-                (void)Mat_uint32Swap(uncomp_buf);
-                (void)Mat_uint32Swap(uncomp_buf+1);
-            }
-            /* Rank and Dimension */
-            if ( uncomp_buf[0] == MAT_T_INT32 ) {
-                int j = 0;
+            if ( cells[i]->class_type != MAT_C_OPAQUE ) {
+                bytesread += InflateDimensions(mat,matvar,uncomp_buf);
+                nbytes -= 8;
+                if ( mat->byteswap ) {
+                    (void)Mat_uint32Swap(uncomp_buf);
+                    (void)Mat_uint32Swap(uncomp_buf+1);
+                }
+                /* Rank and Dimension */
+                if ( uncomp_buf[0] == MAT_T_INT32 ) {
+                    int j = 0;
 
-                cells[i]->rank = uncomp_buf[1];
-                nbytes -= cells[i]->rank;
-                cells[i]->rank /= 4;
-                cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));
+                    cells[i]->rank = uncomp_buf[1];
+                    nbytes -= cells[i]->rank;
+                    cells[i]->rank /= 4;
+                    cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));
+                    if ( mat->byteswap ) {
+                        for ( j = 0; j < cells[i]->rank; j++ )
+                            cells[i]->dims[j] = Mat_uint32Swap(uncomp_buf+2+j);
+                    } else {
+                        for ( j = 0; j < cells[i]->rank; j++ )
+                            cells[i]->dims[j] = uncomp_buf[2+j];
+                    }
+                    if ( cells[i]->rank % 2 != 0 )
+                        nbytes -= 4;
+                }
+                bytesread += InflateVarNameTag(mat,matvar,uncomp_buf);
+                nbytes -= 8;
                 if ( mat->byteswap ) {
-                    for ( j = 0; j < cells[i]->rank; j++ )
-                        cells[i]->dims[j] = Mat_uint32Swap(uncomp_buf+2+j);
-                } else {
-                    for ( j = 0; j < cells[i]->rank; j++ )
-                        cells[i]->dims[j] = uncomp_buf[2+j];
+                    (void)Mat_uint32Swap(uncomp_buf);
+                    (void)Mat_uint32Swap(uncomp_buf+1);
                 }
-                if ( cells[i]->rank % 2 != 0 )
-                    nbytes -= 4;
-            }
-            bytesread += InflateVarNameTag(mat,matvar,uncomp_buf);
-            nbytes -= 8;
-            if ( mat->byteswap ) {
-                (void)Mat_uint32Swap(uncomp_buf);
-                (void)Mat_uint32Swap(uncomp_buf+1);
-            }
-            /* Handle cell elements written with a variable name */
-            if ( uncomp_buf[1] > 0 ) {
-                /* Name of variable */
-                int len = 0;
-                if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
-                    len = uncomp_buf[1];
+                /* Handle cell elements written with a variable name */
+                if ( uncomp_buf[1] > 0 ) {
+                    /* Name of variable */
+                    int len = 0;
+                    if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
+                        len = uncomp_buf[1];
 
-                    if ( len % 8 > 0 )
-                        len = len+(8-(len % 8));
-                    cells[i]->name = (char*)malloc(len+1);
-                    /* Inflate variable name */
-                    bytesread += InflateVarName(mat,matvar,cells[i]->name,len);
-                    cells[i]->name[len] = '\0';
-                    nbytes -= len;
-                } else if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) &&
-                           ((uncomp_buf[0] & 0xffff0000) != 0x00) ) {
-                    /* Name packed in tag */
-                    len = (uncomp_buf[0] & 0xffff0000) >> 16;
-                    cells[i]->name = (char*)malloc(len+1);
-                    memcpy(cells[i]->name,uncomp_buf+1,len);
-                    cells[i]->name[len] = '\0';
+                        if ( len % 8 > 0 )
+                            len = len+(8-(len % 8));
+                        cells[i]->name = (char*)malloc(len+1);
+                        /* Inflate variable name */
+                        bytesread += InflateVarName(mat,matvar,cells[i]->name,len);
+                        cells[i]->name[len] = '\0';
+                        nbytes -= len;
+                    } else if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) &&
+                               ((uncomp_buf[0] & 0xffff0000) != 0x00) ) {
+                        /* Name packed in tag */
+                        len = (uncomp_buf[0] & 0xffff0000) >> 16;
+                        cells[i]->name = (char*)malloc(len+1);
+                        memcpy(cells[i]->name,uncomp_buf+1,len);
+                        cells[i]->name[len] = '\0';
+                    }
                 }
-            }
-            cells[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));
-            if ( cells[i]->internal->z != NULL ) {
-                err = inflateCopy(cells[i]->internal->z,matvar->internal->z);
-                if ( err == Z_OK ) {
-                    cells[i]->internal->datapos = ftell((FILE*)mat->fp);
-                    if ( cells[i]->internal->datapos != -1L ) {
-                        cells[i]->internal->datapos -= matvar->internal->z->avail_in;
-                        if ( cells[i]->class_type == MAT_C_STRUCT )
-                            bytesread+=ReadNextStructField(mat,cells[i]);
-                        else if ( cells[i]->class_type == MAT_C_CELL )
-                            bytesread+=ReadNextCell(mat,cells[i]);
-                        else if ( nbytes <= (1 << MAX_WBITS) ) {
-                            /* Memory optimization: Read data if less in size
-                               than the zlib inflate state (approximately) */
-                            cells[i]->internal->fp = mat;
-                            Read5(mat,cells[i]);
-                            cells[i]->internal->data = cells[i]->data;
-                            cells[i]->data = NULL;
+                cells[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));
+                if ( cells[i]->internal->z != NULL ) {
+                    err = inflateCopy(cells[i]->internal->z,matvar->internal->z);
+                    if ( err == Z_OK ) {
+                        cells[i]->internal->datapos = ftell((FILE*)mat->fp);
+                        if ( cells[i]->internal->datapos != -1L ) {
+                            cells[i]->internal->datapos -= matvar->internal->z->avail_in;
+                            if ( cells[i]->class_type == MAT_C_STRUCT )
+                                bytesread+=ReadNextStructField(mat,cells[i]);
+                            else if ( cells[i]->class_type == MAT_C_CELL )
+                                bytesread+=ReadNextCell(mat,cells[i]);
+                            else if ( nbytes <= (1 << MAX_WBITS) ) {
+                                /* Memory optimization: Read data if less in size
+                                   than the zlib inflate state (approximately) */
+                                cells[i]->internal->fp = mat;
+                                Read5(mat,cells[i]);
+                                cells[i]->internal->data = cells[i]->data;
+                                cells[i]->data = NULL;
+                            }
+                            (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos,SEEK_SET);
+                        } else {
+                            Mat_Critical("Couldn't determine file position");
                         }
-                        (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos,SEEK_SET);
+                        if ( cells[i]->internal->data != NULL ||
+                             cells[i]->class_type == MAT_C_STRUCT ||
+                             cells[i]->class_type == MAT_C_CELL ) {
+                            /* Memory optimization: Free inflate state */
+                            inflateEnd(cells[i]->internal->z);
+                            free(cells[i]->internal->z);
+                            cells[i]->internal->z = NULL;
+                        }
                     } else {
-                        Mat_Critical("Couldn't determine file position");
+                        Mat_Critical("inflateCopy returned error %s",zError(err));
                     }
-                    if ( cells[i]->internal->data != NULL ||
-                         cells[i]->class_type == MAT_C_STRUCT ||
-                         cells[i]->class_type == MAT_C_CELL ) {
-                        /* Memory optimization: Free inflate state */
-                        inflateEnd(cells[i]->internal->z);
-                        free(cells[i]->internal->z);
-                        cells[i]->internal->z = NULL;
-                    }
                 } else {
-                    Mat_Critical("inflateCopy returned error %s",zError(err));
+                    Mat_Critical("Couldn't allocate memory");
                 }
-            } else {
-                Mat_Critical("Couldn't allocate memory");
             }
             bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);
         }
@@ -12620,7 +11772,7 @@
 
     } else {
         mat_uint32_t buf[16];
-        int      nbytes,nBytes;
+        int nbytes,nBytes;
         mat_uint32_t array_flags;
 
         for ( i = 0; i < ncells; i++ ) {
@@ -12664,7 +11816,7 @@
             cells[i]->internal->z = NULL;
 #endif
 
-            /* Read Array Flags and The Dimensions Tag */
+            /* Read array flags and the dimensions tag */
             bytesread += fread(buf,4,6,(FILE*)mat->fp);
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
@@ -12675,19 +11827,19 @@
                 (void)Mat_uint32Swap(buf+5);
             }
             nBytes-=24;
-            /* Array Flags */
+            /* Array flags */
             if ( buf[0] == MAT_T_UINT32 ) {
                array_flags = buf[2];
-               cells[i]->class_type  = CLASS_FROM_ARRAY_FLAGS(array_flags);
-               cells[i]->isComplex   = (array_flags & MAT_F_COMPLEX);
-               cells[i]->isGlobal    = (array_flags & MAT_F_GLOBAL);
-               cells[i]->isLogical   = (array_flags & MAT_F_LOGICAL);
+               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
+               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
+               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
+               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
                if ( cells[i]->class_type == MAT_C_SPARSE ) {
                    /* Need to find a more appropriate place to store nzmax */
-                   cells[i]->nbytes      = buf[3];
+                   cells[i]->nbytes = buf[3];
                }
             }
-            /* Rank and Dimension */
+            /* Rank and dimension */
             if ( buf[4] == MAT_T_INT32 ) {
                 int j;
                 nbytes = buf[5];
@@ -12711,7 +11863,7 @@
                         cells[i]->dims[j] = buf[j];
                 }
             }
-            /* Variable Name Tag */
+            /* Variable name tag */
             bytesread+=fread(buf,1,8,(FILE*)mat->fp);
             nBytes-=8;
             if ( mat->byteswap ) {
@@ -12766,9 +11918,8 @@
 
     if ( matvar->compression ) {
 #if defined(HAVE_ZLIB)
-        char    *ptr;
         mat_uint32_t uncomp_buf[16] = {0,};
-        int      nbytes, j;
+        int nbytes, j;
         mat_uint32_t array_flags;
         int err;
 
@@ -12799,7 +11950,7 @@
         else
             i = 0;
         if ( nfields ) {
-            ptr = (char*)malloc(nfields*fieldname_size+i);
+            char *ptr = (char*)malloc(nfields*fieldname_size+i);
             bytesread += InflateFieldNames(mat,matvar,ptr,nfields,fieldname_size,i);
             matvar->internal->num_fields = nfields;
             matvar->internal->fieldnames =
@@ -12821,7 +11972,7 @@
             return bytesread;
 
         matvar->data = malloc(matvar->nbytes);
-        if ( !matvar->data )
+        if ( NULL == matvar->data )
             return bytesread;
 
         fields = (matvar_t**)matvar->data;
@@ -12865,16 +12016,16 @@
                 (void)Mat_uint32Swap(uncomp_buf+2);
                 (void)Mat_uint32Swap(uncomp_buf+3);
             }
-            /* Array Flags */
+            /* Array flags */
             if ( uncomp_buf[0] == MAT_T_UINT32 ) {
                array_flags = uncomp_buf[2];
-               fields[i]->class_type  = CLASS_FROM_ARRAY_FLAGS(array_flags);
-               fields[i]->isComplex   = (array_flags & MAT_F_COMPLEX);
-               fields[i]->isGlobal    = (array_flags & MAT_F_GLOBAL);
-               fields[i]->isLogical   = (array_flags & MAT_F_LOGICAL);
+               fields[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
+               fields[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
+               fields[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
+               fields[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
                if ( fields[i]->class_type == MAT_C_SPARSE ) {
                    /* Need to find a more appropriate place to store nzmax */
-                   fields[i]->nbytes      = uncomp_buf[3];
+                   fields[i]->nbytes = uncomp_buf[3];
                }
             } else {
                 Mat_Critical("Expected MAT_T_UINT32 for Array Tags, got %d",
@@ -12881,69 +12032,71 @@
                     uncomp_buf[0]);
                 bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);
             }
-            bytesread += InflateDimensions(mat,matvar,uncomp_buf);
-            nbytes -= 8;
-            if ( mat->byteswap ) {
-                (void)Mat_uint32Swap(uncomp_buf);
-                (void)Mat_uint32Swap(uncomp_buf+1);
-            }
-            /* Rank and Dimension */
-            if ( uncomp_buf[0] == MAT_T_INT32 ) {
-                int j = 0;
-
-                fields[i]->rank = uncomp_buf[1];
-                nbytes -= fields[i]->rank;
-                fields[i]->rank /= 4;
-                fields[i]->dims = (size_t*)malloc(fields[i]->rank*
-                                         sizeof(*fields[i]->dims));
+            if ( fields[i]->class_type != MAT_C_OPAQUE ) {
+                bytesread += InflateDimensions(mat,matvar,uncomp_buf);
+                nbytes -= 8;
                 if ( mat->byteswap ) {
-                    for ( j = 0; j < fields[i]->rank; j++ )
-                        fields[i]->dims[j] = Mat_uint32Swap(uncomp_buf+2+j);
-                } else {
-                    for ( j = 0; j < fields[i]->rank; j++ )
-                        fields[i]->dims[j] = uncomp_buf[2+j];
+                    (void)Mat_uint32Swap(uncomp_buf);
+                    (void)Mat_uint32Swap(uncomp_buf+1);
                 }
-                if ( fields[i]->rank % 2 != 0 )
-                    nbytes -= 4;
-            }
-            bytesread += InflateVarNameTag(mat,matvar,uncomp_buf);
-            nbytes -= 8;
-            fields[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));
-            if ( fields[i]->internal->z != NULL ) {
-                err = inflateCopy(fields[i]->internal->z,matvar->internal->z);
-                if ( err == Z_OK ) {
-                    fields[i]->internal->datapos = ftell((FILE*)mat->fp);
-                    if ( fields[i]->internal->datapos != -1L ) {
-                        fields[i]->internal->datapos -= matvar->internal->z->avail_in;
-                        if ( fields[i]->class_type == MAT_C_STRUCT )
-                            bytesread+=ReadNextStructField(mat,fields[i]);
-                        else if ( fields[i]->class_type == MAT_C_CELL )
-                            bytesread+=ReadNextCell(mat,fields[i]);
-                        else if ( nbytes <= (1 << MAX_WBITS) ) {
-                            /* Memory optimization: Read data if less in size
-                               than the zlib inflate state (approximately) */
-                            fields[i]->internal->fp = mat;
-                            Read5(mat,fields[i]);
-                            fields[i]->internal->data = fields[i]->data;
-                            fields[i]->data = NULL;
+                /* Rank and dimension */
+                if ( uncomp_buf[0] == MAT_T_INT32 ) {
+                    int j = 0;
+
+                    fields[i]->rank = uncomp_buf[1];
+                    nbytes -= fields[i]->rank;
+                    fields[i]->rank /= 4;
+                    fields[i]->dims = (size_t*)malloc(fields[i]->rank*
+                                             sizeof(*fields[i]->dims));
+                    if ( mat->byteswap ) {
+                        for ( j = 0; j < fields[i]->rank; j++ )
+                            fields[i]->dims[j] = Mat_uint32Swap(uncomp_buf+2+j);
+                    } else {
+                        for ( j = 0; j < fields[i]->rank; j++ )
+                            fields[i]->dims[j] = uncomp_buf[2+j];
+                    }
+                    if ( fields[i]->rank % 2 != 0 )
+                        nbytes -= 4;
+                }
+                bytesread += InflateVarNameTag(mat,matvar,uncomp_buf);
+                nbytes -= 8;
+                fields[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));
+                if ( fields[i]->internal->z != NULL ) {
+                    err = inflateCopy(fields[i]->internal->z,matvar->internal->z);
+                    if ( err == Z_OK ) {
+                        fields[i]->internal->datapos = ftell((FILE*)mat->fp);
+                        if ( fields[i]->internal->datapos != -1L ) {
+                            fields[i]->internal->datapos -= matvar->internal->z->avail_in;
+                            if ( fields[i]->class_type == MAT_C_STRUCT )
+                                bytesread+=ReadNextStructField(mat,fields[i]);
+                            else if ( fields[i]->class_type == MAT_C_CELL )
+                                bytesread+=ReadNextCell(mat,fields[i]);
+                            else if ( nbytes <= (1 << MAX_WBITS) ) {
+                                /* Memory optimization: Read data if less in size
+                                   than the zlib inflate state (approximately) */
+                                fields[i]->internal->fp = mat;
+                                Read5(mat,fields[i]);
+                                fields[i]->internal->data = fields[i]->data;
+                                fields[i]->data = NULL;
+                            }
+                            (void)fseek((FILE*)mat->fp,fields[i]->internal->datapos,SEEK_SET);
+                        } else {
+                            Mat_Critical("Couldn't determine file position");
                         }
-                        (void)fseek((FILE*)mat->fp,fields[i]->internal->datapos,SEEK_SET);
+                        if ( fields[i]->internal->data != NULL ||
+                             fields[i]->class_type == MAT_C_STRUCT ||
+                             fields[i]->class_type == MAT_C_CELL ) {
+                            /* Memory optimization: Free inflate state */
+                            inflateEnd(fields[i]->internal->z);
+                            free(fields[i]->internal->z);
+                            fields[i]->internal->z = NULL;
+                        }
                     } else {
-                        Mat_Critical("Couldn't determine file position");
+                        Mat_Critical("inflateCopy returned error %s",zError(err));
                     }
-                    if ( fields[i]->internal->data != NULL ||
-                         fields[i]->class_type == MAT_C_STRUCT ||
-                         fields[i]->class_type == MAT_C_CELL ) {
-                        /* Memory optimization: Free inflate state */
-                        inflateEnd(fields[i]->internal->z);
-                        free(fields[i]->internal->z);
-                        fields[i]->internal->z = NULL;
-                    }
                 } else {
-                    Mat_Critical("inflateCopy returned error %s",zError(err));
+                    Mat_Critical("Couldn't allocate memory");
                 }
-            } else {
-                Mat_Critical("Couldn't allocate memory");
             }
             bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);
         }
@@ -12952,7 +12105,7 @@
 #endif
     } else {
         mat_uint32_t buf[16] = {0,};
-        int      nbytes,nBytes,j;
+        int nbytes,nBytes,j;
         mat_uint32_t array_flags;
 
         bytesread+=fread(buf,4,2,(FILE*)mat->fp);
@@ -12999,7 +12152,7 @@
             return bytesread;
 
         matvar->data = malloc(matvar->nbytes);
-        if ( !matvar->data )
+        if ( NULL == matvar->data )
             return bytesread;
 
         fields = (matvar_t**)matvar->data;
@@ -13040,7 +12193,7 @@
             fields[i]->internal->z = NULL;
 #endif
 
-            /* Read Array Flags and The Dimensions Tag */
+            /* Read array flags and the dimensions tag */
             bytesread += fread(buf,4,6,(FILE*)mat->fp);
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
@@ -13051,19 +12204,19 @@
                 (void)Mat_uint32Swap(buf+5);
             }
             nBytes-=24;
-            /* Array Flags */
+            /* Array flags */
             if ( buf[0] == MAT_T_UINT32 ) {
                array_flags = buf[2];
-               fields[i]->class_type  = CLASS_FROM_ARRAY_FLAGS(array_flags);
-               fields[i]->isComplex   = (array_flags & MAT_F_COMPLEX);
-               fields[i]->isGlobal    = (array_flags & MAT_F_GLOBAL);
-               fields[i]->isLogical   = (array_flags & MAT_F_LOGICAL);
+               fields[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
+               fields[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
+               fields[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
+               fields[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
                if ( fields[i]->class_type == MAT_C_SPARSE ) {
                    /* Need to find a more appropriate place to store nzmax */
-                   fields[i]->nbytes      = buf[3];
+                   fields[i]->nbytes = buf[3];
                }
             }
-            /* Rank and Dimension */
+            /* Rank and dimension */
             if ( buf[4] == MAT_T_INT32 ) {
                 int j;
 
@@ -13089,7 +12242,7 @@
                         fields[i]->dims[j] = buf[j];
                 }
             }
-            /* Variable Name Tag */
+            /* Variable name tag */
             bytesread+=fread(buf,1,8,(FILE*)mat->fp);
             nBytes-=8;
             fields[i]->internal->datapos = ftell((FILE*)mat->fp);
@@ -13120,7 +12273,6 @@
 {
     int nfunctions = 1, i;
     size_t bytesread = 0;
-    matvar_t **functions = NULL;
 
     for ( i = 0; i < matvar->rank; i++ )
         nfunctions *= matvar->dims[i];
@@ -13127,9 +12279,9 @@
 
     matvar->data = malloc(nfunctions*sizeof(matvar_t *));
     if ( matvar->data != NULL ) {
+        matvar_t **functions = (matvar_t**)matvar->data;;
         matvar->data_size = sizeof(matvar_t *);
         matvar->nbytes    = nfunctions*matvar->data_size;
-        functions = (matvar_t**)matvar->data;
         for ( i = 0; i < nfunctions; i++ )
             functions[i] = Mat_VarReadNextInfo(mat);
     } else {
@@ -13277,6 +12429,7 @@
         case MAT_C_FUNCTION:
         case MAT_C_OBJECT:
         case MAT_C_EMPTY:
+        case MAT_C_OPAQUE:
             break;
     }
     end = ftell((FILE*)mat->fp);
@@ -13302,12 +12455,12 @@
 WriteCellArrayField(mat_t *mat,matvar_t *matvar )
 {
     mat_uint32_t array_flags = 0x0;
-    mat_int16_t  array_name_type = MAT_T_INT8,fieldname_type = MAT_T_INT32,fieldname_data_size=4;
-    int      array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
-    int      array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;
-    mat_int8_t   pad1 = 0;
-    int      nBytes, i, nmemb = 1, nzmax = 0;
-    long     start = 0, end = 0;
+    mat_int16_t array_name_type = MAT_T_INT8;
+    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
+    int array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;
+    mat_int8_t pad1 = 0;
+    int nBytes, i, nmemb = 1, nzmax = 0;
+    long start = 0, end = 0;
 
     if ((matvar == NULL) || (mat == NULL))
         return 1;
@@ -13431,8 +12584,10 @@
         }
         case MAT_C_STRUCT:
         {
-            char  *padzero;
-            int    fieldname_size, nfields;
+            mat_int16_t fieldname_type = MAT_T_INT32;
+            mat_int16_t fieldname_data_size = 4;
+            char *padzero;
+            int fieldname_size, nfields;
             size_t maxlen = 0;
             matvar_t **fields = (matvar_t **)matvar->data;
             unsigned fieldname;
@@ -13507,6 +12662,7 @@
         case MAT_C_FUNCTION:
         case MAT_C_OBJECT:
         case MAT_C_EMPTY:
+        case MAT_C_OPAQUE:
             break;
     }
     end = ftell((FILE*)mat->fp);
@@ -13533,13 +12689,10 @@
 WriteCompressedCellArrayField(mat_t *mat,matvar_t *matvar,z_streamp z)
 {
     mat_uint32_t array_flags = 0x0;
-    mat_int16_t  array_name_type     = MAT_T_INT8;
-    mat_int16_t  fieldname_type      = MAT_T_INT32;
-    mat_int16_t  fieldname_data_size = 4;
-    int      array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
-    int      array_flags_size = 8, pad4 = 0;
-    int      nBytes, i, nmemb = 1, nzmax = 0;
-    long     start = 0;
+    mat_int16_t  array_name_type = MAT_T_INT8;
+    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
+    int array_flags_size = 8;
+    int nBytes, i, nmemb = 1, nzmax = 0;
 
     mat_uint32_t comp_buf[512];
     mat_uint32_t uncomp_buf[512] = {0,};
@@ -13549,7 +12702,6 @@
     if ( NULL == matvar || NULL == mat || NULL == z)
         return 0;
 
-    start = ftell((FILE*)mat->fp);
 
     /* Array Flags */
     array_flags = matvar->class_type & CLASS_TYPE_MASK;
@@ -13588,6 +12740,7 @@
         uncomp_buf[6+i] = dim;
     }
     if ( matvar->rank % 2 != 0 ) {
+        int pad4 = 0;
         uncomp_buf[6+i] = pad4;
         i++;
     }
@@ -13670,9 +12823,11 @@
         }
         case MAT_C_STRUCT:
         {
+            mat_int16_t fieldname_type = MAT_T_INT32;
+            mat_int16_t fieldname_data_size = 4;
             unsigned char *padzero;
-            int        fieldname_size, nfields;
-            size_t     maxlen = 0;
+            int fieldname_size, nfields;
+            size_t maxlen = 0;
             mat_int32_t array_name_type = MAT_T_INT8;
             matvar_t **fields = (matvar_t **)matvar->data;
 
@@ -13680,8 +12835,7 @@
             /* Check for a structure with no fields */
             if ( nfields < 1 ) {
                 fieldname_size = 1;
-                uncomp_buf[0] = (fieldname_data_size << 16) |
-                                 fieldname_type;
+                uncomp_buf[0] = (fieldname_data_size << 16) | fieldname_type;
                 uncomp_buf[1] = fieldname_size;
                 uncomp_buf[2] = array_name_type;
                 uncomp_buf[3] = 0;
@@ -13764,6 +12918,7 @@
         case MAT_C_FUNCTION:
         case MAT_C_OBJECT:
         case MAT_C_EMPTY:
+        case MAT_C_OPAQUE:
             break;
     }
     return byteswritten;
@@ -13781,7 +12936,6 @@
 WriteStructField(mat_t *mat,matvar_t *matvar)
 {
     mat_uint32_t array_flags = 0x0;
-    mat_int16_t  fieldname_type = MAT_T_INT32,fieldname_data_size=4;
     mat_int32_t  array_name_type = MAT_T_INT8;
     int      array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
     int      array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;
@@ -13890,8 +13044,10 @@
         }
         case MAT_C_STRUCT:
         {
-            char  *padzero;
-            int    fieldname_size, nfields = 0;
+            mat_int16_t fieldname_type = MAT_T_INT32;
+            mat_int16_t fieldname_data_size = 4;
+            char *padzero;
+            int fieldname_size, nfields = 0;
             size_t maxlen = 0;
             matvar_t **fields = (matvar_t **)matvar->data;
             unsigned fieldname;
@@ -13969,6 +13125,7 @@
         case MAT_C_FUNCTION:
         case MAT_C_OBJECT:
         case MAT_C_EMPTY:
+        case MAT_C_OPAQUE:
             break;
     }
     end = ftell((FILE*)mat->fp);
@@ -13996,13 +13153,10 @@
 WriteCompressedStructField(mat_t *mat,matvar_t *matvar,z_streamp z)
 {
     mat_uint32_t array_flags = 0x0;
-    mat_int16_t  array_name_type     = MAT_T_INT8;
-    mat_int16_t  fieldname_type      = MAT_T_INT32;
-    mat_int16_t  fieldname_data_size = 4;
-    int      array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
-    int      array_flags_size = 8, pad4 = 0;
-    int      nBytes, i, nmemb = 1, nzmax = 0;
-    long     start = 0;
+    mat_int16_t  array_name_type = MAT_T_INT8;
+    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
+    int array_flags_size = 8;
+    int nBytes, i, nmemb = 1, nzmax = 0;
 
     mat_uint32_t comp_buf[512];
     mat_uint32_t uncomp_buf[512] = {0,};
@@ -14017,7 +13171,6 @@
         byteswritten = Mat_WriteCompressedEmptyVariable5(mat, NULL, 2, dims, z);
         return byteswritten;
     }
-    start = ftell((FILE*)mat->fp);
 
     /* Array Flags */
     array_flags = matvar->class_type & CLASS_TYPE_MASK;
@@ -14056,6 +13209,7 @@
         uncomp_buf[6+i] = dim;
     }
     if ( matvar->rank % 2 != 0 ) {
+        int pad4 = 0;
         uncomp_buf[6+i] = pad4;
         i++;
     }
@@ -14138,9 +13292,11 @@
         }
         case MAT_C_STRUCT:
         {
+            mat_int16_t fieldname_type = MAT_T_INT32;
+            mat_int16_t fieldname_data_size = 4;
             unsigned char *padzero;
-            int        fieldname_size, nfields;
-            size_t     maxlen = 0;
+            int fieldname_size, nfields;
+            size_t maxlen = 0;
             mat_int32_t array_name_type = MAT_T_INT8;
             matvar_t **fields = (matvar_t **)matvar->data;
 
@@ -14148,8 +13304,7 @@
             /* Check for a structure with no fields */
             if ( nfields < 1 ) {
                 fieldname_size = 1;
-                uncomp_buf[0] = (fieldname_data_size << 16) |
-                                 fieldname_type;
+                uncomp_buf[0] = (fieldname_data_size << 16) | fieldname_type;
                 uncomp_buf[1] = fieldname_size;
                 uncomp_buf[2] = array_name_type;
                 uncomp_buf[3] = 0;
@@ -14232,6 +13387,7 @@
         case MAT_C_FUNCTION:
         case MAT_C_OBJECT:
         case MAT_C_EMPTY:
+        case MAT_C_OPAQUE:
             break;
     }
 
@@ -14326,10 +13482,9 @@
                                   size_t *dims,z_streamp z)
 {
     mat_uint32_t array_flags = 0x0;
-    mat_int16_t  array_name_type     = MAT_T_INT8;
-    int      array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
-    int      array_flags_size = 8, pad4 = 0;
-    int      nBytes, i, nmemb = 1;
+    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
+    int array_flags_size = 8;
+    int nBytes, i, nmemb = 1;
 
     mat_uint32_t comp_buf[512];
     mat_uint32_t uncomp_buf[512] = {0,};
@@ -14369,6 +13524,7 @@
         uncomp_buf[6+i] = dim;
     }
     if ( rank % 2 != 0 ) {
+        int pad4 = 0;
         uncomp_buf[6+i] = pad4;
         i++;
     }
@@ -14383,6 +13539,7 @@
     } while ( z->avail_out == 0 );
     /* Name of variable */
     if ( NULL == name ) {
+        mat_int16_t array_name_type = MAT_T_INT8;
         uncomp_buf[0] = array_name_type;
         uncomp_buf[1] = 0;
         z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);
@@ -14393,46 +13550,44 @@
             deflate(z,Z_NO_FLUSH);
             byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,(FILE*)mat->fp);
         } while ( z->avail_out == 0 );
-    } else {
-        if ( strlen(name) <= 4 ) {
-            mat_int16_t array_name_len = (mat_int16_t)strlen(name);
-            mat_int16_t array_name_type = MAT_T_INT8;
+    } else if ( strlen(name) <= 4 ) {
+        mat_int16_t array_name_len = (mat_int16_t)strlen(name);
+        mat_int16_t array_name_type = MAT_T_INT8;
 
-            memset(uncomp_buf,0,8);
-            uncomp_buf[0] = (array_name_len << 16) | array_name_type;
-            memcpy(uncomp_buf+1,name,array_name_len);
-            if ( array_name_len % 4 )
-                array_name_len += 4-(array_name_len % 4);
+        memset(uncomp_buf,0,8);
+        uncomp_buf[0] = (array_name_len << 16) | array_name_type;
+        memcpy(uncomp_buf+1,name,array_name_len);
+        if ( array_name_len % 4 )
+            array_name_len += 4-(array_name_len % 4);
 
-            z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);
-            z->avail_in = 8;
-            do {
-                z->next_out  = ZLIB_BYTE_PTR(comp_buf);
-                z->avail_out = buf_size_bytes;
-                deflate(z,Z_NO_FLUSH);
-                byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,
-                    (FILE*)mat->fp);
-            } while ( z->avail_out == 0 );
-        } else {
-            mat_int32_t array_name_len = (mat_int32_t)strlen(name);
-            mat_int32_t array_name_type = MAT_T_INT8;
+        z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);
+        z->avail_in = 8;
+        do {
+            z->next_out  = ZLIB_BYTE_PTR(comp_buf);
+            z->avail_out = buf_size_bytes;
+            deflate(z,Z_NO_FLUSH);
+            byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,
+                (FILE*)mat->fp);
+        } while ( z->avail_out == 0 );
+    } else {
+        mat_int32_t array_name_len = (mat_int32_t)strlen(name);
+        mat_int32_t array_name_type = MAT_T_INT8;
 
-            memset(uncomp_buf,0,buf_size*sizeof(*uncomp_buf));
-            uncomp_buf[0] = array_name_type;
-            uncomp_buf[1] = array_name_len;
-            memcpy(uncomp_buf+2,name,array_name_len);
-            if ( array_name_len % 8 )
-                array_name_len += 8-(array_name_len % 8);
-            z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);
-            z->avail_in = 8+array_name_len;
-            do {
-                z->next_out  = ZLIB_BYTE_PTR(comp_buf);
-                z->avail_out = buf_size_bytes;
-                deflate(z,Z_NO_FLUSH);
-                byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,
-                    (FILE*)mat->fp);
-            } while ( z->avail_out == 0 );
-        }
+        memset(uncomp_buf,0,buf_size*sizeof(*uncomp_buf));
+        uncomp_buf[0] = array_name_type;
+        uncomp_buf[1] = array_name_len;
+        memcpy(uncomp_buf+2,name,array_name_len);
+        if ( array_name_len % 8 )
+            array_name_len += 8-(array_name_len % 8);
+        z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);
+        z->avail_in = 8+array_name_len;
+        do {
+            z->next_out  = ZLIB_BYTE_PTR(comp_buf);
+            z->avail_out = buf_size_bytes;
+            deflate(z,Z_NO_FLUSH);
+            byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,
+                (FILE*)mat->fp);
+        } while ( z->avail_out == 0 );
     }
 
     byteswritten += WriteCompressedData(mat,z,NULL,0,MAT_T_DOUBLE);
@@ -14663,22 +13818,11 @@
                 mat_complex_split_t *complex_data;
 
                 matvar->nbytes = len*matvar->data_size;
-                complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
+                complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
-                    Mat_Critical("Failed to allocate %d bytes",sizeof(*complex_data));
+                    Mat_Critical("Memory allocation failure");
                     break;
                 }
-                complex_data->Re = malloc(matvar->nbytes);
-                complex_data->Im = malloc(matvar->nbytes);
-                if ( NULL == complex_data->Re || NULL == complex_data->Im ) {
-                    if ( NULL != complex_data->Re )
-                        free(complex_data->Re);
-                    if ( NULL != complex_data->Im )
-                        free(complex_data->Im);
-                    free(complex_data);
-                    Mat_Critical("Failed to allocate %d bytes",2*matvar->nbytes);
-                    break;
-                }
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Re,len);
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Im,len);
                 matvar->data = complex_data;
@@ -14685,7 +13829,7 @@
             } else {
                 matvar->nbytes = len*matvar->data_size;
                 matvar->data   = malloc(matvar->nbytes);
-                if ( !matvar->data ) {
+                if ( NULL == matvar->data ) {
                     Mat_Critical("Failed to allocate %d bytes",matvar->nbytes);
                     break;
                 }
@@ -14700,22 +13844,11 @@
                 mat_complex_split_t *complex_data;
 
                 matvar->nbytes = len*matvar->data_size;
-                complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
+                complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
-                    Mat_Critical("Failed to allocate %d bytes",sizeof(*complex_data));
+                    Mat_Critical("Memory allocation failure");
                     break;
                 }
-                complex_data->Re = malloc(matvar->nbytes);
-                complex_data->Im = malloc(matvar->nbytes);
-                if ( NULL == complex_data->Re || NULL == complex_data->Im ) {
-                    if ( NULL != complex_data->Re )
-                        free(complex_data->Re);
-                    if ( NULL != complex_data->Im )
-                        free(complex_data->Im);
-                    free(complex_data);
-                    Mat_Critical("Failed to allocate %d bytes",2*matvar->nbytes);
-                    break;
-                }
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Re,len);
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Im,len);
                 matvar->data = complex_data;
@@ -14722,7 +13855,7 @@
             } else {
                 matvar->nbytes = len*matvar->data_size;
                 matvar->data   = malloc(matvar->nbytes);
-                if ( !matvar->data ) {
+                if ( NULL == matvar->data ) {
                     Mat_Critical("Failed to allocate %d bytes",matvar->nbytes);
                     break;
                 }
@@ -14738,22 +13871,11 @@
                 mat_complex_split_t *complex_data;
 
                 matvar->nbytes = len*matvar->data_size;
-                complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
+                complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
-                    Mat_Critical("Failed to allocate %d bytes",sizeof(*complex_data));
+                    Mat_Critical("Memory allocation failure");
                     break;
                 }
-                complex_data->Re = malloc(matvar->nbytes);
-                complex_data->Im = malloc(matvar->nbytes);
-                if ( NULL == complex_data->Re || NULL == complex_data->Im ) {
-                    if ( NULL != complex_data->Re )
-                        free(complex_data->Re);
-                    if ( NULL != complex_data->Im )
-                        free(complex_data->Im);
-                    free(complex_data);
-                    Mat_Critical("Failed to allocate %d bytes",2*matvar->nbytes);
-                    break;
-                }
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Re,len);
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Im,len);
                 matvar->data = complex_data;
@@ -14760,7 +13882,7 @@
             } else {
                 matvar->nbytes = len*matvar->data_size;
                 matvar->data   = malloc(matvar->nbytes);
-                if ( !matvar->data ) {
+                if ( NULL == matvar->data ) {
                     Mat_Critical("Failed to allocate %d bytes",matvar->nbytes);
                     break;
                 }
@@ -14777,22 +13899,11 @@
                 mat_complex_split_t *complex_data;
 
                 matvar->nbytes = len*matvar->data_size;
-                complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
+                complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
-                    Mat_Critical("Failed to allocate %d bytes",sizeof(*complex_data));
+                    Mat_Critical("Memory allocation failure");
                     break;
                 }
-                complex_data->Re = malloc(matvar->nbytes);
-                complex_data->Im = malloc(matvar->nbytes);
-                if ( NULL == complex_data->Re || NULL == complex_data->Im ) {
-                    if ( NULL != complex_data->Re )
-                        free(complex_data->Re);
-                    if ( NULL != complex_data->Im )
-                        free(complex_data->Im);
-                    free(complex_data);
-                    Mat_Critical("Failed to allocate %d bytes",2*matvar->nbytes);
-                    break;
-                }
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Re,len);
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Im,len);
                 matvar->data = complex_data;
@@ -14799,7 +13910,7 @@
             } else {
                 matvar->nbytes = len*matvar->data_size;
                 matvar->data   = malloc(matvar->nbytes);
-                if ( !matvar->data ) {
+                if ( NULL == matvar->data ) {
                     Mat_Critical("Failed to allocate %d bytes",matvar->nbytes);
                     break;
                 }
@@ -14815,22 +13926,11 @@
                 mat_complex_split_t *complex_data;
 
                 matvar->nbytes = len*matvar->data_size;
-                complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
+                complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
-                    Mat_Critical("Failed to allocate %d bytes",sizeof(*complex_data));
+                    Mat_Critical("Memory allocation failure");
                     break;
                 }
-                complex_data->Re = malloc(matvar->nbytes);
-                complex_data->Im = malloc(matvar->nbytes);
-                if ( NULL == complex_data->Re || NULL == complex_data->Im ) {
-                    if ( NULL != complex_data->Re )
-                        free(complex_data->Re);
-                    if ( NULL != complex_data->Im )
-                        free(complex_data->Im);
-                    free(complex_data);
-                    Mat_Critical("Failed to allocate %d bytes",2*matvar->nbytes);
-                    break;
-                }
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Re,len);
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Im,len);
                 matvar->data = complex_data;
@@ -14837,7 +13937,7 @@
             } else {
                 matvar->nbytes = len*matvar->data_size;
                 matvar->data   = malloc(matvar->nbytes);
-                if ( !matvar->data ) {
+                if ( NULL == matvar->data ) {
                     Mat_Critical("Failed to allocate %d bytes",matvar->nbytes);
                     break;
                 }
@@ -14852,22 +13952,11 @@
                 mat_complex_split_t *complex_data;
 
                 matvar->nbytes = len*matvar->data_size;
-                complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
+                complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
-                    Mat_Critical("Failed to allocate %d bytes",sizeof(*complex_data));
+                    Mat_Critical("Memory allocation failure");
                     break;
                 }
-                complex_data->Re = malloc(matvar->nbytes);
-                complex_data->Im = malloc(matvar->nbytes);
-                if ( NULL == complex_data->Re || NULL == complex_data->Im ) {
-                    if ( NULL != complex_data->Re )
-                        free(complex_data->Re);
-                    if ( NULL != complex_data->Im )
-                        free(complex_data->Im);
-                    free(complex_data);
-                    Mat_Critical("Failed to allocate %d bytes",2*matvar->nbytes);
-                    break;
-                }
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Re,len);
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Im,len);
                 matvar->data = complex_data;
@@ -14874,7 +13963,7 @@
             } else {
                 matvar->nbytes = len*matvar->data_size;
                 matvar->data   = malloc(matvar->nbytes);
-                if ( !matvar->data ) {
+                if ( NULL == matvar->data ) {
                     Mat_Critical("Failed to allocate %d bytes",matvar->nbytes);
                     break;
                 }
@@ -14889,22 +13978,11 @@
                 mat_complex_split_t *complex_data;
 
                 matvar->nbytes = len*matvar->data_size;
-                complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
+                complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
-                    Mat_Critical("Failed to allocate %d bytes",sizeof(*complex_data));
+                    Mat_Critical("Memory allocation failure");
                     break;
                 }
-                complex_data->Re = malloc(matvar->nbytes);
-                complex_data->Im = malloc(matvar->nbytes);
-                if ( NULL == complex_data->Re || NULL == complex_data->Im ) {
-                    if ( NULL != complex_data->Re )
-                        free(complex_data->Re);
-                    if ( NULL != complex_data->Im )
-                        free(complex_data->Im);
-                    free(complex_data);
-                    Mat_Critical("Failed to allocate %d bytes",2*matvar->nbytes);
-                    break;
-                }
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Re,len);
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Im,len);
                 matvar->data = complex_data;
@@ -14911,7 +13989,7 @@
             } else {
                 matvar->nbytes = len*matvar->data_size;
                 matvar->data   = malloc(matvar->nbytes);
-                if ( !matvar->data ) {
+                if ( NULL == matvar->data ) {
                     Mat_Critical("Failed to allocate %d bytes",matvar->nbytes);
                     break;
                 }
@@ -14926,22 +14004,11 @@
                 mat_complex_split_t *complex_data;
 
                 matvar->nbytes = len*matvar->data_size;
-                complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
+                complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
-                    Mat_Critical("Failed to allocate %d bytes",sizeof(*complex_data));
+                    Mat_Critical("Memory allocation failure");
                     break;
                 }
-                complex_data->Re = malloc(matvar->nbytes);
-                complex_data->Im = malloc(matvar->nbytes);
-                if ( NULL == complex_data->Re || NULL == complex_data->Im ) {
-                    if ( NULL != complex_data->Re )
-                        free(complex_data->Re);
-                    if ( NULL != complex_data->Im )
-                        free(complex_data->Im);
-                    free(complex_data);
-                    Mat_Critical("Failed to allocate %d bytes",2*matvar->nbytes);
-                    break;
-                }
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Re,len);
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Im,len);
                 matvar->data = complex_data;
@@ -14948,7 +14015,7 @@
             } else {
                 matvar->nbytes = len*matvar->data_size;
                 matvar->data   = malloc(matvar->nbytes);
-                if ( !matvar->data ) {
+                if ( NULL == matvar->data ) {
                     Mat_Critical("Failed to allocate %d bytes",matvar->nbytes);
                     break;
                 }
@@ -14963,22 +14030,11 @@
                 mat_complex_split_t *complex_data;
 
                 matvar->nbytes = len*matvar->data_size;
-                complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
+                complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
-                    Mat_Critical("Failed to allocate %d bytes",sizeof(*complex_data));
+                    Mat_Critical("Memory allocation failure");
                     break;
                 }
-                complex_data->Re = malloc(matvar->nbytes);
-                complex_data->Im = malloc(matvar->nbytes);
-                if ( NULL == complex_data->Re || NULL == complex_data->Im ) {
-                    if ( NULL != complex_data->Re )
-                        free(complex_data->Re);
-                    if ( NULL != complex_data->Im )
-                        free(complex_data->Im);
-                    free(complex_data);
-                    Mat_Critical("Failed to allocate %d bytes",2*matvar->nbytes);
-                    break;
-                }
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Re,len);
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Im,len);
                 matvar->data = complex_data;
@@ -14985,7 +14041,7 @@
             } else {
                 matvar->nbytes = len*matvar->data_size;
                 matvar->data   = malloc(matvar->nbytes);
-                if ( !matvar->data ) {
+                if ( NULL == matvar->data ) {
                     Mat_Critical("Failed to allocate %d bytes",matvar->nbytes);
                     break;
                 }
@@ -15000,22 +14056,11 @@
                 mat_complex_split_t *complex_data;
 
                 matvar->nbytes = len*matvar->data_size;
-                complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
+                complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
-                    Mat_Critical("Failed to allocate %d bytes",sizeof(*complex_data));
+                    Mat_Critical("Memory allocation failure");
                     break;
                 }
-                complex_data->Re = malloc(matvar->nbytes);
-                complex_data->Im = malloc(matvar->nbytes);
-                if ( NULL == complex_data->Re || NULL == complex_data->Im ) {
-                    if ( NULL != complex_data->Re )
-                        free(complex_data->Re);
-                    if ( NULL != complex_data->Im )
-                        free(complex_data->Im);
-                    free(complex_data);
-                    Mat_Critical("Failed to allocate %d bytes",2*matvar->nbytes);
-                    break;
-                }
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Re,len);
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Im,len);
                 matvar->data = complex_data;
@@ -15022,7 +14067,7 @@
             } else {
                 matvar->nbytes = len*matvar->data_size;
                 matvar->data   = malloc(matvar->nbytes);
-                if ( !matvar->data ) {
+                if ( NULL == matvar->data ) {
                     Mat_Critical("Failed to allocate %d bytes",matvar->nbytes);
                     break;
                 }
@@ -15067,6 +14112,8 @@
                     nBytes = tag[1];
                 }
             }
+            /* FIXME: */
+            matvar->data_type = MAT_T_UINT8;
             if ( nBytes == 0 ) {
                 matvar->nbytes = 0;
                 matvar->data   = calloc(0,1);
@@ -15073,22 +14120,20 @@
                 break;
             }
             matvar->data_size = sizeof(char);
-            /* FIXME: */
-            matvar->data_type = MAT_T_UINT8;
             matvar->nbytes = len*matvar->data_size;
             matvar->data   = calloc(matvar->nbytes+1,1);
-            if ( !matvar->data ) {
+            if ( NULL == matvar->data ) {
                 Mat_Critical("Failed to allocate %d bytes",matvar->nbytes);
                 break;
             }
             if ( matvar->compression == MAT_COMPRESSION_NONE) {
                 nBytes = ReadCharData(mat,(char*)matvar->data,packed_type,len);
-                    /*
-                     * If the data was in the tag we started on a 4-byte
-                     * boundary so add 4 to make it an 8-byte
-                     */
-                    if ( data_in_tag )
-                        nBytes+=4;
+                /*
+                 * If the data was in the tag we started on a 4-byte
+                 * boundary so add 4 to make it an 8-byte
+                 */
+                if ( data_in_tag )
+                    nBytes+=4;
                 if ( (nBytes % 8) != 0 )
                     (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if defined(HAVE_ZLIB)
@@ -15095,12 +14140,12 @@
             } else if ( matvar->compression == MAT_COMPRESSION_ZLIB) {
                 nBytes = ReadCompressedCharData(mat,matvar->internal->z,
                              (char*)matvar->data,packed_type,len);
-                    /*
-                     * If the data was in the tag we started on a 4-byte
-                     * boundary so add 4 to make it an 8-byte
-                     */
-                    if ( data_in_tag )
-                        nBytes+=4;
+                /*
+                 * If the data was in the tag we started on a 4-byte
+                 * boundary so add 4 to make it an 8-byte
+                 */
+                if ( data_in_tag )
+                    nBytes+=4;
                 if ( (nBytes % 8) != 0 )
                     InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
 #endif
@@ -15117,8 +14162,10 @@
             nfields = matvar->internal->num_fields;
             fields = (matvar_t **)matvar->data;
             for ( i = 0; i < len*nfields; i++ ) {
-                fields[i]->internal->fp = mat;
-                Read5(mat,fields[i]);
+                if ( NULL != fields[i] ) {
+                    fields[i]->internal->fp = mat;
+                    Read5(mat,fields[i]);
+                }
             }
             break;
         }
@@ -15126,14 +14173,16 @@
         {
             matvar_t **cells;
 
-            if ( !matvar->data ) {
+            if ( NULL == matvar->data ) {
                 Mat_Critical("Data is NULL for Cell Array %s",matvar->name);
                 break;
             }
             cells = (matvar_t **)matvar->data;
             for ( i = 0; i < len; i++ ) {
-                cells[i]->internal->fp = mat;
-                Read5(mat,cells[i]);
+                if ( NULL != cells[i] ) {
+                    cells[i]->internal->fp = mat;
+                    Read5(mat,cells[i]);
+                }
             }
             /* FIXME: */
             matvar->data_type = MAT_T_CELL;
@@ -15314,7 +14363,7 @@
             }
             if ( matvar->isLogical && packed_type == MAT_T_DOUBLE ) {
                 /* For some reason, MAT says the data type is a double,
-                 * but it appears to be written as 8-bit integer.
+                 * but it appears to be written as 8-bit unsigned integer.
                  */
                 packed_type = MAT_T_UINT8;
             }
@@ -15330,27 +14379,12 @@
                 data->ndata = N / s_type;
             }
             if ( matvar->isComplex ) {
-                mat_complex_split_t *complex_data;
-
-                complex_data = (mat_complex_split_t*)malloc(sizeof(*complex_data));
+                mat_complex_split_t *complex_data =
+                    ComplexMalloc(data->ndata*Mat_SizeOf(matvar->data_type));
                 if ( NULL == complex_data ) {
-                    Mat_Critical("Failed to allocate %d bytes",sizeof(*complex_data));
+                    Mat_Critical("Memory allocation failure");
                     break;
                 }
-                complex_data->Re = malloc(data->ndata*
-                                          Mat_SizeOf(matvar->data_type));
-                complex_data->Im = malloc(data->ndata*
-                                          Mat_SizeOf(matvar->data_type));
-                if ( NULL == complex_data->Re || NULL == complex_data->Im ) {
-                    if ( NULL != complex_data->Re )
-                        free(complex_data->Re);
-                    if ( NULL != complex_data->Im )
-                        free(complex_data->Im);
-                    free(complex_data);
-                    Mat_Critical("Failed to allocate %d bytes",
-                                 data->ndata* Mat_SizeOf(matvar->data_type));
-                    break;
-                }
                 if ( matvar->compression == MAT_COMPRESSION_NONE) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
@@ -15806,8 +14840,10 @@
     do { \
         ptr_in += start[1]*dims[0] + start[0]; \
         for ( i = 0; i < edge[1]; i++ ) { \
-            for ( j = 0; j < edge[0]; j++ ) \
-                memcpy(ptr++, ptr_in+j*stride[0], data_size); \
+            for ( j = 0; j < edge[0]; j++ ) { \
+                *ptr = *(ptr_in+j*stride[0]); \
+                ptr++; \
+            } \
             ptr_in += stride[1]*dims[0]; \
         } \
     } while (0)
@@ -15831,11 +14867,14 @@
         ptr_in += I; \
         if ( stride[0] == 1 ) { \
             for ( i = 0; i < N; i+=edge[0] ) { \
+                int k; \
                 if ( start[0] ) { \
                     ptr_in += start[0]; \
                     I += start[0]; \
                 } \
-                memcpy(ptr+i, ptr_in, edge[0]*data_size); \
+                for ( k = 0; k < edge[0]; k++ ) { \
+                    *(ptr+i+k) = *(ptr_in+k); \
+                } \
                 I += dims[0]-start[0]; \
                 ptr_in += dims[0]-start[0]; \
                 GET_DATA_SLABN_RANK_LOOP; \
@@ -15847,7 +14886,7 @@
                     I += start[0]; \
                 } \
                 for ( j = 0; j < edge[0]; j++ ) { \
-                    memcpy(ptr+i+j, ptr_in, data_size); \
+                    *(ptr+i+j) = *ptr_in; \
                     ptr_in += stride[0]; \
                     I += stride[0]; \
                 } \
@@ -15865,6 +14904,18 @@
 {
     int err = 0;
     int data_size = Mat_SizeOf(data_type);
+    int same_type = 0;
+    if (( class_type == MAT_C_DOUBLE && data_type == MAT_T_DOUBLE ) ||
+        ( class_type == MAT_C_SINGLE && data_type == MAT_T_SINGLE ) ||
+        ( class_type == MAT_C_INT16 && data_type == MAT_T_INT16 ) ||
+        ( class_type == MAT_C_INT32 && data_type == MAT_T_INT32 ) ||
+        ( class_type == MAT_C_INT64 && data_type == MAT_T_INT64 ) ||
+        ( class_type == MAT_C_INT8 && data_type == MAT_T_INT8 ) ||
+        ( class_type == MAT_C_UINT16 && data_type == MAT_T_UINT16 ) ||
+        ( class_type == MAT_C_UINT32 && data_type == MAT_T_UINT32 ) ||
+        ( class_type == MAT_C_UINT64 && data_type == MAT_T_UINT64 ) ||
+        ( class_type == MAT_C_UINT8 && data_type == MAT_T_UINT8 ))
+        same_type = 1;
 
     if ( rank == 2 ) {
         if ( stride[0]*(edge[0]-1)+start[0]+1 > dims[0] )
@@ -15871,8 +14922,8 @@
             err = 1;
         else if ( stride[1]*(edge[1]-1)+start[1]+1 > dims[1] )
             err = 1;
-        else if ( (stride[0] == 1 && edge[0] == dims[0]) &&
-                  (stride[1] == 1) )
+        else if ( ( stride[0] == 1 && edge[0] == dims[0] ) &&
+                  ( stride[1] == 1 ) && ( same_type == 1 ) )
             memcpy(data_out, data_in, nbytes);
         else {
             int i, j;
@@ -15881,15 +14932,149 @@
                 case MAT_C_DOUBLE:
                 {
                     double *ptr = (double *)data_out;
-                    double *ptr_in = (double *)data_in;
-                    GET_DATA_SLAB2;
+                    switch ( data_type ) {
+                        case MAT_T_DOUBLE:
+                        {
+                            double *ptr_in = (double *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_SINGLE:
+                        {
+                            float *ptr_in = (float *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#ifdef HAVE_MATIO_INT64_T
+                        case MAT_T_INT64:
+                        {
+                            mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                        case MAT_T_UINT64:
+                        {
+                            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_UINT64_T */
+                        case MAT_T_INT32:
+                        {
+                            mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT32:
+                        {
+                            mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT16:
+                        {
+                            mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT16:
+                        {
+                            mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT8:
+                        {
+                            mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT8:
+                        {
+                            mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        default:
+                            err = 1;
+                            break;
+                    }
                     break;
                 }
                 case MAT_C_SINGLE:
                 {
                     float *ptr = (float *)data_out;
-                    float *ptr_in = (float *)data_in;
-                    GET_DATA_SLAB2;
+                    switch ( data_type ) {
+                        case MAT_T_DOUBLE:
+                        {
+                            double *ptr_in = (double *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_SINGLE:
+                        {
+                            float *ptr_in = (float *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#ifdef HAVE_MATIO_INT64_T
+                        case MAT_T_INT64:
+                        {
+                            mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                        case MAT_T_UINT64:
+                        {
+                            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_UINT64_T */
+                        case MAT_T_INT32:
+                        {
+                            mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT32:
+                        {
+                            mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT16:
+                        {
+                            mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT16:
+                        {
+                            mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT8:
+                        {
+                            mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT8:
+                        {
+                            mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        default:
+                            err = 1;
+                            break;
+                    }
                     break;
                 }
 #ifdef HAVE_MATIO_INT64_T
@@ -15896,8 +15081,75 @@
                 case MAT_C_INT64:
                 {
                     mat_int64_t *ptr = (mat_int64_t *)data_out;
-                    mat_int64_t *ptr_in = (mat_int64_t *)data_in;
-                    GET_DATA_SLAB2;
+                    switch ( data_type ) {
+                        case MAT_T_DOUBLE:
+                        {
+                            double *ptr_in = (double *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_SINGLE:
+                        {
+                            float *ptr_in = (float *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#ifdef HAVE_MATIO_INT64_T
+                        case MAT_T_INT64:
+                        {
+                            mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                        case MAT_T_UINT64:
+                        {
+                            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_UINT64_T */
+                        case MAT_T_INT32:
+                        {
+                            mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT32:
+                        {
+                            mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT16:
+                        {
+                            mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT16:
+                        {
+                            mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT8:
+                        {
+                            mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT8:
+                        {
+                            mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        default:
+                            err = 1;
+                            break;
+                    }
                     break;
                 }
 #endif /* HAVE_MATIO_INT64_T */
@@ -15905,8 +15157,75 @@
                 case MAT_C_UINT64:
                 {
                     mat_uint64_t *ptr = (mat_uint64_t *)data_out;
-                    mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
-                    GET_DATA_SLAB2;
+                    switch ( data_type ) {
+                        case MAT_T_DOUBLE:
+                        {
+                            double *ptr_in = (double *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_SINGLE:
+                        {
+                            float *ptr_in = (float *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#ifdef HAVE_MATIO_INT64_T
+                        case MAT_T_INT64:
+                        {
+                            mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                        case MAT_T_UINT64:
+                        {
+                            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_UINT64_T */
+                        case MAT_T_INT32:
+                        {
+                            mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT32:
+                        {
+                            mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT16:
+                        {
+                            mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT16:
+                        {
+                            mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT8:
+                        {
+                            mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT8:
+                        {
+                            mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        default:
+                            err = 1;
+                            break;
+                    }
                     break;
                 }
 #endif /* HAVE_MATIO_UINT64_T */
@@ -15913,43 +15232,445 @@
                 case MAT_C_INT32:
                 {
                     mat_int32_t *ptr = (mat_int32_t *)data_out;
-                    mat_int32_t *ptr_in = (mat_int32_t *)data_in;
-                    GET_DATA_SLAB2;
+                    switch ( data_type ) {
+                        case MAT_T_DOUBLE:
+                        {
+                            double *ptr_in = (double *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_SINGLE:
+                        {
+                            float *ptr_in = (float *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#ifdef HAVE_MATIO_INT64_T
+                        case MAT_T_INT64:
+                        {
+                            mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                        case MAT_T_UINT64:
+                        {
+                            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_UINT64_T */
+                        case MAT_T_INT32:
+                        {
+                            mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT32:
+                        {
+                            mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT16:
+                        {
+                            mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT16:
+                        {
+                            mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT8:
+                        {
+                            mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT8:
+                        {
+                            mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        default:
+                            err = 1;
+                            break;
+                    }
                     break;
                 }
                 case MAT_C_UINT32:
                 {
                     mat_uint32_t *ptr = (mat_uint32_t *)data_out;
-                    mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
-                    GET_DATA_SLAB2;
+                    switch ( data_type ) {
+                        case MAT_T_DOUBLE:
+                        {
+                            double *ptr_in = (double *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_SINGLE:
+                        {
+                            float *ptr_in = (float *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#ifdef HAVE_MATIO_INT64_T
+                        case MAT_T_INT64:
+                        {
+                            mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                        case MAT_T_UINT64:
+                        {
+                            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_UINT64_T */
+                        case MAT_T_INT32:
+                        {
+                            mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT32:
+                        {
+                            mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT16:
+                        {
+                            mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT16:
+                        {
+                            mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT8:
+                        {
+                            mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT8:
+                        {
+                            mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        default:
+                            err = 1;
+                            break;
+                    }
                     break;
                 }
                 case MAT_C_INT16:
                 {
                     mat_int16_t *ptr = (mat_int16_t *)data_out;
-                    mat_int16_t *ptr_in = (mat_int16_t *)data_in;
-                    GET_DATA_SLAB2;
+                    switch ( data_type ) {
+                        case MAT_T_DOUBLE:
+                        {
+                            double *ptr_in = (double *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_SINGLE:
+                        {
+                            float *ptr_in = (float *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#ifdef HAVE_MATIO_INT64_T
+                        case MAT_T_INT64:
+                        {
+                            mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                        case MAT_T_UINT64:
+                        {
+                            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_UINT64_T */
+                        case MAT_T_INT32:
+                        {
+                            mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT32:
+                        {
+                            mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT16:
+                        {
+                            mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT16:
+                        {
+                            mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT8:
+                        {
+                            mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT8:
+                        {
+                            mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        default:
+                            err = 1;
+                            break;
+                    }
                     break;
                 }
                 case MAT_C_UINT16:
                 {
                     mat_uint16_t *ptr = (mat_uint16_t *)data_out;
-                    mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
-                    GET_DATA_SLAB2;
+                    switch ( data_type ) {
+                        case MAT_T_DOUBLE:
+                        {
+                            double *ptr_in = (double *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_SINGLE:
+                        {
+                            float *ptr_in = (float *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#ifdef HAVE_MATIO_INT64_T
+                        case MAT_T_INT64:
+                        {
+                            mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                        case MAT_T_UINT64:
+                        {
+                            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_UINT64_T */
+                        case MAT_T_INT32:
+                        {
+                            mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT32:
+                        {
+                            mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT16:
+                        {
+                            mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT16:
+                        {
+                            mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT8:
+                        {
+                            mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT8:
+                        {
+                            mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        default:
+                            err = 1;
+                            break;
+                    }
                     break;
                 }
                 case MAT_C_INT8:
                 {
                     mat_int8_t *ptr = (mat_int8_t *)data_out;
-                    mat_int8_t *ptr_in = (mat_int8_t *)data_in;
-                    GET_DATA_SLAB2;
+                    switch ( data_type ) {
+                        case MAT_T_DOUBLE:
+                        {
+                            double *ptr_in = (double *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_SINGLE:
+                        {
+                            float *ptr_in = (float *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#ifdef HAVE_MATIO_INT64_T
+                        case MAT_T_INT64:
+                        {
+                            mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                        case MAT_T_UINT64:
+                        {
+                            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_UINT64_T */
+                        case MAT_T_INT32:
+                        {
+                            mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT32:
+                        {
+                            mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT16:
+                        {
+                            mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT16:
+                        {
+                            mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT8:
+                        {
+                            mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT8:
+                        {
+                            mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        default:
+                            err = 1;
+                            break;
+                    }
                     break;
                 }
                 case MAT_C_UINT8:
                 {
                     mat_uint8_t *ptr = (mat_uint8_t *)data_out;
-                    mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
-                    GET_DATA_SLAB2;
+                    switch ( data_type ) {
+                        case MAT_T_DOUBLE:
+                        {
+                            double *ptr_in = (double *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_SINGLE:
+                        {
+                            float *ptr_in = (float *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#ifdef HAVE_MATIO_INT64_T
+                        case MAT_T_INT64:
+                        {
+                            mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                        case MAT_T_UINT64:
+                        {
+                            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+#endif /* HAVE_MATIO_UINT64_T */
+                        case MAT_T_INT32:
+                        {
+                            mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT32:
+                        {
+                            mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT16:
+                        {
+                            mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT16:
+                        {
+                            mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_INT8:
+                        {
+                            mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        case MAT_T_UINT8:
+                        {
+                            mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                            GET_DATA_SLAB2;
+                            break;
+                        }
+                        default:
+                            err = 1;
+                            break;
+                    }
                     break;
                 }
                 default:
@@ -15965,15 +15686,149 @@
             case MAT_C_DOUBLE:
             {
                 double *ptr = (double *)data_out;
-                double *ptr_in = (double *)data_in;
-                GET_DATA_SLABN;
+                switch ( data_type ) {
+                    case MAT_T_DOUBLE:
+                    {
+                        double *ptr_in = (double *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_SINGLE:
+                    {
+                        float *ptr_in = (float *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#ifdef HAVE_MATIO_INT64_T
+                    case MAT_T_INT64:
+                    {
+                        mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                    case MAT_T_UINT64:
+                    {
+                        mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_UINT64_T */
+                    case MAT_T_INT32:
+                    {
+                        mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT32:
+                    {
+                        mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT16:
+                    {
+                        mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT16:
+                    {
+                        mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT8:
+                    {
+                        mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT8:
+                    {
+                        mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    default:
+                        err = 1;
+                        break;
+                }
                 break;
             }
             case MAT_C_SINGLE:
             {
                 float *ptr = (float *)data_out;
-                float *ptr_in = (float *)data_in;
-                GET_DATA_SLABN;
+                switch ( data_type ) {
+                    case MAT_T_DOUBLE:
+                    {
+                        double *ptr_in = (double *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_SINGLE:
+                    {
+                        float *ptr_in = (float *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#ifdef HAVE_MATIO_INT64_T
+                    case MAT_T_INT64:
+                    {
+                        mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                    case MAT_T_UINT64:
+                    {
+                        mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_UINT64_T */
+                    case MAT_T_INT32:
+                    {
+                        mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT32:
+                    {
+                        mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT16:
+                    {
+                        mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT16:
+                    {
+                        mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT8:
+                    {
+                        mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT8:
+                    {
+                        mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    default:
+                        err = 1;
+                        break;
+                }
                 break;
             }
 #ifdef HAVE_MATIO_INT64_T
@@ -15980,8 +15835,75 @@
             case MAT_C_INT64:
             {
                 mat_int64_t *ptr = (mat_int64_t *)data_out;
-                mat_int64_t *ptr_in = (mat_int64_t *)data_in;
-                GET_DATA_SLABN;
+                switch ( data_type ) {
+                    case MAT_T_DOUBLE:
+                    {
+                        double *ptr_in = (double *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_SINGLE:
+                    {
+                        float *ptr_in = (float *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#ifdef HAVE_MATIO_INT64_T
+                    case MAT_T_INT64:
+                    {
+                        mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                    case MAT_T_UINT64:
+                    {
+                        mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_UINT64_T */
+                    case MAT_T_INT32:
+                    {
+                        mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT32:
+                    {
+                        mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT16:
+                    {
+                        mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT16:
+                    {
+                        mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT8:
+                    {
+                        mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT8:
+                    {
+                        mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    default:
+                        err = 1;
+                        break;
+                }
                 break;
             }
 #endif /* HAVE_MATIO_INT64_T */
@@ -15989,8 +15911,75 @@
             case MAT_C_UINT64:
             {
                 mat_uint64_t *ptr = (mat_uint64_t *)data_out;
-                mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
-                GET_DATA_SLABN;
+                switch ( data_type ) {
+                    case MAT_T_DOUBLE:
+                    {
+                        double *ptr_in = (double *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_SINGLE:
+                    {
+                        float *ptr_in = (float *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#ifdef HAVE_MATIO_INT64_T
+                    case MAT_T_INT64:
+                    {
+                        mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                    case MAT_T_UINT64:
+                    {
+                        mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_UINT64_T */
+                    case MAT_T_INT32:
+                    {
+                        mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT32:
+                    {
+                        mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT16:
+                    {
+                        mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT16:
+                    {
+                        mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT8:
+                    {
+                        mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT8:
+                    {
+                        mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    default:
+                        err = 1;
+                        break;
+                }
                 break;
             }
 #endif /* HAVE_MATIO_UINT64_T */
@@ -15997,43 +15986,445 @@
             case MAT_C_INT32:
             {
                 mat_int32_t *ptr = (mat_int32_t *)data_out;
-                mat_int32_t *ptr_in = (mat_int32_t *)data_in;
-                GET_DATA_SLABN;
+                switch ( data_type ) {
+                    case MAT_T_DOUBLE:
+                    {
+                        double *ptr_in = (double *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_SINGLE:
+                    {
+                        float *ptr_in = (float *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#ifdef HAVE_MATIO_INT64_T
+                    case MAT_T_INT64:
+                    {
+                        mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                    case MAT_T_UINT64:
+                    {
+                        mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_UINT64_T */
+                    case MAT_T_INT32:
+                    {
+                        mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT32:
+                    {
+                        mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT16:
+                    {
+                        mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT16:
+                    {
+                        mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT8:
+                    {
+                        mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT8:
+                    {
+                        mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    default:
+                        err = 1;
+                        break;
+                }
                 break;
             }
             case MAT_C_UINT32:
             {
                 mat_uint32_t *ptr = (mat_uint32_t *)data_out;
-                mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
-                GET_DATA_SLABN;
+                switch ( data_type ) {
+                    case MAT_T_DOUBLE:
+                    {
+                        double *ptr_in = (double *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_SINGLE:
+                    {
+                        float *ptr_in = (float *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#ifdef HAVE_MATIO_INT64_T
+                    case MAT_T_INT64:
+                    {
+                        mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                    case MAT_T_UINT64:
+                    {
+                        mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_UINT64_T */
+                    case MAT_T_INT32:
+                    {
+                        mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT32:
+                    {
+                        mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT16:
+                    {
+                        mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT16:
+                    {
+                        mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT8:
+                    {
+                        mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT8:
+                    {
+                        mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    default:
+                        err = 1;
+                        break;
+                }
                 break;
             }
             case MAT_C_INT16:
             {
                 mat_int16_t *ptr = (mat_int16_t *)data_out;
-                mat_int16_t *ptr_in = (mat_int16_t *)data_in;
-                GET_DATA_SLABN;
+                switch ( data_type ) {
+                    case MAT_T_DOUBLE:
+                    {
+                        double *ptr_in = (double *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_SINGLE:
+                    {
+                        float *ptr_in = (float *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#ifdef HAVE_MATIO_INT64_T
+                    case MAT_T_INT64:
+                    {
+                        mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                    case MAT_T_UINT64:
+                    {
+                        mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_UINT64_T */
+                    case MAT_T_INT32:
+                    {
+                        mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT32:
+                    {
+                        mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT16:
+                    {
+                        mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT16:
+                    {
+                        mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT8:
+                    {
+                        mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT8:
+                    {
+                        mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    default:
+                        err = 1;
+                        break;
+                }
                 break;
             }
             case MAT_C_UINT16:
             {
                 mat_uint16_t *ptr = (mat_uint16_t *)data_out;
-                mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
-                GET_DATA_SLABN;
+                switch ( data_type ) {
+                    case MAT_T_DOUBLE:
+                    {
+                        double *ptr_in = (double *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_SINGLE:
+                    {
+                        float *ptr_in = (float *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#ifdef HAVE_MATIO_INT64_T
+                    case MAT_T_INT64:
+                    {
+                        mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                    case MAT_T_UINT64:
+                    {
+                        mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_UINT64_T */
+                    case MAT_T_INT32:
+                    {
+                        mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT32:
+                    {
+                        mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT16:
+                    {
+                        mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT16:
+                    {
+                        mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT8:
+                    {
+                        mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT8:
+                    {
+                        mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    default:
+                        err = 1;
+                        break;
+                }
                 break;
             }
             case MAT_C_INT8:
             {
                 mat_int8_t *ptr = (mat_int8_t *)data_out;
-                mat_int8_t *ptr_in = (mat_int8_t *)data_in;
-                GET_DATA_SLABN;
+                switch ( data_type ) {
+                    case MAT_T_DOUBLE:
+                    {
+                        double *ptr_in = (double *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_SINGLE:
+                    {
+                        float *ptr_in = (float *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#ifdef HAVE_MATIO_INT64_T
+                    case MAT_T_INT64:
+                    {
+                        mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                    case MAT_T_UINT64:
+                    {
+                        mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_UINT64_T */
+                    case MAT_T_INT32:
+                    {
+                        mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT32:
+                    {
+                        mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT16:
+                    {
+                        mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT16:
+                    {
+                        mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT8:
+                    {
+                        mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT8:
+                    {
+                        mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    default:
+                        err = 1;
+                        break;
+                }
                 break;
             }
             case MAT_C_UINT8:
             {
                 mat_uint8_t *ptr = (mat_uint8_t *)data_out;
-                mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
-                GET_DATA_SLABN;
+                switch ( data_type ) {
+                    case MAT_T_DOUBLE:
+                    {
+                        double *ptr_in = (double *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_SINGLE:
+                    {
+                        float *ptr_in = (float *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#ifdef HAVE_MATIO_INT64_T
+                    case MAT_T_INT64:
+                    {
+                        mat_int64_t *ptr_in = (mat_int64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_INT64_T */
+#ifdef HAVE_MATIO_UINT64_T
+                    case MAT_T_UINT64:
+                    {
+                        mat_uint64_t *ptr_in = (mat_uint64_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+#endif /* HAVE_MATIO_UINT64_T */
+                    case MAT_T_INT32:
+                    {
+                        mat_int32_t *ptr_in = (mat_int32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT32:
+                    {
+                        mat_uint32_t *ptr_in = (mat_uint32_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT16:
+                    {
+                        mat_int16_t *ptr_in = (mat_int16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT16:
+                    {
+                        mat_uint16_t *ptr_in = (mat_uint16_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_INT8:
+                    {
+                        mat_int8_t *ptr_in = (mat_int8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    case MAT_T_UINT8:
+                    {
+                        mat_uint8_t *ptr_in = (mat_uint8_t *)data_in;
+                        GET_DATA_SLABN;
+                        break;
+                    }
+                    default:
+                        err = 1;
+                        break;
+                }
                 break;
             }
             default:
@@ -16172,10 +16563,10 @@
 {
     int err = 0,real_bytes = 0;
     mat_int32_t tag[2];
-    size_t bytesread = 0;
 #if defined(HAVE_ZLIB)
     z_stream z;
 #endif
+    size_t bytesread = 0;
 
     (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
     if ( matvar->compression == MAT_COMPRESSION_NONE ) {
@@ -16445,10 +16836,10 @@
 {
     int err = 0, nmemb = 1, i, real_bytes = 0;
     mat_int32_t tag[2];
-    size_t bytesread = 0;
 #if defined(HAVE_ZLIB)
     z_stream z;
 #endif
+    size_t bytesread = 0;
 
     if ( mat->version == MAT_FT_MAT4 )
         return -1;
@@ -16644,12 +17035,13 @@
 Mat_VarWrite5(mat_t *mat,matvar_t *matvar,int compress)
 {
     mat_uint32_t array_flags = 0x0;
-    mat_int16_t  fieldname_type = MAT_T_INT32,fieldname_data_size=4;
-    mat_int8_t  pad1 = 0;
-    int      array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
-    int      array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;
-    int      nBytes, i, nmemb = 1,nzmax = 0;
-    long     start = 0, end = 0;
+    mat_int16_t fieldname_type = MAT_T_INT32;
+    mat_int16_t fieldname_data_size = 4;
+    mat_int8_t pad1 = 0;
+    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
+    int array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;
+    int nBytes, i, nmemb = 1,nzmax = 0;
+    long start = 0, end = 0;
 
     if ( NULL == mat )
         return -1;
@@ -16785,12 +17177,12 @@
             }
             case MAT_C_STRUCT:
             {
-                char      *padzero;
-                int        fieldname_size, nfields;
-                size_t     maxlen = 0;
+                char *padzero;
+                int fieldname_size, nfields;
+                size_t maxlen = 0;
                 matvar_t **fields = (matvar_t **)matvar->data;
                 mat_int32_t array_name_type = MAT_T_INT8;
-                unsigned   fieldname;
+                unsigned fieldname;
 
                 nfields = matvar->internal->num_fields;
                 /* Check for a structure with no fields */
@@ -16875,6 +17267,7 @@
             case MAT_C_EMPTY:
             case MAT_C_FUNCTION:
             case MAT_C_OBJECT:
+            case MAT_C_OPAQUE:
                 break;
         }
 #if defined(HAVE_ZLIB)
@@ -17049,8 +17442,8 @@
             case MAT_C_STRUCT:
             {
                 unsigned char *padzero;
-                int        fieldname_size, nfields;
-                size_t     maxlen = 0;
+                int fieldname_size, nfields;
+                size_t maxlen = 0;
                 mat_int32_t array_name_type = MAT_T_INT8;
                 matvar_t **fields = (matvar_t **)matvar->data;
 
@@ -17058,8 +17451,7 @@
                 /* Check for a structure with no fields */
                 if ( nfields < 1 ) {
                     fieldname_size = 1;
-                    uncomp_buf[0] = (fieldname_data_size << 16) |
-                                     fieldname_type;
+                    uncomp_buf[0] = (fieldname_data_size << 16) | fieldname_type;
                     uncomp_buf[1] = fieldname_size;
                     uncomp_buf[2] = array_name_type;
                     uncomp_buf[3] = 0;
@@ -17143,6 +17535,7 @@
             case MAT_C_EMPTY:
             case MAT_C_FUNCTION:
             case MAT_C_OBJECT:
+            case MAT_C_OPAQUE:
                 break;
         }
         matvar->internal->z->next_in  = NULL;
@@ -17192,17 +17585,17 @@
 WriteInfo5(mat_t *mat, matvar_t *matvar)
 {
     mat_uint32_t array_flags = 0x0;
-    mat_int16_t  fieldname_type = MAT_T_INT32,fieldname_data_size=4;
-    mat_int8_t  pad1 = 0;
-    int      array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
-    int      array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;
-    int      nBytes, i, nmemb = 1,nzmax = 0;
-    long     start = 0, end = 0;
+    mat_int8_t pad1 = 0;
+    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
+    int array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;
+    int nBytes, nmemb = 1,nzmax = 0;
+    long start = 0, end = 0;
 
     /* FIXME: SEEK_END is not Guaranteed by the C standard */
     (void)fseek((FILE*)mat->fp,0,SEEK_END);         /* Always write at end of file */
 
     if ( matvar->compression == MAT_COMPRESSION_NONE ) {
+        int i;
         fwrite(&matrix_type,4,1,(FILE*)mat->fp);
         fwrite(&pad4,4,1,(FILE*)mat->fp);
         start = ftell((FILE*)mat->fp);
@@ -17297,7 +17690,7 @@
                 if ( matvar->nbytes == 0 || matvar->data_size == 0 ||
                      matvar->data   == NULL )
                     break;
-                ncells  = matvar->nbytes / matvar->data_size;
+                ncells = matvar->nbytes / matvar->data_size;
 
                 for ( i = 0; i < ncells; i++ )
                     WriteCellArrayFieldInfo(mat,cells[i]);
@@ -17306,10 +17699,12 @@
             case MAT_C_STRUCT:
             {
                 char *padzero;
+                mat_int16_t fieldname_type = MAT_T_INT32;
+                mat_int16_t fieldname_data_size = 4;
                 int maxlen = 0, fieldname_size;
                 int nfields = matvar->internal->num_fields;
                 matvar_t **fields = (matvar_t **)matvar->data;
-                mat_int32_t  array_name_type = MAT_T_INT8;
+                mat_int32_t array_name_type = MAT_T_INT8;
                 unsigned fieldname;
 
                 for ( i = 0; i < nfields; i++ ) {
@@ -17347,6 +17742,7 @@
             case MAT_C_EMPTY:
             case MAT_C_FUNCTION:
             case MAT_C_OBJECT:
+            case MAT_C_OPAQUE:
                 break;
         }
     /* Does not work.
@@ -17539,7 +17935,7 @@
     matvar_t *matvar = NULL;
     mat_uint32_t array_flags;
 
-    if( mat == NULL )
+    if ( mat == NULL )
         return NULL;
 
     fpos = ftell((FILE*)mat->fp);
@@ -17564,14 +17960,6 @@
             long     bytesread = 0;
 
             matvar               = Mat_VarCalloc();
-            matvar->name         = NULL;
-            matvar->data         = NULL;
-            matvar->dims         = NULL;
-            matvar->nbytes       = 0;
-            matvar->data_type    = MAT_T_UNKNOWN;
-            matvar->class_type   = MAT_C_EMPTY;
-            matvar->data_size    = 0;
-            matvar->mem_conserve = 0;
             matvar->compression  = MAT_COMPRESSION_ZLIB;
 
             matvar->internal->fp = mat;
@@ -17585,7 +17973,7 @@
                 break;
             }
 
-            /* Read Variable tag */
+            /* Read variable tag */
             bytesread += InflateVarTag(mat,matvar,uncomp_buf);
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
@@ -17599,7 +17987,7 @@
                 Mat_Critical("Uncompressed type not MAT_T_MATRIX");
                 break;
             }
-            /* Inflate Array Flags */
+            /* Inflate array flags */
             bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
@@ -17606,75 +17994,77 @@
                 (void)Mat_uint32Swap(uncomp_buf+2);
                 (void)Mat_uint32Swap(uncomp_buf+3);
             }
-            /* Array Flags */
+            /* Array flags */
             if ( uncomp_buf[0] == MAT_T_UINT32 ) {
-               array_flags = uncomp_buf[2];
-               matvar->class_type  = CLASS_FROM_ARRAY_FLAGS(array_flags);
-               matvar->isComplex   = (array_flags & MAT_F_COMPLEX);
-               matvar->isGlobal    = (array_flags & MAT_F_GLOBAL);
-               matvar->isLogical   = (array_flags & MAT_F_LOGICAL);
-               if ( matvar->class_type == MAT_C_SPARSE ) {
-                   /* Need to find a more appropriate place to store nzmax */
-                   matvar->nbytes      = uncomp_buf[3];
-               }
+                array_flags = uncomp_buf[2];
+                matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
+                matvar->isComplex  = (array_flags & MAT_F_COMPLEX);
+                matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);
+                matvar->isLogical  = (array_flags & MAT_F_LOGICAL);
+                if ( matvar->class_type == MAT_C_SPARSE ) {
+                    /* Need to find a more appropriate place to store nzmax */
+                    matvar->nbytes = uncomp_buf[3];
+                }
             }
-            /* Inflate Dimensions */
-            bytesread += InflateDimensions(mat,matvar,uncomp_buf);
-            if ( mat->byteswap ) {
-                (void)Mat_uint32Swap(uncomp_buf);
-                (void)Mat_uint32Swap(uncomp_buf+1);
-            }
-            /* Rank and Dimension */
-            if ( uncomp_buf[0] == MAT_T_INT32 ) {
-                nbytes = uncomp_buf[1];
-                matvar->rank = nbytes / 4;
-                matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
+            if ( matvar->class_type != MAT_C_OPAQUE ) {
+                /* Inflate dimensions */
+                bytesread += InflateDimensions(mat,matvar,uncomp_buf);
                 if ( mat->byteswap ) {
-                    for ( i = 0; i < matvar->rank; i++ )
-                        matvar->dims[i] = Mat_uint32Swap(&(uncomp_buf[2+i]));
-                } else {
-                    for ( i = 0; i < matvar->rank; i++ )
-                        matvar->dims[i] = uncomp_buf[2+i];
+                    (void)Mat_uint32Swap(uncomp_buf);
+                    (void)Mat_uint32Swap(uncomp_buf+1);
                 }
-            }
-            /* Inflate variable name tag */
-            bytesread += InflateVarNameTag(mat,matvar,uncomp_buf);
-            if ( mat->byteswap )
-                (void)Mat_uint32Swap(uncomp_buf);
-            /* Name of variable */
-            if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
-                int len;
+                /* Rank and dimension */
+                if ( uncomp_buf[0] == MAT_T_INT32 ) {
+                    nbytes = uncomp_buf[1];
+                    matvar->rank = nbytes / 4;
+                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
+                    if ( mat->byteswap ) {
+                        for ( i = 0; i < matvar->rank; i++ )
+                            matvar->dims[i] = Mat_uint32Swap(&(uncomp_buf[2+i]));
+                    } else {
+                        for ( i = 0; i < matvar->rank; i++ )
+                            matvar->dims[i] = uncomp_buf[2+i];
+                    }
+                }
+                /* Inflate variable name tag */
+                bytesread += InflateVarNameTag(mat,matvar,uncomp_buf);
                 if ( mat->byteswap )
-                    len = Mat_uint32Swap(uncomp_buf+1);
-                else
-                    len = uncomp_buf[1];
+                    (void)Mat_uint32Swap(uncomp_buf);
+                /* Name of variable */
+                if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
+                    int len;
+                    if ( mat->byteswap )
+                        len = Mat_uint32Swap(uncomp_buf+1);
+                    else
+                        len = uncomp_buf[1];
 
-                if ( len % 8 == 0 )
-                    i = len;
-                else
-                    i = len+(8-(len % 8));
-                matvar->name = (char*)malloc(i+1);
-                /* Inflate variable name */
-                bytesread += InflateVarName(mat,matvar,matvar->name,i);
-                matvar->name[len] = '\0';
-            } else if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) &&
-                        ((uncomp_buf[0] & 0xffff0000) != 0x00) ) {
-                /* Name packed in tag */
-                int len;
-                len = (uncomp_buf[0] & 0xffff0000) >> 16;
-                matvar->name = (char*)malloc(len+1);
-                memcpy(matvar->name,uncomp_buf+1,len);
-                matvar->name[len] = '\0';
+                    if ( len % 8 == 0 )
+                        i = len;
+                    else
+                        i = len+(8-(len % 8));
+                    matvar->name = (char*)malloc(i+1);
+                    /* Inflate variable name */
+                    bytesread += InflateVarName(mat,matvar,matvar->name,i);
+                    matvar->name[len] = '\0';
+                } else if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) &&
+                            ((uncomp_buf[0] & 0xffff0000) != 0x00) ) {
+                    /* Name packed in tag */
+                    int len;
+                    len = (uncomp_buf[0] & 0xffff0000) >> 16;
+                    matvar->name = (char*)malloc(len+1);
+                    memcpy(matvar->name,uncomp_buf+1,len);
+                    matvar->name[len] = '\0';
+                }
+                if ( matvar->class_type == MAT_C_STRUCT )
+                    (void)ReadNextStructField(mat,matvar);
+                else if ( matvar->class_type == MAT_C_CELL )
+                    (void)ReadNextCell(mat,matvar);
+                (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);
+                matvar->internal->datapos = ftell((FILE*)mat->fp);
+                if ( matvar->internal->datapos == -1L ) {
+                    Mat_Critical("Couldn't determine file position");
+                }
             }
-            if ( matvar->class_type == MAT_C_STRUCT )
-                (void)ReadNextStructField(mat,matvar);
-            else if ( matvar->class_type == MAT_C_CELL )
-                (void)ReadNextCell(mat,matvar);
-            (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);
-            matvar->internal->datapos = ftell((FILE*)mat->fp);
-            if ( matvar->internal->datapos == -1L ) {
-                Mat_Critical("Couldn't determine file position");
-            }
             (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);
             break;
 #else
@@ -17686,15 +18076,14 @@
         }
         case MAT_T_MATRIX:
         {
-            int      nbytes;
             mat_uint32_t buf[32];
-            size_t   bytesread = 0;
+            size_t bytesread = 0;
 
             matvar = Mat_VarCalloc();
             matvar->internal->fpos = fpos;
             matvar->internal->fp   = mat;
 
-            /* Read Array Flags and The Dimensions Tag */
+            /* Read array flags and the dimensions tag */
             bytesread += fread(buf,4,6,(FILE*)mat->fp);
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
@@ -17704,21 +18093,21 @@
                 (void)Mat_uint32Swap(buf+4);
                 (void)Mat_uint32Swap(buf+5);
             }
-            /* Array Flags */
+            /* Array flags */
             if ( buf[0] == MAT_T_UINT32 ) {
                array_flags = buf[2];
-               matvar->class_type  = CLASS_FROM_ARRAY_FLAGS(array_flags);
-               matvar->isComplex   = (array_flags & MAT_F_COMPLEX);
-               matvar->isGlobal    = (array_flags & MAT_F_GLOBAL);
-               matvar->isLogical   = (array_flags & MAT_F_LOGICAL);
+               matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
+               matvar->isComplex  = (array_flags & MAT_F_COMPLEX);
+               matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);
+               matvar->isLogical  = (array_flags & MAT_F_LOGICAL);
                if ( matvar->class_type == MAT_C_SPARSE ) {
                    /* Need to find a more appropriate place to store nzmax */
-                   matvar->nbytes      = buf[3];
+                   matvar->nbytes = buf[3];
                }
             }
-            /* Rank and Dimension */
+            /* Rank and dimension */
             if ( buf[4] == MAT_T_INT32 ) {
-                nbytes = buf[5];
+                int nbytes = buf[5];
 
                 matvar->rank = nbytes / 4;
                 matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
@@ -17737,7 +18126,7 @@
                         matvar->dims[i] = buf[i];
                 }
             }
-            /* Variable Name Tag */
+            /* Variable name tag */
             bytesread+=fread(buf,4,2,(FILE*)mat->fp);
             if ( mat->byteswap )
                 (void)Mat_uint32Swap(buf);
@@ -17837,6 +18226,14 @@
     matvar_t *matvar;
 };
 
+#if defined(H5Rdereference)
+/* HDF5 1.10.0 */
+#define H5RDEREFERENCE(obj_id, ref_type, _ref) H5Rdereference2((obj_id), H5P_DATASET_ACCESS_DEFAULT, (ref_type), (_ref))
+#else
+/* HDF5 prior to 1.10.0 */
+#define H5RDEREFERENCE(obj_id, ref_type, _ref) H5Rdereference((obj_id), (ref_type), (_ref))
+#endif
+
 /*===========================================================================
  *  Private functions
  *===========================================================================
@@ -18292,9 +18689,7 @@
 static void
 Mat_H5ReadDatasetInfo(mat_t *mat,matvar_t *matvar,hid_t dset_id)
 {
-    ssize_t  name_len;
-    /* FIXME */
-    hsize_t  dims[10];
+    ssize_t name_len;
     hid_t   attr_id,type_id,space_id;
 
 #if 0
@@ -18323,11 +18718,19 @@
     matvar->rank = H5Sget_simple_extent_ndims(space_id);
     matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
     if ( NULL != matvar->dims ) {
-        int k;
-        H5Sget_simple_extent_dims(space_id,dims,NULL);
-        for ( k = 0; k < matvar->rank; k++ )
-            matvar->dims[k] = dims[matvar->rank - k - 1];
-        H5Sclose(space_id);
+        hsize_t* dims = (hsize_t*)malloc(matvar->rank*sizeof(hsize_t));
+        if ( NULL != dims ) {
+            int k;
+            (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
+            for ( k = 0; k < matvar->rank; k++ )
+                matvar->dims[k] = dims[matvar->rank - k - 1];
+            free(dims);
+            H5Sclose(space_id);
+        } else {
+            H5Sclose(space_id);
+            Mat_Critical("Error allocating memory for dims");
+            return;
+        }
     } else {
         H5Sclose(space_id);
         Mat_Critical("Error allocating memory for matvar->dims");
@@ -18382,14 +18785,13 @@
 
         if ( ncells ) {
             ref_ids = (hobj_ref_t*)malloc(ncells*sizeof(*ref_ids));
-            H5Dread(dset_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,H5P_DEFAULT,
-                    ref_ids);
+            H5Dread(dset_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,H5P_DEFAULT,ref_ids);
             for ( i = 0; i < ncells; i++ ) {
                 hid_t ref_id;
                 cells[i] = Mat_VarCalloc();
                 cells[i]->internal->hdf5_ref = ref_ids[i];
                 /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */
-                ref_id = H5Rdereference(dset_id,H5R_OBJECT,ref_ids+i);
+                ref_id = H5RDEREFERENCE(dset_id,H5R_OBJECT,ref_ids+i);
                 cells[i]->internal->id = ref_id;
                 cells[i]->internal->fp = matvar->internal->fp;
                 Mat_H5ReadNextReferenceInfo(ref_id,cells[i],mat);
@@ -18438,8 +18840,7 @@
 {
     ssize_t  name_len;
     int      k, fields_are_variables = 1;
-    /* FIXME */
-    hsize_t  dims[10],nfields=0,numel;
+    hsize_t  nfields=0,numel;
     hid_t   attr_id,type_id,space_id,field_id,field_type_id;
     matvar_t **fields;
     H5O_type_t obj_type;
@@ -18489,7 +18890,7 @@
 
         matvar->rank = 2;
         matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
-        if (matvar->dims == NULL) {
+        if ( matvar->dims == NULL ) {
             Mat_Critical("Error allocating memory for matvar->dims");
             return;
         }
@@ -18496,12 +18897,22 @@
         matvar->dims[0] = nrows;
 
         if ( H5Lexists(dset_id,"jc",H5P_DEFAULT) ) {
+            hsize_t* dims;
             sparse_dset_id = H5Dopen(dset_id,"jc",H5P_DEFAULT);
             space_id = H5Dget_space(sparse_dset_id);
-            (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
-            matvar->dims[1] = dims[0] - 1;
-            H5Sclose(space_id);
-            H5Dclose(sparse_dset_id);
+            dims = (hsize_t*)malloc(matvar->rank*sizeof(hsize_t));
+            if ( NULL != dims ) {
+                (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
+                matvar->dims[1] = dims[0] - 1;
+                free(dims);
+                H5Sclose(space_id);
+                H5Dclose(sparse_dset_id);
+            } else {
+                H5Sclose(space_id);
+                H5Dclose(sparse_dset_id);
+                Mat_Critical("Error allocating memory for dims");
+                return;
+            }
         }
 
         /* Test if dataset type is compound and if so if it's complex */
@@ -18543,7 +18954,7 @@
         H5Aclose(attr_id);
         free(fieldnames_vl);
     } else {
-        H5G_info_t group_info;
+        H5G_info_t group_info = {0};
         matvar->internal->num_fields = 0;
         H5Gget_info(dset_id, &group_info);
         if ( group_info.nlinks > 0 ) {
@@ -18589,9 +19000,9 @@
             if ( H5Aexists_by_name(field_id,".","MATLAB_class",H5P_DEFAULT) ) {
                 attr_id = H5Aopen_by_name(field_id,".","MATLAB_class",H5P_DEFAULT,H5P_DEFAULT);
                 H5Aclose(attr_id);
-                matvar->rank    = 2;
-                matvar->dims    = (size_t*)malloc(2*sizeof(*matvar->dims));
-                if (matvar->dims == NULL) {
+                matvar->rank = 2;
+                matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));
+                if ( matvar->dims == NULL ) {
                     H5Tclose(field_type_id);
                     H5Dclose(field_id);
                     Mat_Critical("Error allocating memory for matvar->dims");
@@ -18601,10 +19012,11 @@
                 matvar->dims[1] = 1;
                 numel = 1;
             } else {
+                hsize_t* dims;
                 space_id     = H5Dget_space(field_id);
                 matvar->rank = H5Sget_simple_extent_ndims(space_id);
                 matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
-                if (matvar->dims == NULL) {
+                if ( matvar->dims == NULL ) {
                     H5Tclose(field_type_id);
                     H5Dclose(field_id);
                     H5Sclose(space_id);
@@ -18611,20 +19023,28 @@
                     Mat_Critical("Error allocating memory for matvar->dims");
                     return;
                 }
-                (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
-                numel = 1;
-                for ( k = 0; k < matvar->rank; k++ ) {
-                    matvar->dims[k] = dims[matvar->rank - k - 1];
-                    numel *= matvar->dims[k];
+                dims = (hsize_t*)malloc(matvar->rank*sizeof(hsize_t));
+                if ( NULL != dims ) {
+                    (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
+                    numel = 1;
+                    for ( k = 0; k < matvar->rank; k++ ) {
+                        matvar->dims[k] = dims[matvar->rank - k - 1];
+                        numel *= matvar->dims[k];
+                    }
+                    free(dims);
+                    H5Sclose(space_id);
+                    fields_are_variables = 0;
+                } else {
+                    H5Sclose(space_id);
+                    Mat_Critical("Error allocating memory for dims");
+                    return;
                 }
-                H5Sclose(space_id);
-                fields_are_variables = 0;
             }
         } else {
             /* Structure should be a scalar */
-            matvar->rank    = 2;
-            matvar->dims    = (size_t*)malloc(2*sizeof(*matvar->dims));
-            if (matvar->dims == NULL) {
+            matvar->rank = 2;
+            matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));
+            if ( matvar->dims == NULL ) {
                 H5Tclose(field_type_id);
                 H5Dclose(field_id);
                 Mat_Critical("Error allocating memory for matvar->dims");
@@ -18639,9 +19059,9 @@
     } else {
         /* Structure should be a scalar */
         numel = 1;
-        matvar->rank    = 2;
-        matvar->dims    = (size_t*)malloc(2*sizeof(*matvar->dims));
-        if (matvar->dims == NULL) {
+        matvar->rank = 2;
+        matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));
+        if ( matvar->dims == NULL ) {
             Mat_Critical("Error allocating memory for matvar->dims");
             return;
         }
@@ -18684,20 +19104,16 @@
                                 fields[l*nfields+k]->internal->hdf5_name,
                                 name_len+1);
                         }
-                        /* Closing of ref_id is done in
-                         * Mat_H5ReadNextReferenceInfo
-                         */
-                        ref_id = H5Rdereference(field_id,H5R_OBJECT,
-                                                ref_ids+l);
-                        fields[l*nfields+k]->internal->id=ref_id;
+                        /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */
+                        ref_id = H5RDEREFERENCE(field_id,H5R_OBJECT,ref_ids+l);
+                        fields[l*nfields+k]->internal->id = ref_id;
                         Mat_H5ReadNextReferenceInfo(ref_id,fields[l*nfields+k],mat);
                     }
                     free(ref_ids);
                 } else {
                     fields[k] = Mat_VarCalloc();
-                    fields[k]->internal->fp   = mat;
-                    fields[k]->name =
-                        mat_strdup(matvar->internal->fieldnames[k]);
+                    fields[k]->internal->fp = mat;
+                    fields[k]->name = mat_strdup(matvar->internal->fieldnames[k]);
                     Mat_H5ReadDatasetInfo(mat,fields[k],field_id);
                 }
                 H5Dclose(field_id);
@@ -18706,7 +19122,7 @@
                                    H5P_DEFAULT);
                 if ( -1 < field_id ) {
                     fields[k] = Mat_VarCalloc();
-                    fields[k]->internal->fp   = mat;
+                    fields[k]->internal->fp = mat;
                     fields[k]->name = mat_strdup(matvar->internal->fieldnames[k]);
                     Mat_H5ReadGroupInfo(mat,fields[k],field_id);
                     H5Gclose(field_id);
@@ -18735,21 +19151,12 @@
     matvar = group_data->matvar;
 
     switch ( object_info.type ) {
-        case H5O_TYPE_DATASET:
-        {
-            if ( matvar != NULL ) {
-                matvar->internal->fieldnames[group_data->nfields] =
-                    (char*)calloc(strlen(name)+1,sizeof(char));
-                strcpy(matvar->internal->fieldnames[group_data->nfields], name);
-            }
-            group_data->nfields++;
-            break;
-        }
         case H5O_TYPE_GROUP:
-        {
             /* Check that this is not the /#refs# group */
             if ( 0 == strcmp(name,"#refs#") )
                 return 0;
+            /* Fall through */
+        case H5O_TYPE_DATASET:
             if ( matvar != NULL ) {
                 matvar->internal->fieldnames[group_data->nfields] =
                     (char*)calloc(strlen(name)+1,sizeof(char));
@@ -18757,8 +19164,8 @@
             }
             group_data->nfields++;
             break;
-        }
         default:
+            /* Not possible to get here */
             break;
     }
     return 1;
@@ -18773,9 +19180,7 @@
     switch ( H5Iget_type(ref_id) ) {
         case H5I_DATASET:
         {
-            /* FIXME */
-            hsize_t  dims[10];
-            hid_t   attr_id,type_id,dset_id,space_id;
+            hid_t attr_id,type_id,dset_id,space_id;
 
             /* matvar->fp = mat; */
             dset_id = ref_id;
@@ -18796,12 +19201,20 @@
                 H5Sclose(space_id);
                 break;
             } else {
-                int k;
-                H5Sget_simple_extent_dims(space_id,dims,NULL);
-                for ( k = 0; k < matvar->rank; k++ )
-                    matvar->dims[k] = dims[matvar->rank - k - 1];
+                hsize_t* dims = (hsize_t*)malloc(matvar->rank*sizeof(hsize_t));
+                if ( NULL != dims ) {
+                    int k;
+                    (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
+                    for ( k = 0; k < matvar->rank; k++ )
+                        matvar->dims[k] = dims[matvar->rank - k - 1];
+                    free(dims);
+                    H5Sclose(space_id);
+                } else {
+                    H5Sclose(space_id);
+                    Mat_Critical("Error allocating memory for dims");
+                    return;
+                }
             }
-            H5Sclose(space_id);
 
             Mat_H5ReadClassType(matvar,dset_id);
 
@@ -18851,16 +19264,15 @@
                 if ( ncells > 0 ) {
                     hobj_ref_t *ref_ids;
                     ref_ids = (hobj_ref_t*)malloc(ncells*sizeof(*ref_ids));
-                    H5Dread(dset_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,H5P_DEFAULT,
-                            ref_ids);
+                    H5Dread(dset_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,H5P_DEFAULT,ref_ids);
                     for ( i = 0; i < ncells; i++ ) {
                         hid_t ref_id;
                         cells[i] = Mat_VarCalloc();
                         cells[i]->internal->hdf5_ref = ref_ids[i];
                         /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */
-                        ref_id = H5Rdereference(dset_id,H5R_OBJECT,ref_ids+i);
-                        cells[i]->internal->id=ref_id;
-                        cells[i]->internal->fp=matvar->internal->fp;
+                        ref_id = H5RDEREFERENCE(dset_id,H5R_OBJECT,ref_ids+i);
+                        cells[i]->internal->id = ref_id;
+                        cells[i]->internal->fp = matvar->internal->fp;
                         Mat_H5ReadNextReferenceInfo(ref_id,cells[i],mat);
                     }
                     free(ref_ids);
@@ -18963,7 +19375,7 @@
                 matvar->data_size = Mat_SizeOfClass(matvar->class_type);
                 data_type_id      = Mat_class_type_to_hid_t(matvar->class_type);
             }
-            matvar->nbytes    = numel*matvar->data_size;
+            matvar->nbytes = numel*matvar->data_size;
 
             if ( matvar->nbytes < 1 ) {
                 H5Dclose(ref_id);
@@ -18973,7 +19385,7 @@
             dset_id = ref_id;
 
             if ( !matvar->isComplex ) {
-                matvar->data      = malloc(matvar->nbytes);
+                matvar->data = malloc(matvar->nbytes);
                 if ( NULL != matvar->data ) {
                     H5Dread(dset_id,data_type_id,H5S_ALL,H5S_ALL,H5P_DEFAULT,
                             matvar->data);
@@ -18980,27 +19392,26 @@
                 }
             } else {
                 mat_complex_split_t *complex_data;
-                hid_t h5_complex_base,h5_complex;
+                hid_t h5_complex_base, h5_complex;
 
-                complex_data     = (mat_complex_split_t*)malloc(sizeof(*complex_data));
-                complex_data->Re = malloc(matvar->nbytes);
-                complex_data->Im = malloc(matvar->nbytes);
+                complex_data = ComplexMalloc(matvar->nbytes);
+                if ( NULL != complex_data ) {
+                    h5_complex_base = data_type_id;
+                    h5_complex      = H5Tcreate(H5T_COMPOUND,
+                                                H5Tget_size(h5_complex_base));
+                    H5Tinsert(h5_complex,"real",0,h5_complex_base);
+                    H5Dread(dset_id,h5_complex,H5S_ALL,H5S_ALL,H5P_DEFAULT,
+                            complex_data->Re);
+                    H5Tclose(h5_complex);
 
-                h5_complex_base = data_type_id;
-                h5_complex      = H5Tcreate(H5T_COMPOUND,
-                                            H5Tget_size(h5_complex_base));
-                H5Tinsert(h5_complex,"real",0,h5_complex_base);
-                H5Dread(dset_id,h5_complex,H5S_ALL,H5S_ALL,H5P_DEFAULT,
-                        complex_data->Re);
-                H5Tclose(h5_complex);
-
-                h5_complex      = H5Tcreate(H5T_COMPOUND,
-                                            H5Tget_size(h5_complex_base));
-                H5Tinsert(h5_complex,"imag",0,h5_complex_base);
-                H5Dread(dset_id,h5_complex,H5S_ALL,H5S_ALL,H5P_DEFAULT,
-                        complex_data->Im);
-                H5Tclose(h5_complex);
-                matvar->data = complex_data;
+                    h5_complex      = H5Tcreate(H5T_COMPOUND,
+                                                H5Tget_size(h5_complex_base));
+                    H5Tinsert(h5_complex,"imag",0,h5_complex_base);
+                    H5Dread(dset_id,h5_complex,H5S_ALL,H5S_ALL,H5P_DEFAULT,
+                            complex_data->Im);
+                    H5Tclose(h5_complex);
+                    matvar->data = complex_data;
+                }
             }
             H5Dclose(dset_id);
             break;
@@ -19069,13 +19480,11 @@
         dset_id = H5Dcreate(id,name,H5T_NATIVE_HSIZE,mspace_id,
                             H5P_DEFAULT,H5P_DEFAULT,H5P_DEFAULT);
         attr_type_id = H5Tcopy(H5T_C_S1);
-        H5Tset_size(attr_type_id,
-                    strlen(Mat_class_names[matvar->class_type])+1);
+        H5Tset_size(attr_type_id, strlen(Mat_class_names[matvar->class_type]));
         aspace_id = H5Screate(H5S_SCALAR);
         attr_id = H5Acreate(dset_id,"MATLAB_class",attr_type_id,
                             aspace_id,H5P_DEFAULT,H5P_DEFAULT);
-        H5Awrite(attr_id,attr_type_id,
-                 Mat_class_names[matvar->class_type]);
+        H5Awrite(attr_id, attr_type_id, Mat_class_names[matvar->class_type]);
         H5Sclose(aspace_id);
         H5Aclose(attr_id);
         H5Tclose(attr_type_id);
@@ -19091,7 +19500,6 @@
                  H5P_DEFAULT,matvar->dims);
         H5Dclose(dset_id);
         H5Sclose(mspace_id);
-
         err = 0;
     } else {
         (void)H5Iget_name(id,id_name,127);
@@ -19117,7 +19525,7 @@
                                 H5P_DEFAULT,H5P_DEFAULT,H5P_DEFAULT);
 
             for ( k = 0; k < nmemb; k++ ) {
-                H5G_info_t group_info;
+                H5G_info_t group_info = {0};
                 H5Gget_info(*refs_id, &group_info);
                 sprintf(obj_name,"%lld",group_info.nlinks);
                 if ( NULL != cells[k] )
@@ -19131,7 +19539,7 @@
                      H5P_DEFAULT,refs);
 
             str_type_id = H5Tcopy(H5T_C_S1);
-            H5Tset_size(str_type_id,7);
+            H5Tset_size(str_type_id,4);
             aspace_id = H5Screate(H5S_SCALAR);
             attr_id = H5Acreate(dset_id,"MATLAB_class",str_type_id,
                                 aspace_id,H5P_DEFAULT,H5P_DEFAULT);
@@ -19142,7 +19550,6 @@
             H5Dclose(dset_id);
             free(refs);
             H5Sclose(mspace_id);
-
             err = 0;
         }
     }
@@ -19182,13 +19589,11 @@
         dset_id = H5Dcreate(id,name,H5T_NATIVE_HSIZE,mspace_id,
                             H5P_DEFAULT,H5P_DEFAULT,H5P_DEFAULT);
         attr_type_id = H5Tcopy(H5T_C_S1);
-        H5Tset_size(attr_type_id,
-                    strlen(Mat_class_names[matvar->class_type])+1);
+        H5Tset_size(attr_type_id, strlen(Mat_class_names[matvar->class_type]));
         aspace_id = H5Screate(H5S_SCALAR);
         attr_id = H5Acreate(dset_id,"MATLAB_class",attr_type_id,
                             aspace_id,H5P_DEFAULT,H5P_DEFAULT);
-        H5Awrite(attr_id,attr_type_id,
-                 Mat_class_names[matvar->class_type]);
+        H5Awrite(attr_id, attr_type_id, Mat_class_names[matvar->class_type]);
         H5Sclose(aspace_id);
         H5Aclose(attr_id);
         H5Tclose(attr_type_id);
@@ -19235,8 +19640,7 @@
                 return err;
         }
         attr_type_id = H5Tcopy(H5T_C_S1);
-        H5Tset_size(attr_type_id,
-                    strlen(Mat_class_names[matvar->class_type])+1);
+        H5Tset_size(attr_type_id, strlen(Mat_class_names[matvar->class_type]));
         aspace_id = H5Screate(H5S_SCALAR);
         attr_id = H5Acreate(dset_id,"MATLAB_class",attr_type_id,
                             aspace_id,H5P_DEFAULT,H5P_DEFAULT);
@@ -19274,7 +19678,7 @@
                         H5P_DEFAULT,H5P_DEFAULT,H5P_DEFAULT);
     if ( dset_id > -1 ) {
         attr_type_id = H5Tcopy(H5T_C_S1);
-        H5Tset_size(attr_type_id,7);
+        H5Tset_size(attr_type_id,6);
         aspace_id = H5Screate(H5S_SCALAR);
         attr_id = H5Acreate(dset_id,"MATLAB_class",attr_type_id,
                             aspace_id,H5P_DEFAULT,H5P_DEFAULT);
@@ -19293,10 +19697,11 @@
         /* Write the dimensions as the data */
         H5Dwrite(dset_id,Mat_dims_type_to_hid_t(),H5S_ALL,H5S_ALL,
                  H5P_DEFAULT,dims);
+        H5Dclose(dset_id);
         err = 0;
-        H5Dclose(dset_id);
     }
     H5Sclose(mspace_id);
+
     return err;
 }
 
@@ -19453,13 +19858,11 @@
         dset_id = H5Dcreate(id,name,H5T_NATIVE_HSIZE,mspace_id,
                             H5P_DEFAULT,H5P_DEFAULT,H5P_DEFAULT);
         attr_type_id = H5Tcopy(H5T_C_S1);
-        H5Tset_size(attr_type_id,
-                    strlen(Mat_class_names[matvar->class_type])+1);
+        H5Tset_size(attr_type_id, strlen(Mat_class_names[matvar->class_type]));
         aspace_id = H5Screate(H5S_SCALAR);
         attr_id = H5Acreate(dset_id,"MATLAB_class",attr_type_id,
                             aspace_id,H5P_DEFAULT,H5P_DEFAULT);
-        H5Awrite(attr_id,attr_type_id,
-                 Mat_class_names[matvar->class_type]);
+        H5Awrite(attr_id, attr_type_id, Mat_class_names[matvar->class_type]);
         H5Sclose(aspace_id);
         H5Aclose(attr_id);
         H5Tclose(attr_type_id);
@@ -19489,13 +19892,11 @@
         dset_id = H5Dcreate(id,name,h5_complex,mspace_id,H5P_DEFAULT,
                             plist,H5P_DEFAULT);
         attr_type_id = H5Tcopy(H5T_C_S1);
-        H5Tset_size(attr_type_id,
-                    strlen(Mat_class_names[matvar->class_type])+1);
+        H5Tset_size(attr_type_id, strlen(Mat_class_names[matvar->class_type]));
         aspace_id = H5Screate(H5S_SCALAR);
         attr_id = H5Acreate(dset_id,"MATLAB_class",attr_type_id,
                             aspace_id,H5P_DEFAULT,H5P_DEFAULT);
-        H5Awrite(attr_id,attr_type_id,
-                 Mat_class_names[matvar->class_type]);
+        H5Awrite(attr_id, attr_type_id, Mat_class_names[matvar->class_type]);
         H5Sclose(aspace_id);
         H5Aclose(attr_id);
         H5Tclose(attr_type_id);
@@ -19510,8 +19911,8 @@
         H5Tclose(h5_complex);
 
         /* Write imaginary part of dataset */
-        h5_complex      = H5Tcreate(H5T_COMPOUND,
-                                    H5Tget_size(h5_complex_base));
+        h5_complex = H5Tcreate(H5T_COMPOUND,
+                               H5Tget_size(h5_complex_base));
         H5Tinsert(h5_complex,"imag",0,h5_complex_base);
         H5Dwrite(dset_id,h5_complex,H5S_ALL,H5S_ALL,H5P_DEFAULT,
                  ((mat_complex_split_t*)matvar->data)->Im);
@@ -19525,13 +19926,11 @@
                             Mat_class_type_to_hid_t(matvar->class_type),
                             mspace_id,H5P_DEFAULT,plist,H5P_DEFAULT);
         attr_type_id = H5Tcopy(H5T_C_S1);
-        H5Tset_size(attr_type_id,
-                    strlen(Mat_class_names[matvar->class_type])+1);
+        H5Tset_size(attr_type_id, strlen(Mat_class_names[matvar->class_type]));
         aspace_id = H5Screate(H5S_SCALAR);
         attr_id = H5Acreate(dset_id,"MATLAB_class",attr_type_id,
                             aspace_id,H5P_DEFAULT,H5P_DEFAULT);
-        H5Awrite(attr_id,attr_type_id,
-                 Mat_class_names[matvar->class_type]);
+        H5Awrite(attr_id, attr_type_id, Mat_class_names[matvar->class_type]);
         H5Sclose(aspace_id);
         H5Aclose(attr_id);
         H5Tclose(attr_type_id);
@@ -19564,9 +19963,9 @@
 {
     int err = -1;
     unsigned k;
-    hid_t      sparse_id,mspace_id,dset_id,attr_type_id,attr_id,aspace_id;
-    hsize_t    nmemb;
-    hsize_t    perm_dims[10];
+    hid_t   sparse_id,mspace_id,dset_id,attr_type_id,attr_id,aspace_id;
+    hsize_t nmemb;
+    hsize_t perm_dims[10];
 
     nmemb = matvar->dims[0];
     for ( k = 1; k < matvar->rank; k++ )
@@ -19588,17 +19987,34 @@
 
         class_type = Mat_TypeToClass73(matvar->data_type);
         attr_type_id = H5Tcopy(H5T_C_S1);
-        H5Tset_size(attr_type_id,
-                    strlen(Mat_class_names[class_type])+1);
+        if ( matvar->isLogical ) {
+            H5Tset_size(attr_type_id, 7);
+        } else {
+            H5Tset_size(attr_type_id, strlen(Mat_class_names[class_type]));
+        }
         aspace_id = H5Screate(H5S_SCALAR);
         attr_id = H5Acreate(sparse_id,"MATLAB_class",attr_type_id,
                             aspace_id,H5P_DEFAULT,H5P_DEFAULT);
-        H5Awrite(attr_id,attr_type_id,
-                 Mat_class_names[class_type]);
+        if ( matvar->isLogical ) {
+            H5Awrite(attr_id, attr_type_id, "logical");
+        } else {
+            H5Awrite(attr_id, attr_type_id, Mat_class_names[class_type]);
+        }
         H5Sclose(aspace_id);
         H5Aclose(attr_id);
         H5Tclose(attr_type_id);
 
+        if ( matvar->isLogical ) {
+            /* Write the MATLAB_int_decode attribute */
+            int int_decode = 1;
+            aspace_id = H5Screate(H5S_SCALAR);
+            attr_id = H5Acreate(sparse_id, "MATLAB_int_decode", H5T_NATIVE_INT,
+                                aspace_id, H5P_DEFAULT, H5P_DEFAULT);
+            H5Awrite(attr_id, H5T_NATIVE_INT, &int_decode);
+            H5Sclose(aspace_id);
+            H5Aclose(attr_id);
+        }
+
         sparse_attr_value = matvar->dims[0];
         size_type_id = Mat_class_type_to_hid_t(MAT_C_UINT64);
         aspace_id = H5Screate(H5S_SCALAR);
@@ -19718,13 +20134,11 @@
         dset_id = H5Dcreate(id,name,H5T_NATIVE_HSIZE,mspace_id,
                             H5P_DEFAULT,H5P_DEFAULT,H5P_DEFAULT);
         attr_type_id = H5Tcopy(H5T_C_S1);
-        H5Tset_size(attr_type_id,
-                    strlen(Mat_class_names[matvar->class_type])+1);
+        H5Tset_size(attr_type_id, strlen(Mat_class_names[matvar->class_type]));
         aspace_id = H5Screate(H5S_SCALAR);
         attr_id = H5Acreate(dset_id,"MATLAB_class",attr_type_id,
                             aspace_id,H5P_DEFAULT,H5P_DEFAULT);
-        H5Awrite(attr_id,attr_type_id,
-                 Mat_class_names[matvar->class_type]);
+        H5Awrite(attr_id, attr_type_id, Mat_class_names[matvar->class_type]);
         H5Sclose(aspace_id);
         H5Aclose(attr_id);
         H5Tclose(attr_type_id);
@@ -19764,6 +20178,7 @@
                  H5P_DEFAULT,matvar->dims);
         H5Dclose(dset_id);
         H5Sclose(mspace_id);
+        err = 0;
     } else {
         (void)H5Iget_name(id,id_name,127);
         is_ref = !strcmp(id_name,"/#refs#");
@@ -19773,7 +20188,7 @@
             Mat_Critical("Error creating group for struct %s",name);
         } else {
             str_type_id = H5Tcopy(H5T_C_S1);
-            H5Tset_size(str_type_id,7);
+            H5Tset_size(str_type_id,6);
             aspace_id = H5Screate(H5S_SCALAR);
             attr_id = H5Acreate(struct_id,"MATLAB_class",str_type_id,
                                 aspace_id,H5P_DEFAULT,H5P_DEFAULT);
@@ -19836,7 +20251,7 @@
 
                     for ( k = 0; k < nmemb; k++ ) {
                         for ( l = 0; l < nfields; l++ ) {
-                            H5G_info_t group_info;
+                            H5G_info_t group_info = {0};
                             H5Gget_info(*refs_id, &group_info);
                             sprintf(name,"%lld",group_info.nlinks);
                             if ( NULL != fields[k*nfields+l] )
@@ -19866,9 +20281,11 @@
                     H5Sclose(mspace_id);
                 }
             }
+            H5Gclose(struct_id);
+            err = 0;
         }
-        H5Gclose(struct_id);
     }
+
     return err;
 }
 
@@ -19879,7 +20296,7 @@
     if ( NULL == matvar ) {
         size_t dims[2] = {0,0};
         return Mat_WriteEmptyVariable73(id,name,2,dims);
-    } else if ( matvar->isLogical ) {
+    } else if ( matvar->isLogical && matvar->class_type != MAT_C_SPARSE ) {
         return Mat_VarWriteLogical73(id,matvar,name);
     }
 
@@ -19911,6 +20328,7 @@
         case MAT_C_EMPTY:
         case MAT_C_FUNCTION:
         case MAT_C_OBJECT:
+        case MAT_C_OPAQUE:
             break;
     }
     return err;
@@ -19960,16 +20378,18 @@
         return NULL;
     }
 
-    mat->fp               = NULL;
-    mat->header           = NULL;
-    mat->subsys_offset    = NULL;
-    mat->filename         = NULL;
-    mat->version          = 0;
-    mat->byteswap         = 0;
-    mat->mode             = 0;
-    mat->bof              = 0;
-    mat->next_index       = 0;
-    mat->refs_id          = -1;
+    mat->fp            = NULL;
+    mat->header        = NULL;
+    mat->subsys_offset = NULL;
+    mat->filename      = NULL;
+    mat->version       = 0;
+    mat->byteswap      = 0;
+    mat->mode          = 0;
+    mat->bof           = 128;
+    mat->next_index    = 0;
+    mat->num_datasets  = 0;
+    mat->refs_id       = -1;
+    mat->dir           = NULL;
 
     t = time(NULL);
     mat->filename = strdup_printf("%s",matname);
@@ -20058,7 +20478,7 @@
                 H5Iinc_ref(ref_id);
             }
             if ( 0 < matvar->internal->hdf5_ref ) {
-                dset_id = H5Rdereference(ref_id,H5R_OBJECT,&matvar->internal->hdf5_ref);
+                dset_id = H5RDEREFERENCE(ref_id,H5R_OBJECT,&matvar->internal->hdf5_ref);
             } else {
                 dset_id = ref_id;
                 H5Iinc_ref(dset_id);
@@ -20065,7 +20485,7 @@
             }
 
             if ( !matvar->isComplex ) {
-                matvar->data     = malloc(matvar->nbytes);
+                matvar->data = malloc(matvar->nbytes);
                 if ( NULL != matvar->data ) {
                     H5Dread(dset_id,Mat_class_type_to_hid_t(matvar->class_type),
                             H5S_ALL,H5S_ALL,H5P_DEFAULT,matvar->data);
@@ -20072,27 +20492,26 @@
                 }
             } else {
                 mat_complex_split_t *complex_data;
-                hid_t h5_complex_base,h5_complex;
+                hid_t h5_complex_base, h5_complex;
 
-                complex_data     = (mat_complex_split_t*)malloc(sizeof(*complex_data));
-                complex_data->Re = malloc(matvar->nbytes);
-                complex_data->Im = malloc(matvar->nbytes);
+                complex_data = ComplexMalloc(matvar->nbytes);
+                if ( NULL != complex_data ) {
+                    h5_complex_base = Mat_class_type_to_hid_t(matvar->class_type);
+                    h5_complex      = H5Tcreate(H5T_COMPOUND,
+                                                H5Tget_size(h5_complex_base));
+                    H5Tinsert(h5_complex,"real",0,h5_complex_base);
+                    H5Dread(dset_id,h5_complex,H5S_ALL,H5S_ALL,H5P_DEFAULT,
+                            complex_data->Re);
+                    H5Tclose(h5_complex);
 
-                h5_complex_base = Mat_class_type_to_hid_t(matvar->class_type);
-                h5_complex      = H5Tcreate(H5T_COMPOUND,
-                                            H5Tget_size(h5_complex_base));
-                H5Tinsert(h5_complex,"real",0,h5_complex_base);
-                H5Dread(dset_id,h5_complex,H5S_ALL,H5S_ALL,H5P_DEFAULT,
-                        complex_data->Re);
-                H5Tclose(h5_complex);
-
-                h5_complex      = H5Tcreate(H5T_COMPOUND,
-                                            H5Tget_size(h5_complex_base));
-                H5Tinsert(h5_complex,"imag",0,h5_complex_base);
-                H5Dread(dset_id,h5_complex,H5S_ALL,H5S_ALL,H5P_DEFAULT,
-                        complex_data->Im);
-                H5Tclose(h5_complex);
-                matvar->data = complex_data;
+                    h5_complex      = H5Tcreate(H5T_COMPOUND,
+                                                H5Tget_size(h5_complex_base));
+                    H5Tinsert(h5_complex,"imag",0,h5_complex_base);
+                    H5Dread(dset_id,h5_complex,H5S_ALL,H5S_ALL,H5P_DEFAULT,
+                            complex_data->Im);
+                    H5Tclose(h5_complex);
+                    matvar->data = complex_data;
+                }
             }
             H5Dclose(dset_id);
             H5Dclose(ref_id);
@@ -20111,11 +20530,14 @@
                 dset_id = matvar->internal->id;
                 H5Iinc_ref(dset_id);
             }
-            matvar->data = malloc(matvar->nbytes);
-            if ( NULL != matvar->data ) {
-                H5Dread(dset_id,Mat_data_type_to_hid_t(matvar->data_type),
-                        H5S_ALL,H5S_ALL,H5P_DEFAULT,matvar->data);
+            if ( matvar->nbytes > 0 ) {
+                matvar->data = malloc(matvar->nbytes);
+                if ( NULL != matvar->data ) {
+                    H5Dread(dset_id,Mat_data_type_to_hid_t(matvar->data_type),
+                            H5S_ALL,H5S_ALL,H5P_DEFAULT,matvar->data);
+                }
             }
+            H5Dclose(dset_id);
             break;
         case MAT_C_STRUCT:
         {
@@ -20145,13 +20567,6 @@
             matvar_t **cells;
             int i,ncells = 0;
 
-            if ( NULL != matvar->internal->hdf5_name ) {
-                dset_id = H5Dopen(fid,matvar->internal->hdf5_name,H5P_DEFAULT);
-            } else {
-                dset_id = matvar->internal->id;
-                H5Iinc_ref(dset_id);
-            }
-
             ncells = matvar->nbytes / matvar->data_size;
             cells  = (matvar_t**)matvar->data;
 
@@ -20176,7 +20591,7 @@
             if ( H5Lexists(dset_id,"ir",H5P_DEFAULT) ) {
                 sparse_dset_id = H5Dopen(dset_id,"ir",H5P_DEFAULT);
                 space_id = H5Dget_space(sparse_dset_id);
-                H5Sget_simple_extent_dims(space_id,dims,NULL);
+                (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
                 sparse_data->nir = dims[0];
                 sparse_data->ir = (int*)malloc(sparse_data->nir*
                                          sizeof(*sparse_data->ir));
@@ -20189,7 +20604,7 @@
             if ( H5Lexists(dset_id,"jc",H5P_DEFAULT) ) {
                 sparse_dset_id = H5Dopen(dset_id,"jc",H5P_DEFAULT);
                 space_id = H5Dget_space(sparse_dset_id);
-                H5Sget_simple_extent_dims(space_id,dims,NULL);
+                (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
                 sparse_data->njc = dims[0];
                 sparse_data->jc = (int*)malloc(sparse_data->njc*
                                          sizeof(*sparse_data->jc));
@@ -20203,7 +20618,7 @@
                 size_t ndata_bytes;
                 sparse_dset_id = H5Dopen(dset_id,"data",H5P_DEFAULT);
                 space_id = H5Dget_space(sparse_dset_id);
-                H5Sget_simple_extent_dims(space_id,dims,NULL);
+                (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
                 sparse_data->nzmax = dims[0];
                 sparse_data->ndata = dims[0];
                 matvar->data_size  = sizeof(mat_sparse_t);
@@ -20211,7 +20626,7 @@
 
                 ndata_bytes = sparse_data->nzmax*Mat_SizeOf(matvar->data_type);
                 if ( !matvar->isComplex ) {
-                    sparse_data->data  = malloc(ndata_bytes);
+                    sparse_data->data = malloc(ndata_bytes);
                     if ( NULL != sparse_data->data ) {
                         H5Dread(sparse_dset_id,
                                 Mat_data_type_to_hid_t(matvar->data_type),
@@ -20219,27 +20634,26 @@
                     }
                 } else {
                     mat_complex_split_t *complex_data;
-                    hid_t h5_complex_base,h5_complex;
+                    hid_t h5_complex_base, h5_complex;
 
-                    complex_data     = (mat_complex_split_t*)malloc(sizeof(*complex_data));
-                    complex_data->Re = malloc(ndata_bytes);
-                    complex_data->Im = malloc(ndata_bytes);
+                    complex_data = ComplexMalloc(ndata_bytes);
+                    if ( NULL != complex_data ) {
+                        h5_complex_base = Mat_data_type_to_hid_t(matvar->data_type);
+                        h5_complex      = H5Tcreate(H5T_COMPOUND,
+                                                    H5Tget_size(h5_complex_base));
+                        H5Tinsert(h5_complex,"real",0,h5_complex_base);
+                        H5Dread(sparse_dset_id,h5_complex,H5S_ALL,H5S_ALL,
+                                H5P_DEFAULT,complex_data->Re);
+                        H5Tclose(h5_complex);
 
-                    h5_complex_base = Mat_data_type_to_hid_t(matvar->data_type);
-                    h5_complex      = H5Tcreate(H5T_COMPOUND,
-                                                H5Tget_size(h5_complex_base));
-                    H5Tinsert(h5_complex,"real",0,h5_complex_base);
-                    H5Dread(sparse_dset_id,h5_complex,H5S_ALL,H5S_ALL,
-                            H5P_DEFAULT,complex_data->Re);
-                    H5Tclose(h5_complex);
-
-                    h5_complex      = H5Tcreate(H5T_COMPOUND,
-                                                H5Tget_size(h5_complex_base));
-                    H5Tinsert(h5_complex,"imag",0,h5_complex_base);
-                    H5Dread(sparse_dset_id,h5_complex,H5S_ALL,H5S_ALL,
-                            H5P_DEFAULT,complex_data->Im);
-                    H5Tclose(h5_complex);
-                    sparse_data->data = complex_data;
+                        h5_complex      = H5Tcreate(H5T_COMPOUND,
+                                                    H5Tget_size(h5_complex_base));
+                        H5Tinsert(h5_complex,"imag",0,h5_complex_base);
+                        H5Dread(sparse_dset_id,h5_complex,H5S_ALL,H5S_ALL,
+                                H5P_DEFAULT,complex_data->Im);
+                        H5Tclose(h5_complex);
+                        sparse_data->data = complex_data;
+                    }
                 }
                 H5Sclose(space_id);
                 H5Dclose(sparse_dset_id);
@@ -20251,6 +20665,7 @@
         case MAT_C_EMPTY:
         case MAT_C_FUNCTION:
         case MAT_C_OBJECT:
+        case MAT_C_OPAQUE:
             break;
     }
 }
@@ -20311,7 +20726,7 @@
                 H5Iinc_ref(ref_id);
             }
             if ( 0 < matvar->internal->hdf5_ref ) {
-                dset_id = H5Rdereference(ref_id,H5R_OBJECT,&matvar->internal->hdf5_ref);
+                dset_id = H5RDEREFERENCE(ref_id,H5R_OBJECT,&matvar->internal->hdf5_ref);
             } else {
                 dset_id = ref_id;
                 H5Iinc_ref(dset_id);
@@ -20326,7 +20741,7 @@
                         mem_space,dset_space,H5P_DEFAULT,data);
             } else {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
-                hid_t h5_complex_base,h5_complex;
+                hid_t h5_complex_base, h5_complex;
 
                 h5_complex_base = Mat_class_type_to_hid_t(matvar->class_type);
                 h5_complex      = H5Tcreate(H5T_COMPOUND,
@@ -20436,7 +20851,7 @@
                         mem_space,dset_space,H5P_DEFAULT,data);
             } else {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
-                hid_t h5_complex_base,h5_complex;
+                hid_t h5_complex_base, h5_complex;
 
                 h5_complex_base = Mat_class_type_to_hid_t(matvar->class_type);
                 h5_complex      = H5Tcreate(H5T_COMPOUND,
@@ -20482,7 +20897,7 @@
     herr_t  herr;
     struct mat_read_next_iter_data mat_data;
 
-    if( mat == NULL )
+    if ( mat == NULL )
         return NULL;
 
     if ( mat->next_index >= mat->num_datasets )
@@ -20494,7 +20909,7 @@
     mat_data.matvar = NULL;
     herr = H5Literate(fid, H5_INDEX_NAME, H5_ITER_NATIVE, &idx, Mat_VarReadNextInfoIterate, (void*)&mat_data);
     if ( herr > 0 )
-        mat->next_index = (long)idx;
+        mat->next_index = (size_t)idx;
     return mat_data.matvar;
 }
 
@@ -20508,8 +20923,8 @@
 
     /* FIXME: follow symlinks, datatypes? */
 
-    /* Check that this is not the /#refs# group */
-    if ( 0 == strcmp(name, "#refs#") )
+    /* Check that this is not the /#refs# or /"#subsystem#" group */
+    if ( 0 == strcmp(name, "#refs#") || 0 == strcmp(name, "#subsystem#") )
         return 0;
 
     H5Oget_info_by_name(fid, name, &object_info, H5P_DEFAULT);
@@ -20517,7 +20932,7 @@
         return 0;
 
     mat_data = (struct mat_read_next_iter_data *)op_data;
-    if (mat_data == NULL )
+    if ( mat_data == NULL )
         return -1;
     mat = mat_data->mat;
     matvar = mat_data->matvar;
@@ -20536,9 +20951,7 @@
     switch ( object_info.type ) {
         case H5O_TYPE_DATASET:
         {
-            ssize_t     name_len;
-            /* FIXME */
-            hsize_t  dims[10];
+            ssize_t name_len;
             hid_t   attr_id,type_id,dset_id,space_id;
 
             dset_id = H5Dopen(fid,matvar->name,H5P_DEFAULT);
@@ -20558,10 +20971,19 @@
             matvar->rank = H5Sget_simple_extent_ndims(space_id);
             matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
             if ( NULL != matvar->dims ) {
-                int k;
-                H5Sget_simple_extent_dims(space_id,dims,NULL);
-                for ( k = 0; k < matvar->rank; k++ )
-                    matvar->dims[k] = dims[matvar->rank - k - 1];
+                hsize_t* dims = (hsize_t*)malloc(matvar->rank*sizeof(hsize_t));
+                if ( NULL != dims ) {
+                    int k;
+                    (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
+                    for ( k = 0; k < matvar->rank; k++ )
+                        matvar->dims[k] = dims[matvar->rank - k - 1];
+                    free(dims);
+                    H5Sclose(space_id);
+                } else {
+                    H5Sclose(space_id);
+                    Mat_Critical("Error allocating memory for dims");
+                    return -1;
+                }
             } else {
                 H5Sclose(space_id);
                 Mat_VarFree(matvar);
@@ -20568,7 +20990,6 @@
                 Mat_Critical("Error allocating memory for matvar->dims");
                 return -1;
             }
-            H5Sclose(space_id);
 
             Mat_H5ReadClassType(matvar,dset_id);
 
@@ -20618,18 +21039,15 @@
 
                 if ( ncells ) {
                     ref_ids = (hobj_ref_t*)malloc(ncells*sizeof(*ref_ids));
-                    H5Dread(dset_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,H5P_DEFAULT,
-                            ref_ids);
+                    H5Dread(dset_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,H5P_DEFAULT,ref_ids);
                     for ( i = 0; i < ncells; i++ ) {
                         hid_t ref_id;
                         cells[i] = Mat_VarCalloc();
                         cells[i]->internal->hdf5_ref = ref_ids[i];
-                        /* Closing of ref_id is done in
-                         * Mat_H5ReadNextReferenceInfo
-                         */
-                        ref_id = H5Rdereference(dset_id,H5R_OBJECT,ref_ids+i);
-                        cells[i]->internal->id=ref_id;
-                        cells[i]->internal->fp=matvar->internal->fp;
+                        /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */
+                        ref_id = H5RDEREFERENCE(dset_id,H5R_OBJECT,ref_ids+i);
+                        cells[i]->internal->id = ref_id;
+                        cells[i]->internal->fp = matvar->internal->fp;
                         Mat_H5ReadNextReferenceInfo(ref_id,cells[i],mat);
                     }
                     free(ref_ids);
Index: Modelica/Resources/C-Sources/ModelicaMatIO.h
===================================================================
--- Modelica/Resources/C-Sources/ModelicaMatIO.h	(revision 10440)
+++ Modelica/Resources/C-Sources/ModelicaMatIO.h	(working copy)
@@ -1,6 +1,6 @@
 /* ModelicaMatIO.h - MAT file I/O functions header
 
-   Copyright (C) 2013-2016, Christopher C. Hulbert, Modelica Association, and ITI GmbH
+   Copyright (C) 2013-2017, Christopher C. Hulbert, Modelica Association, and ESI ITI GmbH
    Copyright (C) 2005-2013, Christopher C. Hulbert
    All rights reserved.
 
@@ -34,8 +34,8 @@
    matio_pubconf.h
 */
 
-#ifndef MODELICAMATIO_H
-#define MODELICAMATIO_H
+#ifndef MODELICA_MATIO_H_
+#define MODELICA_MATIO_H_
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -50,13 +50,13 @@
 #define MATIO_MINOR_VERSION 5
 
 /* Matio release level number */
-#define MATIO_RELEASE_LEVEL 6
+#define MATIO_RELEASE_LEVEL 10
 
 /* Matio version number */
-#define MATIO_VERSION 156
+#define MATIO_VERSION 1510
 
 /* Matio version string */
-#define MATIO_VERSION_STR "1.5.6"
+#define MATIO_VERSION_STR "1.5.10"
 
 /* Default file format */
 #define MAT_FT_DEFAULT MAT_FT_MAT5
@@ -63,9 +63,15 @@
 
 /* Have MAT int64 / uint64 */
 #if defined(_WIN32)
-#if defined(_MSC_VER) || defined(__WATCOMC__) || defined(__MINGW32__) || defined(__CYGWIN__)
+#if defined(__WATCOMC__) || defined(__MINGW32__) || defined(__CYGWIN__)
 #define HAVE_MATIO_INT64_T 1
 #define HAVE_MATIO_UINT64_T 1
+#elif defined(_MSC_VER) && _MSC_VER > 1300
+#define HAVE_MATIO_INT64_T 1
+#define HAVE_MATIO_UINT64_T 1
+#elif defined(_MSC_VER)
+#define HAVE_MATIO_INT64_T 1
+#undef HAVE_MATIO_UINT64_T
 #else
 #undef HAVE_MATIO_INT64_T
 #undef HAVE_MATIO_UINT64_T
@@ -129,9 +135,9 @@
 #include <stdarg.h>
 
 #if defined(__cplusplus)
-#define EXTERN extern "C"
+#define MATIO_EXTERN extern "C"
 #else
-#define EXTERN
+#define MATIO_EXTERN
 #endif
 
 /** @defgroup MAT Matlab MAT File I/O Library */
@@ -166,7 +172,7 @@
  * Matlab data types
  */
 enum matio_types {
-    MAT_T_UNKNOWN    =  0,    /**< @brief UNKNOWN data type                    */
+    MAT_T_UNKNOWN    =  0,    /**< @brief UNKNOWN data type                   */
     MAT_T_INT8       =  1,    /**< @brief 8-bit signed integer data type      */
     MAT_T_UINT8      =  2,    /**< @brief 8-bit unsigned integer data type    */
     MAT_T_INT16      =  3,    /**< @brief 16-bit signed integer data type     */
@@ -179,9 +185,9 @@
     MAT_T_UINT64     = 13,    /**< @brief 64-bit unsigned integer data type   */
     MAT_T_MATRIX     = 14,    /**< @brief matrix data type                    */
     MAT_T_COMPRESSED = 15,    /**< @brief compressed data type                */
-    MAT_T_UTF8       = 16,    /**< @brief 8-bit unicode text data type        */
-    MAT_T_UTF16      = 17,    /**< @brief 16-bit unicode text data type       */
-    MAT_T_UTF32      = 18,    /**< @brief 32-bit unicode text data type       */
+    MAT_T_UTF8       = 16,    /**< @brief 8-bit Unicode text data type        */
+    MAT_T_UTF16      = 17,    /**< @brief 16-bit Unicode text data type       */
+    MAT_T_UTF32      = 18,    /**< @brief 32-bit Unicode text data type       */
 
     MAT_T_STRING     = 20,    /**< @brief String data type                    */
     MAT_T_CELL       = 21,    /**< @brief Cell array data type                */
@@ -212,7 +218,8 @@
     MAT_C_UINT32   = 13, /**< @brief Matlab unsigned 32-bit integer class  */
     MAT_C_INT64    = 14, /**< @brief Matlab signed 64-bit integer class    */
     MAT_C_UINT64   = 15, /**< @brief Matlab unsigned 64-bit integer class  */
-    MAT_C_FUNCTION = 16  /**< @brief Matlab function class                 */
+    MAT_C_FUNCTION = 16, /**< @brief Matlab function class                 */
+    MAT_C_OPAQUE   = 17  /**< @brief Matlab opaque class                   */
 };
 
 /** @brief Matlab array flags
@@ -275,9 +282,9 @@
 typedef struct matvar_t {
     size_t nbytes;                    /**< Number of bytes for the MAT variable */
     int    rank;                      /**< Rank (Number of dimensions) of the data */
-    enum matio_types   data_type;     /**< Data type(MAT_T_*) */
+    enum matio_types   data_type;     /**< Data type (MAT_T_*) */
     int   data_size;                  /**< Bytes / element for the data */
-    enum matio_classes class_type;    /**< Class type in Matlab(MAT_C_DOUBLE, etc) */
+    enum matio_classes class_type;    /**< Class type in Matlab (MAT_C_DOUBLE, etc) */
     int   isComplex;                  /**< non-zero if the data is complex, 0 if real */
     int   isGlobal;                   /**< non-zero if the variable is global */
     int   isLogical;                  /**< non-zero if the variable is logical */
@@ -310,80 +317,81 @@
 } mat_sparse_t;
 
 /* Library function */
-EXTERN void Mat_GetLibraryVersion(int *major,int *minor,int *release);
+MATIO_EXTERN void Mat_GetLibraryVersion(int *major,int *minor,int *release);
 
-/*     io.c         */
-EXTERN char  *strdup_vprintf(const char *format, va_list ap);
-EXTERN char  *strdup_printf(const char *format, ...);
-EXTERN void   Mat_Critical( const char *format, ... );
-EXTERN void   Mat_Warning( const char *format, ... );
-EXTERN size_t Mat_SizeOf(enum matio_types data_type);
-EXTERN size_t Mat_SizeOfClass(int class_type);
+/* io.c */
+MATIO_EXTERN char  *strdup_vprintf(const char *format, va_list ap);
+MATIO_EXTERN char  *strdup_printf(const char *format, ...);
+MATIO_EXTERN void   Mat_Critical( const char *format, ... );
+MATIO_EXTERN void   Mat_Warning( const char *format, ... );
+MATIO_EXTERN size_t Mat_SizeOf(enum matio_types data_type);
+MATIO_EXTERN size_t Mat_SizeOfClass(int class_type);
 
-/*   MAT File functions   */
-#define            Mat_Create(a,b) Mat_CreateVer(a,b,MAT_FT_DEFAULT)
-EXTERN mat_t      *Mat_CreateVer(const char *matname,const char *hdr_str,
-                       enum mat_ft mat_file_ver);
-EXTERN int         Mat_Close(mat_t *mat);
-EXTERN mat_t      *Mat_Open(const char *matname,int mode);
-EXTERN const char *Mat_GetFilename(mat_t *matfp);
-EXTERN enum mat_ft Mat_GetVersion(mat_t *matfp);
-EXTERN int         Mat_Rewind(mat_t *mat);
+/* MAT File functions */
+#define                  Mat_Create(a,b) Mat_CreateVer(a,b,MAT_FT_DEFAULT)
+MATIO_EXTERN mat_t      *Mat_CreateVer(const char *matname,const char *hdr_str,
+                             enum mat_ft mat_file_ver);
+MATIO_EXTERN int         Mat_Close(mat_t *mat);
+MATIO_EXTERN mat_t      *Mat_Open(const char *matname,int mode);
+MATIO_EXTERN const char *Mat_GetFilename(mat_t *mat);
+MATIO_EXTERN enum mat_ft Mat_GetVersion(mat_t *mat);
+MATIO_EXTERN char      **Mat_GetDir(mat_t *mat, size_t *n);
+MATIO_EXTERN int         Mat_Rewind(mat_t *mat);
 
 /* MAT variable functions */
-EXTERN matvar_t  *Mat_VarCalloc(void);
-EXTERN matvar_t  *Mat_VarCreate(const char *name,enum matio_classes class_type,
-                      enum matio_types data_type,int rank,size_t *dims,
-                      void *data,int opt);
-EXTERN matvar_t  *Mat_VarCreateStruct(const char *name,int rank,size_t *dims,
-                      const char **fields,unsigned nfields);
-EXTERN int        Mat_VarDelete(mat_t *mat, const char *name);
-EXTERN matvar_t  *Mat_VarDuplicate(const matvar_t *in, int opt);
-EXTERN void       Mat_VarFree(matvar_t *matvar);
-EXTERN matvar_t  *Mat_VarGetCell(matvar_t *matvar,int index);
-EXTERN matvar_t **Mat_VarGetCells(matvar_t *matvar,int *start,int *stride,
-                      int *edge);
-EXTERN matvar_t **Mat_VarGetCellsLinear(matvar_t *matvar,int start,int stride,
-                      int edge);
-EXTERN size_t     Mat_VarGetSize(matvar_t *matvar);
-EXTERN unsigned   Mat_VarGetNumberOfFields(matvar_t *matvar);
-EXTERN int        Mat_VarAddStructField(matvar_t *matvar,const char *fieldname);
-EXTERN char * const *Mat_VarGetStructFieldnames(const matvar_t *matvar);
-EXTERN matvar_t  *Mat_VarGetStructFieldByIndex(matvar_t *matvar,
-                      size_t field_index,size_t index);
-EXTERN matvar_t  *Mat_VarGetStructFieldByName(matvar_t *matvar,
-                      const char *field_name,size_t index);
-EXTERN matvar_t  *Mat_VarGetStructField(matvar_t *matvar,void *name_or_index,
-                      int opt,int index);
-EXTERN matvar_t  *Mat_VarGetStructs(matvar_t *matvar,int *start,int *stride,
-                      int *edge,int copy_fields);
-EXTERN matvar_t  *Mat_VarGetStructsLinear(matvar_t *matvar,int start,int stride,
-                      int edge,int copy_fields);
-EXTERN void       Mat_VarPrint( matvar_t *matvar, int printdata );
-EXTERN matvar_t  *Mat_VarRead(mat_t *mat, const char *name );
-EXTERN int        Mat_VarReadData(mat_t *mat,matvar_t *matvar,void *data,
-                      int *start,int *stride,int *edge);
-EXTERN int        Mat_VarReadDataAll(mat_t *mat,matvar_t *matvar);
-EXTERN int        Mat_VarReadDataLinear(mat_t *mat,matvar_t *matvar,void *data,
-                      int start,int stride,int edge);
-EXTERN matvar_t  *Mat_VarReadInfo( mat_t *mat, const char *name );
-EXTERN matvar_t  *Mat_VarReadNext( mat_t *mat );
-EXTERN matvar_t  *Mat_VarReadNextInfo( mat_t *mat );
-EXTERN matvar_t  *Mat_VarSetCell(matvar_t *matvar,int index,matvar_t *cell);
-EXTERN matvar_t  *Mat_VarSetStructFieldByIndex(matvar_t *matvar,
-                      size_t field_index,size_t index,matvar_t *field);
-EXTERN matvar_t  *Mat_VarSetStructFieldByName(matvar_t *matvar,
-                      const char *field_name,size_t index,matvar_t *field);
-EXTERN int        Mat_VarWrite(mat_t *mat,matvar_t *matvar,
-                      enum matio_compression compress );
-EXTERN int        Mat_VarWriteInfo(mat_t *mat,matvar_t *matvar);
-EXTERN int        Mat_VarWriteData(mat_t *mat,matvar_t *matvar,void *data,
-                      int *start,int *stride,int *edge);
+MATIO_EXTERN matvar_t  *Mat_VarCalloc(void);
+MATIO_EXTERN matvar_t  *Mat_VarCreate(const char *name,enum matio_classes class_type,
+                            enum matio_types data_type,int rank,size_t *dims,
+                            void *data,int opt);
+MATIO_EXTERN matvar_t  *Mat_VarCreateStruct(const char *name,int rank,size_t *dims,
+                            const char **fields,unsigned nfields);
+MATIO_EXTERN int        Mat_VarDelete(mat_t *mat, const char *name);
+MATIO_EXTERN matvar_t  *Mat_VarDuplicate(const matvar_t *in, int opt);
+MATIO_EXTERN void       Mat_VarFree(matvar_t *matvar);
+MATIO_EXTERN matvar_t  *Mat_VarGetCell(matvar_t *matvar,int index);
+MATIO_EXTERN matvar_t **Mat_VarGetCells(matvar_t *matvar,int *start,int *stride,
+                            int *edge);
+MATIO_EXTERN matvar_t **Mat_VarGetCellsLinear(matvar_t *matvar,int start,int stride,
+                            int edge);
+MATIO_EXTERN size_t     Mat_VarGetSize(matvar_t *matvar);
+MATIO_EXTERN unsigned   Mat_VarGetNumberOfFields(matvar_t *matvar);
+MATIO_EXTERN int        Mat_VarAddStructField(matvar_t *matvar,const char *fieldname);
+MATIO_EXTERN char * const *Mat_VarGetStructFieldnames(const matvar_t *matvar);
+MATIO_EXTERN matvar_t  *Mat_VarGetStructFieldByIndex(matvar_t *matvar,
+                            size_t field_index,size_t index);
+MATIO_EXTERN matvar_t  *Mat_VarGetStructFieldByName(matvar_t *matvar,
+                            const char *field_name,size_t index);
+MATIO_EXTERN matvar_t  *Mat_VarGetStructField(matvar_t *matvar,void *name_or_index,
+                            int opt,int index);
+MATIO_EXTERN matvar_t  *Mat_VarGetStructs(matvar_t *matvar,int *start,int *stride,
+                            int *edge,int copy_fields);
+MATIO_EXTERN matvar_t  *Mat_VarGetStructsLinear(matvar_t *matvar,int start,int stride,
+                            int edge,int copy_fields);
+MATIO_EXTERN void       Mat_VarPrint( matvar_t *matvar, int printdata );
+MATIO_EXTERN matvar_t  *Mat_VarRead(mat_t *mat, const char *name );
+MATIO_EXTERN int        Mat_VarReadData(mat_t *mat,matvar_t *matvar,void *data,
+                            int *start,int *stride,int *edge);
+MATIO_EXTERN int        Mat_VarReadDataAll(mat_t *mat,matvar_t *matvar);
+MATIO_EXTERN int        Mat_VarReadDataLinear(mat_t *mat,matvar_t *matvar,void *data,
+                            int start,int stride,int edge);
+MATIO_EXTERN matvar_t  *Mat_VarReadInfo( mat_t *mat, const char *name );
+MATIO_EXTERN matvar_t  *Mat_VarReadNext( mat_t *mat );
+MATIO_EXTERN matvar_t  *Mat_VarReadNextInfo( mat_t *mat );
+MATIO_EXTERN matvar_t  *Mat_VarSetCell(matvar_t *matvar,int index,matvar_t *cell);
+MATIO_EXTERN matvar_t  *Mat_VarSetStructFieldByIndex(matvar_t *matvar,
+                            size_t field_index,size_t index,matvar_t *field);
+MATIO_EXTERN matvar_t  *Mat_VarSetStructFieldByName(matvar_t *matvar,
+                            const char *field_name,size_t index,matvar_t *field);
+MATIO_EXTERN int        Mat_VarWrite(mat_t *mat,matvar_t *matvar,
+                            enum matio_compression compress );
+MATIO_EXTERN int        Mat_VarWriteInfo(mat_t *mat,matvar_t *matvar);
+MATIO_EXTERN int        Mat_VarWriteData(mat_t *mat,matvar_t *matvar,void *data,
+                            int *start,int *stride,int *edge);
 
 /* Other functions */
-EXTERN int       Mat_CalcSingleSubscript(int rank,int *dims,int *subs);
-EXTERN int       Mat_CalcSingleSubscript2(int rank,size_t *dims,size_t *subs,size_t *index);
-EXTERN int      *Mat_CalcSubscripts(int rank,int *dims,int index);
-EXTERN size_t   *Mat_CalcSubscripts2(int rank,size_t *dims,size_t index);
+MATIO_EXTERN int     Mat_CalcSingleSubscript(int rank,int *dims,int *subs);
+MATIO_EXTERN int     Mat_CalcSingleSubscript2(int rank,size_t *dims,size_t *subs,size_t *index);
+MATIO_EXTERN int    *Mat_CalcSubscripts(int rank,int *dims,int index);
+MATIO_EXTERN size_t *Mat_CalcSubscripts2(int rank,size_t *dims,size_t index);
 
 #endif /* MODELICAMATIO_H */
Index: Modelica/Resources/C-Sources/ModelicaRandom.c
===================================================================
--- Modelica/Resources/C-Sources/ModelicaRandom.c	(revision 10440)
+++ Modelica/Resources/C-Sources/ModelicaRandom.c	(working copy)
@@ -1,6 +1,6 @@
 /* ModelicaRandom.c - External functions for Modelica.Math.Random library
 
-   Copyright (C) 2015-2016, Modelica Association and DLR
+   Copyright (C) 2015-2017, Modelica Association and DLR
    All rights reserved.
 
    Redistribution and use in source and binary forms, with or without
@@ -25,19 +25,10 @@
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-/* The functions in this file are non-portable. The following #define's are used
-   to define the system calls of the operating system
+/* Release Notes:
+      Sep. 23, 2016: by Thomas Beutlich, ESI ITI GmbH
+                     Fixed resource leak (ticket #2069)
 
-   _MSC_VER       : Microsoft Visual C++
-   MODELICA_EXPORT: Prefix used for function calls. If not defined, blank is used
-                    Useful definitions:
-                    - "static" that is all functions become static
-                      (useful if file is included with other C-sources for an
-                       embedded system)
-                    - "__declspec(dllexport)" if included in a DLL and the
-                      functions shall be visible outside of the DLL
-
-   Release Notes:
       Oct. 27, 2015: by Thomas Beutlich, ITI GmbH
                      Added nonnull attribute/annotations (ticket #1436)
 
@@ -45,9 +36,7 @@
                      Implemented a first version
 */
 
-#if !defined(MODELICA_EXPORT)
-#   define MODELICA_EXPORT
-#endif
+#include "ModelicaRandom.h"
 
 /* Have RANDOM int64 / uint64 */
 #if defined (_WIN32)
@@ -104,10 +93,11 @@
 #include <limits.h>
 #include <math.h>
 #include <string.h>
+#include "ModelicaInternal.h"
 #include "ModelicaUtilities.h"
 #include "gconstructor.h"
 
-/* The standard way to detect posix is to check _POSIX_VERSION,
+/* The standard way to detect POSIX is to check _POSIX_VERSION,
  * which is defined in <unistd.h>
  */
 #if defined(__unix__) || defined(__linux__) || defined(__APPLE_CC__)
@@ -117,8 +107,8 @@
   #define _POSIX_ 1
 #endif
 
-/* On Posix systems define a mutex using the single static variable "m" */
-#if defined(_POSIX_)
+/* On POSIX systems define a mutex using the single static variable "m" */
+#if defined(_POSIX_) && !defined(NO_MUTEX)
 #include <pthread.h>
 static pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
 #define MUTEX_LOCK() pthread_mutex_lock(&m)
@@ -129,7 +119,7 @@
 #if !defined(WIN32_LEAN_AND_MEAN)
 #define WIN32_LEAN_AND_MEAN
 #endif
-#include <Windows.h>
+#include <windows.h>
 static CRITICAL_SECTION cs;
 #ifdef G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA
 #pragma G_DEFINE_CONSTRUCTOR_PRAGMA_ARGS(initializeCS)
@@ -154,36 +144,6 @@
 #define MUTEX_UNLOCK()
 #endif
 
-/*
- * Non-null pointers need to be passed to external functions.
- *
- * The following macros handle nonnull attributes for GNU C and Microsoft SAL.
- */
-#if defined(__GNUC__)
-#define MODELICA_NONNULLATTR __attribute__((nonnull))
-#else
-#define MODELICA_NONNULLATTR
-#endif
-#if !defined(__ATTR_SAL)
-#define _In_
-#define _Out_
-#endif
-
-MODELICA_EXPORT void ModelicaRandom_xorshift64star(_In_ int state_in[],
-    _Out_ int state_out[], _Out_ double* y) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaRandom_xorshift128plus(_In_ int state_in[],
-    _Out_ int state_out[], _Out_ double* y) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaRandom_xorshift1024star(_In_ int state_in[],
-    _Out_ int state_out[], _Out_ double* y) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaRandom_setInternalState_xorshift1024star(
-    _In_ int* state, size_t nState, int id) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaRandom_convertRealToIntegers(double d,
-    _Out_ int i[]) MODELICA_NONNULLATTR;
-void ModelicaInternal_getTime(_Out_ int* ms, _Out_ int* sec,
-    _Out_ int* min, _Out_ int* hour, _Out_ int* mday, _Out_ int* mon,
-    _Out_ int* year) MODELICA_NONNULLATTR;
-int ModelicaInternal_getpid(void);
-
 /* XORSHIFT ALGORITHMS */
 
 /* For details see http://xorshift.di.unimi.it/
@@ -209,7 +169,8 @@
 #define ModelicaRandom_INVM64 5.42101086242752217004e-20 /* = 2^(-64) */
 #define ModelicaRandom_RAND(INT64) ( (int64_t)(INT64) * ModelicaRandom_INVM64 + 0.5 )
 
-MODELICA_EXPORT void ModelicaRandom_xorshift64star(int state_in[], int state_out[], double* y) {
+void ModelicaRandom_xorshift64star(_In_ int* state_in,
+                                   _Out_ int* state_out, _Out_ double* y) {
     /*  xorshift64* random number generator.
         For details see http://xorshift.di.unimi.it/
 
@@ -258,7 +219,8 @@
     *y = ModelicaRandom_RAND(x);
 }
 
-MODELICA_EXPORT void ModelicaRandom_xorshift128plus(int state_in[], int state_out[], double* y) {
+void ModelicaRandom_xorshift128plus(_In_ int* state_in,
+                                    _Out_ int* state_out, _Out_ double* y) {
     /*  xorshift128+ random number generator.
         For details see http://xorshift.di.unimi.it
         Arguments seed and newSeed must be int32_t vectors with at least 4 elements each.
@@ -359,7 +321,8 @@
 #endif
 }
 
-MODELICA_EXPORT void ModelicaRandom_xorshift1024star(int state_in[], int state_out[], double* y) {
+void ModelicaRandom_xorshift1024star(_In_ int* state_in,
+                                     _Out_ int* state_out, _Out_ double* y) {
     /*  xorshift1024* random number generator.
         For details see http://xorshift.di.unimi.it
 
@@ -418,7 +381,8 @@
 static int ModelicaRandom_p;
 static int ModelicaRandom_id = 0;
 
-MODELICA_EXPORT void ModelicaRandom_setInternalState_xorshift1024star(int* state, size_t nState, int id) {
+void ModelicaRandom_setInternalState_xorshift1024star(_In_ int* state,
+                                                      size_t nState, int id) {
     /* Receive the external states from Modelica */
     union s_tag {
         int32_t  s32[2];
@@ -440,7 +404,7 @@
     MUTEX_UNLOCK();
 }
 
-MODELICA_EXPORT double ModelicaRandom_impureRandom_xorshift1024star(int id) {
+double ModelicaRandom_impureRandom_xorshift1024star(int id) {
     /* xorshift1024* random number generator (same as above, but with internal state, instead of external one).
        For details see http://xorshift.di.unimi.it
 
@@ -463,21 +427,23 @@
        a 64-bit seed,  we suggest to seed a xorshift64* generator and use its
        output to fill s. */
 
-    double y;
-
     MUTEX_LOCK();
     /* Check that ModelicaRandom_initializeImpureRandome_xorshift1024star was called before */
     if ( id != ModelicaRandom_id ) {
+        MUTEX_UNLOCK();
         ModelicaError("Function impureRandom not initialized with function initializeImpureRandom\n");
+        return 0;
     }
-
-    /* Compute random number */
-    ModelicaRandom_xorshift1024star_internal(ModelicaRandom_s, &ModelicaRandom_p, &y);
-    MUTEX_UNLOCK();
-    return y;
+    else {
+        /* Compute random number */
+        double y;
+        ModelicaRandom_xorshift1024star_internal(ModelicaRandom_s, &ModelicaRandom_p, &y);
+        MUTEX_UNLOCK();
+        return y;
+    }
 }
 
-MODELICA_EXPORT int ModelicaRandom_automaticGlobalSeed(double dummy) {
+int ModelicaRandom_automaticGlobalSeed(double dummy) {
     /* Creates an automatic integer seed (typically from the current time and process id) */
 
     int ms, sec, min, hour, mday, mon, year;
@@ -497,7 +463,7 @@
     return seed;
 }
 
-MODELICA_EXPORT void ModelicaRandom_convertRealToIntegers(double d, int i[]) {
+void ModelicaRandom_convertRealToIntegers(double d, _Out_ int* i) {
     /* Cast a double to two integers */
     union d2i {
         double d;
Index: Modelica/Resources/C-Sources/ModelicaRandom.h
===================================================================
--- Modelica/Resources/C-Sources/ModelicaRandom.h	(nonexistent)
+++ Modelica/Resources/C-Sources/ModelicaRandom.h	(working copy)
@@ -0,0 +1,78 @@
+/* ModelicaRandom.h - External functions header for Modelica.Math.Random library
+
+   Copyright (C) 2015-2017, Modelica Association and DLR
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   1. Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/* The following #define's are available.
+
+   NO_MUTEX       : Pthread mutex is not present (e.g. on dSPACE)
+   MODELICA_EXPORT: Prefix used for function calls. If not defined, blank is used
+                    Useful definition:
+                    - "__declspec(dllexport)" if included in a DLL and the
+                      functions shall be visible outside of the DLL
+*/
+
+#ifndef MODELICA_RANDOM_H_
+#define MODELICA_RANDOM_H_
+
+#include <stdlib.h>
+
+#if !defined(MODELICA_EXPORT)
+#if defined(__cplusplus)
+#define MODELICA_EXPORT extern "C"
+#else
+#define MODELICA_EXPORT
+#endif
+#endif
+
+/*
+ * Non-null pointers need to be passed to external functions.
+ *
+ * The following macros handle nonnull attributes for GNU C and Microsoft SAL.
+ */
+#if defined(__GNUC__)
+#define MODELICA_NONNULLATTR __attribute__((nonnull))
+#else
+#define MODELICA_NONNULLATTR
+#endif
+#if !defined(__ATTR_SAL)
+#define _In_
+#define _Out_
+#endif
+
+MODELICA_EXPORT void ModelicaRandom_xorshift64star(_In_ int* state_in,
+    _Out_ int* state_out, _Out_ double* y) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaRandom_xorshift128plus(_In_ int* state_in,
+    _Out_ int* state_out, _Out_ double* y) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaRandom_xorshift1024star(_In_ int* state_in,
+    _Out_ int* state_out, _Out_ double* y) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaRandom_setInternalState_xorshift1024star(
+    _In_ int* state, size_t nState, int id) MODELICA_NONNULLATTR;
+MODELICA_EXPORT double ModelicaRandom_impureRandom_xorshift1024star(int id);
+MODELICA_EXPORT int ModelicaRandom_automaticGlobalSeed(double dummy);
+MODELICA_EXPORT void ModelicaRandom_convertRealToIntegers(double d,
+    _Out_ int* i) MODELICA_NONNULLATTR;
+
+#endif
Index: Modelica/Resources/C-Sources/ModelicaStandardTables.c
===================================================================
--- Modelica/Resources/C-Sources/ModelicaStandardTables.c	(revision 10440)
+++ Modelica/Resources/C-Sources/ModelicaStandardTables.c	(working copy)
@@ -1,6 +1,6 @@
 /* ModelicaStandardTables.c - External table functions
 
-   Copyright (C) 2013-2016, Modelica Association, DLR, and ITI GmbH
+   Copyright (C) 2013-2017, Modelica Association, DLR, and ESI ITI GmbH
    All rights reserved.
 
    Redistribution and use in source and binary forms, with or without
@@ -33,19 +33,50 @@
       Modelica.Blocks.Tables.CombiTable1Ds
       Modelica.Blocks.Tables.CombiTable2D
 
-   The following #define's are available.
+   Release Notes:
+      Aug. 25, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added support for extrapolation in CombiTable2D (ticket #1839)
 
-   NO_FILE_SYSTEM        : A file system is not present (e.g. on dSPACE or xPC).
-   DEBUG_TIME_EVENTS     : Trace time events of CombiTimeTable
-   DUMMY_FUNCTION_USERTAB: Use a dummy function "usertab"
-   NO_TABLE_COPY         : Do not copy table data passed to _init functions
-                           This is a potentially unsafe optimization (ticket #1143).
-   TABLE_SHARE           : If NO_FILE_SYTEM is not defined then common/shared table
-                           arrays are stored in a global hash table in order to
-                           avoid superfluous file input access and to decrease the
-                           utilized memory (tickets #1110 and #1550).
+      Apr. 24, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added functions to retrieve minimum and maximum abscissa
+                     values of CombiTable2D (ticket #2244)
 
-   Release Notes:
+      Apr. 15, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added support for time event generation (independent of
+                     smoothness) in CombiTimeTable (ticket #2080)
+
+      Apr. 11, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Revised initialization of CombiTimeTable, CombiTable1D
+                     and CombiTable2D (ticket #1899)
+                     - Already read table in the initialization functions
+                     - Removed the implementation of the read functions
+
+      Apr. 07, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added support for shift time (independent of start time)
+                     in CombiTimeTable (ticket #1771)
+
+      Apr. 05, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Fixed extrapolation of CombiTimeTable if simulation start
+                     time equals the maximum time of the table (ticket #2233)
+
+      Mar. 08, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Moved file I/O functions to ModelicaIO (ticket #2192)
+
+      Feb. 26, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Fixed definition of uthash_fatal, called by HASH_ADD_KEYPTR
+                     in function readTable (ticket #2097)
+
+      Feb. 25, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added support for extrapolation in CombiTable1D (ticket #1839)
+                     Added functions to retrieve minimum and maximum abscissa
+                     values of CombiTable1D (ticket #2120)
+
+      Aug. 10, 2016: by Thomas Beutlich, ESI ITI GmbH
+                     Fixed event detection of CombiTimeTable for restarted
+                     simulation (ticket #2040)
+                     Fixed tracing time events (DEBUG_TIME_EVENTS) of CombiTimeTable
+                     for negative simulation time
+
       Dec. 16, 2015: by Thomas Beutlich, ITI GmbH
                      Added univariate Steffen-spline interpolation (ticket #1814)
 
@@ -93,6 +124,8 @@
 
       May 21, 2014:  by Thomas Beutlich, ITI GmbH
                      Fixed bivariate Akima-spline extrapolation (ticket #1465)
+                     Improved error message in case of trailing numbers when parsing
+                     a line of an external ASCII text file (ticket #1494)
 
       Oct. 17, 2013: by Thomas Beutlich, ITI GmbH
                      Added support of 2D tables that actually degrade to 1D tables
@@ -107,27 +140,21 @@
                      Implemented a first version
 */
 
-#if defined(__gnu_linux__) && !defined(NO_FILE_SYSTEM)
-#define _GNU_SOURCE 1
-#endif
 #include "ModelicaStandardTables.h"
+#include "ModelicaIO.h"
 #include "ModelicaUtilities.h"
-#if !defined(NO_FILE_SYSTEM)
-#include <stdio.h>
-#include <locale.h>
-#include "ModelicaMatIO.h"
-#if defined(TABLE_SHARE)
-#define uthash_fatal(msg) ModelicaFormatMessage("Error: %s\n", msg); break
+#if defined(TABLE_SHARE) && !defined(NO_FILE_SYSTEM)
+#define uthash_strlen(s) key_strlen(s)
 #include "uthash.h"
+#undef uthash_fatal /* Ensure that nowhere in this file uses uthash_fatal by accident */
 #include "gconstructor.h"
 #endif
-#endif
 #include <float.h>
 #include <math.h>
 #include <string.h>
 
-#if defined(TABLE_SHARE) && !defined(NO_FILE_SYSTEM)
-/* The standard way to detect posix is to check _POSIX_VERSION,
+#if !defined(NO_FILE_SYSTEM)
+/* The standard way to detect POSIX is to check _POSIX_VERSION,
  * which is defined in <unistd.h>
  */
 #if defined(__unix__) || defined(__linux__) || defined(__APPLE_CC__)
@@ -156,6 +183,13 @@
     NO_EXTRAPOLATION
 };
 
+enum TimeEvents {
+    UNDEFINED = 0,
+    ALWAYS,
+    AT_DISCONT,
+    NO_TIMEEVENTS
+};
+
 /* ----- Internal enumerations ----- */
 
 enum PointInterval {
@@ -183,8 +217,7 @@
 typedef size_t Interval[2];
 
 typedef struct CombiTimeTable {
-    char* fileName; /* Name of table file */
-    char* tableName; /* Name of table */
+    char* key; /* Key consisting of concatenated names of file and table */
     double* table; /* Table values */
     size_t nRow; /* Number of rows of table */
     size_t nCol; /* Number of columns of table */
@@ -192,9 +225,11 @@
     enum Smoothness smoothness; /* Smoothness kind */
     enum Extrapolation extrapolation; /* Extrapolation kind */
     enum TableSource source; /* Source kind */
+    enum TimeEvents timeEvents; /* Kind of time event handling */
     int* cols; /* Columns of table to be interpolated */
     size_t nCols; /* Number of columns of table to be interpolated */
-    double startTime; /* Start time of interpolation */
+    double startTime; /* Start time of inter-/extrapolation */
+    double shiftTime; /* Shift time of first table column */
     CubicHermite1D* spline; /* Pre-calculated cubic Hermite spline coefficients,
         only used if smoothness is AKIMA_C1 or
         FRITSCH_BUTLAND_MONOTONE_C1 or STEFFEN_MONOTONE_C1 */
@@ -212,13 +247,13 @@
 } CombiTimeTable;
 
 typedef struct CombiTable1D {
-    char* fileName; /* Name of table file */
-    char* tableName; /* Name of table */
+    char* key; /* Key consisting of concatenated names of file and table */
     double* table; /* Table values */
     size_t nRow; /* Number of rows of table */
     size_t nCol; /* Number of columns of table */
     size_t last; /* Last accessed row index of table */
     enum Smoothness smoothness; /* Smoothness kind */
+    enum Extrapolation extrapolation; /* Extrapolation kind */
     enum TableSource source; /* Source kind */
     int* cols; /* Columns of table to be interpolated */
     size_t nCols; /* Number of columns of table to be interpolated */
@@ -228,8 +263,7 @@
 } CombiTable1D;
 
 typedef struct CombiTable2D {
-    char* fileName; /* Name of table file */
-    char* tableName; /* Name of table */
+    char* key; /* Key consisting of concatenated names of file and table */
     double* table; /* Table values */
     size_t nRow; /* Number of rows of table */
     size_t nCol; /* Number of columns of table */
@@ -236,6 +270,7 @@
     size_t last1; /* Last accessed row index of table */
     size_t last2; /* Last accessed column index of table */
     enum Smoothness smoothness; /* Smoothness kind */
+    enum Extrapolation extrapolation; /* Extrapolation kind */
     enum TableSource source; /* Source kind */
     CubicHermite2D* spline; /* Pre-calculated cubic Hermite spline coefficients,
         only used if smoothness is AKIMA_C1 */
@@ -243,9 +278,12 @@
 
 /* ----- Internal constants ----- */
 
+#if !defined(_EPSILON)
 #define _EPSILON (1e-10)
+#endif
+#if !defined(MAX_TABLE_DIMENSIONS)
 #define MAX_TABLE_DIMENSIONS (3)
-#define LINE_BUFFER_LENGTH (64)
+#endif
 
 /* ----- Internal shortcuts ----- */
 
@@ -255,19 +293,33 @@
 #define TABLE_COL0(i) table[(i)*nCol]
 
 #define LINEAR(u, u0, u1, y0, y1) \
-    y = (y0) + ((y1) - (y0))*((u) - (u0))/((u1) - (u0));
+do {\
+    y = (y0) + ((y1) - (y0))*((u) - (u0))/((u1) - (u0)); \
+} while(0)
 /*
 LINEAR(u0, ...) -> y0
 LINEAR(u1, ...) -> y1
 */
 
-#define LINEAR_SLOPE(y0, dy_du, du) ((y0) + (dy_du)*(du))
+#define LINEAR_SLOPE(y0, dy_du, du) \
+do {\
+    y = (y0) + (dy_du)*(du); \
+} while(0)
 
-#define BILINEAR(u1, u2, u10, u11, u20, u21, y00, y01, y10, y11) {\
+#define BILINEAR(u1, u2) \
+do {\
+    const double u10 = TABLE_COL0(last1 + 1); \
+    const double u11 = TABLE_COL0(last1 + 2); \
+    const double u20 = TABLE_ROW0(last2 + 1); \
+    const double u21 = TABLE_ROW0(last2 + 2); \
+    const double y00 = TABLE(last1 + 1, last2 + 1); \
+    const double y01 = TABLE(last1 + 1, last2 + 2); \
+    const double y10 = TABLE(last1 + 2, last2 + 1); \
+    const double y11 = TABLE(last1 + 2, last2 + 2); \
     const double tmp = ((u2) - (u20))/((u20) - (u21)); \
     y = (y00) + tmp*((y00) - (y01)) + ((u1) - (u10))/((u10) - (u11))* \
         ((1 + tmp)*((y00) - (y10)) + tmp*((y11) - (y01))); \
-}
+} while(0)
 /*
 BILINEAR(u10, u20, ...) -> y00
 BILINEAR(u10, u21, ...) -> y01
@@ -275,9 +327,27 @@
 BILINEAR(u11, u21, ...) -> y11
 */
 
+#define BILINEAR_DER(u1, u2) \
+do {\
+    const double u10 = TABLE_COL0(last1 + 1); \
+    const double u11 = TABLE_COL0(last1 + 2); \
+    const double u20 = TABLE_ROW0(last2 + 1); \
+    const double u21 = TABLE_ROW0(last2 + 2); \
+    const double y00 = TABLE(last1 + 1, last2 + 1); \
+    const double y01 = TABLE(last1 + 1, last2 + 2); \
+    const double y10 = TABLE(last1 + 2, last2 + 1); \
+    const double y11 = TABLE(last1 + 2, last2 + 2); \
+    der_y = (u21*(y10 - y00) + u20*(y01 - y11) + \
+        u2*(y00 - y01 - y10 + y11))*der_u1; \
+    der_y += (u11*(y01 - y00) + u10*(y10 - y11) + \
+        u1*(y00 - y01 - y10 + y11))*der_u2; \
+    der_y /= (u10 - u11); \
+    der_y /= (u20 - u21); \
+} while(0)
+
 #if defined(TABLE_SHARE) && !defined(NO_FILE_SYSTEM)
 typedef struct TableShare {
-    char* key; /* Key consisting of concatenated names of table and file */
+    char* key; /* Key consisting of concatenated names of file and table */
     size_t refCount; /* Reference counter */
     size_t nRow; /* Number of rows of table */
     size_t nCol; /* Number of columns of table */
@@ -313,7 +383,7 @@
 #if !defined(WIN32_LEAN_AND_MEAN)
 #define WIN32_LEAN_AND_MEAN
 #endif
-#include <Windows.h>
+#include <windows.h>
 static CRITICAL_SECTION cs;
 #ifdef G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA
 #pragma G_DEFINE_CONSTRUCTOR_PRAGMA_ARGS(initializeCS)
@@ -374,17 +444,20 @@
 static int isValidName(_In_z_ const char* name) MODELICA_NONNULLATTR;
   /* Check, whether a file or table name is valid */
 
-static int isValidCombiTimeTable(const CombiTimeTable* tableID);
+static int isValidCombiTimeTable(CombiTimeTable* tableID,
+                                 _In_z_ const char* tableName, int cleanUp);
   /* Check, whether a CombiTimeTable is well parameterized */
 
-static int isValidCombiTable1D(const CombiTable1D* tableID);
+static int isValidCombiTable1D(CombiTable1D* tableID,
+                               _In_z_ const char* tableName, int cleanUp);
   /* Check, whether a CombiTable1D is well parameterized */
 
-static int isValidCombiTable2D(const CombiTable2D* tableID);
+static int isValidCombiTable2D(CombiTable2D* tableID,
+                               _In_z_ const char* tableName, int cleanUp);
   /* Check, whether a CombiTable2D is well parameterized */
 
-static enum TableSource getTableSource(_In_z_ const char *tableName,
-                                       _In_z_ const char *fileName) MODELICA_NONNULLATTR;
+static enum TableSource getTableSource(_In_z_ const char* fileName,
+                                       _In_z_ const char* tableName) MODELICA_NONNULLATTR;
   /* Determine table source (file, model or "usertab" function) from table
      and file names
   */
@@ -392,33 +465,25 @@
 static void transpose(_Inout_ double* table, size_t nRow, size_t nCol) MODELICA_NONNULLATTR;
   /* Cycle-based in-place array transposition */
 
-#if !defined(NO_FILE_SYSTEM)
-static double* readTable(_In_z_ const char* tableName, _In_z_ const char* fileName,
-                         _Inout_ size_t* nRow, _Inout_ size_t* nCol, int verbose,
-                         int force) MODELICA_NONNULLATTR;
+#if defined(TABLE_SHARE) && !defined(NO_FILE_SYSTEM)
+static size_t key_strlen(_In_z_ const char *s);
+  /* Special strlen for key consisting of concatenated names of file and table */
+#endif
+
+#if defined(TABLE_SHARE)
+#define READ_RESULT TableShare*
+#else
+#define READ_RESULT double*
+#endif
+static READ_RESULT readTable(_In_z_ const char* fileName, _In_z_ const char* tableName,
+                             _Inout_ size_t* nRow, _Inout_ size_t* nCol, int verbose,
+                             int force) MODELICA_NONNULLATTR;
   /* Read a table from an ASCII text or MATLAB MAT-file
 
-     <- RETURN: Pointer to array (row-wise storage) of table values
+     <- RETURN: Pointer to TableShare structure or
+        pointer to array (row-wise storage) of table values
   */
 
-static double* readMatTable(_In_z_ const char* tableName, _In_z_ const char* fileName,
-                            _Inout_ size_t* nRow, _Inout_ size_t* nCol) MODELICA_NONNULLATTR;
-  /* Read a table from a MATLAB MAT-file using MatIO functions
-
-     <- RETURN: Pointer to array (row-wise storage) of table values
-  */
-
-static double* readTxtTable(_In_z_ const char* tableName, _In_z_ const char* fileName,
-                            _Inout_ size_t* nRow, _Inout_ size_t* nCol) MODELICA_NONNULLATTR;
-  /* Read a table from an ASCII text file
-
-     <- RETURN: Pointer to array (row-wise storage) of table values
-  */
-
-static int readLine(_In_ char** buf, _In_ int* bufLen, _In_ FILE* fp) MODELICA_NONNULLATTR;
-  /* Read line (of unknown and arbitrary length) from an ASCII text file */
-#endif /* #if !defined(NO_FILE_SYSTEM) */
-
 static CubicHermite1D* akimaSpline1DInit(_In_ const double* table, size_t nRow,
                                          size_t nCol, _In_ const int* cols,
                                          size_t nCols) MODELICA_NONNULLATTR;
@@ -464,314 +529,278 @@
 
 /* ----- Interface functions ----- */
 
-void* ModelicaStandardTables_CombiTimeTable_init(const char* tableName,
-                                                 const char* fileName,
-                                                 double* table,
-                                                 size_t nRow, size_t nColumn,
-                                                 double startTime, int* cols,
+void* ModelicaStandardTables_CombiTimeTable_init(_In_z_ const char* tableName,
+                                                 _In_z_ const char* fileName,
+                                                 _In_ double* table, size_t nRow,
+                                                 size_t nColumn,
+                                                 double startTime,
+                                                 _In_ int* cols,
                                                  size_t nCols, int smoothness,
                                                  int extrapolation) {
-    CombiTimeTable* tableID = (CombiTimeTable*)calloc(1, sizeof(CombiTimeTable));
-    if (tableID != NULL) {
-        tableID->smoothness = (enum Smoothness)smoothness;
-        tableID->extrapolation = (enum Extrapolation)extrapolation;
-        tableID->nCols = nCols;
-        if (nCols > 0) {
-            tableID->cols = (int*)malloc(tableID->nCols*sizeof(int));
-            if (tableID->cols != NULL) {
-                memcpy(tableID->cols, cols, tableID->nCols*sizeof(int));
+    return ModelicaStandardTables_CombiTimeTable_init2(fileName,
+        tableName, table, nRow, nColumn, startTime, cols, nCols, smoothness,
+        extrapolation, startTime, ALWAYS, 1 /* verbose */);
+}
+
+void* ModelicaStandardTables_CombiTimeTable_init2(_In_z_ const char* fileName,
+                                                  _In_z_ const char* tableName,
+                                                  _In_ double* table, size_t nRow,
+                                                  size_t nColumn,
+                                                  double startTime,
+                                                  _In_ int* cols,
+                                                  size_t nCols, int smoothness,
+                                                  int extrapolation,
+                                                  double shiftTime,
+                                                  int timeEvents,
+                                                  int verbose) {
+    CombiTimeTable* tableID;
+#if defined(TABLE_SHARE)
+    TableShare* file = NULL;
+    char* keyFile = NULL;
+#endif
+    double* tableFile = NULL;
+    size_t nRowFile = 0;
+    size_t nColFile = 0;
+    enum TableSource source = getTableSource(fileName, tableName);
+
+    /* Read table from file before any other heap allocation */
+    if (TABLESOURCE_FILE == source) {
+#if defined(TABLE_SHARE)
+        file = readTable(fileName, tableName, &nRowFile, &nColFile, verbose, 0);
+        if (NULL != file) {
+            keyFile = file->key;
+            tableFile = file->table;
+        }
+        else {
+            return NULL;
+        }
+#else
+        tableFile = readTable(fileName, tableName, &nRowFile, &nColFile, verbose, 0);
+        if (NULL == tableFile) {
+            return NULL;
+        }
+#endif
+    }
+
+    tableID = (CombiTimeTable*)calloc(1, sizeof(CombiTimeTable));
+    if (NULL == tableID) {
+#if defined(TABLE_SHARE)
+        if (NULL != keyFile) {
+            MUTEX_LOCK();
+            if (--file->refCount == 0) {
+                free(file->table);
+                free(file->key);
+                HASH_DEL(tableShare, file);
+                free(file);
             }
+            MUTEX_UNLOCK();
+        }
+        else {
+            /* Should not be possible to get here */
+            if (NULL != tableFile) {
+                free(tableFile);
+            }
+        }
+#else
+        if (NULL != tableFile) {
+            free(tableFile);
+        }
+#endif
+        ModelicaError("Memory allocation error\n");
+        return NULL;
+    }
+
+    tableID->smoothness = (enum Smoothness)smoothness;
+    tableID->extrapolation = (enum Extrapolation)extrapolation;
+    tableID->timeEvents = (enum TimeEvents)timeEvents;
+    tableID->nCols = nCols;
+    tableID->startTime = startTime;
+    tableID->shiftTime = shiftTime;
+    tableID->preNextTimeEvent = -DBL_MAX;
+    tableID->preNextTimeEventCalled = -DBL_MAX;
+    tableID->source = source;
+
+    switch (tableID->source) {
+        case TABLESOURCE_FILE:
+#if defined(TABLE_SHARE)
+            tableID->key = keyFile;
+#else
+            {
+                size_t lenFileName = strlen(fileName);
+                tableID->key = (char*)malloc((lenFileName + strlen(tableName) + 2)*sizeof(char));
+                if (NULL != tableID->key) {
+                    strcpy(tableID->key, fileName);
+                    strcpy(tableID->key + lenFileName + 1, tableName);
+                }
+            }
+#endif
+            tableID->nRow = nRowFile;
+            tableID->nCol = nColFile;
+            tableID->table = tableFile;
+            break;
+
+        case TABLESOURCE_MODEL:
+            tableID->nRow = nRow;
+            tableID->nCol = nColumn;
+#if defined(NO_TABLE_COPY)
+            tableID->table = table;
+#else
+            tableID->table = (double*)malloc(nRow*nColumn*sizeof(double));
+            if (NULL != tableID->table) {
+                memcpy(tableID->table, table, nRow*nColumn*sizeof(double));
+            }
             else {
-                free(tableID);
+                ModelicaStandardTables_CombiTimeTable_close(tableID);
                 ModelicaError("Memory allocation error\n");
                 return NULL;
             }
-        }
-        tableID->startTime = startTime;
-        tableID->source = getTableSource(tableName, fileName);
+#endif
+            break;
 
-        switch (tableID->source) {
-            case TABLESOURCE_FILE:
-                tableID->tableName = (char*)malloc((strlen(tableName) + 1)*sizeof(char));
-                if (tableID->tableName != NULL) {
-                    strcpy(tableID->tableName, tableName);
+        case TABLESOURCE_FUNCTION: {
+            int colWise;
+            int dim[MAX_TABLE_DIMENSIONS];
+            if (usertab((char*)tableName, 0 /* Time-interpolation */, dim,
+                &colWise, &tableID->table) == 0) {
+                if (0 == colWise) {
+                    tableID->nRow = (size_t)dim[0];
+                    tableID->nCol = (size_t)dim[1];
                 }
                 else {
-                    if (nCols > 0) {
-                        free(tableID->cols);
+                    /* Need to transpose */
+                    double* tableT = (double*)malloc(
+                        (size_t)dim[0]*(size_t)dim[1]*sizeof(double));
+                    if (NULL != tableT) {
+                        memcpy(tableT, tableID->table,
+                            (size_t)dim[0]*(size_t)dim[1]*sizeof(double));
+                        tableID->table = tableT;
+                        tableID->nRow = (size_t)dim[1];
+                        tableID->nCol = (size_t)dim[0];
+                        tableID->source = TABLESOURCE_FUNCTION_TRANSPOSE;
+                        transpose(tableID->table, tableID->nRow, tableID->nCol);
                     }
-                    free(tableID);
-                    ModelicaError("Memory allocation error\n");
-                    return NULL;
-                }
-                tableID->fileName = (char*)malloc((strlen(fileName) + 1)*sizeof(char));
-                if (tableID->fileName != NULL) {
-                    strcpy(tableID->fileName, fileName);
-                }
-                else {
-                    free(tableID->tableName);
-                    if (nCols > 0) {
-                        free(tableID->cols);
-                    }
-                    free(tableID);
-                    ModelicaError("Memory allocation error\n");
-                    return NULL;
-                }
-                break;
-
-            case TABLESOURCE_MODEL:
-                tableID->nRow = nRow;
-                tableID->nCol = nColumn;
-                tableID->table = table;
-                if (isValidCombiTimeTable((const CombiTimeTable*)tableID)) {
-                    if (tableID->nRow <= 2) {
-                        if (tableID->smoothness == AKIMA_C1 ||
-                            tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1 ||
-                            tableID->smoothness == STEFFEN_MONOTONE_C1) {
-                            tableID->smoothness = LINEAR_SEGMENTS;
-                        }
-                    }
-                    if (tableID->smoothness == AKIMA_C1) {
-                        /* Initialization of the cubic Hermite spline coefficients */
-                        tableID->spline = akimaSpline1DInit(table,
-                            tableID->nRow, tableID->nCol, (const int*)cols,
-                            tableID->nCols);
-                        if (tableID->spline == NULL) {
-                            if (nCols > 0) {
-                                free(tableID->cols);
-                            }
-                            free(tableID);
-                            ModelicaError("Memory allocation error\n");
-                            return NULL;
-                        }
-                    }
-                    else if (tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1) {
-                        /* Initialization of the cubic Hermite spline coefficients */
-                        tableID->spline = fritschButlandSpline1DInit(table,
-                            tableID->nRow, tableID->nCol, (const int*)cols,
-                            tableID->nCols);
-                        if (tableID->spline == NULL) {
-                            if (nCols > 0) {
-                                free(tableID->cols);
-                            }
-                            free(tableID);
-                            ModelicaError("Memory allocation error\n");
-                            return NULL;
-                        }
-                    }
-                    else if (tableID->smoothness == STEFFEN_MONOTONE_C1) {
-                        /* Initialization of the cubic Hermite spline coefficients */
-                        tableID->spline = steffenSpline1DInit(table,
-                            tableID->nRow, tableID->nCol, (const int*)cols,
-                            tableID->nCols);
-                        if (tableID->spline == NULL) {
-                            if (nCols > 0) {
-                                free(tableID->cols);
-                            }
-                            free(tableID);
-                            ModelicaError("Memory allocation error\n");
-                            return NULL;
-                        }
-                    }
-#if !defined(NO_TABLE_COPY)
-                    tableID->table = (double*)malloc(
-                        tableID->nRow*tableID->nCol*sizeof(double));
-                    if (tableID->table != NULL) {
-                        memcpy(tableID->table, table, tableID->nRow*
-                            tableID->nCol*sizeof(double));
-                    }
                     else {
-                        if (nCols > 0) {
-                            free(tableID->cols);
-                        }
-                        spline1DClose(&tableID->spline);
-                        free(tableID);
+                        ModelicaStandardTables_CombiTimeTable_close(tableID);
                         ModelicaError("Memory allocation error\n");
                         return NULL;
                     }
-#endif
                 }
-                else {
-                    tableID->table = NULL;
-                }
-                break;
-
-            case TABLESOURCE_FUNCTION: {
-                int colWise;
-                int dim[MAX_TABLE_DIMENSIONS];
-                if (usertab((char*)tableName, 0 /* Time-interpolation */, dim,
-                    &colWise, &tableID->table) == 0) {
-                    if (colWise == 0) {
-                        tableID->nRow = (size_t)dim[0];
-                        tableID->nCol = (size_t)dim[1];
-                    }
-                    else {
-                        /* Need to transpose */
-                        double* tableT = (double*)malloc(dim[0]*dim[1]*sizeof(double));
-                        if (tableT != NULL) {
-                            memcpy(tableT, tableID->table, dim[0]*dim[1]*sizeof(double));
-                            tableID->table = tableT;
-                            tableID->nRow = (size_t)dim[1];
-                            tableID->nCol = (size_t)dim[0];
-                            tableID->source = TABLESOURCE_FUNCTION_TRANSPOSE;
-                            transpose(tableID->table, tableID->nRow, tableID->nCol);
-                        }
-                        else {
-                            if (nCols > 0) {
-                                free(tableID->cols);
-                            }
-                            free(tableID);
-                            ModelicaError("Memory allocation error\n");
-                            return NULL;
-                        }
-                    }
-                    if (isValidCombiTimeTable((const CombiTimeTable*)tableID)) {
-                        if (tableID->nRow <= 2) {
-                            if (tableID->smoothness == AKIMA_C1 ||
-                                tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1 ||
-                                tableID->smoothness == STEFFEN_MONOTONE_C1) {
-                                tableID->smoothness = LINEAR_SEGMENTS;
-                            }
-                        }
-                        if (tableID->smoothness == AKIMA_C1) {
-                            /* Initialization of the cubic Hermite spline coefficients */
-                            tableID->spline = akimaSpline1DInit(table,
-                                tableID->nRow, tableID->nCol, (const int*)cols,
-                                tableID->nCols);
-                            if (tableID->spline == NULL) {
-                                if (nCols > 0) {
-                                    free(tableID->cols);
-                                }
-                                if (tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE) {
-                                    free(tableID->table);
-                                }
-                                free(tableID);
-                                ModelicaError("Memory allocation error\n");
-                                return NULL;
-                            }
-                        }
-                        else if (tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1) {
-                            /* Initialization of the cubic Hermite spline coefficients */
-                            tableID->spline = fritschButlandSpline1DInit(table,
-                                tableID->nRow, tableID->nCol, (const int*)cols,
-                                tableID->nCols);
-                            if (tableID->spline == NULL) {
-                                if (nCols > 0) {
-                                    free(tableID->cols);
-                                }
-                                if (tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE) {
-                                    free(tableID->table);
-                                }
-                                free(tableID);
-                                ModelicaError("Memory allocation error\n");
-                                return NULL;
-                            }
-                        }
-                        else if (tableID->smoothness == STEFFEN_MONOTONE_C1) {
-                            /* Initialization of the cubic Hermite spline coefficients */
-                            tableID->spline = steffenSpline1DInit(table,
-                                tableID->nRow, tableID->nCol, (const int*)cols,
-                                tableID->nCols);
-                            if (tableID->spline == NULL) {
-                                if (nCols > 0) {
-                                    free(tableID->cols);
-                                }
-                                if (tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE) {
-                                    free(tableID->table);
-                                }
-                                free(tableID);
-                                ModelicaError("Memory allocation error\n");
-                                return NULL;
-                            }
-                        }
-                    }
-                }
-                break;
             }
+            break;
+        }
 
-            case TABLESOURCE_FUNCTION_TRANSPOSE:
-                /* Should not be possible to get here */
-                break;
+        case TABLESOURCE_FUNCTION_TRANSPOSE:
+            /* Should not be possible to get here */
+            break;
 
-            default:
-                if (nCols > 0) {
-                    free(tableID->cols);
-                }
-                free(tableID);
-                ModelicaError("Table source error\n");
-                return NULL;
+        default:
+            ModelicaStandardTables_CombiTimeTable_close(tableID);
+            ModelicaError("Table source error\n");
+            return NULL;
+    }
+
+    if (nCols > 0) {
+        tableID->cols = (int*)malloc(tableID->nCols*sizeof(int));
+        if (NULL != tableID->cols) {
+            memcpy(tableID->cols, cols, tableID->nCols*sizeof(int));
         }
+        else {
+            ModelicaStandardTables_CombiTimeTable_close(tableID);
+            ModelicaError("Memory allocation error\n");
+            return NULL;
+        }
     }
-    else {
-        ModelicaError("Memory allocation error\n");
+
+    if (isValidCombiTimeTable(tableID, tableName,
+        1 /* Clean up if called from constructor */) == 0) {
+        /* ModelicaStandardTables_CombiTimeTable_close(tableID); */
+        return NULL;
     }
+
+    if (tableID->nRow <= 2) {
+        if (tableID->smoothness == AKIMA_C1 ||
+            tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1 ||
+            tableID->smoothness == STEFFEN_MONOTONE_C1) {
+            tableID->smoothness = LINEAR_SEGMENTS;
+        }
+    }
+    /* Initialization of the cubic Hermite spline coefficients */
+    if (tableID->smoothness == AKIMA_C1) {
+        tableID->spline = akimaSpline1DInit(
+            (const double*)tableID->table, tableID->nRow,
+            tableID->nCol, (const int*)tableID->cols, tableID->nCols);
+    }
+    else if (tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1) {
+        tableID->spline = fritschButlandSpline1DInit(
+            (const double*)tableID->table, tableID->nRow,
+            tableID->nCol, (const int*)tableID->cols, tableID->nCols);
+    }
+    else if (tableID->smoothness == STEFFEN_MONOTONE_C1) {
+        tableID->spline = steffenSpline1DInit(
+            (const double*)tableID->table, tableID->nRow,
+            tableID->nCol, (const int*)tableID->cols, tableID->nCols);
+    }
+    if (tableID->smoothness == AKIMA_C1 ||
+        tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1 ||
+        tableID->smoothness == STEFFEN_MONOTONE_C1) {
+        if (NULL == tableID->spline) {
+            ModelicaStandardTables_CombiTimeTable_close(tableID);
+            ModelicaError("Memory allocation error\n");
+            return NULL;
+        }
+    }
+
     return (void*)tableID;
 }
 
 void ModelicaStandardTables_CombiTimeTable_close(void* _tableID) {
     CombiTimeTable* tableID = (CombiTimeTable*)_tableID;
-    if (tableID != NULL) {
-        if (tableID->table != NULL && tableID->source == TABLESOURCE_FILE) {
+    if (NULL == tableID) {
+        return;
+    }
+    if (NULL != tableID->table && tableID->source == TABLESOURCE_FILE) {
 #if defined(TABLE_SHARE) && !defined(NO_FILE_SYSTEM)
-            if (tableID->tableName != NULL && tableID->fileName != NULL) {
-                char* key = malloc((strlen(tableID->tableName) +
-                    strlen(tableID->fileName) + 2)*sizeof(char));
-                if (key != NULL) {
-                    TableShare *iter;
-                    strcpy(key, tableID->tableName);
-                    strcat(key, "|");
-                    strcat(key, tableID->fileName);
-                    MUTEX_LOCK();
-                    HASH_FIND_STR(tableShare, key, iter);
-                    if (iter != NULL) {
-                        /* Share hit */
-                        if (--iter->refCount == 0) {
-                            free(iter->table);
-                            free(iter->key);
-                            HASH_DEL(tableShare, iter);
-                            free(iter);
-                        }
-                    }
-                    MUTEX_UNLOCK();
-                    free(key);
+        if (NULL != tableID->key) {
+            TableShare* file;
+            MUTEX_LOCK();
+            HASH_FIND_STR(tableShare, tableID->key, file);
+            if (NULL != file) {
+                /* Share hit */
+                if (--file->refCount == 0) {
+                    free(file->table);
+                    free(file->key);
+                    HASH_DEL(tableShare, file);
+                    free(file);
                 }
             }
-            else {
-                /* Should not be possible to get here */
-                free(tableID->table);
-            }
-#else
-            free(tableID->table);
-#endif
-            tableID->table = NULL;
+            MUTEX_UNLOCK();
         }
-        else if (tableID->table != NULL && (
-#if !defined(NO_TABLE_COPY)
-            tableID->source == TABLESOURCE_MODEL ||
-#endif
-            tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE)) {
+        else {
+            /* Should not be possible to get here */
             free(tableID->table);
-            tableID->table = NULL;
         }
-        if (tableID->nCols > 0 && tableID->cols != NULL) {
-            free(tableID->cols);
-            tableID->cols = NULL;
+#else
+        if (NULL != tableID->key) {
+            free(tableID->key);
         }
-        if (tableID->tableName != NULL) {
-            free(tableID->tableName);
-            tableID->tableName = NULL;
-        }
-        if (tableID->fileName != NULL) {
-            free(tableID->fileName);
-            tableID->fileName = NULL;
-        }
-        if (tableID->intervals != NULL) {
-            free(tableID->intervals);
-            tableID->intervals = NULL;
-        }
-        spline1DClose(&tableID->spline);
-        free(tableID);
+        free(tableID->table);
+#endif
     }
+    else if (NULL != tableID->table && (
+#if !defined(NO_TABLE_COPY)
+        tableID->source == TABLESOURCE_MODEL ||
+#endif
+        tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE)) {
+        free(tableID->table);
+    }
+    if (tableID->nCols > 0 && NULL != tableID->cols) {
+        free(tableID->cols);
+    }
+    if (NULL != tableID->intervals) {
+        free(tableID->intervals);
+    }
+    spline1DClose(&tableID->spline);
+    free(tableID);
 }
 
 double ModelicaStandardTables_CombiTimeTable_getValue(void* _tableID, int iCol,
@@ -779,18 +808,14 @@
                                                       double preNextTimeEvent) {
     double y = 0.;
     CombiTimeTable* tableID = (CombiTimeTable*)_tableID;
-    if (tableID != NULL && tableID->table != NULL && tableID->cols != NULL) {
-        /* Shift time by start time */
-        const double tOld = t;
-        t -= tableID->startTime;
-
-        if (t >= 0 && nextTimeEvent < DBL_MAX &&
-            nextTimeEvent == preNextTimeEvent &&
+    if (NULL != tableID && NULL != tableID->table && NULL != tableID->cols &&
+        t >= tableID->startTime) {
+        if (nextTimeEvent < DBL_MAX && nextTimeEvent == preNextTimeEvent &&
             tableID->startTime >= nextTimeEvent) {
             /* Before start time event iteration: Return zero */
-            return 0.;
+            return y;
         }
-        else if (t >= 0) {
+        else {
             const double* table = tableID->table;
             const size_t nRow = tableID->nRow;
             const size_t nCol = tableID->nCol;
@@ -802,11 +827,14 @@
             }
             else {
                 enum PointInterval extrapolate = IN_TABLE;
+                const double tMin = TABLE_ROW0(0);
+                const double tMax = TABLE_COL0(nRow - 1);
+                /* Shift time */
+                const double tOld = t;
+                t -= tableID->shiftTime;
 
                 /* Periodic extrapolation */
                 if (tableID->extrapolation == PERIODIC) {
-                    const double tMin = TABLE_ROW0(0);
-                    const double tMax = TABLE_COL0(nRow - 1);
                     const double T = tMax - tMin;
                     /* Event handling for periodic extrapolation */
                     if (nextTimeEvent == preNextTimeEvent &&
@@ -844,10 +872,14 @@
 
                         t -= tableID->tOffset;
                         if (t < tMin) {
-                            t += T;
+                            do {
+                                t += T;
+                            } while (t < tMin);
                         }
                         else if (t > tMax) {
-                            t -= T;
+                            do {
+                                t -= T;
+                            } while (t > tMax);
                         }
                         tableID->last = findRowIndex(
                             table, nRow, nCol, tableID->last, t);
@@ -865,18 +897,16 @@
                         }
                     }
                 }
-                else if (t < TABLE_ROW0(0)) {
+                else if (t < tMin) {
                     extrapolate = LEFT;
                 }
-                else if (t >= TABLE_COL0(nRow - 1)) {
+                else if (t >= tMax) {
                     extrapolate = RIGHT;
-                    if (tableID->extrapolation != PERIODIC) {
-                        /* Event handling for non-periodic extrapolation */
-                        if (nextTimeEvent == preNextTimeEvent &&
-                            nextTimeEvent < DBL_MAX && tOld >= nextTimeEvent) {
-                            /* Before event iteration */
-                            extrapolate = IN_TABLE;
-                        }
+                    /* Event handling for non-periodic extrapolation */
+                    if (nextTimeEvent == preNextTimeEvent &&
+                        nextTimeEvent < DBL_MAX && tOld >= nextTimeEvent) {
+                        /* Before event iteration */
+                        extrapolate = IN_TABLE;
                     }
                 }
 
@@ -903,7 +933,7 @@
                                 last = tableID->intervals[
                                     tableID->eventInterval - 2][1];
                             }
-                            else if (t >= TABLE_COL0(nRow - 1)) {
+                            else if (t >= tMax) {
                                 last = nRow - 1;
                             }
                             else {
@@ -936,13 +966,6 @@
 
                     /* Interpolation */
                     switch (tableID->smoothness) {
-                        case CONSTANT_SEGMENTS:
-                            if (t >= TABLE_COL0(last + 1)) {
-                                last += 1;
-                            }
-                            y = TABLE(last, col);
-                            break;
-
                         case LINEAR_SEGMENTS: {
                             const double t0 = TABLE_COL0(last);
                             const double t1 = TABLE_COL0(last + 1);
@@ -952,17 +975,24 @@
                                 y = y1;
                             }
                             else {
-                                LINEAR(t, t0, t1, y0, y1)
+                                LINEAR(t, t0, t1, y0, y1);
                             }
                             break;
                         }
 
+                        case CONSTANT_SEGMENTS:
+                            if (t >= TABLE_COL0(last + 1)) {
+                                last++;
+                            }
+                            y = TABLE(last, col);
+                            break;
+
                         case AKIMA_C1:
                         case FRITSCH_BUTLAND_MONOTONE_C1:
                         case STEFFEN_MONOTONE_C1:
-                            if (tableID->spline != NULL) {
+                            if (NULL != tableID->spline) {
                                 const double* c = tableID->spline[
-                                    IDX(last, iCol - 1, tableID->nCols)];
+                                    IDX(last, (size_t)(iCol - 1), tableID->nCols)];
                                 t -= TABLE_COL0(last);
                                 y = TABLE(last, col); /* c[3] = y0 */
                                 y += ((c[0]*t + c[1])*t + c[2])*t;
@@ -977,52 +1007,65 @@
                 else {
                     /* Extrapolation */
                     switch (tableID->extrapolation) {
-                        case NO_EXTRAPOLATION:
-                            ModelicaError("Extrapolation error\n");
-                            return y;
-
-                        case HOLD_LAST_POINT:
-                            y = (extrapolate == RIGHT) ? TABLE(nRow - 1, col) :
-                                TABLE_ROW0(col);
-                            break;
-
                         case LAST_TWO_POINTS: {
                             const size_t last =
                                 (extrapolate == RIGHT) ? nRow - 2 : 0;
-                            const double t0 = TABLE_COL0(last);
-                            const double y0 = TABLE(last, col);
 
-                            if (tableID->smoothness == AKIMA_C1 ||
-                                tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1 ||
-                                tableID->smoothness == STEFFEN_MONOTONE_C1) {
-                                if (tableID->spline != NULL) {
-                                    const double* c = tableID->spline[
-                                        IDX(last, iCol - 1, tableID->nCols)];
-                                    if (extrapolate == LEFT) {
-                                        y = LINEAR_SLOPE(y0, c[2], t - t0);
+                            switch(tableID->smoothness) {
+                                case LINEAR_SEGMENTS:
+                                case CONSTANT_SEGMENTS: {
+                                    const double t0 = TABLE_COL0(last);
+                                    const double t1 = TABLE_COL0(last + 1);
+                                    const double y1 = TABLE(last + 1, col);
+                                    if (isNearlyEqual(t0, t1)) {
+                                        y = y1;
                                     }
-                                    else /* if (extrapolate == RIGHT) */ {
-                                        const double t1 = TABLE_COL0(last + 1);
-                                        const double v = t1 - t0;
-                                        y = LINEAR_SLOPE(TABLE(last + 1, col),
-                                            (3*c[0]*v + 2*c[1])*v + c[2],
-                                            t - t1);
+                                    else {
+                                        const double y0 = TABLE(last, col);
+                                        LINEAR(t, t0, t1, y0, y1);
                                     }
+                                    break;
                                 }
+
+                                case AKIMA_C1:
+                                case FRITSCH_BUTLAND_MONOTONE_C1:
+                                case STEFFEN_MONOTONE_C1:
+                                    if (NULL != tableID->spline) {
+                                        const double* c = tableID->spline[
+                                            IDX(last, (size_t)(iCol - 1), tableID->nCols)];
+                                        if (extrapolate == LEFT) {
+                                            LINEAR_SLOPE(TABLE(0, col), c[2], t - tMin);
+                                        }
+                                        else /* if (extrapolate == RIGHT) */ {
+                                            const double v = tMax - TABLE_COL0(nRow - 2);
+                                            LINEAR_SLOPE(TABLE(last + 1, col),
+                                                (3*c[0]*v + 2*c[1])*v + c[2], t - tMax);
+                                        }
+                                    }
+                                    break;
+
+                                default:
+                                    ModelicaError("Unknown smoothness kind\n");
+                                    return y;
                             }
-                            else {
-                                const double t1 = TABLE_COL0(last + 1);
-                                const double y1 = TABLE(last + 1, col);
-                                if (isNearlyEqual(t0, t1)) {
-                                    y = y1;
-                                }
-                                else {
-                                    LINEAR(t, t0, t1, y0, y1)
-                                }
-                            }
                             break;
                         }
 
+                        case HOLD_LAST_POINT:
+                            y = (extrapolate == RIGHT) ? TABLE(nRow - 1, col) :
+                                TABLE_ROW0(col);
+                            break;
+
+                        case NO_EXTRAPOLATION:
+                            ModelicaFormatError("Extrapolation error: Time "
+                                "(=%lf) must be %s or equal\nthan the %s abscissa "
+                                "value %s (=%lf) defined in the table.\n", tOld,
+                                (extrapolate == LEFT) ? "greater" : "less",
+                                (extrapolate == LEFT) ? "minimum" : "maximum",
+                                (extrapolate == LEFT) ? "t_min" : "t_max",
+                                (extrapolate == LEFT) ? tMin : tMax);
+                            return y;
+
                         case PERIODIC:
                             /* Should not be possible to get here */
                             break;
@@ -1045,18 +1088,14 @@
                                                          double der_t) {
     double der_y = 0.;
     CombiTimeTable* tableID = (CombiTimeTable*)_tableID;
-    if (tableID != NULL && tableID->table != NULL && tableID->cols != NULL) {
-        /* Shift time by start time */
-        const double tOld = t;
-        t -= tableID->startTime;
-
-        if (t >= 0 && nextTimeEvent < DBL_MAX &&
-            nextTimeEvent == preNextTimeEvent &&
+    if (NULL != tableID && NULL != tableID->table && NULL != tableID->cols &&
+        t >= tableID->startTime) {
+        if (nextTimeEvent < DBL_MAX && nextTimeEvent == preNextTimeEvent &&
             tableID->startTime >= nextTimeEvent) {
             /* Before start time event iteration: Return zero */
-            return 0.;
+            return der_y;
         }
-        else if (t >= 0) {
+        else {
             const double* table = tableID->table;
             const size_t nRow = tableID->nRow;
             const size_t nCol = tableID->nCol;
@@ -1064,13 +1103,16 @@
 
             if (nRow > 1) {
                 enum PointInterval extrapolate = IN_TABLE;
+                const double tMin = TABLE_ROW0(0);
+                const double tMax = TABLE_COL0(nRow - 1);
                 size_t last = 0;
                 int haveLast = 0;
+                /* Shift time */
+                const double tOld = t;
+                t -= tableID->shiftTime;
 
                 /* Periodic extrapolation */
                 if (tableID->extrapolation == PERIODIC) {
-                    const double tMin = TABLE_ROW0(0);
-                    const double tMax = TABLE_COL0(nRow - 1);
                     const double T = tMax - tMin;
                     /* Event handling for periodic extrapolation */
                     if (nextTimeEvent == preNextTimeEvent &&
@@ -1099,10 +1141,14 @@
 
                         t -= tableID->tOffset;
                         if (t < tMin) {
-                            t += T;
+                            do {
+                                t += T;
+                            } while (t < tMin);
                         }
                         else if (t > tMax) {
-                            t -= T;
+                            do {
+                                t -= T;
+                            } while (t > tMax);
                         }
                         tableID->last = findRowIndex(
                             table, nRow, nCol, tableID->last, t);
@@ -1120,18 +1166,16 @@
                         }
                     }
                 }
-                else if (t < TABLE_ROW0(0)) {
+                else if (t < tMin) {
                     extrapolate = LEFT;
                 }
-                else if (t >= TABLE_COL0(nRow - 1)) {
+                else if (t >= tMax) {
                     extrapolate = RIGHT;
-                    if (tableID->extrapolation != PERIODIC) {
-                        /* Event handling for non-periodic extrapolation */
-                        if (nextTimeEvent == preNextTimeEvent &&
-                            nextTimeEvent < DBL_MAX && tOld >= nextTimeEvent) {
-                            /* Before event iteration */
-                            extrapolate = IN_TABLE;
-                        }
+                    /* Event handling for non-periodic extrapolation */
+                    if (nextTimeEvent == preNextTimeEvent &&
+                        nextTimeEvent < DBL_MAX && tOld >= nextTimeEvent) {
+                        /* Before event iteration */
+                        extrapolate = IN_TABLE;
                     }
                 }
 
@@ -1153,7 +1197,7 @@
                                 last = tableID->intervals[
                                     tableID->eventInterval - 2][1];
                             }
-                            else if (t >= TABLE_COL0(nRow - 1)) {
+                            else if (t >= tMax) {
                                 last = nRow - 1;
                             }
                             else {
@@ -1192,9 +1236,6 @@
                 if (extrapolate == IN_TABLE) {
                     /* Interpolation */
                     switch (tableID->smoothness) {
-                        case CONSTANT_SEGMENTS:
-                            break;
-
                         case LINEAR_SEGMENTS: {
                             const double t0 = TABLE_COL0(last);
                             const double t1 = TABLE_COL0(last + 1);
@@ -1206,12 +1247,15 @@
                             break;
                         }
 
+                        case CONSTANT_SEGMENTS:
+                            break;
+
                         case AKIMA_C1:
                         case FRITSCH_BUTLAND_MONOTONE_C1:
                         case STEFFEN_MONOTONE_C1:
-                            if (tableID->spline != NULL) {
+                            if (NULL != tableID->spline) {
                                 const double* c = tableID->spline[
-                                    IDX(last, iCol - 1, tableID->nCols)];
+                                    IDX(last, (size_t)(iCol - 1), tableID->nCols)];
                                 t -= TABLE_COL0(last);
                                 der_y = (3*c[0]*t + 2*c[1])*t + c[2];
                                 der_y *= der_t;
@@ -1226,44 +1270,57 @@
                 else {
                     /* Extrapolation */
                     switch (tableID->extrapolation) {
-                        case NO_EXTRAPOLATION:
-                            ModelicaError("Extrapolation error\n");
-                            return der_y;
-
-                        case HOLD_LAST_POINT:
-                            break;
-
                         case LAST_TWO_POINTS:
                             last = (extrapolate == RIGHT) ? nRow - 2 : 0;
+                            switch(tableID->smoothness) {
+                                case LINEAR_SEGMENTS:
+                                case CONSTANT_SEGMENTS: {
+                                    const double t0 = TABLE_COL0(last);
+                                    const double t1 = TABLE_COL0(last + 1);
+                                    if (!isNearlyEqual(t0, t1)) {
+                                        der_y = (TABLE(last + 1, col) - TABLE(last, col))/
+                                            (t1 - t0);
+                                    }
+                                    break;
+                                }
 
-                            if (tableID->smoothness == AKIMA_C1 ||
-                                tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1 ||
-                                tableID->smoothness == STEFFEN_MONOTONE_C1) {
-                                if(tableID->spline) {
-                                    const double* c = tableID->spline[
-                                        IDX(last, iCol - 1, tableID->nCols)];
-                                    if (extrapolate == LEFT) {
-                                        der_y = c[2];
+                                case AKIMA_C1:
+                                case FRITSCH_BUTLAND_MONOTONE_C1:
+                                case STEFFEN_MONOTONE_C1:
+                                    if (NULL != tableID->spline) {
+                                        const double* c = tableID->spline[
+                                            IDX(last, (size_t)(iCol - 1), tableID->nCols)];
+                                        if (extrapolate == LEFT) {
+                                            der_y = c[2];
+                                        }
+                                        else /* if (extrapolate == RIGHT) */ {
+                                            der_y = tMax - TABLE_COL0(nRow - 2);
+                                            der_y = (3*c[0]*der_y + 2*c[1])*
+                                                der_y + c[2];
+                                        }
                                     }
-                                    else /* if (extrapolate == RIGHT) */ {
-                                        der_y = TABLE_COL0(last + 1) -
-                                            TABLE_COL0(last); /* = (t1 - t0) */
-                                        der_y = (3*c[0]*der_y + 2*c[1])*
-                                            der_y + c[2];
-                                    }
-                                }
+                                    break;
+
+                                default:
+                                    ModelicaError("Unknown smoothness kind\n");
+                                    return der_y;
                             }
-                            else {
-                                const double t0 = TABLE_COL0(last);
-                                const double t1 = TABLE_COL0(last + 1);
-                                if (!isNearlyEqual(t0, t1)) {
-                                    der_y = (TABLE(last + 1, col) - TABLE(last, col))/
-                                        (t1 - t0);
-                                }
-                            }
                             der_y *= der_t;
                             break;
 
+                        case HOLD_LAST_POINT:
+                            break;
+
+                        case NO_EXTRAPOLATION:
+                            ModelicaFormatError("Extrapolation error: Time "
+                                "(=%lf) must be %s or equal\nthan the %s abscissa "
+                                "value %s (=%lf) defined in the table.\n", tOld,
+                                (extrapolate == LEFT) ? "greater" : "less",
+                                (extrapolate == LEFT) ? "minimum" : "maximum",
+                                (extrapolate == LEFT) ? "t_min" : "t_max",
+                                (extrapolate == LEFT) ? tMin : tMax);
+                            return der_y;
+
                         case PERIODIC:
                             /* Should not be possible to get here */
                             break;
@@ -1282,7 +1339,7 @@
 double ModelicaStandardTables_CombiTimeTable_minimumTime(void* _tableID) {
     double tMin = 0.;
     CombiTimeTable* tableID = (CombiTimeTable*)_tableID;
-    if (tableID != NULL && tableID->table != NULL) {
+    if (NULL != tableID && NULL != tableID->table) {
         const double* table = tableID->table;
         tMin = TABLE_ROW0(0);
     }
@@ -1292,7 +1349,7 @@
 double ModelicaStandardTables_CombiTimeTable_maximumTime(void* _tableID) {
     double tMax = 0.;
     CombiTimeTable* tableID = (CombiTimeTable*)_tableID;
-    if (tableID != NULL && tableID->table != NULL) {
+    if (NULL != tableID && NULL != tableID->table) {
         const double* table = tableID->table;
         const size_t nCol = tableID->nCol;
         tMax = TABLE_COL0(tableID->nRow - 1);
@@ -1304,7 +1361,7 @@
                                                            double t) {
     double nextTimeEvent = DBL_MAX;
     CombiTimeTable* tableID = (CombiTimeTable*)_tableID;
-    if (tableID != NULL && tableID->table != NULL) {
+    if (NULL != tableID && NULL != tableID->table) {
         const double* table = tableID->table;
         const size_t nRow = tableID->nRow;
         const size_t nCol = tableID->nCol;
@@ -1311,8 +1368,16 @@
 
         if (tableID->nEvent > 0) {
             if (t > tableID->preNextTimeEventCalled) {
-                tableID->preNextTimeEventCalled = t;
+                /* Intentionally empty */
             }
+            else if (t < tableID->preNextTimeEventCalled) {
+                /* Force reinitialization of event interval */
+                tableID->eventInterval = 0;
+                /* Reset time event counter */
+                tableID->nEvent = 0;
+                /* Reset time event */
+                tableID->preNextTimeEvent = -DBL_MAX;
+            }
             else {
                 return tableID->preNextTimeEvent;
             }
@@ -1325,26 +1390,25 @@
 
             /* There is at least one time event at the interval boundaries */
             tableID->maxEvents = 1;
-            for (i = 0; i < nRow - 1; i++) {
-                double t0 = TABLE_COL0(i);
-                double t1 = TABLE_COL0(i + 1);
-                if (t1 > tEvent && !isNearlyEqual(t1, tMax)) {
-                    if (tableID->smoothness == CONSTANT_SEGMENTS) {
-                        if (!isNearlyEqual(t0, t1)) {
+            if (tableID->timeEvents == ALWAYS ||
+                tableID->timeEvents == AT_DISCONT) {
+                for (i = 0; i < nRow - 1; i++) {
+                    double t0 = TABLE_COL0(i);
+                    double t1 = TABLE_COL0(i + 1);
+                    if (t1 > tEvent && !isNearlyEqual(t1, tMax)) {
+                        int isEq = isNearlyEqual(t0, t1);
+                        if ((tableID->timeEvents == ALWAYS && !isEq) ||
+                            (tableID->timeEvents == AT_DISCONT && isEq)) {
                             tEvent = t1;
                             tableID->maxEvents++;
                         }
                     }
-                    else if (isNearlyEqual(t0, t1)) {
-                        tEvent = t1;
-                        tableID->maxEvents++;
-                    }
                 }
             }
             /* Once again with storage of indices of event intervals */
             tableID->intervals = (Interval*)calloc(tableID->maxEvents,
                 sizeof(Interval));
-            if (tableID->intervals == NULL) {
+            if (NULL == tableID->intervals) {
                 ModelicaError("Memory allocation error\n");
                 return nextTimeEvent;
             }
@@ -1351,52 +1415,54 @@
 
             tEvent = TABLE_ROW0(0);
             eventInterval = 0;
-            if (tableID->smoothness == CONSTANT_SEGMENTS) {
+            if (tableID->timeEvents == ALWAYS ||
+                tableID->timeEvents == AT_DISCONT) {
                 for (i = 0; i < nRow - 1 &&
                     eventInterval < tableID->maxEvents; i++) {
                     double t0 = TABLE_COL0(i);
                     double t1 = TABLE_COL0(i + 1);
-                    if (t1 > tEvent) {
-                        if (!isNearlyEqual(t0, t1)) {
-                            tEvent = t1;
-                            tableID->intervals[eventInterval][0] = i;
-                            tableID->intervals[eventInterval][1] = i + 1;
-                            eventInterval++;
+                    if (tableID->timeEvents == ALWAYS) {
+                        if (t1 > tEvent) {
+                            if (!isNearlyEqual(t0, t1)) {
+                                tEvent = t1;
+                                tableID->intervals[eventInterval][0] = i;
+                                tableID->intervals[eventInterval][1] = i + 1;
+                                eventInterval++;
+                            }
+                            else {
+                                tableID->intervals[eventInterval][0] = i + 1;
+                            }
                         }
                         else {
-                            tableID->intervals[eventInterval][0] = i + 1;
+                            tableID->intervals[eventInterval][1] = i + 1;
                         }
                     }
-                    else {
-                        tableID->intervals[eventInterval][1] = i + 1;
-                    }
-                }
-            }
-            else {
-                for (i = 0; i < nRow - 1 &&
-                    eventInterval < tableID->maxEvents; i++) {
-                    double t0 = TABLE_COL0(i);
-                    double t1 = TABLE_COL0(i + 1);
-                    if (t1 > tEvent) {
-                        if (isNearlyEqual(t0, t1)) {
-                            tEvent = t1;
-                            tableID->intervals[eventInterval][1] = i;
-                            eventInterval++;
-                            if (eventInterval < tableID->maxEvents) {
-                                tableID->intervals[eventInterval][0] = i + 1;
+                    else if (tableID->timeEvents == AT_DISCONT) {
+                        if (t1 > tEvent) {
+                            if (isNearlyEqual(t0, t1)) {
+                                tEvent = t1;
+                                tableID->intervals[eventInterval][1] = i;
+                                eventInterval++;
+                                if (eventInterval < tableID->maxEvents) {
+                                    tableID->intervals[eventInterval][0] = i + 1;
+                                }
                             }
+                            else {
+                                tableID->intervals[eventInterval][1] = i + 1;
+                            }
                         }
                         else {
-                            tableID->intervals[eventInterval][1] = i + 1;
+                            tableID->intervals[eventInterval][0] = i + 1;
                         }
                     }
-                    else {
-                        tableID->intervals[eventInterval][0] = i + 1;
-                    }
                 }
             }
+            else {
+                tableID->intervals[0][1] = nRow - 1;
+            }
         }
 
+        tableID->preNextTimeEventCalled = t;
         if (t < tableID->startTime) {
             nextTimeEvent = tableID->startTime;
         }
@@ -1410,9 +1476,9 @@
                 const double tOld = t;
 #endif
                 double tEvent = tMin;
-                size_t i, iStart, iEnd;
+                size_t iStart, iEnd;
 
-                t -= tableID->startTime;
+                t -= tableID->shiftTime;
                 if (tableID->extrapolation == PERIODIC) {
                     /* Initialization of offset time */
                     tableID->tOffset = floor((t - tMin)/T)*T;
@@ -1429,7 +1495,7 @@
                     tableID->eventInterval = 1;
                     iEnd = iStart < (nRow - 1) ? iStart : (nRow - 1);
                 }
-                else if (t > tMax) {
+                else if (t >= tMax) {
                     iStart = nRow - 1;
                     tableID->eventInterval = tableID->maxEvents + 1;
                     iEnd = 0;
@@ -1455,35 +1521,33 @@
                     iEnd = iStart < (nRow - 1) ? iStart : (nRow - 1);
                 }
 
-                for (i = iStart + 1; i < nRow - 1; i++) {
-                    double t0 = TABLE_COL0(i);
-                    double t1 = TABLE_COL0(i + 1);
-                    if (t0 > t) {
-                        if (tableID->smoothness == CONSTANT_SEGMENTS) {
-                            nextTimeEvent = t0;
-                            break;
+                if (tableID->timeEvents == ALWAYS ||
+                    tableID->timeEvents == AT_DISCONT) {
+                    size_t i;
+                    for (i = iStart + 1; i < nRow - 1; i++) {
+                        double t0 = TABLE_COL0(i);
+                        if (t0 > t) {
+                            double t1 = TABLE_COL0(i + 1);
+                            int isEq = isNearlyEqual(t0, t1);
+                            if ((tableID->timeEvents == ALWAYS && !isEq) ||
+                                (tableID->timeEvents == AT_DISCONT && isEq)) {
+                                nextTimeEvent = t0;
+                                break;
+                            }
                         }
-                        else if (isNearlyEqual(t0, t1)) {
-                            nextTimeEvent = t0;
-                            break;
-                        }
                     }
-                }
 
-                for (i = 0; i < iEnd; i++) {
-                    double t0 = TABLE_COL0(i);
-                    double t1 = TABLE_COL0(i + 1);
-                    if (t1 > tEvent && !isNearlyEqual(t1, tMax)) {
-                        if (tableID->smoothness == CONSTANT_SEGMENTS) {
-                            if (!isNearlyEqual(t0, t1)) {
+                    for (i = 0; i < iEnd; i++) {
+                        double t0 = TABLE_COL0(i);
+                        double t1 = TABLE_COL0(i + 1);
+                        if (t1 > tEvent && !isNearlyEqual(t1, tMax)) {
+                            int isEq = isNearlyEqual(t0, t1);
+                            if ((tableID->timeEvents == ALWAYS && !isEq) ||
+                                (tableID->timeEvents == AT_DISCONT && isEq)) {
                                 tEvent = t1;
                                 tableID->eventInterval++;
                             }
                         }
-                        else if (isNearlyEqual(t0, t1)) {
-                            tEvent = t1;
-                            tableID->eventInterval++;
-                        }
                     }
                 }
 
@@ -1497,7 +1561,7 @@
                 t = tOld;
 #endif
                 if (nextTimeEvent < DBL_MAX) {
-                    nextTimeEvent += tableID->startTime;
+                    nextTimeEvent += tableID->shiftTime;
                 }
             }
             else {
@@ -1508,7 +1572,7 @@
                             1 + tableID->eventInterval % tableID->maxEvents;
                         if (tableID->eventInterval == tableID->maxEvents) {
                             nextTimeEvent = tMax + tableID->tOffset +
-                                tableID->startTime;
+                                tableID->shiftTime;
                             tableID->tOffset += T;
                         }
                         else {
@@ -1515,13 +1579,13 @@
                             size_t i = tableID->intervals[
                                 tableID->eventInterval - 1][1];
                             nextTimeEvent = TABLE_COL0(i) + tableID->tOffset +
-                                tableID->startTime;
+                                tableID->shiftTime;
                         }
                     }
                     else if (tableID->eventInterval <= tableID->maxEvents) {
                         size_t i = tableID->intervals[
                             tableID->eventInterval - 1][1];
-                        nextTimeEvent = TABLE_COL0(i) + tableID->startTime;
+                        nextTimeEvent = TABLE_COL0(i) + tableID->shiftTime;
                         /* Increment event interval */
                         tableID->eventInterval++;
                     }
@@ -1539,8 +1603,23 @@
 
 #if defined(DEBUG_TIME_EVENTS)
         if (nextTimeEvent < DBL_MAX) {
-            ModelicaFormatMessage("At time %.17lg: %lu. time event at %.17lg\n", t,
-                (unsigned long)tableID->nEvent, nextTimeEvent);
+            if (tableID->extrapolation == PERIODIC) {
+                ModelicaFormatMessage("At time %.17lg (interval %lu of %lu): %lu. "
+                    "time event at %.17lg\n", t, (unsigned long)tableID->eventInterval,
+                    (unsigned long)tableID->maxEvents, (unsigned long)tableID->nEvent,
+                    nextTimeEvent);
+            }
+            else if (tableID->eventInterval > 0) {
+                ModelicaFormatMessage("At time %.17lg (interval %lu of %lu): %lu. "
+                    "time event at %.17lg\n", t, (unsigned long)tableID->eventInterval - 1,
+                    (unsigned long)tableID->maxEvents, (unsigned long)tableID->nEvent,
+                    nextTimeEvent);
+            }
+            else {
+                ModelicaFormatMessage("At time %.17lg: %lu. "
+                    "time event at %.17lg\n", t, (unsigned long)tableID->nEvent,
+                    nextTimeEvent);
+            }
         }
         else {
             ModelicaFormatMessage("No more time events for time > %.17lg\n", t);
@@ -1561,20 +1640,31 @@
                                                   int verbose) {
 #if !defined(NO_FILE_SYSTEM)
     CombiTimeTable* tableID = (CombiTimeTable*)_tableID;
-    if (tableID != NULL && tableID->source == TABLESOURCE_FILE) {
-        if (force || tableID->table == NULL) {
-#if !defined(TABLE_SHARE)
-            if (tableID->table != NULL) {
+    if (NULL != tableID && tableID->source == TABLESOURCE_FILE) {
+        if (force || NULL == tableID->table) {
+            const char* fileName = tableID->key;
+            const char* tableName = tableID->key + strlen(fileName) + 1;
+#if defined(TABLE_SHARE)
+            TableShare* file = readTable(fileName, tableName, &tableID->nRow,
+                &tableID->nCol, verbose, force);
+            if (NULL != file) {
+                tableID->table = file->table;
+            }
+            else {
+                return 0.; /* Error */
+            }
+#else
+            if (NULL != tableID->table) {
                 free(tableID->table);
             }
+            tableID->table = readTable(fileName, tableName, &tableID->nRow,
+                &tableID->nCol, verbose, force);
 #endif
-            tableID->table = readTable(tableID->tableName,
-                tableID->fileName, &tableID->nRow, &tableID->nCol,
-                verbose, force);
-            if (tableID->table == NULL) {
+            if (NULL == tableID->table) {
                 return 0.; /* Error */
             }
-            if (!isValidCombiTimeTable((const CombiTimeTable*)tableID)) {
+            if (isValidCombiTimeTable(tableID, tableName,
+                0 /* No clean up */) == 0) {
                 return 0.; /* Error */
             }
             if (tableID->nRow <= 2) {
@@ -1584,35 +1674,29 @@
                     tableID->smoothness = LINEAR_SEGMENTS;
                 }
             }
+            /* Reinitialization of the cubic Hermite spline coefficients */
             if (tableID->smoothness == AKIMA_C1) {
-                /* Reinitialization of the cubic Hermite spline coefficients */
                 spline1DClose(&tableID->spline);
                 tableID->spline = akimaSpline1DInit(
                     (const double*)tableID->table, tableID->nRow,
                     tableID->nCol, (const int*)tableID->cols, tableID->nCols);
-                if (tableID->spline == NULL) {
-                    ModelicaError("Memory allocation error\n");
-                    return 0.; /* Error */
-                }
             }
             else if (tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1) {
-                /* Reinitialization of the cubic Hermite spline coefficients */
                 spline1DClose(&tableID->spline);
                 tableID->spline = fritschButlandSpline1DInit(
                     (const double*)tableID->table, tableID->nRow,
                     tableID->nCol, (const int*)tableID->cols, tableID->nCols);
-                if (tableID->spline == NULL) {
-                    ModelicaError("Memory allocation error\n");
-                    return 0.; /* Error */
-                }
             }
             else if (tableID->smoothness == STEFFEN_MONOTONE_C1) {
-                /* Reinitialization of the cubic Hermite spline coefficients */
                 spline1DClose(&tableID->spline);
                 tableID->spline = steffenSpline1DInit(
                     (const double*)tableID->table, tableID->nRow,
                     tableID->nCol, (const int*)tableID->cols, tableID->nCols);
-                if (tableID->spline == NULL) {
+            }
+            if (tableID->smoothness == AKIMA_C1 ||
+                tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1 ||
+                tableID->smoothness == STEFFEN_MONOTONE_C1) {
+                if (NULL == tableID->spline) {
                     ModelicaError("Memory allocation error\n");
                     return 0.; /* Error */
                 }
@@ -1623,308 +1707,265 @@
     return 1.; /* Success */
 }
 
-void* ModelicaStandardTables_CombiTable1D_init(const char* tableName,
-                                               const char* fileName,
-                                               double* table, size_t nRow,
-                                               size_t nColumn, int* cols,
+void* ModelicaStandardTables_CombiTable1D_init(_In_z_ const char* tableName,
+                                               _In_z_ const char* fileName,
+                                               _In_ double* table, size_t nRow,
+                                               size_t nColumn,
+                                               _In_ int* cols,
                                                size_t nCols, int smoothness) {
-    CombiTable1D* tableID = (CombiTable1D*)calloc(1, sizeof(CombiTable1D));
-    if (tableID != NULL) {
-        tableID->smoothness = (enum Smoothness)smoothness;
-        tableID->nCols = nCols;
-        if (nCols > 0) {
-            tableID->cols = (int*)malloc(tableID->nCols*sizeof(int));
-            if (tableID->cols != NULL) {
-                memcpy(tableID->cols, cols, tableID->nCols*sizeof(int));
+    return ModelicaStandardTables_CombiTable1D_init2(fileName, tableName,
+        table, nRow, nColumn, cols, nCols, smoothness, LAST_TWO_POINTS,
+        1 /* verbose */);
+}
+
+void* ModelicaStandardTables_CombiTable1D_init2(_In_z_ const char* fileName,
+                                                _In_z_ const char* tableName,
+                                                _In_ double* table, size_t nRow,
+                                                size_t nColumn,
+                                                _In_ int* cols,
+                                                size_t nCols, int smoothness,
+                                                int extrapolation,
+                                                int verbose) {
+    CombiTable1D* tableID;
+#if defined(TABLE_SHARE)
+    TableShare* file = NULL;
+    char* keyFile = NULL;
+#endif
+    double* tableFile = NULL;
+    size_t nRowFile = 0;
+    size_t nColFile = 0;
+    enum TableSource source = getTableSource(fileName, tableName);
+
+    /* Read table from file before any other heap allocation */
+    if (TABLESOURCE_FILE == source) {
+#if defined(TABLE_SHARE)
+        file = readTable(fileName, tableName, &nRowFile, &nColFile, verbose, 0);
+        if (NULL != file) {
+            keyFile = file->key;
+            tableFile = file->table;
+        }
+        else {
+            return NULL;
+        }
+#else
+        tableFile = readTable(fileName, tableName, &nRowFile, &nColFile, verbose, 0);
+        if (NULL == tableFile) {
+            return NULL;
+        }
+#endif
+    }
+
+    tableID = (CombiTable1D*)calloc(1, sizeof(CombiTable1D));
+    if (NULL == tableID) {
+#if defined(TABLE_SHARE)
+        if (NULL != keyFile) {
+            MUTEX_LOCK();
+            if (--file->refCount == 0) {
+                free(file->table);
+                free(file->key);
+                HASH_DEL(tableShare, file);
+                free(file);
             }
+            MUTEX_UNLOCK();
+        }
+        else {
+            /* Should not be possible to get here */
+            if (NULL != tableFile) {
+                free(tableFile);
+            }
+        }
+#else
+        if (NULL != tableFile) {
+            free(tableFile);
+        }
+#endif
+        ModelicaError("Memory allocation error\n");
+        return NULL;
+    }
+
+    tableID->smoothness = (enum Smoothness)smoothness;
+    tableID->extrapolation = (enum Extrapolation)extrapolation;
+    tableID->nCols = nCols;
+    tableID->source = source;
+
+    switch (tableID->source) {
+        case TABLESOURCE_FILE:
+#if defined(TABLE_SHARE)
+            tableID->key = keyFile;
+#else
+            {
+                size_t lenFileName = strlen(fileName);
+                tableID->key = (char*)malloc((lenFileName + strlen(tableName) + 2)*sizeof(char));
+                if (NULL != tableID->key) {
+                    strcpy(tableID->key, fileName);
+                    strcpy(tableID->key + lenFileName + 1, tableName);
+                }
+            }
+#endif
+            tableID->nRow = nRowFile;
+            tableID->nCol = nColFile;
+            tableID->table = tableFile;
+            break;
+
+        case TABLESOURCE_MODEL:
+            tableID->nRow = nRow;
+            tableID->nCol = nColumn;
+#if defined(NO_TABLE_COPY)
+            tableID->table = table;
+#else
+            tableID->table = (double*)malloc(nRow*nColumn*sizeof(double));
+            if (NULL != tableID->table) {
+                memcpy(tableID->table, table, nRow*nColumn*sizeof(double));
+            }
             else {
-                free(tableID);
+                ModelicaStandardTables_CombiTable1D_close(tableID);
                 ModelicaError("Memory allocation error\n");
                 return NULL;
             }
-        }
-        tableID->source = getTableSource(tableName, fileName);
+#endif
+            break;
 
-        switch (tableID->source) {
-            case TABLESOURCE_FILE:
-                tableID->tableName = (char*)malloc(
-                    (strlen(tableName) + 1)*sizeof(char));
-                if (tableID->tableName != NULL) {
-                    strcpy(tableID->tableName, tableName);
+        case TABLESOURCE_FUNCTION: {
+            int colWise;
+            int dim[MAX_TABLE_DIMENSIONS];
+            if (usertab((char*)tableName, 1 /* 1D-interpolation */, dim,
+                &colWise, &tableID->table) == 0) {
+                if (0 == colWise) {
+                    tableID->nRow = (size_t)dim[0];
+                    tableID->nCol = (size_t)dim[1];
                 }
                 else {
-                    if (nCols > 0) {
-                        free(tableID->cols);
+                    /* Need to transpose */
+                    double* tableT = (double*)malloc(
+                        (size_t)dim[0]*(size_t)dim[1]*sizeof(double));
+                    if (NULL != tableT) {
+                        memcpy(tableT, tableID->table,
+                            (size_t)dim[0]*(size_t)dim[1]*sizeof(double));
+                        tableID->table = tableT;
+                        tableID->nRow = (size_t)dim[1];
+                        tableID->nCol = (size_t)dim[0];
+                        tableID->source = TABLESOURCE_FUNCTION_TRANSPOSE;
+                        transpose(tableID->table, tableID->nRow, tableID->nCol);
                     }
-                    free(tableID);
-                    ModelicaError("Memory allocation error\n");
-                    return NULL;
-                }
-                tableID->fileName = (char*)malloc(
-                    (strlen(fileName) + 1)*sizeof(char));
-                if (tableID->fileName != NULL) {
-                    strcpy(tableID->fileName, fileName);
-                }
-                else {
-                    free(tableID->tableName);
-                    if (nCols > 0) {
-                        free(tableID->cols);
-                    }
-                    free(tableID);
-                    ModelicaError("Memory allocation error\n");
-                    return NULL;
-                }
-                break;
-
-            case TABLESOURCE_MODEL:
-                tableID->nRow = nRow;
-                tableID->nCol = nColumn;
-                tableID->table = table;
-                if (isValidCombiTable1D((const CombiTable1D*)tableID)) {
-                    if (tableID->nRow <= 2) {
-                        if (tableID->smoothness == AKIMA_C1 ||
-                            tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1 ||
-                            tableID->smoothness == STEFFEN_MONOTONE_C1) {
-                            tableID->smoothness = LINEAR_SEGMENTS;
-                        }
-                    }
-                    if (tableID->smoothness == AKIMA_C1) {
-                        /* Initialization of the cubic Hermite spline coefficients */
-                        tableID->spline = akimaSpline1DInit(table,
-                            tableID->nRow, tableID->nCol, (const int*)cols,
-                            tableID->nCols);
-                        if (tableID->spline == NULL) {
-                            if (nCols > 0) {
-                                free(tableID->cols);
-                            }
-                            free(tableID);
-                            ModelicaError("Memory allocation error\n");
-                            return NULL;
-                        }
-                    }
-                    else if (tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1) {
-                        /* Initialization of the cubic Hermite spline coefficients */
-                        tableID->spline = fritschButlandSpline1DInit(table,
-                            tableID->nRow, tableID->nCol, (const int*)cols,
-                            tableID->nCols);
-                        if (tableID->spline == NULL) {
-                            if (nCols > 0) {
-                                free(tableID->cols);
-                            }
-                            free(tableID);
-                            ModelicaError("Memory allocation error\n");
-                            return NULL;
-                        }
-                    }
-                    else if (tableID->smoothness == STEFFEN_MONOTONE_C1) {
-                        /* Initialization of the cubic Hermite spline coefficients */
-                        tableID->spline = steffenSpline1DInit(table,
-                            tableID->nRow, tableID->nCol, (const int*)cols,
-                            tableID->nCols);
-                        if (tableID->spline == NULL) {
-                            if (nCols > 0) {
-                                free(tableID->cols);
-                            }
-                            free(tableID);
-                            ModelicaError("Memory allocation error\n");
-                            return NULL;
-                        }
-                    }
-#if !defined(NO_TABLE_COPY)
-                    tableID->table = (double*)malloc(
-                        tableID->nRow*tableID->nCol*sizeof(double));
-                    if (tableID->table != NULL) {
-                        memcpy(tableID->table, table, tableID->nRow*
-                            tableID->nCol*sizeof(double));
-                    }
                     else {
-                        if (nCols > 0) {
-                            free(tableID->cols);
-                        }
-                        spline1DClose(&tableID->spline);
-                        free(tableID);
+                        ModelicaStandardTables_CombiTable1D_close(tableID);
                         ModelicaError("Memory allocation error\n");
                         return NULL;
                     }
-#endif
                 }
-                else {
-                    tableID->table = NULL;
-                }
-                break;
-
-            case TABLESOURCE_FUNCTION: {
-                int colWise;
-                int dim[MAX_TABLE_DIMENSIONS];
-                if (usertab((char*)tableName, 1 /* 1D-interpolation */, dim,
-                    &colWise, &tableID->table) == 0) {
-                    if (colWise == 0) {
-                        tableID->nRow = (size_t)dim[0];
-                        tableID->nCol = (size_t)dim[1];
-                    }
-                    else {
-                        /* Need to transpose */
-                        double* tableT = (double*)malloc(dim[0]*dim[1]*sizeof(double));
-                        if (tableT != NULL) {
-                            memcpy(tableT, tableID->table, dim[0]*dim[1]*sizeof(double));
-                            tableID->table = tableT;
-                            tableID->nRow = (size_t)dim[1];
-                            tableID->nCol = (size_t)dim[0];
-                            tableID->source = TABLESOURCE_FUNCTION_TRANSPOSE;
-                            transpose(tableID->table, tableID->nRow, tableID->nCol);
-                        }
-                        else {
-                            if (nCols > 0) {
-                                free(tableID->cols);
-                            }
-                            free(tableID);
-                            ModelicaError("Memory allocation error\n");
-                            return NULL;
-                        }
-                    }
-                    if (isValidCombiTable1D((const CombiTable1D*)tableID)) {
-                        if (tableID->nRow <= 2) {
-                            if (tableID->smoothness == AKIMA_C1 ||
-                                tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1 ||
-                                tableID->smoothness == STEFFEN_MONOTONE_C1) {
-                                tableID->smoothness = LINEAR_SEGMENTS;
-                            }
-                        }
-                        if (tableID->smoothness == AKIMA_C1) {
-                            /* Initialization of the cubic Hermite spline coefficients */
-                            tableID->spline = akimaSpline1DInit(table,
-                                tableID->nRow, tableID->nCol, (const int*)cols,
-                                tableID->nCols);
-                            if (tableID->spline == NULL) {
-                                if (nCols > 0) {
-                                    free(tableID->cols);
-                                }
-                                if (tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE) {
-                                    free(tableID->table);
-                                }
-                                free(tableID);
-                                ModelicaError("Memory allocation error\n");
-                                return NULL;
-                            }
-                        }
-                        else if (tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1) {
-                            /* Initialization of the cubic Hermite spline coefficients */
-                            tableID->spline = fritschButlandSpline1DInit(table,
-                                tableID->nRow, tableID->nCol, (const int*)cols,
-                                tableID->nCols);
-                            if (tableID->spline == NULL) {
-                                if (nCols > 0) {
-                                    free(tableID->cols);
-                                }
-                                if (tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE) {
-                                    free(tableID->table);
-                                }
-                                free(tableID);
-                                ModelicaError("Memory allocation error\n");
-                                return NULL;
-                            }
-                        }
-                        else if (tableID->smoothness == STEFFEN_MONOTONE_C1) {
-                            /* Initialization of the cubic Hermite spline coefficients */
-                            tableID->spline = steffenSpline1DInit(table,
-                                tableID->nRow, tableID->nCol, (const int*)cols,
-                                tableID->nCols);
-                            if (tableID->spline == NULL) {
-                                if (nCols > 0) {
-                                    free(tableID->cols);
-                                }
-                                if (tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE) {
-                                    free(tableID->table);
-                                }
-                                free(tableID);
-                                ModelicaError("Memory allocation error\n");
-                                return NULL;
-                            }
-                        }
-                    }
-                }
-                break;
             }
+            break;
+        }
 
-            case TABLESOURCE_FUNCTION_TRANSPOSE:
-                /* Should not be possible to get here */
-                break;
+        case TABLESOURCE_FUNCTION_TRANSPOSE:
+            /* Should not be possible to get here */
+            break;
 
-            default:
-                if (nCols > 0) {
-                    free(tableID->cols);
-                }
-                free(tableID);
-                ModelicaError("Table source error\n");
-                return NULL;
+        default:
+            ModelicaStandardTables_CombiTable1D_close(tableID);
+            ModelicaError("Table source error\n");
+            return NULL;
+    }
+
+    if (nCols > 0) {
+        tableID->cols = (int*)malloc(tableID->nCols*sizeof(int));
+        if (NULL != tableID->cols) {
+            memcpy(tableID->cols, cols, tableID->nCols*sizeof(int));
         }
+        else {
+            ModelicaStandardTables_CombiTable1D_close(tableID);
+            ModelicaError("Memory allocation error\n");
+            return NULL;
+        }
     }
-    else {
-        ModelicaError("Memory allocation error\n");
+
+    if (isValidCombiTable1D(tableID, tableName,
+        1 /* Clean up if called from constructor */) == 0) {
+        /* ModelicaStandardTables_CombiTable1D_close(tableID); */
+        return NULL;
     }
+
+    if (tableID->nRow <= 2) {
+        if (tableID->smoothness == AKIMA_C1 ||
+            tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1 ||
+            tableID->smoothness == STEFFEN_MONOTONE_C1) {
+            tableID->smoothness = LINEAR_SEGMENTS;
+        }
+    }
+    /* Initialization of the cubic Hermite spline coefficients */
+    if (tableID->smoothness == AKIMA_C1) {
+        tableID->spline = akimaSpline1DInit(
+            (const double*)tableID->table, tableID->nRow,
+            tableID->nCol, (const int*)tableID->cols, tableID->nCols);
+    }
+    else if (tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1) {
+        tableID->spline = fritschButlandSpline1DInit(
+            (const double*)tableID->table, tableID->nRow,
+            tableID->nCol, (const int*)tableID->cols, tableID->nCols);
+    }
+    else if (tableID->smoothness == STEFFEN_MONOTONE_C1) {
+        tableID->spline = steffenSpline1DInit(
+            (const double*)tableID->table, tableID->nRow,
+            tableID->nCol, (const int*)tableID->cols, tableID->nCols);
+    }
+    if (tableID->smoothness == AKIMA_C1 ||
+        tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1 ||
+        tableID->smoothness == STEFFEN_MONOTONE_C1) {
+        if (NULL == tableID->spline) {
+            ModelicaStandardTables_CombiTable1D_close(tableID);
+            ModelicaError("Memory allocation error\n");
+            return NULL;
+        }
+    }
+
     return (void*)tableID;
 }
 
 void ModelicaStandardTables_CombiTable1D_close(void* _tableID) {
     CombiTable1D* tableID = (CombiTable1D*)_tableID;
-    if (tableID != NULL) {
-        if (tableID->table != NULL && tableID->source == TABLESOURCE_FILE) {
+    if (NULL == tableID) {
+        return;
+    }
+    if (NULL != tableID->table && tableID->source == TABLESOURCE_FILE) {
 #if defined(TABLE_SHARE) && !defined(NO_FILE_SYSTEM)
-            if (tableID->tableName != NULL && tableID->fileName != NULL) {
-                char* key = malloc((strlen(tableID->tableName) +
-                    strlen(tableID->fileName) + 2)*sizeof(char));
-                if (key != NULL) {
-                    TableShare *iter;
-                    strcpy(key, tableID->tableName);
-                    strcat(key, "|");
-                    strcat(key, tableID->fileName);
-                    MUTEX_LOCK();
-                    HASH_FIND_STR(tableShare, key, iter);
-                    if (iter != NULL) {
-                        /* Share hit */
-                        if (--iter->refCount == 0) {
-                            free(iter->table);
-                            free(iter->key);
-                            HASH_DEL(tableShare, iter);
-                            free(iter);
-                        }
-                    }
-                    MUTEX_UNLOCK();
-                    free(key);
+        if (NULL != tableID->key) {
+            TableShare* file;
+            MUTEX_LOCK();
+            HASH_FIND_STR(tableShare, tableID->key, file);
+            if (NULL != file) {
+                /* Share hit */
+                if (--file->refCount == 0) {
+                    free(file->table);
+                    free(file->key);
+                    HASH_DEL(tableShare, file);
+                    free(file);
                 }
             }
-            else {
-                /* Should not be possible to get here */
-                free(tableID->table);
-            }
-#else
-            free(tableID->table);
-#endif
-            tableID->table = NULL;
+            MUTEX_UNLOCK();
         }
-        else if (tableID->table != NULL && (
-#if !defined(NO_TABLE_COPY)
-            tableID->source == TABLESOURCE_MODEL ||
-#endif
-            tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE)) {
+        else {
+            /* Should not be possible to get here */
             free(tableID->table);
-            tableID->table = NULL;
         }
-        if (tableID->nCols > 0 && tableID->cols != NULL) {
-            free(tableID->cols);
-            tableID->cols = NULL;
+#else
+        if (NULL != tableID->key) {
+            free(tableID->key);
         }
-        if (tableID->tableName != NULL) {
-            free(tableID->tableName);
-            tableID->tableName = NULL;
-        }
-        if (tableID->fileName != NULL) {
-            free(tableID->fileName);
-            tableID->fileName = NULL;
-        }
-        spline1DClose(&tableID->spline);
-        free(tableID);
+        free(tableID->table);
+#endif
     }
+    else if (NULL != tableID->table && (
+#if !defined(NO_TABLE_COPY)
+        tableID->source == TABLESOURCE_MODEL ||
+#endif
+        tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE)) {
+        free(tableID->table);
+    }
+    if (tableID->nCols > 0 && NULL != tableID->cols) {
+        free(tableID->cols);
+    }
+    spline1DClose(&tableID->spline);
+    free(tableID);
 }
 
 double ModelicaStandardTables_CombiTable1D_getValue(void* _tableID, int iCol,
@@ -1931,7 +1972,7 @@
                                                     double u) {
     double y = 0.;
     CombiTable1D* tableID = (CombiTable1D*)_tableID;
-    if (tableID != NULL && tableID->table != NULL && tableID->cols != NULL) {
+    if (NULL != tableID && NULL != tableID->table && NULL != tableID->cols) {
         const double* table = tableID->table;
         const size_t nRow = tableID->nRow;
         const size_t nCol = tableID->nCol;
@@ -1943,13 +1984,32 @@
         }
         else {
             enum PointInterval extrapolate = IN_TABLE;
+            const double uMin = TABLE_ROW0(0);
+            const double uMax = TABLE_COL0(nRow - 1);
             size_t last;
 
-            if (u < TABLE_ROW0(0)) {
+            /* Periodic extrapolation */
+            if (tableID->extrapolation == PERIODIC) {
+                const double T = uMax - uMin;
+
+                if (u < uMin) {
+                    do {
+                        u += T;
+                    } while (u < uMin);
+                }
+                else if (u > uMax) {
+                    do {
+                        u -= T;
+                    } while (u > uMax);
+                }
+                last = findRowIndex(table, nRow, nCol, tableID->last, u);
+                tableID->last = last;
+            }
+            else if (u < uMin) {
                 extrapolate = LEFT;
                 last = 0;
             }
-            else if (u > TABLE_COL0(nRow - 1)) {
+            else if (u > uMax) {
                 extrapolate = RIGHT;
                 last = nRow - 2;
             }
@@ -1958,52 +2018,102 @@
                 tableID->last = last;
             }
 
-            switch (tableID->smoothness) {
-                case CONSTANT_SEGMENTS:
-                    if (extrapolate == IN_TABLE) {
+            if (extrapolate == IN_TABLE) {
+                switch (tableID->smoothness) {
+                    case LINEAR_SEGMENTS: {
+                        const double u0 = TABLE_COL0(last);
+                        const double u1 = TABLE_COL0(last + 1);
+                        const double y0 = TABLE(last, col);
+                        const double y1 = TABLE(last + 1, col);
+                        LINEAR(u, u0, u1, y0, y1);
+                        break;
+                    }
+
+                    case CONSTANT_SEGMENTS:
                         if (u >= TABLE_COL0(last + 1)) {
-                            last += 1;
+                            last++;
                         }
                         y = TABLE(last, col);
                         break;
-                    }
-                    /* Fall through: linear extrapolation */
-                case LINEAR_SEGMENTS: {
-                    const double u0 = TABLE_COL0(last);
-                    const double u1 = TABLE_COL0(last + 1);
-                    const double y0 = TABLE(last, col);
-                    const double y1 = TABLE(last + 1, col);
-                    LINEAR(u, u0, u1, y0, y1)
-                    break;
-                }
 
-                case AKIMA_C1:
-                case FRITSCH_BUTLAND_MONOTONE_C1:
-                case STEFFEN_MONOTONE_C1:
-                    if (tableID->spline != NULL) {
-                        const double* c = tableID->spline[
-                            IDX(last, iCol - 1, tableID->nCols)];
-                        const double u0 = TABLE_COL0(last);
-                        if (extrapolate == IN_TABLE) {
-                            const double v = u - u0;
+                    case AKIMA_C1:
+                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                    case STEFFEN_MONOTONE_C1:
+                        if (NULL != tableID->spline) {
+                            const double* c = tableID->spline[
+                                IDX(last, (size_t)(iCol - 1), tableID->nCols)];
+                            const double v = u - TABLE_COL0(last);
                             y = TABLE(last, col); /* c[3] = y0 */
                             y += ((c[0]*v + c[1])*v + c[2])*v;
                         }
-                        else if (extrapolate == LEFT) {
-                            y = LINEAR_SLOPE(TABLE(last, col), c[2], u - u0);
+                        break;
+
+                    default:
+                        ModelicaError("Unknown smoothness kind\n");
+                        return y;
+                }
+            }
+            else {
+                /* Extrapolation */
+                switch (tableID->extrapolation) {
+                    case LAST_TWO_POINTS:
+                        switch (tableID->smoothness) {
+                            case LINEAR_SEGMENTS:
+                            case CONSTANT_SEGMENTS: {
+                                const double u0 = TABLE_COL0(last);
+                                const double u1 = TABLE_COL0(last + 1);
+                                const double y0 = TABLE(last, col);
+                                const double y1 = TABLE(last + 1, col);
+                                LINEAR(u, u0, u1, y0, y1);
+                                break;
+                            }
+
+                            case AKIMA_C1:
+                            case FRITSCH_BUTLAND_MONOTONE_C1:
+                            case STEFFEN_MONOTONE_C1:
+                                if (NULL != tableID->spline) {
+                                    const double* c = tableID->spline[
+                                        IDX(last, (size_t)(iCol - 1), tableID->nCols)];
+                                    if (extrapolate == LEFT) {
+                                        LINEAR_SLOPE(TABLE(0, col), c[2], u - uMin);
+                                    }
+                                    else /* if (extrapolate == RIGHT) */ {
+                                        const double v = uMax - TABLE_COL0(nRow - 2);
+                                        LINEAR_SLOPE(TABLE(nRow - 1, col),
+                                            (3*c[0]*v + 2*c[1])*v + c[2], u - uMax);
+                                    }
+                                }
+                                break;
+
+                            default:
+                                ModelicaError("Unknown smoothness kind\n");
+                                return y;
                         }
-                        else /* if (extrapolate == RIGHT) */ {
-                            const double u1 = TABLE_COL0(last + 1);
-                            const double v = u1 - u0;
-                            y = LINEAR_SLOPE(TABLE(last + 1, col),
-                               (3*c[0]*v + 2*c[1])*v + c[2], u - u1);
-                        }
-                    }
-                    break;
+                        break;
 
-                default:
-                    ModelicaError("Unknown smoothness kind\n");
-                    return y;
+                    case HOLD_LAST_POINT:
+                        y = (extrapolate == RIGHT) ? TABLE(nRow - 1, col) :
+                            TABLE_ROW0(col);
+                        break;
+
+                    case NO_EXTRAPOLATION:
+                        ModelicaFormatError("Extrapolation error: The value u "
+                            "(=%lf) must be %s or equal\nthan the %s abscissa "
+                            "value %s (=%lf) defined in the table.\n", u,
+                            (extrapolate == LEFT) ? "greater" : "less",
+                            (extrapolate == LEFT) ? "minimum" : "maximum",
+                            (extrapolate == LEFT) ? "u_min" : "u_max",
+                            (extrapolate == LEFT) ? uMin : uMax);
+                        return y;
+
+                    case PERIODIC:
+                        /* Should not be possible to get here */
+                        break;
+
+                    default:
+                        ModelicaError("Unknown extrapolation kind\n");
+                        return y;
+                }
             }
         }
     }
@@ -2014,7 +2124,7 @@
                                                        double u, double der_u) {
     double der_y = 0.;
     CombiTable1D* tableID = (CombiTable1D*)_tableID;
-    if (tableID != NULL && tableID->table != NULL && tableID->cols != NULL) {
+    if (NULL != tableID && NULL != tableID->table && NULL != tableID->cols) {
         const double* table = tableID->table;
         const size_t nRow = tableID->nRow;
         const size_t nCol = tableID->nCol;
@@ -2022,13 +2132,32 @@
 
         if (nRow > 1) {
             enum PointInterval extrapolate = IN_TABLE;
+            const double uMin = TABLE_ROW0(0);
+            const double uMax = TABLE_COL0(nRow - 1);
             size_t last;
 
-            if (u < TABLE_ROW0(0)) {
+            /* Periodic extrapolation */
+            if (tableID->extrapolation == PERIODIC) {
+                const double T = uMax - uMin;
+
+                if (u < uMin) {
+                    do {
+                        u += T;
+                    } while (u < uMin);
+                }
+                else if (u > uMax) {
+                    do {
+                        u -= T;
+                    } while (u > uMax);
+                }
+                last = findRowIndex(table, nRow, nCol, tableID->last, u);
+                tableID->last = last;
+            }
+            else if (u < uMin) {
                 extrapolate = LEFT;
                 last = 0;
             }
-            else if (u > TABLE_COL0(nRow - 1)) {
+            else if (u > uMax) {
                 extrapolate = RIGHT;
                 last = nRow - 2;
             }
@@ -2037,43 +2166,93 @@
                 tableID->last = last;
             }
 
-            switch (tableID->smoothness) {
-                case CONSTANT_SEGMENTS:
-                    if (extrapolate == IN_TABLE) {
+            if (extrapolate == IN_TABLE) {
+                switch (tableID->smoothness) {
+                    case LINEAR_SEGMENTS:
+                        der_y = (TABLE(last + 1, col) - TABLE(last, col))/
+                            (TABLE_COL0(last + 1) - TABLE_COL0(last));
+                        der_y *= der_u;
                         break;
-                    }
-                    /* Fall through: linear extrapolation */
-                case LINEAR_SEGMENTS:
-                    der_y = (TABLE(last + 1, col) - TABLE(last, col))/
-                        (TABLE_COL0(last + 1) - TABLE_COL0(last));
-                    der_y *= der_u;
-                    break;
 
-                case AKIMA_C1:
-                case FRITSCH_BUTLAND_MONOTONE_C1:
-                case STEFFEN_MONOTONE_C1:
-                    if (tableID->spline != NULL) {
-                        const double* c = tableID->spline[
-                            IDX(last, iCol - 1, tableID->nCols)];
-                        if (extrapolate == IN_TABLE) {
+                    case CONSTANT_SEGMENTS:
+                        break;
+
+                    case AKIMA_C1:
+                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                    case STEFFEN_MONOTONE_C1:
+                        if (NULL != tableID->spline) {
+                            const double* c = tableID->spline[
+                                IDX(last, (size_t)(iCol - 1), tableID->nCols)];
                             const double v = u - TABLE_COL0(last);
                             der_y = (3*c[0]*v + 2*c[1])*v + c[2];
+                            der_y *= der_u;
                         }
-                        else if (extrapolate == LEFT) {
-                            der_y = c[2];
+                        break;
+
+                    default:
+                        ModelicaError("Unknown smoothness kind\n");
+                        return der_y;
+                }
+            }
+            else {
+                /* Extrapolation */
+                switch (tableID->extrapolation) {
+                    case LAST_TWO_POINTS:
+                        switch (tableID->smoothness) {
+                            case LINEAR_SEGMENTS:
+                            case  CONSTANT_SEGMENTS: {
+                                const double u0 = TABLE_COL0(last);
+                                const double u1 = TABLE_COL0(last + 1);
+                                der_y = (TABLE(last + 1, col) - TABLE(last, col))/
+                                    (u1 - u0);
+                                break;
+                            }
+
+                            case AKIMA_C1:
+                            case FRITSCH_BUTLAND_MONOTONE_C1:
+                            case STEFFEN_MONOTONE_C1:
+                                if (NULL != tableID->spline) {
+                                    const double* c = tableID->spline[
+                                        IDX(last, (size_t)(iCol - 1), tableID->nCols)];
+                                    if (extrapolate == LEFT) {
+                                        der_y = c[2];
+                                    }
+                                    else /* if (extrapolate == RIGHT) */ {
+                                        der_y = uMax - TABLE_COL0(nRow - 2);
+                                        der_y = (3*c[0]*der_y + 2*c[1])*
+                                            der_y + c[2];
+                                    }
+                                }
+                                break;
+
+                            default:
+                                ModelicaError("Unknown smoothness kind\n");
+                                return der_y;
                         }
-                        else /* if (extrapolate == RIGHT) */ {
-                            const double v = TABLE_COL0(last + 1) -
-                                TABLE_COL0(last);
-                            der_y = (3*c[0]*v + 2*c[1])*v + c[2];
-                        }
                         der_y *= der_u;
-                    }
-                    break;
+                        break;
 
-                default:
-                    ModelicaError("Unknown smoothness kind\n");
-                    return der_y;
+                    case HOLD_LAST_POINT:
+                        break;
+
+                    case NO_EXTRAPOLATION:
+                        ModelicaFormatError("Extrapolation error: The value u "
+                            "(=%lf) must be %s or equal\nthan the %s abscissa "
+                            "value %s (=%lf) defined in the table.\n", u,
+                            (extrapolate == LEFT) ? "greater" : "less",
+                            (extrapolate == LEFT) ? "minimum" : "maximum",
+                            (extrapolate == LEFT) ? "u_min" : "u_max",
+                            (extrapolate == LEFT) ? uMin : uMax);
+                        return der_y;
+
+                    case PERIODIC:
+                        /* Should not be possible to get here */
+                        break;
+
+                    default:
+                        ModelicaError("Unknown extrapolation kind\n");
+                        return der_y;
+                }
             }
         }
     }
@@ -2080,24 +2259,56 @@
     return der_y;
 }
 
+double ModelicaStandardTables_CombiTable1D_minimumAbscissa(void* _tableID) {
+    double uMin = 0.;
+    CombiTable1D* tableID = (CombiTable1D*)_tableID;
+    if (NULL != tableID && NULL != tableID->table) {
+        const double* table = tableID->table;
+        uMin = TABLE_ROW0(0);
+    }
+    return uMin;
+}
+
+double ModelicaStandardTables_CombiTable1D_maximumAbscissa(void* _tableID) {
+    double uMax = 0.;
+    CombiTable1D* tableID = (CombiTable1D*)_tableID;
+    if (NULL != tableID && NULL != tableID->table) {
+        const double* table = tableID->table;
+        const size_t nCol = tableID->nCol;
+        uMax = TABLE_COL0(tableID->nRow - 1);
+    }
+    return uMax;
+}
+
 double ModelicaStandardTables_CombiTable1D_read(void* _tableID, int force,
                                                 int verbose) {
 #if !defined(NO_FILE_SYSTEM)
     CombiTable1D* tableID = (CombiTable1D*)_tableID;
-    if (tableID != NULL && tableID->source == TABLESOURCE_FILE) {
-        if (force || tableID->table == NULL) {
-#if !defined(TABLE_SHARE)
-            if (tableID->table != NULL) {
+    if (NULL != tableID && tableID->source == TABLESOURCE_FILE) {
+        if (force || NULL == tableID->table) {
+            const char* fileName = tableID->key;
+            const char* tableName = tableID->key + strlen(fileName) + 1;
+#if defined(TABLE_SHARE)
+            TableShare* file = readTable(fileName, tableName, &tableID->nRow,
+                &tableID->nCol, verbose, force);
+            if (NULL != file) {
+                tableID->table = file->table;
+            }
+            else {
+                return 0.; /* Error */
+            }
+#else
+            if (NULL != tableID->table) {
                 free(tableID->table);
             }
+            tableID->table = readTable(fileName, tableName, &tableID->nRow,
+                &tableID->nCol, verbose, force);
 #endif
-            tableID->table = readTable(tableID->tableName,
-                tableID->fileName, &tableID->nRow, &tableID->nCol,
-                verbose, force);
-            if (tableID->table == NULL) {
+            if (NULL == tableID->table) {
                 return 0.; /* Error */
             }
-            if (!isValidCombiTable1D((const CombiTable1D*)tableID)) {
+            if (isValidCombiTable1D(tableID, tableName,
+                0 /* No clean up */) == 0) {
                 return 0.; /* Error */
             }
             if (tableID->nRow <= 2) {
@@ -2107,35 +2318,29 @@
                     tableID->smoothness = LINEAR_SEGMENTS;
                 }
             }
+            /* Reinitialization of the cubic Hermite spline coefficients */
             if (tableID->smoothness == AKIMA_C1) {
-                /* Reinitialization of the cubic Hermite spline coefficients */
                 spline1DClose(&tableID->spline);
                 tableID->spline = akimaSpline1DInit(
                     (const double*)tableID->table, tableID->nRow,
                     tableID->nCol, (const int*)tableID->cols, tableID->nCols);
-                if (tableID->spline == NULL) {
-                    ModelicaError("Memory allocation error\n");
-                    return 0.; /* Error */
-                }
             }
             else if (tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1) {
-                /* Reinitialization of the cubic Hermite spline coefficients */
                 spline1DClose(&tableID->spline);
                 tableID->spline = fritschButlandSpline1DInit(
                     (const double*)tableID->table, tableID->nRow,
                     tableID->nCol, (const int*)tableID->cols, tableID->nCols);
-                if (tableID->spline == NULL) {
-                    ModelicaError("Memory allocation error\n");
-                    return 0.; /* Error */
-                }
             }
             else if (tableID->smoothness == STEFFEN_MONOTONE_C1) {
-                /* Reinitialization of the cubic Hermite spline coefficients */
                 spline1DClose(&tableID->spline);
                 tableID->spline = steffenSpline1DInit(
                     (const double*)tableID->table, tableID->nRow,
                     tableID->nCol, (const int*)tableID->cols, tableID->nCols);
-                if (tableID->spline == NULL) {
+            }
+            if (tableID->smoothness == AKIMA_C1 ||
+                tableID->smoothness == FRITSCH_BUTLAND_MONOTONE_C1 ||
+                tableID->smoothness == STEFFEN_MONOTONE_C1) {
+                if (NULL == tableID->spline) {
                     ModelicaError("Memory allocation error\n");
                     return 0.; /* Error */
                 }
@@ -2146,239 +2351,226 @@
     return 1.; /* Success */
 }
 
-void* ModelicaStandardTables_CombiTable2D_init(const char* tableName,
-                                               const char* fileName,
-                                               double* table, size_t nRow,
+void* ModelicaStandardTables_CombiTable2D_init(_In_z_ const char* tableName,
+                                               _In_z_ const char* fileName,
+                                               _In_ double* table, size_t nRow,
                                                size_t nColumn, int smoothness) {
-    CombiTable2D* tableID = (CombiTable2D*)calloc(1, sizeof(CombiTable2D));
-    if (tableID != NULL) {
-        tableID->smoothness = (enum Smoothness)smoothness;
-        tableID->source = getTableSource(tableName, fileName);
+    return ModelicaStandardTables_CombiTable2D_init2(fileName, tableName,
+        table, nRow, nColumn, smoothness, LAST_TWO_POINTS, 1 /* verbose */);
+}
 
-        switch (tableID->source) {
-            case TABLESOURCE_FILE:
-                tableID->tableName = (char*)malloc(
-                    (strlen(tableName) + 1)*sizeof(char));
-                if (tableID->tableName != NULL) {
-                    strcpy(tableID->tableName, tableName);
+void* ModelicaStandardTables_CombiTable2D_init2(_In_z_ const char* fileName,
+                                                _In_z_ const char* tableName,
+                                                _In_ double* table, size_t nRow,
+                                                size_t nColumn, int smoothness,
+                                                int extrapolation,
+                                                int verbose) {
+    CombiTable2D* tableID;
+#if defined(TABLE_SHARE)
+    TableShare* file = NULL;
+    char* keyFile = NULL;
+#endif
+    double* tableFile = NULL;
+    size_t nRowFile = 0;
+    size_t nColFile = 0;
+    enum TableSource source = getTableSource(fileName, tableName);
+
+    /* Read table from file before any other heap allocation */
+    if (TABLESOURCE_FILE == source) {
+#if defined(TABLE_SHARE)
+        file = readTable(fileName, tableName, &nRowFile, &nColFile, verbose, 0);
+        if (NULL != file) {
+            keyFile = file->key;
+            tableFile = file->table;
+        }
+        else {
+            return NULL;
+        }
+#else
+        tableFile = readTable(fileName, tableName, &nRowFile, &nColFile, verbose, 0);
+        if (NULL == tableFile) {
+            return NULL;
+        }
+#endif
+    }
+
+    tableID = (CombiTable2D*)calloc(1, sizeof(CombiTable2D));
+    if (NULL == tableID) {
+#if defined(TABLE_SHARE)
+        if (NULL != keyFile) {
+            MUTEX_LOCK();
+            if (--file->refCount == 0) {
+                free(file->table);
+                free(file->key);
+                HASH_DEL(tableShare, file);
+                free(file);
+            }
+            MUTEX_UNLOCK();
+        }
+        else {
+            /* Should not be possible to get here */
+            if (NULL != tableFile) {
+                free(tableFile);
+            }
+        }
+#else
+        if (NULL != tableFile) {
+            free(tableFile);
+        }
+#endif
+        ModelicaError("Memory allocation error\n");
+        return NULL;
+    }
+
+    tableID->smoothness = (enum Smoothness)smoothness;
+    tableID->extrapolation = (enum Extrapolation)extrapolation;
+    tableID->source = source;
+
+    switch (tableID->source) {
+        case TABLESOURCE_FILE:
+#if defined(TABLE_SHARE)
+            tableID->key = keyFile;
+#else
+            {
+                size_t lenFileName = strlen(fileName);
+                tableID->key = (char*)malloc((lenFileName + strlen(tableName) + 2)*sizeof(char));
+                if (NULL != tableID->key) {
+                    strcpy(tableID->key, fileName);
+                    strcpy(tableID->key + lenFileName + 1, tableName);
                 }
-                else {
-                    free(tableID);
-                    ModelicaError("Memory allocation error\n");
-                    return NULL;
+            }
+#endif
+            tableID->nRow = nRowFile;
+            tableID->nCol = nColFile;
+            tableID->table = tableFile;
+            break;
+
+        case TABLESOURCE_MODEL:
+            tableID->nRow = nRow;
+            tableID->nCol = nColumn;
+#if defined(NO_TABLE_COPY)
+            tableID->table = table;
+#else
+            tableID->table = (double*)malloc(nRow*nColumn*sizeof(double));
+            if (NULL != tableID->table) {
+                memcpy(tableID->table, table, nRow*nColumn*sizeof(double));
+            }
+            else {
+                ModelicaStandardTables_CombiTable2D_close(tableID);
+                ModelicaError("Memory allocation error\n");
+                return NULL;
+            }
+#endif
+            break;
+
+        case TABLESOURCE_FUNCTION: {
+            int colWise;
+            int dim[MAX_TABLE_DIMENSIONS];
+            if (usertab((char*)tableName, 2 /* 2D-interpolation */, dim,
+                &colWise, &tableID->table) == 0) {
+                if (0 == colWise) {
+                    tableID->nRow = (size_t)dim[0];
+                    tableID->nCol = (size_t)dim[1];
                 }
-                tableID->fileName = (char*)malloc((strlen(fileName) + 1)*sizeof(char));
-                if (tableID->fileName != NULL) {
-                    strcpy(tableID->fileName, fileName);
-                }
                 else {
-                    free(tableID->tableName);
-                    free(tableID);
-                    ModelicaError("Memory allocation error\n");
-                    return NULL;
-                }
-                break;
-
-            case TABLESOURCE_MODEL:
-                tableID->nRow = nRow;
-                tableID->nCol = nColumn;
-                tableID->table = table;
-                if (isValidCombiTable2D((const CombiTable2D*)tableID)) {
-                    if (tableID->smoothness == AKIMA_C1 &&
-                        tableID->nRow <= 3 && tableID->nCol <= 3) {
-                        tableID->smoothness = LINEAR_SEGMENTS;
+                    /* Need to transpose */
+                    double* tableT = (double*)malloc(
+                        (size_t)dim[0]*(size_t)dim[1]*sizeof(double));
+                    if (NULL != tableT) {
+                        memcpy(tableT, tableID->table,
+                            (size_t)dim[0]*(size_t)dim[1]*sizeof(double));
+                        tableID->table = tableT;
+                        tableID->nRow = (size_t)dim[1];
+                        tableID->nCol = (size_t)dim[0];
+                        tableID->source = TABLESOURCE_FUNCTION_TRANSPOSE;
+                        transpose(tableID->table, tableID->nRow, tableID->nCol);
                     }
-                    if (tableID->smoothness == AKIMA_C1) {
-                        /* Initialization of the Akima-spline coefficients */
-                        tableID->spline = spline2DInit(table, tableID->nRow,
-                            tableID->nCol);
-                        if (tableID->spline == NULL) {
-                            free(tableID);
-                            ModelicaError("Memory allocation error\n");
-                            return NULL;
-                        }
-                    }
-#if !defined(NO_TABLE_COPY)
-                    tableID->table = (double*)malloc(
-                        tableID->nRow*tableID->nCol*sizeof(double));
-                    if (tableID->table != NULL) {
-                        memcpy(tableID->table, table, tableID->nRow*
-                            tableID->nCol*sizeof(double));
-                    }
                     else {
-                        spline2DClose(&tableID->spline);
-                        free(tableID);
+                        ModelicaStandardTables_CombiTable2D_close(tableID);
                         ModelicaError("Memory allocation error\n");
                         return NULL;
                     }
-#endif
                 }
-                else {
-                    tableID->table = NULL;
-                }
-                break;
-
-            case TABLESOURCE_FUNCTION: {
-                int colWise;
-                int dim[MAX_TABLE_DIMENSIONS];
-                if (usertab((char*)tableName, 2 /* 2D-interpolation */, dim,
-                    &colWise, &tableID->table) == 0) {
-                    if (colWise == 0) {
-                        tableID->nRow = (size_t)dim[0];
-                        tableID->nCol = (size_t)dim[1];
-                    }
-                    else {
-                        /* Need to transpose */
-                        double* tableT = (double*)malloc(dim[0]*dim[1]*sizeof(double));
-                        if (tableT != NULL) {
-                            memcpy(tableT, tableID->table, dim[0]*dim[1]*sizeof(double));
-                            tableID->table = tableT;
-                            tableID->nRow = (size_t)dim[1];
-                            tableID->nCol = (size_t)dim[0];
-                            tableID->source = TABLESOURCE_FUNCTION_TRANSPOSE;
-                            transpose(tableID->table, tableID->nRow, tableID->nCol);
-                        }
-                        else {
-                            free(tableID);
-                            ModelicaError("Memory allocation error\n");
-                            return NULL;
-                        }
-                    }
-                    if (isValidCombiTable2D((const CombiTable2D*)tableID)) {
-                        if (tableID->smoothness == AKIMA_C1 &&
-                            tableID->nRow <= 3 && tableID->nCol <= 3) {
-                            tableID->smoothness = LINEAR_SEGMENTS;
-                        }
-                        if (tableID->smoothness == AKIMA_C1) {
-                            /* Initialization of the Akima-spline coefficients */
-                            tableID->spline = spline2DInit(tableID->table,
-                                tableID->nRow, tableID->nCol);
-                            if (tableID->spline == NULL) {
-                                if (tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE) {
-                                    free(tableID->table);
-                                }
-                                free(tableID);
-                                ModelicaError("Memory allocation error\n");
-                                return NULL;
-                            }
-                        }
-                    }
-                }
-                break;
             }
+            break;
+        }
 
-            case TABLESOURCE_FUNCTION_TRANSPOSE:
-                /* Should not be possible to get here */
-                break;
+        case TABLESOURCE_FUNCTION_TRANSPOSE:
+            /* Should not be possible to get here */
+            break;
 
-            default:
-                free(tableID);
-                ModelicaError("Table source error\n");
-                return NULL;
+        default:
+            ModelicaStandardTables_CombiTable2D_close(tableID);
+            ModelicaError("Table source error\n");
+            return NULL;
+    }
+
+    if (isValidCombiTable2D(tableID, tableName,
+        1 /* Clean up if called from constructor */) == 0) {
+        /* ModelicaStandardTables_CombiTable2D_close(tableID); */
+        return NULL;
+    }
+
+    if (tableID->smoothness == AKIMA_C1 &&
+        tableID->nRow <= 3 && tableID->nCol <= 3) {
+        tableID->smoothness = LINEAR_SEGMENTS;
+    }
+    /* Initialization of the Akima-spline coefficients */
+    if (tableID->smoothness == AKIMA_C1) {
+        tableID->spline = spline2DInit((const double*)tableID->table,
+            tableID->nRow, tableID->nCol);
+        if (NULL == tableID->spline) {
+            ModelicaStandardTables_CombiTable2D_close(tableID);
+            ModelicaError("Memory allocation error\n");
+            return NULL;
         }
     }
-    else {
-        ModelicaError("Memory allocation error\n");
-    }
+
     return (void*)tableID;
 }
 
 void ModelicaStandardTables_CombiTable2D_close(void* _tableID) {
     CombiTable2D* tableID = (CombiTable2D*)_tableID;
-    if (tableID != NULL) {
-        if (tableID->table != NULL && tableID->source == TABLESOURCE_FILE) {
+    if (NULL == tableID) {
+        return;
+    }
+    if (NULL != tableID->table && tableID->source == TABLESOURCE_FILE) {
 #if defined(TABLE_SHARE) && !defined(NO_FILE_SYSTEM)
-            if (tableID->tableName != NULL && tableID->fileName != NULL) {
-                char* key = malloc((strlen(tableID->tableName) +
-                    strlen(tableID->fileName) + 2)*sizeof(char));
-                if (key != NULL) {
-                    TableShare *iter;
-                    strcpy(key, tableID->tableName);
-                    strcat(key, "|");
-                    strcat(key, tableID->fileName);
-                    MUTEX_LOCK();
-                    HASH_FIND_STR(tableShare, key, iter);
-                    if (iter != NULL) {
-                        /* Share hit */
-                        if (--iter->refCount == 0) {
-                            free(iter->table);
-                            free(iter->key);
-                            HASH_DEL(tableShare, iter);
-                            free(iter);
-                        }
-                    }
-                    MUTEX_UNLOCK();
-                    free(key);
+        if (NULL != tableID->key) {
+            TableShare* file;
+            MUTEX_LOCK();
+            HASH_FIND_STR(tableShare, tableID->key, file);
+            if (NULL != file) {
+                /* Share hit */
+                if (--file->refCount == 0) {
+                    free(file->table);
+                    free(file->key);
+                    HASH_DEL(tableShare, file);
+                    free(file);
                 }
             }
-            else {
-                /* Should not be possible to get here */
-                free(tableID->table);
-            }
-#else
-            free(tableID->table);
-#endif
-            tableID->table = NULL;
+            MUTEX_UNLOCK();
         }
-        else if (tableID->table != NULL && (
-#if !defined(NO_TABLE_COPY)
-            tableID->source == TABLESOURCE_MODEL ||
-#endif
-            tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE)) {
+        else {
+            /* Should not be possible to get here */
             free(tableID->table);
-            tableID->table = NULL;
         }
-        if (tableID->tableName != NULL) {
-            free(tableID->tableName);
-            tableID->tableName = NULL;
+#else
+        if (NULL != tableID->key) {
+            free(tableID->key);
         }
-        if (tableID->fileName != NULL) {
-            free(tableID->fileName);
-            tableID->fileName = NULL;
-        }
-        spline2DClose(&tableID->spline);
-        free(tableID);
+        free(tableID->table);
+#endif
     }
-}
-
-double ModelicaStandardTables_CombiTable2D_read(void* _tableID, int force,
-                                                int verbose) {
-#if !defined(NO_FILE_SYSTEM)
-    CombiTable2D* tableID = (CombiTable2D*)_tableID;
-    if (tableID != NULL && tableID->source == TABLESOURCE_FILE) {
-        if (force || tableID->table == NULL) {
-#if !defined(TABLE_SHARE)
-            if (tableID->table != NULL) {
-                free(tableID->table);
-            }
+    else if (NULL != tableID->table && (
+#if !defined(NO_TABLE_COPY)
+        tableID->source == TABLESOURCE_MODEL ||
 #endif
-            tableID->table = readTable(tableID->tableName,
-                tableID->fileName, &tableID->nRow, &tableID->nCol,
-                verbose, force);
-            if (tableID->table == NULL) {
-                return 0.; /* Error */
-            }
-            if (!isValidCombiTable2D((const CombiTable2D*)tableID)) {
-                return 0.; /* Error */
-            }
-            if (tableID->smoothness == AKIMA_C1 &&
-                tableID->nRow <= 3 && tableID->nCol <= 3) {
-                tableID->smoothness = LINEAR_SEGMENTS;
-            }
-            if (tableID->smoothness == AKIMA_C1) {
-                /* Reinitialization of the Akima-spline coefficients */
-                spline2DClose(&tableID->spline);
-                tableID->spline = spline2DInit(tableID->table, tableID->nRow,
-                    tableID->nCol);
-                if (tableID->spline == NULL) {
-                    ModelicaError("Memory allocation error\n");
-                    return 0.; /* Error */
-                }
-            }
-        }
+        tableID->source == TABLESOURCE_FUNCTION_TRANSPOSE)) {
+        free(tableID->table);
     }
-#endif
-    return 1.; /* Success */
+    spline2DClose(&tableID->spline);
+    free(tableID);
 }
 
 double ModelicaStandardTables_CombiTable2D_getValue(void* _tableID, double u1,
@@ -2385,94 +2577,188 @@
                                                     double u2) {
     double y = 0;
     CombiTable2D* tableID = (CombiTable2D*)_tableID;
-    if (tableID != NULL && tableID->table != NULL) {
+    if (NULL != tableID && NULL != tableID->table) {
         const double* table = tableID->table;
         const size_t nRow = tableID->nRow;
         const size_t nCol = tableID->nCol;
+        const double u1Min = TABLE_COL0(1);
+        const double u1Max = TABLE_COL0(nRow - 1);
+        const double u2Min = TABLE_ROW0(1);
+        const double u2Max = TABLE_ROW0(nCol - 1);
 
-        if (nRow == 2 && nCol == 2) {
-            /* Single row */
-            y = TABLE(1, 1);
-        }
-        else if (nRow == 2 && nCol > 2) {
-            enum PointInterval extrapolate2 = IN_TABLE;
-            size_t last2;
-
-            if (u2 < TABLE_ROW0(1)) {
-                extrapolate2 = LEFT;
-                last2 = 0;
+        if (nRow == 2) {
+            if (nCol == 2) {
+                /* Single row */
+                y = TABLE(1, 1);
             }
-            else if (u2 > TABLE_ROW0(nCol - 1)) {
-                extrapolate2 = RIGHT;
-                last2 = nCol - 3;
-            }
-            else {
-                last2 = findColIndex(&TABLE(0, 1), nCol - 1,
-                    tableID->last2, u2);
-                tableID->last2 = last2;
-            }
+            else if (nCol > 2) {
+                enum PointInterval extrapolate2 = IN_TABLE;
+                size_t last2;
 
-            switch (tableID->smoothness) {
-                case CONSTANT_SEGMENTS:
-                    if (extrapolate2 == IN_TABLE) {
-                        if (u2 >= TABLE_ROW0(last2 + 2)) {
-                            last2 += 1;
-                        }
-                        y = TABLE(1, last2 + 1);
-                        break;
+                /* Periodic extrapolation */
+                if (tableID->extrapolation == PERIODIC) {
+                    const double T = u2Max - u2Min;
+
+                    if (u2 < u2Min) {
+                        do {
+                            u2 += T;
+                        } while (u2 < u2Min);
                     }
-                    /* Fall through: linear extrapolation */
-                case LINEAR_SEGMENTS: {
-                    const double u20 = TABLE_ROW0(last2 + 1);
-                    const double u21 = TABLE_ROW0(last2 + 2);
-                    const double y0 = TABLE(1, last2 + 1);
-                    const double y1 = TABLE(1, last2 + 2);
-                    LINEAR(u2, u20, u21, y0, y1)
-                    break;
+                    else if (u2 > u2Max) {
+                        do {
+                            u2 -= T;
+                        } while (u2 > u2Max);
+                    }
+                    last2 = findColIndex(&TABLE(0, 1), nCol - 1,
+                        tableID->last2, u2);
+                    tableID->last2 = last2;
                 }
+                else if (u2 < u2Min) {
+                    extrapolate2 = LEFT;
+                    last2 = 0;
+                }
+                else if (u2 > u2Max) {
+                    extrapolate2 = RIGHT;
+                    last2 = nCol - 3;
+                }
+                else {
+                    last2 = findColIndex(&TABLE(0, 1), nCol - 1,
+                        tableID->last2, u2);
+                    tableID->last2 = last2;
+                }
 
-                case AKIMA_C1:
-                    if (tableID->spline != NULL) {
-                        const double* c = tableID->spline[last2];
-                        const double u20 = TABLE_ROW0(last2 + 1);
-                        if (extrapolate2 == IN_TABLE) {
-                            u2 -= u20;
-                            y = TABLE(1, last2 + 1); /* c[3] = y0 */
-                            y += ((c[0]*u2 + c[1])*u2 + c[2])*u2;
-                        }
-                        else if (extrapolate2 == LEFT) {
-                            y = LINEAR_SLOPE(TABLE(1, last2 + 1), c[2],
-                                u2 - u20);
-                        }
-                        else /* if (extrapolate2 == RIGHT) */ {
+                if (extrapolate2 == IN_TABLE) {
+                    switch (tableID->smoothness) {
+                        case LINEAR_SEGMENTS: {
+                            const double u20 = TABLE_ROW0(last2 + 1);
                             const double u21 = TABLE_ROW0(last2 + 2);
-                            const double v2 = u21 - u20;
-                            y = LINEAR_SLOPE(TABLE(1, last2 + 2), (3*c[0]*v2 +
-                                2*c[1])*v2 + c[2], u2 - u21);
+                            const double y0 = TABLE(1, last2 + 1);
+                            const double y1 = TABLE(1, last2 + 2);
+                            LINEAR(u2, u20, u21, y0, y1);
+                            break;
                         }
+
+                        case CONSTANT_SEGMENTS:
+                            if (u2 >= TABLE_ROW0(last2 + 2)) {
+                                last2++;
+                            }
+                            y = TABLE(1, last2 + 1);
+                            break;
+
+                        case AKIMA_C1:
+                            if (NULL != tableID->spline) {
+                                const double* c = tableID->spline[last2];
+                                const double v = u2 - TABLE_ROW0(last2 + 1);
+                                y = TABLE(1, last2 + 1); /* c[3] = y0 */
+                                y += ((c[0]*v + c[1])*v + c[2])*v;
+                            }
+                            break;
+
+                        case FRITSCH_BUTLAND_MONOTONE_C1:
+                        case STEFFEN_MONOTONE_C1:
+                            ModelicaError("Bivariate monotone C1 interpolation is "
+                                "not implemented\n");
+                            return y;
+
+                        default:
+                            ModelicaError("Unknown smoothness kind\n");
+                            return y;
                     }
-                    break;
+                }
+                else {
+                    /* Extrapolation */
+                    switch (tableID->extrapolation) {
+                        case LAST_TWO_POINTS:
+                            switch (tableID->smoothness) {
+                                case LINEAR_SEGMENTS:
+                                case CONSTANT_SEGMENTS: {
+                                    const double u20 = TABLE_ROW0(last2 + 1);
+                                    const double u21 = TABLE_ROW0(last2 + 2);
+                                    const double y0 = TABLE(1, last2 + 1);
+                                    const double y1 = TABLE(1, last2 + 2);
+                                    LINEAR(u2, u20, u21, y0, y1);
+                                    break;
+                                }
 
-                case FRITSCH_BUTLAND_MONOTONE_C1:
-                case STEFFEN_MONOTONE_C1:
-                    ModelicaError("Bivariate monotone C1 interpolation is "
-                        "not implemented\n");
-                    return y;
+                                case AKIMA_C1:
+                                    if (NULL != tableID->spline) {
+                                        const double* c = tableID->spline[last2];
+                                        if (extrapolate2 == LEFT) {
+                                            LINEAR_SLOPE(TABLE(1, 1), c[2], u2 - u2Min);
+                                        }
+                                        else /* if (extrapolate2 == RIGHT) */ {
+                                            const double v2 = u2Max - TABLE_ROW0(nCol - 2);
+                                            LINEAR_SLOPE(TABLE(1, nCol - 1), (3*c[0]*v2 +
+                                                2*c[1])*v2 + c[2], u2 - u2Max);
+                                        }
+                                    }
+                                    break;
 
-                default:
-                    ModelicaError("Unknown smoothness kind\n");
-                    return y;
+                                case FRITSCH_BUTLAND_MONOTONE_C1:
+                                case STEFFEN_MONOTONE_C1:
+                                    ModelicaError("Bivariate monotone C1 interpolation is "
+                                        "not implemented\n");
+                                    return y;
+
+                                default:
+                                    ModelicaError("Unknown smoothness kind\n");
+                                    return y;
+                            }
+                            break;
+
+                        case HOLD_LAST_POINT:
+                            y = (extrapolate2 == RIGHT) ? TABLE(1, nCol - 1) :
+                                TABLE(1, 1);
+                            break;
+
+                        case NO_EXTRAPOLATION:
+                            ModelicaFormatError("Extrapolation error: The value u2 "
+                                "(=%lf) must be %s or equal\nthan the %s abscissa "
+                                "value %s (=%lf) defined in the table.\n", u2,
+                                (extrapolate2 == LEFT) ? "greater" : "less",
+                                (extrapolate2 == LEFT) ? "minimum" : "maximum",
+                                (extrapolate2 == LEFT) ? "u_min[2]" : "u_max[2]",
+                                (extrapolate2 == LEFT) ? u2Min : u2Max);
+                            return y;
+
+                        case PERIODIC:
+                            /* Should not be possible to get here */
+                            break;
+
+                        default:
+                            ModelicaError("Unknown extrapolation kind\n");
+                            return y;
+                    }
+                }
             }
         }
-        else if (nRow > 2 && nCol == 2) {
+        else if (nRow > 2) {
             enum PointInterval extrapolate1 = IN_TABLE;
             size_t last1;
 
-            if (u1 < TABLE_COL0(1)) {
+            /* Periodic extrapolation */
+            if (tableID->extrapolation == PERIODIC) {
+                const double T = u1Max - u1Min;
+
+                if (u1 < u1Min) {
+                    do {
+                        u1 += T;
+                    } while (u1 < u1Min);
+                }
+                else if (u1 > u1Max) {
+                    do {
+                        u1 -= T;
+                    } while (u1 > u1Max);
+                }
+                last1 = findRowIndex(&TABLE(1, 0), nRow - 1, nCol,
+                    tableID->last1, u1);
+                tableID->last1 = last1;
+            }
+            else if (u1 < u1Min) {
                 extrapolate1 = LEFT;
                 last1 = 0;
             }
-            else if (u1 > TABLE_COL0(nRow - 1)) {
+            else if (u1 > u1Max) {
                 extrapolate1 = RIGHT;
                 last1 = nRow - 3;
             }
@@ -2481,252 +2767,827 @@
                     tableID->last1, u1);
                 tableID->last1 = last1;
             }
+            if (nCol == 2) {
+                if (extrapolate1 == IN_TABLE) {
+                    switch (tableID->smoothness) {
+                        case LINEAR_SEGMENTS: {
+                            const double u10 = TABLE_COL0(last1 + 1);
+                            const double u11 = TABLE_COL0(last1 + 2);
+                            const double y0 = TABLE(last1 + 1, 1);
+                            const double y1 = TABLE(last1 + 2, 1);
+                            LINEAR(u1, u10, u11, y0, y1);
+                            break;
+                        }
 
-            switch (tableID->smoothness) {
-                case CONSTANT_SEGMENTS:
-                    if (extrapolate1 == IN_TABLE) {
-                        if (u1 >= TABLE_COL0(last1 + 2)) {
-                            last1 += 1;
-                        }
-                        y = TABLE(last1 + 1, 1);
-                        break;
+                        case CONSTANT_SEGMENTS:
+                            if (u1 >= TABLE_COL0(last1 + 2)) {
+                                last1++;
+                            }
+                            y = TABLE(last1 + 1, 1);
+                            break;
+
+                        case AKIMA_C1:
+                            if (NULL != tableID->spline) {
+                                const double* c = tableID->spline[last1];
+                                const double v = u1 - TABLE_COL0(last1 + 1);
+                                y = TABLE(last1 + 1, 1); /* c[3] = y0 */
+                                y += ((c[0]*v + c[1])*v + c[2])*v;
+                            }
+                            break;
+
+                        case FRITSCH_BUTLAND_MONOTONE_C1:
+                        case STEFFEN_MONOTONE_C1:
+                            ModelicaError("Bivariate monotone C1 interpolation is "
+                                "not implemented\n");
+                            return y;
+
+                        default:
+                            ModelicaError("Unknown smoothness kind\n");
+                            return y;
                     }
-                    /* Fall through: linear extrapolation */
-                case LINEAR_SEGMENTS: {
-                    const double u10 = TABLE_COL0(last1 + 1);
-                    const double u11 = TABLE_COL0(last1 + 2);
-                    const double y0 = TABLE(last1 + 1, 1);
-                    const double y1 = TABLE(last1 + 2, 1);
-                    LINEAR(u1, u10, u11, y0, y1)
-                    break;
                 }
+                else {
+                    /* Extrapolation */
+                    switch (tableID->extrapolation) {
+                        case LAST_TWO_POINTS:
+                            switch (tableID->smoothness) {
+                                case LINEAR_SEGMENTS:
+                                case CONSTANT_SEGMENTS: {
+                                    const double u10 = TABLE_COL0(last1 + 1);
+                                    const double u11 = TABLE_COL0(last1 + 2);
+                                    const double y0 = TABLE(last1 + 1, 1);
+                                    const double y1 = TABLE(last1 + 2, 1);
+                                    LINEAR(u1, u10, u11, y0, y1);
+                                    break;
+                                }
 
-                case AKIMA_C1:
-                    if (tableID->spline != NULL) {
-                        const double* c = tableID->spline[last1];
-                        const double u10 = TABLE_COL0(last1 + 1);
-                        if (extrapolate1 == IN_TABLE) {
-                            u1 -= u10;
-                            y = TABLE(last1 + 1, 1); /* c[3] = y0 */
-                            y += ((c[0]*u1 + c[1])*u1 + c[2])*u1;
+                                case AKIMA_C1:
+                                    if (NULL != tableID->spline) {
+                                        const double* c = tableID->spline[last1];
+                                        if (extrapolate1 == LEFT) {
+                                            LINEAR_SLOPE(TABLE(1, 1), c[2], u1 - u1Min);
+                                        }
+                                        else /* if (extrapolate1 == RIGHT) */ {
+                                            const double v1 = u1Max - TABLE_COL0(nRow - 2);
+                                            LINEAR_SLOPE(TABLE(nRow - 1, 1), (3*c[0]*v1 +
+                                                2*c[1])*v1 + c[2], u1 - u1Max);
+                                        }
+                                    }
+                                    break;
+
+                                case FRITSCH_BUTLAND_MONOTONE_C1:
+                                case STEFFEN_MONOTONE_C1:
+                                    ModelicaError("Bivariate monotone C1 interpolation is "
+                                        "not implemented\n");
+                                    return y;
+
+                                default:
+                                    ModelicaError("Unknown smoothness kind\n");
+                                    return y;
+                            }
+                            break;
+
+                        case HOLD_LAST_POINT:
+                            y = (extrapolate1 == RIGHT) ? TABLE(nRow - 1, 1) :
+                                TABLE(1, 1);
+                            break;
+
+                        case NO_EXTRAPOLATION:
+                            ModelicaFormatError("Extrapolation error: The value u1 "
+                                "(=%lf) must be %s or equal\nthan the %s abscissa "
+                                "value %s (=%lf) defined in the table.\n", u1,
+                                (extrapolate1 == LEFT) ? "greater" : "less",
+                                (extrapolate1 == LEFT) ? "minimum" : "maximum",
+                                (extrapolate1 == LEFT) ? "u_min[1]" : "u_max[1]",
+                                (extrapolate1 == LEFT) ? u1Min : u1Max);
+                            return y;
+
+                        case PERIODIC:
+                            /* Should not be possible to get here */
+                            break;
+
+                        default:
+                            ModelicaError("Unknown extrapolation kind\n");
+                            return y;
+                    }
+                }
+            }
+            else if (nCol > 2) {
+                enum PointInterval extrapolate2 = IN_TABLE;
+                size_t last2;
+
+                /* Periodic extrapolation */
+                if (tableID->extrapolation == PERIODIC) {
+                    const double T = u2Max - u2Min;
+
+                    if (u2 < u2Min) {
+                        do {
+                            u2 += T;
+                        } while (u2 < u2Min);
+                    }
+                    else if (u2 > u2Max) {
+                        do {
+                            u2 -= T;
+                        } while (u2 > u2Max);
+                    }
+                    last2 = findColIndex(&TABLE(0, 1), nCol - 1,
+                        tableID->last2, u2);
+                    tableID->last2 = last2;
+                }
+                else if (u2 < u2Min) {
+                    extrapolate2 = LEFT;
+                    last2 = 0;
+                }
+                else if (u2 > u2Max) {
+                    extrapolate2 = RIGHT;
+                    last2 = nCol - 3;
+                }
+                else {
+                    last2 = findColIndex(&TABLE(0, 1), nCol - 1,
+                        tableID->last2, u2);
+                    tableID->last2 = last2;
+                }
+
+                if (extrapolate1 == IN_TABLE) {
+                    if (extrapolate2 == IN_TABLE) {
+                        switch (tableID->smoothness) {
+                            case LINEAR_SEGMENTS:
+                                BILINEAR(u1, u2);
+                                break;
+
+                            case CONSTANT_SEGMENTS:
+                                if (u1 >= TABLE_COL0(last1 + 2)) {
+                                    last1++;
+                                }
+                                if (u2 >= TABLE_ROW0(last2 + 2)) {
+                                    last2++;
+                                }
+                                y = TABLE(last1 + 1, last2 + 1);
+                                break;
+
+                            case AKIMA_C1:
+                                if (NULL != tableID->spline) {
+                                    const double* c = tableID->spline[
+                                        IDX(last1, last2, nCol - 2)];
+                                    double p1, p2, p3;
+                                    u1 -= TABLE_COL0(last1 + 1);
+                                    u2 -= TABLE_ROW0(last2 + 1);
+                                    p1 = ((c[0]*u2 + c[1])*u2 + c[2])*u2 + c[3];
+                                    p2 = ((c[4]*u2 + c[5])*u2 + c[6])*u2 + c[7];
+                                    p3 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
+                                    y = TABLE(last1 + 1, last2 + 1); /* c[15] = y00 */
+                                    y += ((c[12]*u2 + c[13])*u2 + c[14])*u2; /* p4 */
+                                    y += ((p1*u1 + p2)*u1 + p3)*u1;
+                                }
+                                break;
+
+                            case FRITSCH_BUTLAND_MONOTONE_C1:
+                            case STEFFEN_MONOTONE_C1:
+                                ModelicaError("Bivariate monotone C1 interpolation is "
+                                    "not implemented\n");
+                                return y;
+
+                            default:
+                                ModelicaError("Unknown smoothness kind\n");
+                                return y;
                         }
-                        else if (extrapolate1 == LEFT) {
-                            y = LINEAR_SLOPE(TABLE(last1 + 1, 1), c[2],
-                                u1 - u10);
+                    }
+                    else if (extrapolate2 == LEFT) {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR(u1, u2);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(last1, 0, nCol - 2)];
+                                            double der_y2;
+                                            u1 -= TABLE_COL0(last1 + 1);
+                                            der_y2 = ((c[2]*u1 + c[6])*u1 + c[10])*u1 + c[14];
+                                            y = TABLE(last1 + 1, 1); /* c[15] = y00 */
+                                            y += ((c[3]*u1 + c[7])*u1 + c[11])*u1;
+                                            y += der_y2*(u2 - u2Min);
+                                        }
+                                        break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS: {
+                                        const double u10 = TABLE_COL0(last1 + 1);
+                                        const double u11 = TABLE_COL0(last1 + 2);
+                                        const double y00 = TABLE(last1 + 1, 1);
+                                        const double y10 = TABLE(last1 + 2, 1);
+                                        LINEAR(u1, u10, u11, y00, y10);
+                                        break;
+                                    }
+
+                                    case CONSTANT_SEGMENTS:
+                                        if (u1 >= TABLE_COL0(last1 + 2)) {
+                                            last1++;
+                                        }
+                                        y = TABLE(last1 + 1, 1);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(last1, 0, nCol - 2)];
+                                            u1 -= TABLE_COL0(last1 + 1);
+                                            y = TABLE(last1 + 1, 1); /* c[15] = y00 */
+                                            y += ((c[3]*u1 + c[7])*u1 + c[11])*u1;
+                                        }
+                                        break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return y;
+                                 }
+                                 break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u2 "
+                                    "(=%lf) must be greater or equal\nthan the minimum abscissa "
+                                    "value u_min[2] (=%lf) defined in the table.\n", u2, u2Min);
+                                return y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return y;
                         }
-                        else /* if (extrapolate1 == RIGHT) */ {
-                            const double u11 = TABLE_COL0(last1 + 2);
-                            const double v1 = u11 - u10;
-                            y = LINEAR_SLOPE(TABLE(last1 + 2, 1), (3*c[0]*v1 +
-                                2*c[1])*v1 + c[2], u1 - u11);
+                    }
+                    else /* if (extrapolate2 == RIGHT) */ {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR(u1, u2);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(last1, nCol - 3, nCol - 2)];
+                                            const double v2 = u2Max - TABLE_ROW0(nCol - 2);
+                                            double p1, p2, p3;
+                                            double dp1_u2, dp2_u2, dp3_u2, dp4_u2;
+                                            double der_y2;
+                                            u1 -= TABLE_COL0(last1 + 1);
+                                            y = TABLE(last1 + 1, nCol - 2); /* c[15] = y00 */
+                                            p1 = ((c[0]*v2 + c[1])*v2 + c[2])*v2 + c[3];
+                                            p2 = ((c[4]*v2 + c[5])*v2 + c[6])*v2 + c[7];
+                                            p3 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
+                                            dp1_u2 = (3*c[0]*v2 + 2*c[1])*v2 + c[2];
+                                            dp2_u2 = (3*c[4]*v2 + 2*c[5])*v2 + c[6];
+                                            dp3_u2 = (3*c[8]*v2 + 2*c[9])*v2 + c[10];
+                                            dp4_u2 = (3*c[12]*v2 + 2*c[13])*v2 + c[14];
+                                            der_y2 = ((dp1_u2*u1 + dp2_u2)*u1 + dp3_u2)*u1 + dp4_u2;
+                                            y += ((c[12]*v2 + c[13])*v2 + c[14])*v2; /* p4 */
+                                            y += ((p1*u1 + p2)*u1 + p3)*u1;
+                                            y += der_y2*(u2 - u2Max);
+                                        }
+                                        break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS: {
+                                        const double u10 = TABLE_COL0(last1 + 1);
+                                        const double u11 = TABLE_COL0(last1 + 2);
+                                        const double y01 = TABLE(last1 + 1, nCol - 1);
+                                        const double y11 = TABLE(last1 + 2, nCol - 1);
+                                        LINEAR(u1, u10, u11, y01, y11);
+                                        break;
+                                    }
+
+                                    case CONSTANT_SEGMENTS:
+                                        if (u1 >= TABLE_COL0(last1 + 2)) {
+                                            last1++;
+                                        }
+                                        y = TABLE(last1 + 1, nCol - 1);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(last1, nCol - 3, nCol - 2)];
+                                            const double v2 = u2Max - TABLE_ROW0(nCol - 2);
+                                            double p1, p2, p3;
+                                            u1 -= TABLE_COL0(last1 + 1);
+                                            y = TABLE(last1 + 1, nCol - 2); /* c[15] = y00 */
+                                            p1 = ((c[0]*v2 + c[1])*v2 + c[2])*v2 + c[3];
+                                            p2 = ((c[4]*v2 + c[5])*v2 + c[6])*v2 + c[7];
+                                            p3 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
+                                            y += ((c[12]*v2 + c[13])*v2 + c[14])*v2; /* p4 */
+                                            y += ((p1*u1 + p2)*u1 + p3)*u1;
+                                        }
+                                        break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return y;
+                                 }
+                                 break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u2 "
+                                    "(=%lf) must be less or equal\nthan the maximum abscissa "
+                                    "value u_max[2] (=%lf) defined in the table.\n", u2, u2Max);
+                                return y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return y;
                         }
                     }
-                    break;
+                }
+                else if (extrapolate1 == LEFT) {
+                    if (extrapolate2 == IN_TABLE) {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR(u1, u2);
+                                        break;
 
-                case FRITSCH_BUTLAND_MONOTONE_C1:
-                case STEFFEN_MONOTONE_C1:
-                    ModelicaError("Bivariate monotone C1 interpolation is "
-                        "not implemented\n");
-                    return y;
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(0, last2, nCol - 2)];
+                                            double der_y1;
+                                            u2 -= TABLE_ROW0(last2 + 1);
+                                            der_y1 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
+                                            y = TABLE(1, last2 + 1); /* c[15] = y00 */
+                                            y += ((c[12]*u2 + c[13])*u2 + c[14])*u2; /* p4 */
+                                            y += der_y1*(u1 - u1Min);
+                                        }
+                                        break;
 
-                default:
-                    ModelicaError("Unknown smoothness kind\n");
-                    return y;
-            }
-        }
-        else if (nRow > 2 && nCol > 2) {
-            enum PointInterval extrapolate1 = IN_TABLE;
-            enum PointInterval extrapolate2 = IN_TABLE;
-            size_t last1, last2;
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return y;
 
-            if (u1 < TABLE_COL0(1)) {
-                extrapolate1 = LEFT;
-                last1 = 0;
-            }
-            else if (u1 > TABLE_COL0(nRow - 1)) {
-                extrapolate1 = RIGHT;
-                last1 = nRow - 3;
-            }
-            else {
-                last1 = findRowIndex(&TABLE(1, 0), nRow - 1, nCol,
-                    tableID->last1, u1);
-                tableID->last1 = last1;
-            }
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return y;
+                                 }
+                                 break;
 
-            if (u2 < TABLE_ROW0(1)) {
-                extrapolate2 = LEFT;
-                last2 = 0;
-            }
-            else if (u2 > TABLE_ROW0(nCol - 1)) {
-                extrapolate2 = RIGHT;
-                last2 = nCol - 3;
-            }
-            else {
-                last2 = findColIndex(&TABLE(0, 1), nCol - 1,
-                    tableID->last2, u2);
-                tableID->last2 = last2;
-            }
+                            case HOLD_LAST_POINT:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS: {
+                                        const double u20 = TABLE_ROW0(last2 + 1);
+                                        const double u21 = TABLE_ROW0(last2 + 2);
+                                        const double y00 = TABLE(1, last2 + 1);
+                                        const double y01 = TABLE(1, last2 + 2);
+                                        LINEAR(u2, u20, u21, y00, y01);
+                                        break;
+                                    }
 
-            switch (tableID->smoothness) {
-                case  CONSTANT_SEGMENTS:
-                    if (extrapolate1 == IN_TABLE && extrapolate2 == IN_TABLE) {
-                        if (u1 >= TABLE_COL0(last1 + 2)) {
-                            last1 += 1;
+                                    case CONSTANT_SEGMENTS:
+                                        if (u2 >= TABLE_ROW0(last2 + 2)) {
+                                            last2++;
+                                        }
+                                        y = TABLE(1, last2 + 1);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(0, last2, nCol - 2)];
+                                            u2 -= TABLE_ROW0(last2 + 1);
+                                            y = TABLE(1, last2 + 1); /* c[15] = y00 */
+                                            y += ((c[12]*u2 + c[13])*u2 + c[14])*u2; /* p4 */
+                                        }
+                                        break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return y;
+                                 }
+                                 break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u1 "
+                                    "(=%lf) must be greater or equal\nthan the minimum abscissa "
+                                    "value u_min[1] (=%lf) defined in the table.\n", u1, u1Min);
+                                return y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return y;
                         }
-                        if (u2 >= TABLE_ROW0(last2 + 2)) {
-                            last2 += 1;
+                    }
+                    else if (extrapolate2 == LEFT) {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR(u1, u2);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(0, 0, nCol - 2)];
+                                            double der_y1, der_y2, der_y12;
+                                            u1 -= u1Min;
+                                            u2 -= u2Min;
+                                            der_y1 = c[11];
+                                            der_y2 = c[14];
+                                            der_y12 = c[10];
+                                            y = TABLE(1, 1);
+                                            y += der_y1*u1 + der_y2*u2 + der_y12*u1*u2;
+                                        }
+                                        break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                y =  TABLE(1, 1);
+                                break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u1 "
+                                    "(=%lf) must be greater or equal\nthan the minimum abscissa "
+                                    "value u_min[1] (=%lf) defined in the table.\n"
+                                    "Extrapolation error: The value u2 (=%lf) must be greater "
+                                    "or equal\nthan the minimum abscissa value u_min[2] (=%lf) "
+                                    "defined in the table.\n", u1, u1Min, u2, u2Min);
+                                return y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return y;
                         }
-                        y = TABLE(last1 + 1, last2 + 1);
-                        break;
                     }
-                    /* Fall through: bilinear extrapolation */
-                case LINEAR_SEGMENTS: {
-                    const double u10 = TABLE_COL0(last1 + 1);
-                    const double u11 = TABLE_COL0(last1 + 2);
-                    const double u20 = TABLE_ROW0(last2 + 1);
-                    const double u21 = TABLE_ROW0(last2 + 2);
-                    const double y00 = TABLE(last1 + 1, last2 + 1);
-                    const double y01 = TABLE(last1 + 1, last2 + 2);
-                    const double y10 = TABLE(last1 + 2, last2 + 1);
-                    const double y11 = TABLE(last1 + 2, last2 + 2);
-                    BILINEAR(u1, u2,
-                        u10, u11, u20, u21, y00, y01, y10, y11)
-                    break;
+                    else /* if (extrapolate2 == RIGHT) */ {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR(u1, u2);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(0, nCol - 3, nCol - 2)];
+                                            const double v2 = u2Max - TABLE_ROW0(nCol - 2);
+                                            double der_y1, der_y2, der_y12;
+                                            u1 -= u1Min;
+                                            u2 -= u2Max;
+                                            der_y1 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
+                                            der_y2 =(3*c[12]*v2 + 2*c[13])*v2 + c[14];
+                                            der_y12 = (3*c[8]*v2 + 2*c[9])*v2 + c[10];
+                                            y = TABLE(1, nCol - 1);
+                                            y += der_y1*u1 + der_y2*u2 + der_y12*u1*u2;
+                                        }
+                                        break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                y = TABLE(1, nCol - 1);
+                                break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u1 "
+                                    "(=%lf) must be greater or equal\nthan the minimum abscissa "
+                                    "value u_min[1] (=%lf) defined in the table.\n"
+                                    "Extrapolation error: The value u2 (=%lf) must be less "
+                                    "or equal\nthan the maximum abscissa value u_max[2] (=%lf) "
+                                    "defined in the table.\n", u1, u1Min, u2, u2Max);
+                                return y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return y;
+                        }
+                    }
                 }
+                else /* if (extrapolate1 == RIGHT) */ {
+                    if (extrapolate2 == IN_TABLE) {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR(u1, u2);
+                                        break;
 
-                case AKIMA_C1:
-                    if (tableID->spline != NULL) {
-                        const double* c = tableID->spline[
-                            IDX(last1, last2, nCol - 2)];
-                        if (extrapolate1 == IN_TABLE) {
-                            u1 -= TABLE_COL0(last1 + 1);
-                            y = TABLE(last1 + 1, last2 + 1); /* c[15] = y00 */
-                            if (extrapolate2 == IN_TABLE) {
-                                double p1, p2, p3;
-                                u2 -= TABLE_ROW0(last2 + 1);
-                                p1 = ((c[0]*u2 + c[1])*u2 + c[2])*u2 + c[3];
-                                p2 = ((c[4]*u2 + c[5])*u2 + c[6])*u2 + c[7];
-                                p3 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
-                                y += ((c[12]*u2 + c[13])*u2 + c[14])*u2; /* p4 */
-                                y += ((p1*u1 + p2)*u1 + p3)*u1;
-                            }
-                            else if (extrapolate2 == LEFT) {
-                                double der_y2;
-                                u2 -= TABLE_ROW0(1);
-                                der_y2 = ((c[2]*u1 + c[6])*u1 + c[10])*u1 + c[14];
-                                y += ((c[3]*u1 + c[7])*u1 + c[11])*u1;
-                                y += der_y2*u2;
-                            }
-                            else /* if (extrapolate2 == RIGHT) */ {
-                                const double v2 = TABLE_ROW0(nCol - 1) -
-                                    TABLE_ROW0(nCol - 2);
-                                double p1, p2, p3;
-                                double dp1_u2, dp2_u2, dp3_u2, dp4_u2;
-                                double der_y2;
-                                u2 -= TABLE_ROW0(nCol - 1);
-                                p1 = ((c[0]*v2 + c[1])*v2 + c[2])*v2 + c[3];
-                                p2 = ((c[4]*v2 + c[5])*v2 + c[6])*v2 + c[7];
-                                p3 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
-                                dp1_u2 = (3*c[0]*v2 + 2*c[1])*v2 + c[2];
-                                dp2_u2 = (3*c[4]*v2 + 2*c[5])*v2 + c[6];
-                                dp3_u2 = (3*c[8]*v2 + 2*c[9])*v2 + c[10];
-                                dp4_u2 = (3*c[12]*v2 + 2*c[13])*v2 + c[14];
-                                der_y2 = ((dp1_u2*u1 + dp2_u2)*u1 + dp3_u2)*u1 + dp4_u2;
-                                y += ((c[12]*v2 + c[13])*v2 + c[14])*v2; /* p4 */
-                                y += ((p1*u1 + p2)*u1 + p3)*u1;
-                                y += der_y2*u2;
-                            }
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(nRow - 3, last2, nCol - 2)];
+                                            double p1, p2, p3;
+                                            double der_y1;
+                                            const double v1 = u1Max - TABLE_COL0(nRow - 2);
+                                            u2 -= TABLE_ROW0(last2 + 1);
+                                            p1 = ((c[0]*u2 + c[1])*u2 + c[2])*u2 + c[3];
+                                            p2 = ((c[4]*u2 + c[5])*u2 + c[6])*u2 + c[7];
+                                            p3 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
+                                            der_y1 = (3*p1*v1 + 2*p2)*v1 + p3;
+                                            y = TABLE(nRow - 2, last2 + 1); /* c[15] = y00 */
+                                            y += ((c[12]*u2 + c[13])*u2 + c[14])*u2; /* p4 */
+                                            y += ((p1*v1 + p2)*v1 + p3)*v1;
+                                            y += der_y1*(u1 - u1Max);
+                                        }
+                                        break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS: {
+                                        const double u20 = TABLE_ROW0(last2 + 1);
+                                        const double u21 = TABLE_ROW0(last2 + 2);
+                                        const double y10 = TABLE(nRow - 1, last2 + 1);
+                                        const double y11 = TABLE(nRow - 1, last2 + 2);
+                                        LINEAR(u2, u20, u21, y10, y11);
+                                        break;
+                                    }
+
+                                    case CONSTANT_SEGMENTS:
+                                        if (u2 >= TABLE_ROW0(last2 + 2)) {
+                                            last2++;
+                                        }
+                                        y = TABLE(nRow - 1, last2 + 1);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(nRow - 3, last2, nCol - 2)];
+                                            double p1, p2, p3;
+                                            const double v1 = u1Max - TABLE_COL0(nRow - 2);
+                                            u2 -= TABLE_ROW0(last2 + 1);
+                                            p1 = ((c[0]*u2 + c[1])*u2 + c[2])*u2 + c[3];
+                                            p2 = ((c[4]*u2 + c[5])*u2 + c[6])*u2 + c[7];
+                                            p3 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
+                                            y = TABLE(nRow - 2, last2 + 1); /* c[15] = y00 */
+                                            y += ((c[12]*u2 + c[13])*u2 + c[14])*u2; /* p4 */
+                                            y += ((p1*v1 + p2)*v1 + p3)*v1;
+                                        }
+                                        break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return y;
+                                 }
+                                 break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u1 "
+                                    "(=%lf) must be less or equal\nthan the maximum abscissa "
+                                    "value u_max[1] (=%lf) defined in the table.\n", u1, u1Max);
+                                return y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return y;
                         }
-                        else if (extrapolate1 == LEFT) {
-                            u1 -= TABLE_COL0(1);
-                            if (extrapolate2 == IN_TABLE) {
-                                double der_y1;
-                                u2 -= TABLE_ROW0(last2 + 1);
-                                der_y1 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
-                                y = TABLE(last1 + 1, last2 + 1); /* c[15] = y00 */
-                                y += ((c[12]*u2 + c[13])*u2 + c[14])*u2; /* p4 */
-                                y += der_y1*u1;
-                            }
-                            else if (extrapolate2 == LEFT) {
-                                double der_y1, der_y2, der_y12;
-                                u2 -= TABLE_ROW0(1);
-                                der_y1 = c[11];
-                                der_y2 = c[14];
-                                der_y12 = c[10];
-                                y = TABLE(1, 1);
-                                y += der_y1*u1 + der_y2*u2 + der_y12*u1*u2;
-                            }
-                            else /* if (extrapolate2 == RIGHT) */ {
-                                const double v2 = TABLE_ROW0(nCol - 1) -
-                                    TABLE_ROW0(nCol - 2);
-                                double der_y1, der_y2, der_y12;
-                                u2 -= TABLE_ROW0(nCol - 1);
-                                der_y1 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
-                                der_y2 =(3*c[12]*v2 + 2*c[13])*v2 + c[14];
-                                der_y12 = (3*c[8]*v2 + 2*c[9])*v2 + c[10];
-                                y = TABLE(1, nCol - 1);
-                                y += der_y1*u1 + der_y2*u2 + der_y12*u1*u2;
-                            }
-                        }
-                        else /* if (extrapolate1 == RIGHT) */ {
-                            const double v1 = TABLE_COL0(nRow - 1) -
-                                TABLE_COL0(nRow - 2);
-                            u1 -= TABLE_COL0(nRow - 1);
-                            if (extrapolate2 == IN_TABLE) {
-                                double p1, p2, p3;
-                                double der_y1;
-                                u2 -= TABLE_ROW0(last2 + 1);
-                                p1 = ((c[0]*u2 + c[1])*u2 + c[2])*u2 + c[3];
-                                p2 = ((c[4]*u2 + c[5])*u2 + c[6])*u2 + c[7];
-                                p3 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
-                                der_y1 = (3*p1*v1 + 2*p2)*v1 + p3;
-                                y = TABLE(last1 + 1, last2 + 1); /* c[15] = y00 */
-                                y += ((c[12]*u2 + c[13])*u2 + c[14])*u2; /* p4 */
-                                y += ((p1*v1 + p2)*v1 + p3)*v1;
-                                y += der_y1*u1;
-                            }
-                            else if (extrapolate2 == LEFT) {
-                                double der_y1, der_y2, der_y12;
-                                u2 -= TABLE_ROW0(1);
-                                der_y1 = (3*c[3]*v1 + 2*c[7])*v1 + c[11];
-                                der_y2 = ((c[2]*v1 + c[6])*v1 + c[10])*v1 + c[14];
-                                der_y12 = (3*c[2]*v1 + 2*c[6])*v1 + c[10];
+                    }
+                    else if (extrapolate2 == LEFT) {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR(u1, u2);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(nRow - 3 , 0, nCol - 2)];
+                                            const double v1 = u1Max - TABLE_COL0(nRow - 2);
+                                            double der_y1, der_y2, der_y12;
+                                            u1 -= u1Max;
+                                            u2 -= u2Min;
+                                            der_y1 = (3*c[3]*v1 + 2*c[7])*v1 + c[11];
+                                            der_y2 = ((c[2]*v1 + c[6])*v1 + c[10])*v1 + c[14];
+                                            der_y12 = (3*c[2]*v1 + 2*c[6])*v1 + c[10];
+                                            y = TABLE(nRow - 1, 1);
+                                            y += der_y1*u1 + der_y2*u2 + der_y12*u1*u2;
+                                        }
+                                        break;
+
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
                                 y = TABLE(nRow - 1, 1);
-                                y += der_y1*u1 + der_y2*u2 + der_y12*u1*u2;
-                            }
-                            else /* if (extrapolate2 == RIGHT) */ {
-                                const double v2 = TABLE_ROW0(nCol - 1) -
-                                    TABLE_ROW0(nCol - 2);
-                                double p1, p2, p3;
-                                double dp1_u2, dp2_u2, dp3_u2, dp4_u2;
-                                double der_y1, der_y2, der_y12;
-                                u2 -= TABLE_ROW0(nCol - 1);
-                                p1 = ((c[0]*v2 + c[1])*v2 + c[2])*v2 + c[3];
-                                p2 = ((c[4]*v2 + c[5])*v2 + c[6])*v2 + c[7];
-                                p3 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
-                                dp1_u2 = (3*c[0]*v2 + 2*c[1])*v2 + c[2];
-                                dp2_u2 = (3*c[4]*v2 + 2*c[5])*v2 + c[6];
-                                dp3_u2 = (3*c[8]*v2 + 2*c[9])*v2 + c[10];
-                                dp4_u2 = (3*c[12]*v2 + 2*c[13])*v2 + c[14];
-                                der_y1 = (3*p1*v1 + 2*p2)*v1 + p3;
-                                der_y2 = ((dp1_u2*v1 + dp2_u2)*v1 + dp3_u2)*v1 + dp4_u2;
-                                der_y12 = (3*dp1_u2*v1 + 2*dp2_u2)*v1 + dp3_u2;
-                                y = TABLE(nRow - 1, nCol - 1);
-                                y += der_y1*u1 + der_y2*u2 + der_y12*u1*u2;
-                            }
+                                break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u1 "
+                                    "(=%lf) must be less or equal\nthan the maximum abscissa "
+                                    "value u_max[1] (=%lf) defined in the table.\n"
+                                    "Extrapolation error: The value u2 (=%lf) must be greater "
+                                    "or equal\nthan the minimum abscissa value u_min[2] (=%lf) "
+                                    "defined in the table.\n", u1, u1Max, u2, u2Min);
+                                return y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return y;
                         }
                     }
-                    break;
+                    else /* if (extrapolate2 == RIGHT) */ {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR(u1, u2);
+                                        break;
 
-                case FRITSCH_BUTLAND_MONOTONE_C1:
-                case STEFFEN_MONOTONE_C1:
-                    ModelicaError("Bivariate monotone C1 interpolation is "
-                        "not implemented\n");
-                    return y;
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(nRow - 3, nCol - 3, nCol - 2)];
+                                            const double v1 = u1Max - TABLE_COL0(nRow - 2);
+                                            const double v2 = u2Max - TABLE_ROW0(nCol - 2);
+                                            double p1, p2, p3;
+                                            double dp1_u2, dp2_u2, dp3_u2, dp4_u2;
+                                            double der_y1, der_y2, der_y12;
+                                            u1 -= u1Max;
+                                            u2 -= u2Max;
+                                            p1 = ((c[0]*v2 + c[1])*v2 + c[2])*v2 + c[3];
+                                            p2 = ((c[4]*v2 + c[5])*v2 + c[6])*v2 + c[7];
+                                            p3 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
+                                            dp1_u2 = (3*c[0]*v2 + 2*c[1])*v2 + c[2];
+                                            dp2_u2 = (3*c[4]*v2 + 2*c[5])*v2 + c[6];
+                                            dp3_u2 = (3*c[8]*v2 + 2*c[9])*v2 + c[10];
+                                            dp4_u2 = (3*c[12]*v2 + 2*c[13])*v2 + c[14];
+                                            der_y1 = (3*p1*v1 + 2*p2)*v1 + p3;
+                                            der_y2 = ((dp1_u2*v1 + dp2_u2)*v1 + dp3_u2)*v1 + dp4_u2;
+                                            der_y12 = (3*dp1_u2*v1 + 2*dp2_u2)*v1 + dp3_u2;
+                                            y = TABLE(nRow - 1, nCol - 1);
+                                            y += der_y1*u1 + der_y2*u2 + der_y12*u1*u2;
+                                        }
+                                        break;
 
-                default:
-                    ModelicaError("Unknown smoothness kind\n");
-                    return y;
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                y = TABLE(nRow - 1, nCol - 1);
+                                break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u1 "
+                                    "(=%lf) must be less or equal\nthan the maximum abscissa "
+                                    "value u_max[1] (=%lf) defined in the table.\n"
+                                    "Extrapolation error: The value u2 (=%lf) must be less "
+                                    "or equal\nthan the maximum abscissa value u_max[2] (=%lf) "
+                                    "defined in the table.\n", u1, u1Max, u2, u2Max);
+                                return y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return y;
+                        }
+                    }
+                }
             }
         }
     }
@@ -2738,84 +3599,175 @@
                                                        double der_u2) {
     double der_y = 0;
     CombiTable2D* tableID = (CombiTable2D*)_tableID;
-    if (tableID != NULL && tableID->table != NULL) {
+    if (NULL != tableID && NULL != tableID->table) {
         const double* table = tableID->table;
         const size_t nRow = tableID->nRow;
         const size_t nCol = tableID->nCol;
+        const double u1Min = TABLE_COL0(1);
+        const double u1Max = TABLE_COL0(nRow - 1);
+        const double u2Min = TABLE_ROW0(1);
+        const double u2Max = TABLE_ROW0(nCol - 1);
 
-        if (nRow == 2 && nCol == 2) {
-        }
-        else if (nRow == 2 && nCol > 2) {
-            enum PointInterval extrapolate2 = IN_TABLE;
-            size_t last2;
+        if (nRow == 2) {
+            if (nCol > 2) {
+                enum PointInterval extrapolate2 = IN_TABLE;
+                size_t last2;
 
-            if (u2 < TABLE_ROW0(1)) {
-                extrapolate2 = LEFT;
-                last2 = 0;
-            }
-            else if (u2 > TABLE_ROW0(nCol - 1)) {
-                extrapolate2 = RIGHT;
-                last2 = nCol - 3;
-            }
-            else {
-                last2 = findColIndex(&TABLE(0, 1), nCol - 1,
-                    tableID->last2, u2);
-                tableID->last2 = last2;
-            }
+                /* Periodic extrapolation */
+                if (tableID->extrapolation == PERIODIC) {
+                    const double T = u2Max - u2Min;
 
-            switch (tableID->smoothness) {
-                case CONSTANT_SEGMENTS:
-                    if (extrapolate2 == IN_TABLE) {
-                        break;
+                    if (u2 < u2Min) {
+                        do {
+                            u2 += T;
+                        } while (u2 < u2Min);
                     }
-                    /* Fall through: linear extrapolation */
-                case LINEAR_SEGMENTS: {
-                    der_y = (TABLE(1, last2 + 2) - TABLE(1, last2 + 1))/
-                        (TABLE_ROW0(last2 + 2) - TABLE_ROW0(last2 + 1));
-                    der_y *= der_u2;
-                    break;
+                    else if (u2 > u2Max) {
+                        do {
+                            u2 -= T;
+                        } while (u2 > u2Max);
+                    }
+                    last2 = findColIndex(&TABLE(0, 1), nCol - 1,
+                        tableID->last2, u2);
+                    tableID->last2 = last2;
                 }
+                else if (u2 < u2Min) {
+                    extrapolate2 = LEFT;
+                    last2 = 0;
+                }
+                else if (u2 > u2Max) {
+                    extrapolate2 = RIGHT;
+                    last2 = nCol - 3;
+                }
+                else {
+                    last2 = findColIndex(&TABLE(0, 1), nCol - 1,
+                        tableID->last2, u2);
+                    tableID->last2 = last2;
+                }
 
-                case AKIMA_C1:
-                    if (tableID->spline != NULL) {
-                        const double* c = tableID->spline[last2];
-                        const double u20 = TABLE_ROW0(last2 + 1);
-                        if (extrapolate2 == IN_TABLE) {
-                            u2 -= u20;
-                            der_y = (3*c[0]*u2 + 2*c[1])*u2 + c[2];
-                        }
-                        else if (extrapolate2 == LEFT) {
-                            der_y = c[2];
-                        }
-                        else /* if (extrapolate2 == RIGHT) */ {
-                            const double u21 = TABLE_ROW0(last2 + 2);
-                            der_y = u21 - u20;
-                            der_y = (3*c[0]*der_y + 2*c[1])*der_y + c[2];
-                        }
-                        der_y *= der_u2;
+                if (extrapolate2 == IN_TABLE) {
+                    switch (tableID->smoothness) {
+                        case LINEAR_SEGMENTS:
+                            der_y = (TABLE(1, last2 + 2) - TABLE(1, last2 + 1))/
+                                (TABLE_ROW0(last2 + 2) - TABLE_ROW0(last2 + 1));
+                            der_y *= der_u2;
+                            break;
+
+                        case CONSTANT_SEGMENTS:
+                            break;
+
+                        case AKIMA_C1:
+                            if (NULL != tableID->spline) {
+                                const double* c = tableID->spline[last2];
+                                const double u20 = TABLE_ROW0(last2 + 1);
+                                u2 -= u20;
+                                der_y = (3*c[0]*u2 + 2*c[1])*u2 + c[2];
+                                der_y *= der_u2;
+                            }
+                            break;
+
+                        case FRITSCH_BUTLAND_MONOTONE_C1:
+                        case STEFFEN_MONOTONE_C1:
+                            ModelicaError("Bivariate monotone C1 interpolation is "
+                                "not implemented\n");
+                            return der_y;
+
+                        default:
+                            ModelicaError("Unknown smoothness kind\n");
+                            return der_y;
                     }
-                    break;
+                }
+                else {
+                    /* Extrapolation */
+                    switch (tableID->extrapolation) {
+                        case LAST_TWO_POINTS:
+                            switch (tableID->smoothness) {
+                                case LINEAR_SEGMENTS:
+                                case CONSTANT_SEGMENTS:
+                                    der_y = (TABLE(1, last2 + 2) - TABLE(1, last2 + 1))/
+                                        (TABLE_ROW0(last2 + 2) - TABLE_ROW0(last2 + 1));
+                                    der_y *= der_u2;
+                                    break;
 
-                case FRITSCH_BUTLAND_MONOTONE_C1:
-                case STEFFEN_MONOTONE_C1:
-                    ModelicaError("Bivariate monotone C1 interpolation is "
-                        "not implemented\n");
-                    return der_y;
+                                case AKIMA_C1:
+                                    if (NULL != tableID->spline) {
+                                        const double* c = tableID->spline[last2];
+                                        if (extrapolate2 == LEFT) {
+                                            der_y = c[2];
+                                        }
+                                        else /* if (extrapolate2 == RIGHT) */ {
+                                            const double u20 = TABLE_ROW0(last2 + 1);
+                                            const double u21 = TABLE_ROW0(last2 + 2);
+                                            der_y = u21 - u20;
+                                            der_y = (3*c[0]*der_y + 2*c[1])*der_y + c[2];
+                                        }
+                                        der_y *= der_u2;
+                                    }
+                                    break;
 
-                default:
-                    ModelicaError("Unknown smoothness kind\n");
-                    return der_y;
+                                case FRITSCH_BUTLAND_MONOTONE_C1:
+                                case STEFFEN_MONOTONE_C1:
+                                    ModelicaError("Bivariate monotone C1 interpolation is "
+                                        "not implemented\n");
+                                    return der_y;
+
+                                default:
+                                    ModelicaError("Unknown smoothness kind\n");
+                                    return der_y;
+                            }
+                            break;
+
+                        case HOLD_LAST_POINT:
+                            break;
+
+                        case NO_EXTRAPOLATION:
+                            ModelicaFormatError("Extrapolation error: The value u2 "
+                                "(=%lf) must be %s or equal\nthan the %s abscissa "
+                                "value %s (=%lf) defined in the table.\n", u2,
+                                (extrapolate2 == LEFT) ? "greater" : "less",
+                                (extrapolate2 == LEFT) ? "minimum" : "maximum",
+                                (extrapolate2 == LEFT) ? "u_min[2]" : "u_max[2]",
+                                (extrapolate2 == LEFT) ? u2Min : u2Max);
+                            return der_y;
+
+                        case PERIODIC:
+                            /* Should not be possible to get here */
+                            break;
+
+                        default:
+                            ModelicaError("Unknown extrapolation kind\n");
+                            return der_y;
+                    }
+                }
             }
         }
-        else if (nRow > 2 && nCol == 2) {
+        else if (nRow > 2) {
             enum PointInterval extrapolate1 = IN_TABLE;
             size_t last1;
 
-            if (u1 < TABLE_COL0(1)) {
+            /* Periodic extrapolation */
+            if (tableID->extrapolation == PERIODIC) {
+                const double T = u1Max - u1Min;
+
+                if (u1 < u1Min) {
+                    do {
+                        u1 += T;
+                    } while (u1 < u1Min);
+                }
+                else if (u1 > u1Max) {
+                    do {
+                        u1 -= T;
+                    } while (u1 > u1Max);
+                }
+                last1 = findRowIndex(&TABLE(1, 0), nRow - 1, nCol,
+                    tableID->last1, u1);
+                tableID->last1 = last1;
+            }
+            else if (u1 < u1Min) {
                 extrapolate1 = LEFT;
                 last1 = 0;
             }
-            else if (u1 > TABLE_COL0(nRow - 1)) {
+            else if (u1 > u1Max) {
                 extrapolate1 = RIGHT;
                 last1 = nRow - 3;
             }
@@ -2824,248 +3776,659 @@
                     tableID->last1, u1);
                 tableID->last1 = last1;
             }
+            if (nCol == 2) {
+                if (extrapolate1 == IN_TABLE) {
+                    switch (tableID->smoothness) {
+                        case LINEAR_SEGMENTS:
+                            der_y = (TABLE(last1 + 2, 1) - TABLE(last1 + 1, 1))/
+                                (TABLE_COL0(last1 + 2) - TABLE_COL0(last1 + 1));
+                            der_y *= der_u1;
+                            break;
 
-            switch (tableID->smoothness) {
-                case CONSTANT_SEGMENTS:
-                    if (extrapolate1 == IN_TABLE) {
-                        break;
+                        case CONSTANT_SEGMENTS:
+                            break;
+
+                        case AKIMA_C1:
+                            if (NULL != tableID->spline) {
+                                const double* c = tableID->spline[last1];
+                                const double u10 = TABLE_COL0(last1 + 1);
+                                u1 -= u10;
+                                der_y = (3*c[0]*u1 + 2*c[1])*u1 + c[2];
+                                der_y *= der_u1;
+                            }
+                            break;
+
+                        case FRITSCH_BUTLAND_MONOTONE_C1:
+                        case STEFFEN_MONOTONE_C1:
+                            ModelicaError("Bivariate monotone C1 interpolation is "
+                                "not implemented\n");
+                            return der_y;
+
+                        default:
+                            ModelicaError("Unknown smoothness kind\n");
+                            return der_y;
                     }
-                    /* Fall through: linear extrapolation */
-                case LINEAR_SEGMENTS: {
-                    der_y = (TABLE(last1 + 2, 1) - TABLE(last1 + 1, 1))/
-                        (TABLE_COL0(last1 + 2) - TABLE_COL0(last1 + 1));
-                    der_y *= der_u1;
-                    break;
                 }
+                else {
+                    /* Extrapolation */
+                    switch (tableID->extrapolation) {
+                        case LAST_TWO_POINTS:
+                            switch (tableID->smoothness) {
+                                case LINEAR_SEGMENTS:
+                                case CONSTANT_SEGMENTS:
+                                    der_y = (TABLE(last1 + 2, 1) - TABLE(last1 + 1, 1))/
+                                        (TABLE_COL0(last1 + 2) - TABLE_COL0(last1 + 1));
+                                    der_y *= der_u1;
+                                    break;
 
-                case AKIMA_C1:
-                    if (tableID->spline != NULL) {
-                        const double* c = tableID->spline[last1];
-                        const double u10 = TABLE_COL0(last1 + 1);
-                        if (extrapolate1 == IN_TABLE) {
-                            u1 -= u10;
-                            der_y = (3*c[0]*u1 + 2*c[1])*u1 + c[2];
+                                case AKIMA_C1:
+                                    if (NULL != tableID->spline) {
+                                        const double* c = tableID->spline[last1];
+                                        if (extrapolate1 == LEFT) {
+                                            der_y = c[2];
+                                        }
+                                        else /* if (extrapolate1 == RIGHT) */ {
+                                            const double u10 = TABLE_COL0(last1 + 1);
+                                            const double u11 = TABLE_COL0(last1 + 2);
+                                            der_y = u11 - u10;
+                                            der_y = (3*c[0]*der_y + 2*c[1])*der_y + c[2];
+                                        }
+                                        der_y *= der_u1;
+                                    }
+                                    break;
+
+                                case FRITSCH_BUTLAND_MONOTONE_C1:
+                                case STEFFEN_MONOTONE_C1:
+                                    ModelicaError("Bivariate monotone C1 interpolation is "
+                                        "not implemented\n");
+                                    return der_y;
+
+                                default:
+                                    ModelicaError("Unknown smoothness kind\n");
+                                    return der_y;
+                            }
+                            break;
+
+                        case HOLD_LAST_POINT:
+                            break;
+
+                        case NO_EXTRAPOLATION:
+                            ModelicaFormatError("Extrapolation error: The value u1 "
+                                "(=%lf) must be %s or equal\nthan the %s abscissa "
+                                "value %s (=%lf) defined in the table.\n", u1,
+                                (extrapolate1 == LEFT) ? "greater" : "less",
+                                (extrapolate1 == LEFT) ? "minimum" : "maximum",
+                                (extrapolate1 == LEFT) ? "u_min[1]" : "u_max[1]",
+                                (extrapolate1 == LEFT) ? u1Min : u1Max);
+                            return der_y;
+
+                        case PERIODIC:
+                            /* Should not be possible to get here */
+                            break;
+
+                        default:
+                            ModelicaError("Unknown extrapolation kind\n");
+                            return der_y;
+                    }
+                }
+            }
+            else if (nCol > 2) {
+                enum PointInterval extrapolate2 = IN_TABLE;
+                size_t last2;
+
+                /* Periodic extrapolation */
+                if (tableID->extrapolation == PERIODIC) {
+                    const double T = u2Max - u2Min;
+
+                    if (u2 < u2Min) {
+                        do {
+                            u2 += T;
+                        } while (u2 < u2Min);
+                    }
+                    else if (u2 > u2Max) {
+                        do {
+                            u2 -= T;
+                        } while (u2 > u2Max);
+                    }
+                    last2 = findColIndex(&TABLE(0, 1), nCol - 1,
+                        tableID->last2, u2);
+                    tableID->last2 = last2;
+                }
+                else if (u2 < u2Min) {
+                    extrapolate2 = LEFT;
+                    last2 = 0;
+                }
+                else if (u2 > u2Max) {
+                    extrapolate2 = RIGHT;
+                    last2 = nCol - 3;
+                }
+                else {
+                    last2 = findColIndex(&TABLE(0, 1), nCol - 1,
+                        tableID->last2, u2);
+                    tableID->last2 = last2;
+                }
+
+                if (extrapolate1 == IN_TABLE) {
+                    if (extrapolate2 == IN_TABLE) {
+                        switch (tableID->smoothness) {
+                            case LINEAR_SEGMENTS:
+                                BILINEAR_DER(u1, u2);
+                                break;
+
+                            case CONSTANT_SEGMENTS:
+                                break;
+
+                            case AKIMA_C1:
+                                if (NULL != tableID->spline) {
+                                    const double* c = tableID->spline[
+                                        IDX(last1, last2, nCol - 2)];
+                                    double der_y1, der_y2;
+                                    double p1, p2, p3;
+                                    double dp1_u2, dp2_u2, dp3_u2, dp4_u2;
+                                    u1 -= TABLE_COL0(last1 + 1);
+                                    u2 -= TABLE_ROW0(last2 + 1);
+                                    p1 = ((c[0]*u2 + c[1])*u2 + c[2])*u2 + c[3];
+                                    p2 = ((c[4]*u2 + c[5])*u2 + c[6])*u2 + c[7];
+                                    p3 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
+                                    dp1_u2 = (3*c[0]*u2 + 2*c[1])*u2 + c[2];
+                                    dp2_u2 = (3*c[4]*u2 + 2*c[5])*u2 + c[6];
+                                    dp3_u2 = (3*c[8]*u2 + 2*c[9])*u2 + c[10];
+                                    dp4_u2 = (3*c[12]*u2 + 2*c[13])*u2 + c[14];
+                                    der_y1 = (3*p1*u1 + 2*p2)*u1 + p3;
+                                    der_y2 = ((dp1_u2*u1 + dp2_u2)*u1 + dp3_u2)*u1 + dp4_u2;
+                                    der_y = der_y1*der_u1 + der_y2*der_u2;
+                                 }
+                                 break;
+
+                            case FRITSCH_BUTLAND_MONOTONE_C1:
+                            case STEFFEN_MONOTONE_C1:
+                                ModelicaError("Bivariate monotone C1 interpolation is "
+                                    "not implemented\n");
+                                return der_y;
+
+                            default:
+                                ModelicaError("Unknown smoothness kind\n");
+                                return der_y;
                         }
-                        else if (extrapolate1 == LEFT) {
-                            der_y = c[2];
+                    }
+                    else if (extrapolate2 == LEFT) {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR_DER(u1, u2);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(last1, 0, nCol - 2)];
+                                            double der_y1, der_y2;
+                                            u1 -= TABLE_COL0(last1 + 1);
+                                            u2 -= u2Min;
+                                            der_y1 = (3*c[3]*u1 + 2*c[7])*u1 + c[11];
+                                            der_y1 += ((3*c[2]*u1 + 2*c[6])*u1 + c[10])*u2;
+                                            der_y2 = ((c[2]*u1 + c[6])*u1 + c[10])*u1 + c[14];
+                                            der_y = der_y1*der_u1 + der_y2*der_u2;
+                                         }
+                                         break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return der_y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return der_y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u2 "
+                                    "(=%lf) must be greater or equal\nthan the minimum abscissa "
+                                    "value u_min[2] (=%lf) defined in the table.\n", u2, u2Min);
+                                return der_y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return der_y;
                         }
-                        else /* if (extrapolate1 == RIGHT) */ {
-                            const double u11 = TABLE_COL0(last1 + 2);
-                            der_y = u11 - u10;
-                            der_y = (3*c[0]*der_y + 2*c[1])*der_y + c[2];
-                        }
-                        der_y *= der_u1;
                     }
-                    break;
+                    else /* if (extrapolate2 == RIGHT) */ {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR_DER(u1, u2);
+                                        break;
 
-                case FRITSCH_BUTLAND_MONOTONE_C1:
-                case STEFFEN_MONOTONE_C1:
-                    ModelicaError("Bivariate monotone C1 interpolation is "
-                        "not implemented\n");
-                    return der_y;
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(last1, nCol - 3, nCol - 2)];
+                                            double der_y1, der_y2;
+                                            const double v2 = u2Max - TABLE_ROW0(nCol - 2);
+                                            double p1, p2, p3;
+                                            double dp1_u2, dp2_u2, dp3_u2, dp4_u2;
+                                            u1 -= TABLE_COL0(last1 + 1);
+                                            u2 -= u2Max;
+                                            p1 = ((c[0]*v2 + c[1])*v2 + c[2])*v2 + c[3];
+                                            p2 = ((c[4]*v2 + c[5])*v2 + c[6])*v2 + c[7];
+                                            p3 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
+                                            dp1_u2 = (3*c[0]*v2 + 2*c[1])*v2 + c[2];
+                                            dp2_u2 = (3*c[4]*v2 + 2*c[5])*v2 + c[6];
+                                            dp3_u2 = (3*c[8]*v2 + 2*c[9])*v2 + c[10];
+                                            dp4_u2 = (3*c[12]*v2 + 2*c[13])*v2 + c[14];
+                                            der_y1 = (3*p1*u1 + 2*p2)*u1 + p3;
+                                            der_y1 += ((3*dp1_u2*u1 + 2*dp2_u2)*u1 + dp3_u2)*u2;
+                                            der_y2 = ((dp1_u2*u1 + dp2_u2)*u1 + dp3_u2)*u1 + dp4_u2;
+                                            der_y = der_y1*der_u1 + der_y2*der_u2;
+                                         }
+                                         break;
 
-                default:
-                    ModelicaError("Unknown smoothness kind\n");
-                    return der_y;
-            }
-        }
-        else if (nRow > 2 && nCol > 2) {
-            enum PointInterval extrapolate1 = IN_TABLE;
-            enum PointInterval extrapolate2 = IN_TABLE;
-            size_t last1, last2;
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return der_y;
 
-            if (u1 < TABLE_COL0(1)) {
-                extrapolate1 = LEFT;
-                last1 = 0;
-            }
-            else if (u1 > TABLE_COL0(nRow - 1)) {
-                extrapolate1 = RIGHT;
-                last1 = nRow - 3;
-            }
-            else {
-                last1 = findRowIndex(&TABLE(1, 0), nRow - 1, nCol,
-                    tableID->last1, u1);
-                tableID->last1 = last1;
-            }
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return der_y;
+                                 }
+                                 break;
 
-            if (u2 < TABLE_ROW0(1)) {
-                extrapolate2 = LEFT;
-                last2 = 0;
-            }
-            else if (u2 > TABLE_ROW0(nCol - 1)) {
-                extrapolate2 = RIGHT;
-                last2 = nCol - 3;
-            }
-            else {
-                last2 = findColIndex(&TABLE(0, 1), nCol - 1,
-                    tableID->last2, u2);
-                tableID->last2 = last2;
-            }
+                            case HOLD_LAST_POINT:
+                                break;
 
-            switch (tableID->smoothness) {
-                case CONSTANT_SEGMENTS:
-                    if (extrapolate1 == IN_TABLE && extrapolate2 == IN_TABLE) {
-                        break;
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u2 "
+                                    "(=%lf) must be less or equal\nthan the maximum abscissa "
+                                    "value u_max[2] (=%lf) defined in the table.\n", u2, u2Max);
+                                return der_y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return der_y;
+                        }
                     }
-                    /* Fall through: bilinear extrapolation */
-                case LINEAR_SEGMENTS: {
-                    const double u10 = TABLE_COL0(last1 + 1);
-                    const double u11 = TABLE_COL0(last1 + 2);
-                    const double u20 = TABLE_ROW0(last2 + 1);
-                    const double u21 = TABLE_ROW0(last2 + 2);
-                    const double y00 = TABLE(last1 + 1, last2 + 1);
-                    const double y01 = TABLE(last1 + 1, last2 + 2);
-                    const double y10 = TABLE(last1 + 2, last2 + 1);
-                    const double y11 = TABLE(last1 + 2, last2 + 2);
-                    der_y = (u21*(y10 - y00) + u20*(y01 - y11) +
-                        u2*(y00 - y01 - y10 + y11))*der_u1;
-                    der_y += (u11*(y01 - y00) + u10*(y10 - y11) +
-                        u1*(y00 - y01 - y10 + y11))*der_u2;
-                    der_y /= (u10 - u11);
-                    der_y /= (u20 - u21);
-                    break;
                 }
+                else if (extrapolate1 == LEFT) {
+                    if (extrapolate2 == IN_TABLE) {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR_DER(u1, u2);
+                                        break;
 
-                case AKIMA_C1:
-                    if (tableID->spline != NULL) {
-                        const double* c = tableID->spline[
-                            IDX(last1, last2, nCol - 2)];
-                        if (extrapolate1 == IN_TABLE) {
-                            double der_y1, der_y2;
-                            u1 -= TABLE_COL0(last1 + 1);
-                            if (extrapolate2 == IN_TABLE) {
-                                double p1, p2, p3;
-                                double dp1_u2, dp2_u2, dp3_u2, dp4_u2;
-                                u2 -= TABLE_ROW0(last2 + 1);
-                                p1 = ((c[0]*u2 + c[1])*u2 + c[2])*u2 + c[3];
-                                p2 = ((c[4]*u2 + c[5])*u2 + c[6])*u2 + c[7];
-                                p3 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
-                                dp1_u2 = (3*c[0]*u2 + 2*c[1])*u2 + c[2];
-                                dp2_u2 = (3*c[4]*u2 + 2*c[5])*u2 + c[6];
-                                dp3_u2 = (3*c[8]*u2 + 2*c[9])*u2 + c[10];
-                                dp4_u2 = (3*c[12]*u2 + 2*c[13])*u2 + c[14];
-                                der_y1 = (3*p1*u1 + 2*p2)*u1 + p3;
-                                der_y2 = ((dp1_u2*u1 + dp2_u2)*u1 + dp3_u2)*u1 + dp4_u2;
-                            }
-                            else if (extrapolate2 == LEFT) {
-                                u2 -= TABLE_ROW0(1);
-                                der_y1 = (3*c[3]*u1 + 2*c[7])*u1 + c[11];
-                                der_y1 += ((3*c[2]*u1 + 2*c[6])*u1 + c[10])*u2;
-                                der_y2 = ((c[2]*u1 + c[6])*u1 + c[10])*u1 + c[14];
-                            }
-                            else /* if (extrapolate2 == RIGHT) */ {
-                                const double v2 = TABLE_ROW0(nCol - 1) -
-                                    TABLE_ROW0(nCol - 2);
-                                double p1, p2, p3;
-                                double dp1_u2, dp2_u2, dp3_u2, dp4_u2;
-                                u2 -= TABLE_ROW0(nCol - 1);
-                                p1 = ((c[0]*v2 + c[1])*v2 + c[2])*v2 + c[3];
-                                p2 = ((c[4]*v2 + c[5])*v2 + c[6])*v2 + c[7];
-                                p3 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
-                                dp1_u2 = (3*c[0]*v2 + 2*c[1])*v2 + c[2];
-                                dp2_u2 = (3*c[4]*v2 + 2*c[5])*v2 + c[6];
-                                dp3_u2 = (3*c[8]*v2 + 2*c[9])*v2 + c[10];
-                                dp4_u2 = (3*c[12]*v2 + 2*c[13])*v2 + c[14];
-                                der_y1 = (3*p1*u1 + 2*p2)*u1 + p3;
-                                der_y1 += ((3*dp1_u2*u1 + 2*dp2_u2)*u1 + dp3_u2)*u2;
-                                der_y2 = ((dp1_u2*u1 + dp2_u2)*u1 + dp3_u2)*u1 + dp4_u2;
-                            }
-                            der_y = der_y1*der_u1 + der_y2*der_u2;
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(0, last2, nCol - 2)];
+                                            double der_y1, der_y2;
+                                            u1 -= u1Min;
+                                            u2 -= TABLE_ROW0(last2 + 1);
+                                            der_y1 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
+                                            der_y2 = (3*c[12]*u2 + 2*c[13])*u2 + c[14];
+                                            der_y2 += ((3*c[8]*u2 + 2*c[9])*u2 + c[10])*u1;
+                                            der_y = der_y1*der_u1 + der_y2*der_u2;
+                                         }
+                                         break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return der_y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return der_y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u1 "
+                                    "(=%lf) must be greater or equal\nthan the minimum abscissa "
+                                    "value u_min[1] (=%lf) defined in the table.\n", u1, u1Min);
+                                return der_y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return der_y;
                         }
-                        else if (extrapolate1 == LEFT) {
-                            u1 -= TABLE_COL0(1);
-                            if (extrapolate2 == IN_TABLE) {
-                                double der_y1, der_y2;
-                                u2 -= TABLE_ROW0(last2 + 1);
-                                der_y1 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
-                                der_y2 = (3*c[12]*u2 + 2*c[13])*u2 + c[14];
-                                der_y2 += ((3*c[8]*u2 + 2*c[9])*u2 + c[10])*u1;
-                                der_y = der_y1*der_u1 + der_y2*der_u2;
-                            }
-                            else if (extrapolate2 == LEFT) {
-                                double der_y1, der_y2, der_y12;
-                                u2 -= TABLE_ROW0(1);
-                                der_y1 = c[11];
-                                der_y2 = c[14];
-                                der_y12 = c[10];
-                                der_y = (der_y1 + der_y12*u2)*der_u1;
-                                der_y += (der_y2 + der_y12*u1)*der_u2;
-                            }
-                            else /* if (extrapolate2 == RIGHT) */ {
-                                const double v2 = TABLE_ROW0(nCol - 1) -
-                                    TABLE_ROW0(nCol - 2);
-                                double der_y1, der_y2, der_y12;
-                                u2 -= TABLE_ROW0(nCol - 1);
-                                der_y1 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
-                                der_y2 =(3*c[12]*v2 + 2*c[13])*v2 + c[14];
-                                der_y12 = (3*c[8]*v2 + 2*c[9])*v2 + c[10];
-                                der_y = (der_y1 + der_y12*u2)*der_u1;
-                                der_y += (der_y2 + der_y12*u1)*der_u2;
-                            }
+                    }
+                    else if (extrapolate2 == LEFT) {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR_DER(u1, u2);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(0, 0, nCol - 2)];
+                                            double der_y1, der_y2, der_y12;
+                                            u1 -= u1Min;
+                                            u2 -= u2Min;
+                                            der_y1 = c[11];
+                                            der_y2 = c[14];
+                                            der_y12 = c[10];
+                                            der_y = (der_y1 + der_y12*u2)*der_u1;
+                                            der_y += (der_y2 + der_y12*u1)*der_u2;
+                                         }
+                                         break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return der_y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return der_y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u1 "
+                                    "(=%lf) must be greater or equal\nthan the minimum abscissa "
+                                    "value u_min[1] (=%lf) defined in the table.\n"
+                                    "Extrapolation error: The value u2 (=%lf) must be greater "
+                                    "or equal\nthan the minimum abscissa value u_min[2] (=%lf) "
+                                    "defined in the table.\n", u1, u1Min, u2, u2Min);
+                                return der_y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return der_y;
                         }
-                        else /* if (extrapolate1 == RIGHT) */ {
-                            const double v1 = TABLE_COL0(nRow - 1) -
-                                TABLE_COL0(nRow - 2);
-                            u1 -= TABLE_COL0(nRow - 1);
-                            if (extrapolate2 == IN_TABLE) {
-                                double p1, p2, p3;
-                                double dp1_u2, dp2_u2, dp3_u2, dp4_u2;
-                                double der_y1, der_y2;
-                                u2 -= TABLE_ROW0(last2 + 1);
-                                p1 = ((c[0]*u2 + c[1])*u2 + c[2])*u2 + c[3];
-                                p2 = ((c[4]*u2 + c[5])*u2 + c[6])*u2 + c[7];
-                                p3 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
-                                dp1_u2 = (3*c[0]*u2 + 2*c[1])*u2 + c[2];
-                                dp2_u2 = (3*c[4]*u2 + 2*c[5])*u2 + c[6];
-                                dp3_u2 = (3*c[8]*u2 + 2*c[9])*u2 + c[10];
-                                dp4_u2 = (3*c[12]*u2 + 2*c[13])*u2 + c[14];
-                                der_y1 = (3*p1*v1 + 2*p2)*v1 + p3;
-                                der_y2 = ((dp1_u2*v1 + dp2_u2)*v1 + dp3_u2)*v1 + dp4_u2;
-                                der_y2 += ((3*dp1_u2*v1 + 2*dp2_u2)*v1 + dp3_u2)*u1;
-                                der_y = der_y1*der_u1 + der_y2*der_u2;
-                            }
-                            else if (extrapolate2 == LEFT) {
-                                double der_y1, der_y2, der_y12;
-                                u2 -= TABLE_ROW0(1);
-                                der_y1 = (3*c[3]*v1 + 2*c[7])*v1 + c[11];
-                                der_y2 = ((c[2]*v1 + c[6])*v1 + c[10])*v1 + c[14];
-                                der_y12 = (3*c[2]*v1 + 2*c[6])*v1 + c[10];
-                                der_y = (der_y1 + der_y12*u2)*der_u1;
-                                der_y += (der_y2 + der_y12*u1)*der_u2;
-                            }
-                            else /* if (extrapolate2 == RIGHT) */ {
-                                const double v2 = TABLE_ROW0(nCol - 1) -
-                                    TABLE_ROW0(nCol - 2);
-                                double p1, p2, p3;
-                                double dp1_u2, dp2_u2, dp3_u2, dp4_u2;
-                                double der_y1, der_y2, der_y12;
-                                u2 -= TABLE_ROW0(nCol - 1);
-                                p1 = ((c[0]*v2 + c[1])*v2 + c[2])*v2 + c[3];
-                                p2 = ((c[4]*v2 + c[5])*v2 + c[6])*v2 + c[7];
-                                p3 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
-                                dp1_u2 = (3*c[0]*v2 + 2*c[1])*v2 + c[2];
-                                dp2_u2 = (3*c[4]*v2 + 2*c[5])*v2 + c[6];
-                                dp3_u2 = (3*c[8]*v2 + 2*c[9])*v2 + c[10];
-                                dp4_u2 = (3*c[12]*v2 + 2*c[13])*v2 + c[14];
-                                der_y1 = (3*p1*v1 + 2*p2)*v1 + p3;
-                                der_y2 = ((dp1_u2*v1 + dp2_u2)*v1 + dp3_u2)*v1 + dp4_u2;
-                                der_y12 = (3*dp1_u2*v1 + 2*dp2_u2)*v1 + dp3_u2;
-                                der_y = (der_y1 + der_y12*u2)*der_u1;
-                                der_y += (der_y2 + der_y12*u1)*der_u2;
-                            }
+                    }
+                    else /* if (extrapolate2 == RIGHT) */ {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR_DER(u1, u2);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(0, nCol - 3, nCol - 2)];
+                                            const double v2 = u2Max - TABLE_ROW0(nCol - 2);
+                                            double der_y1, der_y2, der_y12;
+                                            u1 -= u1Min;
+                                            u2 -= u2Max;
+                                            der_y1 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
+                                            der_y2 =(3*c[12]*v2 + 2*c[13])*v2 + c[14];
+                                            der_y12 = (3*c[8]*v2 + 2*c[9])*v2 + c[10];
+                                            der_y = (der_y1 + der_y12*u2)*der_u1;
+                                            der_y += (der_y2 + der_y12*u1)*der_u2;
+                                         }
+                                         break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return der_y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return der_y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u1 "
+                                    "(=%lf) must be greater or equal\nthan the minimum abscissa "
+                                    "value u_min[1] (=%lf) defined in the table.\n"
+                                    "Extrapolation error: The value u2 (=%lf) must be less "
+                                    "or equal\nthan the maximum abscissa value u_max[2] (=%lf) "
+                                    "defined in the table.\n", u1, u1Min, u2, u2Max);
+                                return der_y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return der_y;
                         }
                     }
-                    break;
+                }
+                else /* if (extrapolate1 == RIGHT) */ {
+                    if (extrapolate2 == IN_TABLE) {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR_DER(u1, u2);
+                                        break;
 
-                case FRITSCH_BUTLAND_MONOTONE_C1:
-                case STEFFEN_MONOTONE_C1:
-                    ModelicaError("Bivariate monotone C1 interpolation is "
-                        "not implemented\n");
-                    return der_y;
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(nRow - 3, last2, nCol - 2)];
+                                            const double v1 = u1Max - TABLE_COL0(nRow - 2);
+                                            double p1, p2, p3;
+                                            double dp1_u2, dp2_u2, dp3_u2, dp4_u2;
+                                            double der_y1, der_y2;
+                                            u1 -= u1Max;
+                                            u2 -= TABLE_ROW0(last2 + 1);
+                                            p1 = ((c[0]*u2 + c[1])*u2 + c[2])*u2 + c[3];
+                                            p2 = ((c[4]*u2 + c[5])*u2 + c[6])*u2 + c[7];
+                                            p3 = ((c[8]*u2 + c[9])*u2 + c[10])*u2 + c[11];
+                                            dp1_u2 = (3*c[0]*u2 + 2*c[1])*u2 + c[2];
+                                            dp2_u2 = (3*c[4]*u2 + 2*c[5])*u2 + c[6];
+                                            dp3_u2 = (3*c[8]*u2 + 2*c[9])*u2 + c[10];
+                                            dp4_u2 = (3*c[12]*u2 + 2*c[13])*u2 + c[14];
+                                            der_y1 = (3*p1*v1 + 2*p2)*v1 + p3;
+                                            der_y2 = ((dp1_u2*v1 + dp2_u2)*v1 + dp3_u2)*v1 + dp4_u2;
+                                            der_y2 += ((3*dp1_u2*v1 + 2*dp2_u2)*v1 + dp3_u2)*u1;
+                                            der_y = der_y1*der_u1 + der_y2*der_u2;
+                                         }
+                                         break;
 
-                default:
-                    ModelicaError("Unknown smoothness kind\n");
-                    return der_y;
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return der_y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return der_y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u1 "
+                                    "(=%lf) must be less or equal\nthan the maximum abscissa "
+                                    "value u_max[1] (=%lf) defined in the table.\n", u1, u1Max);
+                                return der_y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return der_y;
+                        }
+                    }
+                    else if (extrapolate2 == LEFT) {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR_DER(u1, u2);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(nRow - 3, 0, nCol - 2)];
+                                            const double v1 = u1Max - TABLE_COL0(nRow - 2);
+                                            double der_y1, der_y2, der_y12;
+                                            u1 -= u1Max;
+                                            u2 -= u2Min;
+                                            der_y1 = (3*c[3]*v1 + 2*c[7])*v1 + c[11];
+                                            der_y2 = ((c[2]*v1 + c[6])*v1 + c[10])*v1 + c[14];
+                                            der_y12 = (3*c[2]*v1 + 2*c[6])*v1 + c[10];
+                                            der_y = (der_y1 + der_y12*u2)*der_u1;
+                                            der_y += (der_y2 + der_y12*u1)*der_u2;
+                                         }
+                                         break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return der_y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return der_y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u1 "
+                                    "(=%lf) must be less or equal\nthan the maximum abscissa "
+                                    "value u_max[1] (=%lf) defined in the table.\n"
+                                    "Extrapolation error: The value u2 (=%lf) must be greater "
+                                    "or equal\nthan the minimum abscissa value u_min[2] (=%lf) "
+                                    "defined in the table.\n", u1, u1Max, u2, u2Min);
+                                return der_y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return der_y;
+                        }
+                    }
+                    else /* if (extrapolate2 == RIGHT) */ {
+                        switch (tableID->extrapolation) {
+                            case LAST_TWO_POINTS:
+                                switch (tableID->smoothness) {
+                                    case LINEAR_SEGMENTS:
+                                    case CONSTANT_SEGMENTS:
+                                        BILINEAR_DER(u1, u2);
+                                        break;
+
+                                    case AKIMA_C1:
+                                        if (NULL != tableID->spline) {
+                                            const double* c = tableID->spline[
+                                                IDX(nRow - 3, nCol - 3, nCol - 2)];
+                                            const double v1 = u1Max - TABLE_COL0(nRow - 2);
+                                            const double v2 = u2Max - TABLE_ROW0(nCol - 2);
+                                            double p1, p2, p3;
+                                            double dp1_u2, dp2_u2, dp3_u2, dp4_u2;
+                                            double der_y1, der_y2, der_y12;
+                                            u1 -= u1Max;
+                                            u2 -= u2Max;
+                                            p1 = ((c[0]*v2 + c[1])*v2 + c[2])*v2 + c[3];
+                                            p2 = ((c[4]*v2 + c[5])*v2 + c[6])*v2 + c[7];
+                                            p3 = ((c[8]*v2 + c[9])*v2 + c[10])*v2 + c[11];
+                                            dp1_u2 = (3*c[0]*v2 + 2*c[1])*v2 + c[2];
+                                            dp2_u2 = (3*c[4]*v2 + 2*c[5])*v2 + c[6];
+                                            dp3_u2 = (3*c[8]*v2 + 2*c[9])*v2 + c[10];
+                                            dp4_u2 = (3*c[12]*v2 + 2*c[13])*v2 + c[14];
+                                            der_y1 = (3*p1*v1 + 2*p2)*v1 + p3;
+                                            der_y2 = ((dp1_u2*v1 + dp2_u2)*v1 + dp3_u2)*v1 + dp4_u2;
+                                            der_y12 = (3*dp1_u2*v1 + 2*dp2_u2)*v1 + dp3_u2;
+                                            der_y = (der_y1 + der_y12*u2)*der_u1;
+                                            der_y += (der_y2 + der_y12*u1)*der_u2;
+                                         }
+                                         break;
+
+                                    case FRITSCH_BUTLAND_MONOTONE_C1:
+                                    case STEFFEN_MONOTONE_C1:
+                                        ModelicaError("Bivariate monotone C1 interpolation is "
+                                            "not implemented\n");
+                                        return der_y;
+
+                                    default:
+                                        ModelicaError("Unknown smoothness kind\n");
+                                        return der_y;
+                                 }
+                                 break;
+
+                            case HOLD_LAST_POINT:
+                                break;
+
+                            case NO_EXTRAPOLATION:
+                                ModelicaFormatError("Extrapolation error: The value u1 "
+                                    "(=%lf) must be less or equal\nthan the maximum abscissa "
+                                    "value u_max[1] (=%lf) defined in the table.\n"
+                                    "Extrapolation error: The value u2 (=%lf) must be less "
+                                    "or equal\nthan the maximum abscissa value u_max[2] (=%lf) "
+                                    "defined in the table.\n", u1, u1Max, u2, u2Max);
+                                return der_y;
+
+                            case PERIODIC:
+                                /* Should not be possible to get here */
+                                break;
+
+                            default:
+                                ModelicaError("Unknown extrapolation kind\n");
+                                return der_y;
+                        }
+                    }
+                }
             }
         }
     }
@@ -3072,6 +4435,88 @@
     return der_y;
 }
 
+void ModelicaStandardTables_CombiTable2D_minimumAbscissa(void* _tableID,
+                                                         _Inout_ double* uMin) {
+    CombiTable2D* tableID = (CombiTable2D*)_tableID;
+    if (NULL != tableID && NULL != tableID->table) {
+        const double* table = tableID->table;
+        const size_t nCol = tableID->nCol;
+        uMin[0] = TABLE_COL0(1);
+        uMin[1] = TABLE_ROW0(1);
+    }
+    else {
+        uMin[0] = 0.;
+        uMin[1] = 0.;
+    }
+}
+
+void ModelicaStandardTables_CombiTable2D_maximumAbscissa(void* _tableID,
+                                                         _Inout_ double* uMax) {
+    CombiTable2D* tableID = (CombiTable2D*)_tableID;
+    if (NULL != tableID && NULL != tableID->table) {
+        const double* table = tableID->table;
+        const size_t nRow = tableID->nRow;
+        const size_t nCol = tableID->nCol;
+        uMax[0] = TABLE_COL0(nRow - 1);
+        uMax[1] = TABLE_ROW0(nCol - 1);
+    }
+    else {
+        uMax[0] = 0.;
+        uMax[1] = 0.;
+    }
+}
+
+double ModelicaStandardTables_CombiTable2D_read(void* _tableID, int force,
+                                                int verbose) {
+#if !defined(NO_FILE_SYSTEM)
+    CombiTable2D* tableID = (CombiTable2D*)_tableID;
+    if (NULL != tableID && tableID->source == TABLESOURCE_FILE) {
+        if (force || NULL == tableID->table) {
+            const char* fileName = tableID->key;
+            const char* tableName = tableID->key + strlen(fileName) + 1;
+#if defined(TABLE_SHARE)
+            TableShare* file = readTable(fileName, tableName, &tableID->nRow,
+                &tableID->nCol, verbose, force);
+            if (NULL != file) {
+                tableID->table = file->table;
+            }
+            else {
+                return 0.; /* Error */
+            }
+#else
+            if (NULL != tableID->table) {
+                free(tableID->table);
+            }
+            tableID->table = readTable(fileName, tableName, &tableID->nRow,
+                &tableID->nCol, verbose, force);
+#endif
+            if (NULL == tableID->table) {
+                return 0.; /* Error */
+            }
+            if (isValidCombiTable2D(tableID, tableName,
+                0 /* No clean up */) == 0) {
+                return 0.; /* Error */
+            }
+            if (tableID->smoothness == AKIMA_C1 &&
+                tableID->nRow <= 3 && tableID->nCol <= 3) {
+                tableID->smoothness = LINEAR_SEGMENTS;
+            }
+            /* Reinitialization of the Akima-spline coefficients */
+            if (tableID->smoothness == AKIMA_C1) {
+                spline2DClose(&tableID->spline);
+                tableID->spline = spline2DInit((const double*)tableID->table,
+                    tableID->nRow,tableID->nCol);
+                if (NULL == tableID->spline) {
+                    ModelicaError("Memory allocation error\n");
+                    return 0.; /* Error */
+                }
+            }
+        }
+    }
+#endif
+    return 1.; /* Success */
+}
+
 /* ----- Internal functions ----- */
 
 static int isNearlyEqual(double x, double y) {
@@ -3112,7 +4557,7 @@
     return i0;
 }
 
-static size_t findColIndex(const double* table, size_t nCol, size_t last,
+static size_t findColIndex(_In_ const double* table, size_t nCol, size_t last,
                            double x) {
     size_t i0 = 0;
     size_t i1 = nCol - 1;
@@ -3141,9 +4586,9 @@
 
 /* ----- Internal check functions ----- */
 
-static int isValidName(const char* name) {
+static int isValidName(_In_z_ const char* name) {
     int isValid = 0;
-    if (name != NULL) {
+    if (NULL != name) {
         if (strcmp(name, "NoName") != 0) {
             size_t i;
             size_t len = strlen(name);
@@ -3158,24 +4603,21 @@
     return isValid;
 }
 
-static int isValidCombiTimeTable(const CombiTimeTable* tableID) {
+static int isValidCombiTimeTable(CombiTimeTable* tableID,
+                                 _In_z_ const char* _tableName, int cleanUp) {
     int isValid = 1;
-    if (tableID != NULL) {
+    if (NULL != tableID) {
         const size_t nRow = tableID->nRow;
         const size_t nCol = tableID->nCol;
-        const char* tableName;
         const char* tableDummyName = "NoName";
+        const char* tableName = (0 < strlen(_tableName)) ? _tableName : tableDummyName;
         size_t iCol;
 
-        if (tableID->source == TABLESOURCE_MODEL) {
-            tableName = tableDummyName;
-        }
-        else {
-            tableName = tableID->tableName;
-        }
-
         /* Check dimensions */
         if (nRow < 1 || nCol < 2) {
+            if (1 == cleanUp) {
+                ModelicaStandardTables_CombiTimeTable_close(tableID);
+            }
             ModelicaFormatError(
                 "Table matrix \"%s(%lu,%lu)\" does not have appropriate "
                 "dimensions for time interpolation.\n", tableName,
@@ -3188,6 +4630,9 @@
         for (iCol = 0; iCol < tableID->nCols; ++iCol) {
             const size_t col = (size_t)tableID->cols[iCol];
             if (col < 1 || col > tableID->nCol) {
+                if (1 == cleanUp) {
+                    ModelicaStandardTables_CombiTimeTable_close(tableID);
+                }
                 ModelicaFormatError("The column index %d is out of range "
                     "for table matrix \"%s(%lu,%lu)\".\n", tableID->cols[iCol],
                     tableName, (unsigned long)nRow, (unsigned long)nCol);
@@ -3194,7 +4639,7 @@
             }
         }
 
-        if (tableID->table != NULL && nRow > 1) {
+        if (NULL != tableID->table && nRow > 1) {
             const double* table = tableID->table;
             /* Check period */
             if (tableID->extrapolation == PERIODIC) {
@@ -3202,6 +4647,9 @@
                 const double tMax = TABLE_COL0(nRow - 1);
                 const double T = tMax - tMin;
                 if (T <= 0) {
+                    if (1 == cleanUp) {
+                        ModelicaStandardTables_CombiTimeTable_close(tableID);
+                    }
                     ModelicaFormatError(
                         "Table matrix \"%s\" does not have a positive period/cylce "
                         "time for time interpolation with periodic "
@@ -3221,6 +4669,9 @@
                     double t0 = TABLE_COL0(i);
                     double t1 = TABLE_COL0(i + 1);
                     if (t0 >= t1) {
+                        if (1 == cleanUp) {
+                            ModelicaStandardTables_CombiTimeTable_close(tableID);
+                        }
                         ModelicaFormatError(
                             "The values of the first column of table \"%s(%lu,%lu)\" "
                             "are not strictly increasing because %s(%lu,1) (=%lf) "
@@ -3238,6 +4689,9 @@
                     double t0 = TABLE_COL0(i);
                     double t1 = TABLE_COL0(i + 1);
                     if (t0 > t1) {
+                        if (1 == cleanUp) {
+                            ModelicaStandardTables_CombiTimeTable_close(tableID);
+                        }
                         ModelicaFormatError(
                             "The values of the first column of table \"%s(%lu,%lu)\" "
                             "are not monotonically increasing because %s(%lu,1) "
@@ -3256,24 +4710,21 @@
     return isValid;
 }
 
-static int isValidCombiTable1D(const CombiTable1D* tableID) {
+static int isValidCombiTable1D(CombiTable1D* tableID,
+                               _In_z_ const char* _tableName, int cleanUp) {
     int isValid = 1;
-    if (tableID != NULL) {
+    if (NULL != tableID) {
         const size_t nRow = tableID->nRow;
         const size_t nCol = tableID->nCol;
-        const char* tableName;
         const char* tableDummyName = "NoName";
+        const char* tableName = (0 < strlen(_tableName)) ? _tableName : tableDummyName;
         size_t iCol;
 
-        if (tableID->source == TABLESOURCE_MODEL) {
-            tableName = tableDummyName;
-        }
-        else {
-            tableName = tableID->tableName;
-        }
-
         /* Check dimensions */
         if (nRow < 1 || nCol < 2) {
+            if (1 == cleanUp) {
+                ModelicaStandardTables_CombiTable1D_close(tableID);
+            }
             ModelicaFormatError(
                 "Table matrix \"%s(%lu,%lu)\" does not have appropriate "
                 "dimensions for 1D-interpolation.\n", tableName,
@@ -3286,6 +4737,9 @@
         for (iCol = 0; iCol < tableID->nCols; ++iCol) {
             const size_t col = (size_t)tableID->cols[iCol];
             if (col < 1 || col > tableID->nCol) {
+                if (1 == cleanUp) {
+                    ModelicaStandardTables_CombiTable1D_close(tableID);
+                }
                 ModelicaFormatError("The column index %d is out of range "
                     "for table matrix \"%s(%lu,%lu)\".\n", tableID->cols[iCol],
                     tableName, (unsigned long)nRow, (unsigned long)nCol);
@@ -3292,7 +4746,7 @@
             }
         }
 
-        if (tableID->table != NULL) {
+        if (NULL != tableID->table) {
             const double* table = tableID->table;
             size_t i;
             /* Check, whether first column values are strictly increasing */
@@ -3300,6 +4754,9 @@
                 double x0 = TABLE_COL0(i);
                 double x1 = TABLE_COL0(i + 1);
                 if (x0 >= x1) {
+                    if (1 == cleanUp) {
+                        ModelicaStandardTables_CombiTable1D_close(tableID);
+                    }
                     ModelicaFormatError(
                         "The values of the first column of table \"%s(%lu,%lu)\" are "
                         "not strictly increasing because %s(%lu,1) (=%lf) >= "
@@ -3316,23 +4773,20 @@
     return isValid;
 }
 
-static int isValidCombiTable2D(const CombiTable2D* tableID) {
+static int isValidCombiTable2D(CombiTable2D* tableID,
+                               _In_z_ const char* _tableName, int cleanUp) {
     int isValid = 1;
-    if (tableID != NULL) {
+    if (NULL != tableID) {
         const size_t nRow = tableID->nRow;
         const size_t nCol = tableID->nCol;
-        const char* tableName;
         const char* tableDummyName = "NoName";
+        const char* tableName = (0 < strlen(_tableName)) ? _tableName : tableDummyName;
 
-        if (tableID->source == TABLESOURCE_MODEL) {
-            tableName = tableDummyName;
-        }
-        else {
-            tableName = tableID->tableName;
-        }
-
         /* Check dimensions */
         if (nRow < 2 || nCol < 2) {
+            if (1 == cleanUp) {
+                ModelicaStandardTables_CombiTable2D_close(tableID);
+            }
             ModelicaFormatError(
                 "Table matrix \"%s(%lu,%lu)\" does not have appropriate "
                 "dimensions for 2D-interpolation.\n", tableName,
@@ -3341,7 +4795,7 @@
             return isValid;
         }
 
-        if (tableID->table != NULL) {
+        if (NULL != tableID->table) {
             const double* table = tableID->table;
             size_t i;
             /* Check, whether first column values are strictly increasing */
@@ -3349,6 +4803,9 @@
                 double x0 = TABLE_COL0(i);
                 double x1 = TABLE_COL0(i + 1);
                 if (x0 >= x1) {
+                    if (1 == cleanUp) {
+                        ModelicaStandardTables_CombiTable2D_close(tableID);
+                    }
                     ModelicaFormatError(
                         "The values of the first column of table \"%s(%lu,%lu)\" are "
                         "not strictly increasing because %s(%lu,1) (=%lf) >= "
@@ -3365,6 +4822,9 @@
                 double y0 = TABLE_ROW0(i);
                 double y1 = TABLE_ROW0(i + 1);
                 if (y0 >= y1) {
+                    if (1 == cleanUp) {
+                        ModelicaStandardTables_CombiTable2D_close(tableID);
+                    }
                     ModelicaFormatError(
                         "The values of the first row of table \"%s(%lu,%lu)\" are "
                         "not strictly increasing because %s(1,%lu) (=%lf) >= "
@@ -3381,11 +4841,11 @@
     return isValid;
 }
 
-static enum TableSource getTableSource(const char *tableName,
-                                       const char *fileName) {
+static enum TableSource getTableSource(_In_z_ const char* fileName,
+                                       _In_z_ const char* tableName) {
     enum TableSource tableSource;
+    int fileNameGiven = isValidName(fileName);
     int tableNameGiven = isValidName(tableName);
-    int fileNameGiven = isValidName(fileName);
 
     /* Determine in which way the table values are defined */
     if (tableNameGiven == 0) {
@@ -3418,8 +4878,8 @@
 
 /* ----- Internal univariate spline functions ---- */
 
-static CubicHermite1D* akimaSpline1DInit(const double* table, size_t nRow,
-                                         size_t nCol, const int* cols,
+static CubicHermite1D* akimaSpline1DInit(_In_ const double* table, size_t nRow,
+                                         size_t nCol, _In_ const int* cols,
                                          size_t nCols) {
   /* Reference:
 
@@ -3434,12 +4894,12 @@
 
     /* Actually there is no need for consecutive memory */
     spline = (CubicHermite1D*)malloc((nRow - 1)*nCols*sizeof(CubicHermite1D));
-    if (spline == NULL) {
+    if (NULL == spline) {
         return NULL;
     }
 
     d = (double*)malloc((nRow + 3)*sizeof(double));
-    if (d == NULL) {
+    if (NULL == d) {
         free(spline);
         return NULL;
     }
@@ -3450,8 +4910,8 @@
 
         /* Calculation of the divided differences */
         for (i = 0; i < nRow - 1; i++) {
-            d[i + 2] =
-                (TABLE(i + 1, cols[col] - 1) - TABLE(i, cols[col] - 1))/
+            size_t c = (size_t)(cols[col] - 1);
+            d[i + 2] = (TABLE(i + 1, c) - TABLE(i, c))/
                 (TABLE_COL0(i + 1) - TABLE_COL0(i));
         }
 
@@ -3496,9 +4956,9 @@
     return spline;
 }
 
-static CubicHermite1D* fritschButlandSpline1DInit(const double* table,
+static CubicHermite1D* fritschButlandSpline1DInit(_In_ const double* table,
                                                   size_t nRow, size_t nCol,
-                                                  const int* cols,
+                                                  _In_ const int* cols,
                                                   size_t nCols) {
   /* Reference:
 
@@ -3514,12 +4974,12 @@
 
     /* Actually there is no need for consecutive memory */
     spline = (CubicHermite1D*)malloc((nRow - 1)*nCols*sizeof(CubicHermite1D));
-    if (spline == NULL) {
+    if (NULL == spline) {
         return NULL;
     }
 
     d = (double*)malloc((nRow - 1)*sizeof(double));
-    if (d == NULL) {
+    if (NULL == d) {
         free(spline);
         return NULL;
     }
@@ -3530,8 +4990,8 @@
 
         /* Calculation of the divided differences */
         for (i = 0; i < nRow - 1; i++) {
-            d[i] =
-                (TABLE(i + 1, cols[col] - 1) - TABLE(i, cols[col] - 1))/
+            size_t c = (size_t)(cols[col] - 1);
+            d[i] = (TABLE(i + 1, c) - TABLE(i, c))/
                 (TABLE_COL0(i + 1) - TABLE_COL0(i));
         }
 
@@ -3566,9 +5026,9 @@
     return spline;
 }
 
-static CubicHermite1D* steffenSpline1DInit(const double* table,
+static CubicHermite1D* steffenSpline1DInit(_In_ const double* table,
                                            size_t nRow, size_t nCol,
-                                           const int* cols,
+                                           _In_ const int* cols,
                                            size_t nCols) {
   /* Reference:
 
@@ -3583,12 +5043,12 @@
 
     /* Actually there is no need for consecutive memory */
     spline = (CubicHermite1D*)malloc((nRow - 1)*nCols*sizeof(CubicHermite1D));
-    if (spline == NULL) {
+    if (NULL == spline) {
         return NULL;
     }
 
     d = (double*)malloc((nRow - 1)*sizeof(double));
-    if (d == NULL) {
+    if (NULL == d) {
         free(spline);
         return NULL;
     }
@@ -3599,8 +5059,8 @@
 
         /* Calculation of the divided differences */
         for (i = 0; i < nRow - 1; i++) {
-            d[i] =
-                (TABLE(i + 1, cols[col] - 1) - TABLE(i, cols[col] - 1))/
+            size_t c = (size_t)(cols[col] - 1);
+            d[i] = (TABLE(i + 1, c) - TABLE(i, c))/
                 (TABLE_COL0(i + 1) - TABLE_COL0(i));
         }
 
@@ -3644,7 +5104,7 @@
 }
 
 static void spline1DClose(CubicHermite1D** spline) {
-    if (spline != NULL && *spline != NULL) {
+    if (NULL != spline && NULL != *spline) {
         free(*spline);
         *spline = NULL;
     }
@@ -3692,9 +5152,8 @@
     }
 }
 
-#define TABLE_EX(i, j) tableEx[IDX(i, j, nCol + 3)]
-
-static CubicHermite2D* spline2DInit(const double* table, size_t nRow, size_t nCol) {
+static CubicHermite2D* spline2DInit(_In_ const double* table, size_t nRow,
+                                    size_t nCol) {
   /* Reference:
 
      Hiroshi Akima. A method of bivariate interpolation and smooth surface
@@ -3702,6 +5161,7 @@
      Jan. 1974. (http://dx.doi.org/10.1145/360767.360779)
   */
 
+#define TABLE_EX(i, j) tableEx[IDX(i, j, nCol + 3)]
     CubicHermite2D* spline = NULL;
     if (nRow == 2 /* && nCol > 3 */) {
         CubicHermite1D* spline1D;
@@ -3710,12 +5170,12 @@
 
         /* Need to transpose */
         double* tableT = (double*)malloc(2*(nCol - 1)*sizeof(double));
-        if (tableT == NULL) {
+        if (NULL == tableT) {
             return NULL;
         }
 
         spline = (CubicHermite2D*)malloc((nCol - 1)*sizeof(CubicHermite2D));
-        if (spline == NULL) {
+        if (NULL == spline) {
             free(tableT);
             return NULL;
         }
@@ -3727,7 +5187,7 @@
 
         spline1D = akimaSpline1DInit(tableT, nCol - 1, 2, &cols, 1);
         free(tableT);
-        if (spline1D == NULL) {
+        if (NULL == spline1D) {
             free(spline);
             return NULL;
         }
@@ -3747,12 +5207,12 @@
         int cols = 2;
 
         spline = (CubicHermite2D*)malloc((nRow - 1)*sizeof(CubicHermite2D));
-        if (spline == NULL) {
+        if (NULL == spline) {
             return NULL;
         }
 
         spline1D = akimaSpline1DInit(&table[2], nRow - 1, 2, &cols, 1);
-        if (spline1D == NULL) {
+        if (NULL == spline1D) {
             free(spline);
             return NULL;
         }
@@ -3783,7 +5243,7 @@
 
         /* Copy of x coordinates with extrapolated boundary coordinates */
         x = (double*)malloc((nRow + 3)*sizeof(double));
-        if (x == NULL) {
+        if (NULL == x) {
             return NULL;
         }
         if (nRow == 3) {
@@ -3808,7 +5268,7 @@
 
         /* Copy of y coordinates with extrapolated boundary coordinates */
         y = (double*)malloc((nCol + 3)*sizeof(double));
-        if (y == NULL) {
+        if (NULL == y) {
             free(x);
             return NULL;
         }
@@ -3832,7 +5292,7 @@
 
         /* Copy of table with extrapolated boundary values */
         tableEx = (double*)malloc((nRow + 3)*(nCol + 3)*sizeof(double));
-        if (tableEx == NULL) {
+        if (NULL == tableEx) {
             free(y);
             free(x);
             return NULL;
@@ -3885,7 +5345,7 @@
         }
 
         dz_dx = (double*)malloc((nRow - 1)*(nCol - 1)*sizeof(double));
-        if (dz_dx == NULL) {
+        if (NULL == dz_dx) {
             free(tableEx);
             free(y);
             free(x);
@@ -3893,7 +5353,7 @@
         }
 
         dz_dy = (double*)malloc((nRow - 1)*(nCol - 1)*sizeof(double));
-        if (dz_dy == NULL) {
+        if (NULL == dz_dy) {
             free(dz_dx);
             free(tableEx);
             free(y);
@@ -3902,7 +5362,7 @@
         }
 
         d2z_dxdy = (double*)malloc((nRow - 1)*(nCol - 1)*sizeof(double));
-        if (d2z_dxdy == NULL) {
+        if (NULL == d2z_dxdy) {
             free(dz_dy);
             free(dz_dx);
             free(tableEx);
@@ -3994,7 +5454,7 @@
 
         /* Actually there is no need for consecutive memory */
         spline = (CubicHermite2D*)malloc((nRow - 2)*(nCol - 2)*sizeof(CubicHermite2D));
-        if (spline == NULL) {
+        if (NULL == spline) {
             free(dz_dx);
             free(dz_dy);
             free(d2z_dxdy);
@@ -4074,18 +5534,17 @@
         free(d2z_dxdy);
     }
     return spline;
+#undef TABLE_EX
 }
 
-#undef TABLE_EX
-
 static void spline2DClose(CubicHermite2D** spline) {
-    if (spline != NULL && *spline != NULL) {
+    if (NULL != spline && NULL != *spline) {
         free(*spline);
         *spline = NULL;
     }
 }
 
-static void transpose(double* table, size_t nRow, size_t nCol) {
+static void transpose(_Inout_ double* table, size_t nRow, size_t nCol) {
   /* Reference:
 
      Cycle-based in-place array transposition
@@ -4122,78 +5581,74 @@
 
 /* ----- Internal I/O functions ----- */
 
+#if defined(TABLE_SHARE) && !defined(NO_FILE_SYSTEM)
+static size_t key_strlen(_In_z_ const char *s) {
+    size_t len = strlen(s) + 1;
+    len += strlen(s + len);
+    return len;
+}
+#endif
+
+static READ_RESULT readTable(_In_z_ const char* fileName, _In_z_ const char* tableName,
+                             _Inout_ size_t* nRow, _Inout_ size_t* nCol, int verbose,
+                             int force) {
 #if !defined(NO_FILE_SYSTEM)
-static double* readTable(const char* tableName, const char* fileName,
-                         size_t* nRow, size_t* nCol, int verbose, int force) {
+#if defined(TABLE_SHARE)
+#define uthash_fatal(msg) do { \
+    MUTEX_UNLOCK(); \
+    ModelicaFormatMessage("Error in uthash: %s\n" \
+        "Hash table for table cache may be left in corrupt state.\n", msg); \
+    return file; \
+} while (0)
+    TableShare* file = NULL;
+#endif
     double* table = NULL;
-    if (tableName != NULL && fileName != NULL && nRow != NULL && nCol != NULL) {
+    if (NULL != tableName && NULL != fileName && NULL != nRow && NULL != nCol) {
 #if defined(TABLE_SHARE)
-        char* key = malloc((strlen(tableName) +
-            strlen(fileName) + 2)*sizeof(char));
-        if (key != NULL) {
+        size_t lenFileName = strlen(fileName);
+        char* key = (char*)malloc((lenFileName + strlen(tableName) + 2)*sizeof(char));
+        if (NULL != key) {
             int updateError = 0;
-            TableShare *iter;
-            strcpy(key, tableName);
-            strcat(key, "|");
-            strcat(key, fileName);
+            strcpy(key, fileName);
+            strcpy(key + lenFileName + 1, tableName);
             MUTEX_LOCK();
-            HASH_FIND_STR(tableShare, key, iter);
-            if (iter == NULL || force) {
-#endif
-                const char* ext;
-                int isMatExt = 0;
-
-                /* Table file can be either ASCII text or binary MATLAB MAT-file */
-                ext = strrchr(fileName, '.');
-                if (ext != NULL) {
-                    if (0 == strncmp(ext, ".mat", 4) ||
-                        0 == strncmp(ext, ".MAT", 4)) {
-                        isMatExt = 1;
-                    }
-                }
-
-                if (verbose == 1) {
-                    /* Print info message, that table / file is loading */
-                    ModelicaFormatMessage("... loading \"%s\" from \"%s\"\n",
-                        tableName, fileName);
-                }
-
-#if defined(TABLE_SHARE)
-                /* Release lock since readMatTable/readTxtTable may fail with
+            HASH_FIND_STR(tableShare, key, file);
+            if (NULL == file || force) {
+                /* Release lock since ModelicaIO_readRealTable may fail with
                    ModelicaError
                 */
                 MUTEX_UNLOCK();
 #endif
-                if (isMatExt) {
-                    table = readMatTable(tableName, fileName, nRow, nCol);
-                }
-                else {
-                    table = readTxtTable(tableName, fileName, nRow, nCol);
-                }
-                if (table == NULL) {
+                table = ModelicaIO_readRealTable(fileName, tableName,
+                    nRow, nCol, verbose);
+                if (NULL == table) {
 #if defined(TABLE_SHARE)
                     free(key);
+                    return file;
+#else
+                    return table;
 #endif
-                    return table;
                 }
 #if defined(TABLE_SHARE)
                 /* Again ask for lock and search in hash table share */
                 MUTEX_LOCK();
-                HASH_FIND_STR(tableShare, key, iter);
+                HASH_FIND_STR(tableShare, key, file);
             }
-            if (iter == NULL) {
+            if (NULL == file) {
                 /* Share miss -> Insert new table */
-                iter = malloc(sizeof(TableShare));
-                if (iter != NULL) {
-                    iter->key = key;
-                    iter->refCount = 1;
-                    iter->nRow = *nRow;
-                    iter->nCol = *nCol;
-                    iter->table = table;
-                    HASH_ADD_KEYPTR(hh, tableShare, key, strlen(key), iter);
+                file = (TableShare*)malloc(sizeof(TableShare));
+                if (NULL != file) {
+                    size_t lenKey = key_strlen(key);
+                    file->key = key;
+                    file->refCount = 1;
+                    file->nRow = *nRow;
+                    file->nCol = *nCol;
+                    file->table = table;
+                    HASH_ADD_KEYPTR(hh, tableShare, key, lenKey, file);
                 }
                 else {
                     free(key);
+                    return file;
                 }
             }
             else if (force) {
@@ -4201,11 +5656,11 @@
                    by multiple table objects)
                 */
                 free(key);
-                if (iter->refCount == 1) {
-                    free(iter->table);
-                    iter->nRow = *nRow;
-                    iter->nCol = *nCol;
-                    iter->table = table;
+                if (file->refCount == 1) {
+                    free(file->table);
+                    file->nRow = *nRow;
+                    file->nCol = *nCol;
+                    file->table = table;
                 }
                 else {
                     updateError = 1;
@@ -4216,13 +5671,12 @@
                    reference counter
                 */
                 free(key);
-                if (table != NULL) {
+                if (NULL != table) {
                     free(table);
                 }
-                iter->refCount++;
-                table = iter->table;
-                *nRow = iter->nRow;
-                *nCol = iter->nCol;
+                file->refCount++;
+                *nRow = file->nRow;
+                *nCol = file->nCol;
             }
             MUTEX_UNLOCK();
             if (updateError == 1) {
@@ -4233,509 +5687,17 @@
         }
 #endif
     }
+#if defined(TABLE_SHARE)
+#undef uthash_fatal
+    return file;
+#else
     return table;
-}
-
-static double* readMatTable(const char* tableName, const char* fileName,
-                            size_t* _nRow, size_t* _nCol) {
-    double* table = NULL;
-    if (tableName != NULL && fileName != NULL && _nRow != NULL && _nCol != NULL) {
-        mat_t* mat;
-        matvar_t* matvar;
-        matvar_t* matvarRoot;
-        size_t nRow, nCol;
-        int tableReadError = 0;
-        char* tableNameCopy;
-        char* token;
-
-        tableNameCopy = (char*)malloc((strlen(tableName) + 1)*sizeof(char));
-        if (tableNameCopy != NULL) {
-            strcpy(tableNameCopy, tableName);
-        }
-        else {
-            ModelicaError("Memory allocation error\n");
-            return NULL;
-        }
-
-        mat = Mat_Open(fileName, (int)MAT_ACC_RDONLY);
-        if (mat == NULL) {
-            free(tableNameCopy);
-            ModelicaFormatError("Not possible to open file \"%s\": "
-                "No such file or directory\n", fileName);
-            return NULL;
-        }
-
-        token = strtok(tableNameCopy, ".");
-        matvarRoot = Mat_VarReadInfo(mat, token == NULL ? tableName : token);
-        if (matvarRoot == NULL) {
-            free(tableNameCopy);
-            (void)Mat_Close(mat);
-            ModelicaFormatError(
-                "Table variable \"%s\" not found on file \"%s\".\n",
-                token == NULL ? tableName : token, fileName);
-            return NULL;
-        }
-
-        matvar = matvarRoot;
-        token = strtok(NULL, ".");
-        /* Get field while matvar is of struct class and of 1x1 size */
-        while (token != NULL && matvar != NULL &&
-            matvar->class_type == MAT_C_STRUCT && matvar->rank == 2 &&
-            matvar->dims[0] == 1 && matvar->dims[1] == 1) {
-            matvar = Mat_VarGetStructField(matvar, (void*)token, MAT_BY_NAME, 0);
-            token = strtok(NULL, ".");
-        }
-        free(tableNameCopy);
-
-        if (matvar == NULL) {
-            Mat_VarFree(matvarRoot);
-            (void)Mat_Close(mat);
-            ModelicaFormatError(
-                "Table matrix \"%s\" not found on file \"%s\".\n", tableName,
-                fileName);
-            return NULL;
-        }
-
-        /* Check if matvar is a matrix */
-        if (matvar->rank != 2) {
-            Mat_VarFree(matvarRoot);
-            (void)Mat_Close(mat);
-            ModelicaFormatError(
-                "Table array \"%s\" has not the required rank 2.\n", tableName);
-            return NULL;
-        }
-
-        /* Check if matvar is of double precision class (and thus non-sparse) */
-        if (matvar->class_type != MAT_C_DOUBLE) {
-            Mat_VarFree(matvarRoot);
-            (void)Mat_Close(mat);
-            ModelicaFormatError("Table matrix \"%s\" has not the required "
-                "double precision class.\n", tableName);
-            return NULL;
-        }
-
-        /* Check if matvar is purely real-valued */
-        if (matvar->isComplex) {
-            Mat_VarFree(matvarRoot);
-            (void)Mat_Close(mat);
-            ModelicaFormatError("Table matrix \"%s\" must not be complex.\n",
-                tableName);
-            return NULL;
-        }
-
-        table = (double*)malloc(matvar->dims[0]*matvar->dims[1]*sizeof(double));
-        if (table == NULL) {
-            Mat_VarFree(matvarRoot);
-            (void)Mat_Close(mat);
-            ModelicaError("Memory allocation error\n");
-            return NULL;
-        }
-
-        nRow = matvar->dims[0];
-        nCol = matvar->dims[1];
-        {
-            int start[2] = {0, 0};
-            int stride[2] = {1, 1};
-            int edge[2];
-            edge[0] = (int)nRow;
-            edge[1] = (int)nCol;
-            tableReadError = Mat_VarReadData(mat, matvar, table, start, stride, edge);
-        }
-
-        Mat_VarFree(matvarRoot);
-        (void)Mat_Close(mat);
-
-        if (tableReadError == 0) {
-            /* Array is stored column-wise -> need to transpose */
-            transpose(table, nRow, nCol);
-            *_nRow = nRow;
-            *_nCol = nCol;
-        }
-        else {
-            free(table);
-            *_nRow = 0;
-            *_nCol = 0;
-            ModelicaFormatError(
-                "Error when reading numeric data of matrix \"%s(%lu,%lu)\" "
-                "from file \"%s\"\n", tableName, (unsigned long)nRow,
-                (unsigned long)nCol, fileName);
-            return NULL;
-        }
-    }
-    return table;
-}
-
-#define DELIM_TABLE_HEADER " \t(,)\r"
-#define DELIM_TABLE_NUMBER " \t,;\r"
-
-static double* readTxtTable(const char* tableName, const char* fileName,
-                            size_t* _nRow, size_t* _nCol) {
-    double* table = NULL;
-    if (tableName != NULL && fileName != NULL && _nRow != NULL && _nCol != NULL) {
-        char* buf;
-        int bufLen = LINE_BUFFER_LENGTH;
-        FILE* fp;
-        int foundTable = 0;
-        int tableReadError;
-        unsigned long nRow = 0;
-        unsigned long nCol = 0;
-        unsigned long lineNo = 1;
-#if defined(_MSC_VER) && _MSC_VER >= 1400
-        _locale_t loc;
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
-        locale_t loc;
-#else
-        char* dec;
 #endif
-
-        fp = fopen(fileName, "r");
-        if (fp == NULL) {
-            ModelicaFormatError("Not possible to open file \"%s\": "
-                "No such file or directory\n", fileName);
-            return NULL;
-        }
-
-        buf = (char*)malloc(LINE_BUFFER_LENGTH*sizeof(char));
-        if (buf == NULL) {
-            fclose(fp);
-            ModelicaError("Memory allocation error\n");
-            return NULL;
-        }
-
-        /* Read file header */
-        if ((tableReadError = readLine(&buf, &bufLen, fp)) != 0) {
-            free(buf);
-            fclose(fp);
-            if (tableReadError < 0) {
-                ModelicaFormatError(
-                    "Error reading first line from file \"%s\": "
-                    "End-Of-File reached.\n", fileName);
-            }
-            return NULL;
-        }
-
-        /* Expected file header format: "#1" */
-        if (0 != strncmp(buf, "#1", 2)) {
-            size_t len = strlen(buf);
-            fclose(fp);
-            if (len == 0) {
-                free(buf);
-                ModelicaFormatError(
-                    "Error reading format and version information in first "
-                    "line of file \"%s\": \"#1\" expected.\n", fileName);
-            }
-            else if (len == 1) {
-                char c0 = buf[0];
-                free(buf);
-                ModelicaFormatError(
-                    "Error reading format and version information in first "
-                    "line of file \"%s\": \"#1\" expected, but \"%c\" found.\n",
-                    fileName, c0);
-            }
-            else {
-                char c0 = buf[0];
-                char c1 = buf[1];
-                free(buf);
-                ModelicaFormatError(
-                    "Error reading format and version information in first "
-                    "line of file \"%s\": \"#1\" expected, but \"%c%c\" "
-                    "found.\n", fileName, c0, c1);
-            }
-            return NULL;
-        }
-
-#if defined(_MSC_VER) && _MSC_VER >= 1400
-        loc = _create_locale(LC_NUMERIC, "C");
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
-        loc = newlocale(LC_NUMERIC, "C", NULL);
 #else
-        dec = localeconv()->decimal_point;
-#endif
-
-        /* Loop over lines of file */
-        while (readLine(&buf, &bufLen, fp) == 0) {
-            char* token;
-            char* endptr;
-
-            lineNo++;
-            /* Expected table header format: "dataType tableName(nRow,nCol)" */
-            token = strtok(buf, DELIM_TABLE_HEADER);
-            if (token == NULL) {
-                continue;
-            }
-            if ((0 != strcmp(token, "double")) && (0 != strcmp(token, "float"))) {
-                continue;
-            }
-            token = strtok(NULL, DELIM_TABLE_HEADER);
-            if (token == NULL) {
-                continue;
-            }
-            if (0 == strcmp(token, tableName)) {
-                foundTable = 1;
-            }
-            else {
-                continue;
-            }
-            token = strtok(NULL, DELIM_TABLE_HEADER);
-            if (token == NULL) {
-                continue;
-            }
-#if defined(_MSC_VER) && _MSC_VER >= 1400
-            nRow = (unsigned long)_strtol_l(token, &endptr, 10, loc);
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
-            nRow = (unsigned long)strtol_l(token, &endptr, 10, loc);
-#else
-            nRow = (unsigned long)strtol(token, &endptr, 10);
-#endif
-            if (*endptr != 0) {
-                continue;
-            }
-            token = strtok(NULL, DELIM_TABLE_HEADER);
-            if (token == NULL) {
-                continue;
-            }
-#if defined(_MSC_VER) && _MSC_VER >= 1400
-            nCol = (unsigned long)_strtol_l(token, &endptr, 10, loc);
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
-            nCol = (unsigned long)strtol_l(token, &endptr, 10, loc);
-#else
-            nCol = (unsigned long)strtol(token, &endptr, 10);
-#endif
-            if (*endptr != 0) {
-                continue;
-            }
-
-            { /* foundTable == 1 */
-                size_t i = 0;
-                size_t j = 0;
-
-                table = (double*)malloc(nRow*nCol*sizeof(double));
-                if (table == NULL) {
-                    *_nRow = 0;
-                    *_nCol = 0;
-                    free(buf);
-                    fclose(fp);
-#if defined(_MSC_VER) && _MSC_VER >= 1400
-                    _free_locale(loc);
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
-                    freelocale(loc);
-#endif
-                    ModelicaError("Memory allocation error\n");
-                    return table;
-                }
-
-                /* Loop over rows and store table row-wise */
-                while (tableReadError == 0 && i < nRow) {
-                    int k = 0;
-
-                    lineNo++;
-                    if ((tableReadError = readLine(&buf, &bufLen, fp)) != 0) {
-                        break;
-                    }
-                    /* Ignore leading white space */
-                    while (k < bufLen - 1) {
-                        if (buf[k] != ' ' && buf[k] != '\t') {
-                            break;
-                        }
-                        k++;
-                    }
-                    if (buf[k] == '\0' || buf[k] == '#') {
-                        /* Skip empty or comment line */
-                        continue;
-                    }
-                    token = strtok(&buf[k], DELIM_TABLE_NUMBER);
-                    while (token != NULL && i < nRow && j < nCol) {
-                        if (token[0] == '#') {
-                            /* Skip trailing comment line */
-                            break;
-                        }
-#if defined(_MSC_VER) && _MSC_VER >= 1400
-                        TABLE(i, j) = _strtod_l(token, &endptr, loc);
-                        if (*endptr != 0) {
-                            tableReadError = 1;
-                        }
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
-                        TABLE(i, j) = strtod_l(token, &endptr, loc);
-                        if (*endptr != 0) {
-                            tableReadError = 1;
-                        }
-#else
-                        if (*dec == '.') {
-                            TABLE(i, j) = strtod(token, &endptr);
-                        }
-                        else if (NULL == strchr(token, '.')) {
-                            TABLE(i, j) = strtod(token, &endptr);
-                        }
-                        else {
-                            char* token2 = (char*)malloc(
-                                (strlen(token) + 1)*sizeof(char));
-                            if (token2 != NULL) {
-                                char* p;
-                                strcpy(token2, token);
-                                p = strchr(token2, '.');
-                                *p = *dec;
-                                TABLE(i, j) = strtod(token2, &endptr);
-                                if (*endptr != 0) {
-                                    tableReadError = 1;
-                                }
-                                free(token2);
-                            }
-                            else {
-                                *_nRow = 0;
-                                *_nCol = 0;
-                                free(buf);
-                                fclose(fp);
-                                tableReadError = 1;
-                                ModelicaError("Memory allocation error\n");
-                                break;
-                            }
-                        }
-#endif
-                        if (++j == nCol) {
-                            i++; /* Increment row index */
-                            j = 0; /* Reset column index */
-                        }
-                        if (tableReadError == 0) {
-                            token = strtok(NULL, DELIM_TABLE_NUMBER);
-                            continue;
-                        }
-                        else {
-                            break;
-                        }
-                    }
-                    /* Check for trailing non-comment character */
-                    if (token != NULL && token[0] != '#') {
-                        /* Check for trailing number */
-                        if (i == nRow) {
-                            int foundExponentSign = 0;
-                            int foundExponent = 0;
-                            int foundDec = 0;
-                            tableReadError = 2;
-                            if (token[0] == '+' || token[0] == '-') {
-                                k = 1;
-                            }
-                            else {
-                                k = 0;
-                            }
-                            while (token[k] != '\0') {
-                                if (token[k] >= '0' && token[k] <= '9') {
-                                    k++;
-                                }
-                                else if (token[k] == '.' && foundDec == 0 &&
-                                    foundExponent == 0 && foundExponentSign == 0) {
-                                    foundDec = 1;
-                                    k++;
-                                }
-                                else if ((token[k] == 'e' || token[k] == 'E') &&
-                                    foundExponent == 0) {
-                                    foundExponent = 1;
-                                    k++;
-                                }
-                                else if ((token[k] == '+' || token[k] == '-') &&
-                                    foundExponent == 1 && foundExponentSign == 0) {
-                                    foundExponentSign = 1;
-                                    k++;
-                                }
-                                else {
-                                    tableReadError = 1;
-                                    break;
-                                }
-                            }
-                        }
-                        else {
-                            tableReadError = 1;
-                        }
-                        break;
-                    }
-                }
-                break;
-            }
-        }
-
-        free(buf);
-        fclose(fp);
-#if defined(_MSC_VER) && _MSC_VER >= 1400
-        _free_locale(loc);
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
-        freelocale(loc);
-#endif
-        if (foundTable == 0) {
-            ModelicaFormatError(
-                "Table matrix \"%s\" not found on file \"%s\".\n",
-                tableName, fileName);
-            return table;
-        }
-
-        if (tableReadError == 0) {
-            *_nRow = (size_t)nRow;
-            *_nCol = (size_t)nCol;
-        }
-        else {
-            free(table);
-            table = NULL;
-            *_nRow = 0;
-            *_nCol = 0;
-            if (tableReadError == EOF) {
-                ModelicaFormatError(
-                    "End-of-file reached when reading numeric data of matrix "
-                    "\"%s(%lu,%lu)\" from file \"%s\"\n", tableName, nRow,
-                    nCol, fileName);
-            }
-            else if (tableReadError == 2) {
-                ModelicaFormatError(
-                    "The table dimensions of matrix \"%s(%lu,%lu)\" from file "
-                    "\"%s\" do not match the actual table size.\n", tableName,
-                    nRow, nCol, fileName);
-            }
-            else {
-                ModelicaFormatError(
-                    "Error in line %lu when reading numeric data of matrix "
-                    "\"%s(%lu,%lu)\" from file \"%s\"\n", lineNo, tableName,
-                    nRow, nCol, fileName);
-            }
-        }
-    }
-    return table;
+    return NULL;
+#endif /* #if !defined(NO_FILE_SYSTEM) */
 }
 
-#undef DELIM_TABLE_HEADER
-#undef DELIM_TABLE_NUMBER
-
-static int readLine(char** buf, int* bufLen, FILE* fp) {
-    char* offset;
-    int oldBufLen;
-
-    if (fgets(*buf, *bufLen, fp) == NULL) {
-        return EOF;
-    }
-
-    do {
-        char* p;
-        char* tmp;
-
-        if ((p = strchr(*buf, '\n')) != NULL) {
-            *p = '\0';
-            return 0;
-        }
-
-        oldBufLen = *bufLen;
-        *bufLen *= 2;
-        tmp = (char*)realloc(*buf, (size_t)*bufLen);
-        if (tmp == NULL) {
-            fclose(fp);
-            free(*buf);
-            ModelicaError("Memory allocation error\n");
-            return 1;
-        }
-        *buf = tmp;
-        offset = &((*buf)[oldBufLen - 1]);
-
-    } while (fgets(offset, oldBufLen + 1, fp));
-
-    return 0;
-}
-#endif /* #if !defined(NO_FILE_SYSTEM) */
-
 #if defined(DUMMY_FUNCTION_USERTAB)
 int usertab(char* tableName, int nipo, int dim[], int* colWise,
             double** table) {
Index: Modelica/Resources/C-Sources/ModelicaStandardTables.h
===================================================================
--- Modelica/Resources/C-Sources/ModelicaStandardTables.h	(revision 10440)
+++ Modelica/Resources/C-Sources/ModelicaStandardTables.h	(working copy)
@@ -1,6 +1,6 @@
 /* ModelicaStandardTables.h - External table functions header
 
-   Copyright (C) 2013-2016, Modelica Association, DLR, and ITI GmbH
+   Copyright (C) 2013-2017, Modelica Association, DLR, and ESI ITI GmbH
    Copyright (C) 2008-2013, Modelica Association and DLR
    All rights reserved.
 
@@ -26,15 +26,42 @@
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-/* Definition of interface to external functions for table computation
-   in the Modelica Standard Library:
+/* The following #define's are available.
 
-      Modelica.Blocks.Sources.CombiTimeTable
-      Modelica.Blocks.Tables.CombiTable1D
-      Modelica.Blocks.Tables.CombiTable1Ds
-      Modelica.Blocks.Tables.CombiTable2D
+   NO_FILE_SYSTEM        : A file system is not present (e.g. on dSPACE or xPC).
+   NO_TABLE_COPY         : Do not copy table data passed to _init functions
+                           This is a potentially unsafe optimization (ticket #1143).
+   TABLE_SHARE           : If NO_FILE_SYTEM is not defined then common/shared table
+                           arrays are stored in a global hash table in order to
+                           avoid superfluous file input access and to decrease the
+                           utilized memory (tickets #1110 and #1550).
+   DEBUG_TIME_EVENTS     : Trace time events of CombiTimeTable
+   DUMMY_FUNCTION_USERTAB: Use a dummy function "usertab"
 
    Release Notes:
+      Apr. 24, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added functions to retrieve minimum and maximum abscissa
+                     values of CombiTable2D (ticket #2244)
+
+      Apr. 15, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added support for time event generation (independent of
+                     smoothness) in CombiTimeTable (ticket #2080)
+
+      Apr. 11, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Revised initialization of CombiTimeTable, CombiTable1D
+                     and CombiTable2D (ticket #1899)
+                     - Already read table in the initialization functions
+                     - Removed the implementation of the read functions
+
+      Apr. 07, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added support for shift time (independent of start time)
+                     in CombiTimeTable (ticket #1771)
+
+      Feb. 25, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Added support for extrapolation in CombiTable1D (ticket #1839)
+                     Added functions to retrieve minimum and maximum abscissa
+                     values of CombiTable1D (ticket #2120)
+
       Oct. 27, 2015: by Thomas Beutlich, ITI GmbH
                      Added nonnull attribute/annotations (ticket #1436)
 
@@ -51,7 +78,7 @@
          (= table    is "NoName" or has only blanks AND
             fileName is "NoName" or has only blanks).
 
-     (2) Read from a file (tableName, fileName have to be supplied).
+     (2) Read from a file (fileName, tableName have to be supplied).
 
    Tables may be linearly interpolated or the first derivative
    may be continuous. In the latter case, cubic Hermite splines with Akima slope
@@ -59,13 +86,18 @@
    slope approximation (univariate only) are used.
 */
 
-#ifndef _MODELICASTANDARDTABLES_H_
-#define _MODELICASTANDARDTABLES_H_
+#ifndef MODELICA_STANDARDTABLES_H_
+#define MODELICA_STANDARDTABLES_H_
 
 #include <stdlib.h>
+
+#if !defined(MODELICA_EXPORT)
 #if defined(__cplusplus)
-extern "C" {
+#define MODELICA_EXPORT extern "C"
+#else
+#define MODELICA_EXPORT
 #endif
+#endif
 
 /*
  * Non-null pointers and esp. null-terminated strings need to be passed to
@@ -84,7 +116,7 @@
 #define _Inout_
 #endif
 
-void* ModelicaStandardTables_CombiTimeTable_init(_In_z_ const char* tableName,
+MODELICA_EXPORT void* ModelicaStandardTables_CombiTimeTable_init(_In_z_ const char* tableName,
                                                  _In_z_ const char* fileName,
                                                  _In_ double* table, size_t nRow,
                                                  size_t nColumn,
@@ -92,10 +124,25 @@
                                                  _In_ int* columns,
                                                  size_t nCols, int smoothness,
                                                  int extrapolation) MODELICA_NONNULLATTR;
+  /* Same as ModelicaStandardTables_CombiTimeTable_init2, but without shiftTime, timeEvents and
+     verbose arguments
+  */
+
+MODELICA_EXPORT void* ModelicaStandardTables_CombiTimeTable_init2(_In_z_ const char* fileName,
+                                                  _In_z_ const char* tableName,
+                                                  _In_ double* table, size_t nRow,
+                                                  size_t nColumn,
+                                                  double startTime,
+                                                  _In_ int* columns,
+                                                  size_t nCols, int smoothness,
+                                                  int extrapolation,
+                                                  double shiftTime,
+                                                  int timeEvents,
+                                                  int verbose) MODELICA_NONNULLATTR;
   /* Initialize 1-dim. table where first column is time
 
+     -> fileName: Name of file
      -> tableName: Name of table
-     -> fileName: Name of file
      -> table: If tableName="NoName" or has only blanks AND
                fileName ="NoName" or has only blanks, then
                this pointer points to a 2-dim. array (row-wise storage)
@@ -102,41 +149,41 @@
                in the Modelica environment that holds this matrix.
      -> nRow: Number of rows of table
      -> nColumn: Number of columns of table
-     -> startTime: Output = offset for time < startTime
+     -> startTime: Start time of inter-/extrapolation
      -> columns: Columns of table to be interpolated
      -> nCols: Number of columns of table to be interpolated
      -> smoothness: Interpolation type
-                    = 1: constant
-                    = 2: linear
-                    = 3: continuous first derivative
+                    = 1: linear
+                    = 2: continuous first derivative (by Akima splines)
+                    = 3: constant
+                    = 4: monotonicity-preserving, continuous first derivative
+                         (by Fritsch-Butland splines)
+                    = 5: monotonicity-preserving, continuous first derivative
+                         (by Steffen splines)
      -> extrapolation: Extrapolation type
-                       = 1: no
-                       = 2: hold first/last value
-                       = 3: linear
-                       = 4: periodic
+                       = 1: hold first/last value
+                       = 2: linear
+                       = 3: periodic
+                       = 4: no
+     -> shiftTime: Shift time of first table column
+     -> timeEvents: Time event handling (for constant or linear interpolation)
+                    = 1: always
+                    = 2: at discontinuities
+                    = 3: no
+     -> verbose: Print message that file is loading
      <- RETURN: Pointer to internal memory of table structure
   */
 
-void ModelicaStandardTables_CombiTimeTable_close(void* tableID);
+MODELICA_EXPORT void ModelicaStandardTables_CombiTimeTable_close(void* tableID);
   /* Close table and free allocated memory */
 
-double ModelicaStandardTables_CombiTimeTable_read(void* tableID, int force,
-                                                  int verbose);
-  /* Read table from file
+MODELICA_EXPORT double ModelicaStandardTables_CombiTimeTable_minimumTime(void* tableID);
+  /* Return minimum abscissa defined in table (= table[1,1]) */
 
-     -> tableID: Pointer to table defined with ModelicaStandardTables_CombiTimeTable_init
-     -> force: Read only if forced or not yet read
-     -> verbose: Print message that file is loading
-     <- RETURN: = 1, if table was successfully read from file
-  */
+MODELICA_EXPORT double ModelicaStandardTables_CombiTimeTable_maximumTime(void* tableID);
+  /* Return maximum abscissa defined in table (= table[end,1]) */
 
-double ModelicaStandardTables_CombiTimeTable_minimumTime(void* tableID);
-  /* Return minimum time defined in table (= table[1,1]) */
-
-double ModelicaStandardTables_CombiTimeTable_maximumTime(void* tableID);
-  /* Return maximum time defined in table (= table[end,1]) */
-
-double ModelicaStandardTables_CombiTimeTable_getValue(void* tableID,
+MODELICA_EXPORT double ModelicaStandardTables_CombiTimeTable_getValue(void* tableID,
                                                       int icol, double t,
                                                       double nextTimeEvent,
                                                       double preNextTimeEvent);
@@ -150,7 +197,7 @@
      <- RETURN : Ordinate value
   */
 
-double ModelicaStandardTables_CombiTimeTable_getDerValue(void* tableID,
+MODELICA_EXPORT double ModelicaStandardTables_CombiTimeTable_getDerValue(void* tableID,
                                                          int icol,
                                                          double t,
                                                          double nextTimeEvent,
@@ -167,7 +214,7 @@
      <- RETURN: Derivative of ordinate value
   */
 
-double ModelicaStandardTables_CombiTimeTable_nextTimeEvent(void* tableID, double t);
+MODELICA_EXPORT double ModelicaStandardTables_CombiTimeTable_nextTimeEvent(void* tableID, double t);
   /* Return next time event in table
 
      -> tableID: Pointer to table defined with ModelicaStandardTables_CombiTimeTable_init
@@ -175,17 +222,33 @@
      <- RETURN: Next abscissa value > t that triggers a time event
   */
 
-void* ModelicaStandardTables_CombiTable1D_init(_In_z_ const char* tableName,
+MODELICA_EXPORT double ModelicaStandardTables_CombiTimeTable_read(void* tableID, int force,
+                                                  int verbose);
+  /* Empty function, kept only for backward compatibility */
+
+MODELICA_EXPORT void* ModelicaStandardTables_CombiTable1D_init(_In_z_ const char* tableName,
                                                _In_z_ const char* fileName,
                                                _In_ double* table, size_t nRow,
                                                size_t nColumn,
                                                _In_ int* columns,
                                                size_t nCols, int smoothness) MODELICA_NONNULLATTR;
+  /* Same as ModelicaStandardTables_CombiTable1D_init2, but without extrapolation and
+     verbose arguments
+  */
+
+MODELICA_EXPORT void* ModelicaStandardTables_CombiTable1D_init2(_In_z_ const char* fileName,
+                                                _In_z_ const char* tableName,
+                                                _In_ double* table, size_t nRow,
+                                                size_t nColumn,
+                                                _In_ int* columns,
+                                                size_t nCols, int smoothness,
+                                                int extrapolation,
+                                                int verbose) MODELICA_NONNULLATTR;
   /* Initialize 1-dim. table defined by matrix, where first column
      is x-axis and further columns of matrix are interpolated
 
+     -> fileName: Name of file
      -> tableName: Name of table
-     -> fileName: Name of file
      -> table: If tableName="NoName" or has only blanks AND
                fileName ="NoName" or has only blanks, then
                this pointer points to a 2-dim. array (row-wise storage)
@@ -192,30 +255,35 @@
                in the Modelica environment that holds this matrix.
      -> nRow: Number of rows of table
      -> nColumn: Number of columns of table
-     -> startTime: Output = offset for time < startTime
      -> columns: Columns of table to be interpolated
      -> nCols: Number of columns of table to be interpolated
      -> smoothness: Interpolation type
-                    = 1: constant
-                    = 2: linear
-                    = 3: continuous first derivative
+                    = 1: linear
+                    = 2: continuous first derivative (by Akima splines)
+                    = 3: constant
+                    = 4: monotonicity-preserving, continuous first derivative
+                         (by Fritsch-Butland splines)
+                    = 5: monotonicity-preserving, continuous first derivative
+                         (by Steffen splines)
+     -> extrapolation: Extrapolation type
+                       = 1: hold first/last value
+                       = 2: linear
+                       = 3: periodic
+                       = 4: no
+     -> verbose: Print message that file is loading
      <- RETURN: Pointer to internal memory of table structure
   */
 
-void ModelicaStandardTables_CombiTable1D_close(void* tableID);
+MODELICA_EXPORT void ModelicaStandardTables_CombiTable1D_close(void* tableID);
   /* Close table and free allocated memory */
 
-double ModelicaStandardTables_CombiTable1D_read(void* tableID, int force,
-                                                int verbose);
-  /* Read table from file
+MODELICA_EXPORT double ModelicaStandardTables_CombiTable1D_minimumAbscissa(void* tableID);
+  /* Return minimum abscissa defined in table (= table[1,1]) */
 
-     -> tableID: Pointer to table defined with ModelicaStandardTables_CombiTable1D_init
-     -> force: Read only if forced or not yet read
-     -> verbose: Print message that file is loading
-     <- RETURN: = 1, if table was successfully read from file
-  */
+MODELICA_EXPORT double ModelicaStandardTables_CombiTable1D_maximumAbscissa(void* tableID);
+  /* Return maximum abscissa defined in table (= table[end,1]) */
 
-double ModelicaStandardTables_CombiTable1D_getValue(void* tableID, int icol,
+MODELICA_EXPORT double ModelicaStandardTables_CombiTable1D_getValue(void* tableID, int icol,
                                                     double u);
   /* Interpolate in table
 
@@ -225,7 +293,7 @@
      <- RETURN : Ordinate value
   */
 
-double ModelicaStandardTables_CombiTable1D_getDerValue(void* tableID, int icol,
+MODELICA_EXPORT double ModelicaStandardTables_CombiTable1D_getDerValue(void* tableID, int icol,
                                                        double u, double der_u);
   /* Interpolated derivative in table
 
@@ -236,10 +304,22 @@
      <- RETURN: Derivative of ordinate value
   */
 
-void* ModelicaStandardTables_CombiTable2D_init(_In_z_ const char* tableName,
+MODELICA_EXPORT double ModelicaStandardTables_CombiTable1D_read(void* tableID, int force,
+                                                int verbose);
+  /* Empty function, kept only for backward compatibility */
+
+MODELICA_EXPORT void* ModelicaStandardTables_CombiTable2D_init(_In_z_ const char* tableName,
                                                _In_z_ const char* fileName,
                                                _In_ double* table, size_t nRow,
                                                size_t nColumn, int smoothness) MODELICA_NONNULLATTR;
+  /* Same as ModelicaStandardTables_CombiTable2D_init2, but without verbose argument */
+
+MODELICA_EXPORT void* ModelicaStandardTables_CombiTable2D_init2(_In_z_ const char* fileName,
+                                                _In_z_ const char* tableName,
+                                                _In_ double* table, size_t nRow,
+                                                size_t nColumn, int smoothness,
+                                                int extrapolation,
+                                                int verbose) MODELICA_NONNULLATTR;
   /* Initialize 2-dim. table defined by matrix, where first column
      is x-axis, first row is y-axis and the matrix elements are the
      z-values.
@@ -256,26 +336,30 @@
      -> nRow: Number of rows of table
      -> nColumn: Number of columns of table
      -> smoothness: Interpolation type
-                    = 1: constant
-                    = 2: linear
-                    = 3: continuous first derivative
+                    = 1: bilinear
+                    = 2: continuous first derivative (by bivariate Akima splines)
+                    = 3: bivariate constant
+     -> extrapolation: Extrapolation type
+                       = 1: hold first/last value
+                       = 2: linear
+                       = 3: periodic
+                       = 4: no
+     -> verbose: Print message that file is loading
      <- RETURN: Pointer to internal memory of table structure
   */
 
-void ModelicaStandardTables_CombiTable2D_close(void* tableID);
+MODELICA_EXPORT void ModelicaStandardTables_CombiTable2D_close(void* tableID);
   /* Close table and free allocated memory */
 
-double ModelicaStandardTables_CombiTable2D_read(void* tableID, int force,
-                                                int verbose);
-  /* Read table from file
+MODELICA_EXPORT void ModelicaStandardTables_CombiTable2D_minimumAbscissa(void* tableID,
+                                                         _Inout_ double* uMin);
+  /* Get minimum abscissa defined in table (= table[2,1] and table[1,2]) */
 
-     -> tableID: Pointer to table defined with ModelicaStandardTables_CombiTable2D_init
-     -> force: Read only if forced or not yet read
-     -> verbose: Print message that file is loading
-     <- RETURN: = 1, if table was successfully read from file
-  */
+MODELICA_EXPORT void ModelicaStandardTables_CombiTable2D_maximumAbscissa(void* tableID,
+                                                         _Inout_ double* uMax);
+  /* Get maximum abscissa defined in table (= table[end,1] and table[1,end]) */
 
-double ModelicaStandardTables_CombiTable2D_getValue(void* tableID, double u1,
+MODELICA_EXPORT double ModelicaStandardTables_CombiTable2D_getValue(void* tableID, double u1,
                                                     double u2);
   /* Interpolate in table
 
@@ -285,7 +369,7 @@
      <- RETURN : Interpolated value
   */
 
-double ModelicaStandardTables_CombiTable2D_getDerValue(void* tableID, double u1,
+MODELICA_EXPORT double ModelicaStandardTables_CombiTable2D_getDerValue(void* tableID, double u1,
                                                        double u2, double der_u1,
                                                        double der_u2);
   /* Interpolated derivative in table
@@ -298,8 +382,8 @@
      <- RETURN: Derivative of interpolated value
   */
 
-#if defined(__cplusplus)
-}
+MODELICA_EXPORT double ModelicaStandardTables_CombiTable2D_read(void* tableID, int force,
+                                                int verbose);
+  /* Empty function, kept only for backward compatibility */
+
 #endif
-
-#endif /* _MODELICASTANDARDTABLES_H_ */
Index: Modelica/Resources/C-Sources/ModelicaStrings.c
===================================================================
--- Modelica/Resources/C-Sources/ModelicaStrings.c	(revision 10440)
+++ Modelica/Resources/C-Sources/ModelicaStrings.c	(working copy)
@@ -1,6 +1,6 @@
 /* ModelicaStrings.c - External functions for Modelica.Functions.Strings
 
-   Copyright (C) 2002-2016, Modelica Association and DLR
+   Copyright (C) 2002-2017, Modelica Association and DLR
    All rights reserved.
 
    Redistribution and use in source and binary forms, with or without
@@ -25,20 +25,17 @@
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-/* The functions are mostly non-portable. The following #define's are used
-   to define the system calls of the operating system
+/* Release Notes:
+      Jun. 16, 2017: by Thomas Beutlich, ESI ITI GmbH
+                     Utilize hash macros of uthash.h for ModelicaStrings_hashString
+                     (ticket #2250)
 
-   _MSC_VER       : Microsoft Visual C++
-   __GNUC__       : GNU C compiler
-   MODELICA_EXPORT: Prefix used for function calls. If not defined, blank is used
-                    Useful definitions:
-                    - "static" that is all functions become static
-                      (useful if file is included with other C-sources for an
-                       embedded system)
-                    - "__declspec(dllexport)" if included in a DLL and the
-                      functions shall be visible outside of the DLL
+      Nov. 23, 2016: by Martin Sjoelund, SICS East Swedish ICT AB
+                     Added NO_LOCALE define flag, in case the OS does
+                     not have this (for example when using GCC compiler,
+                     but not libc). Also added autoconf detection for
+                     this flag, NO_PID, NO_TIME, and NO_FILE_SYSTEM
 
-   Release Notes:
       Feb. 26, 2016: by Hans Olsson, DS AB
                      Build hash code on the unsigned characters in
                      ModelicaStrings_hashString (ticket #1926)
@@ -62,7 +59,7 @@
       Sep. 24, 2004: by Martin Otter, DLR
                      Final cleaning up of the code
 
-      Sep.  9, 2004: by Dag Bruck, Dynasim AB
+      Sep.  9, 2004: by Dag Brueck, Dynasim AB
                      Implementation of scan functions
 
       Aug. 19, 2004: by Martin Otter, DLR
@@ -73,61 +70,25 @@
                      Implemented a first version
 */
 
-#if !defined(MODELICA_EXPORT)
-#   define MODELICA_EXPORT
-#endif
 #if defined(__gnu_linux__)
 #define _GNU_SOURCE 1
 #endif
 
-#include "ModelicaUtilities.h"
+#include "ModelicaStrings.h"
+
 #include <ctype.h>
-#include <stdlib.h>
 #include <string.h>
+#if !defined(NO_LOCALE)
 #include <locale.h>
-
-/*
- * Non-null pointers and esp. null-terminated strings need to be passed to
- * external functions.
- *
- * The following macros handle nonnull attributes for GNU C and Microsoft SAL.
- */
-#if defined(__GNUC__)
-#define MODELICA_NONNULLATTR __attribute__((nonnull))
-#if defined(__GNUC_MINOR__) && (__GNUC__ > 3 && __GNUC_MINOR__ > 8)
-#define MODELICA_RETURNNONNULLATTR __attribute__((returns_nonnull))
-#else
-#define MODELICA_RETURNNONNULLATTR
 #endif
-#elif defined(__ATTR_SAL)
-#define MODELICA_NONNULLATTR
-#define MODELICA_RETURNNONNULLATTR _Ret_z_ /* _Ret_notnull_ and null-terminated */
-#else
-#define MODELICA_NONNULLATTR
-#define MODELICA_RETURNNONNULLATTR
-#endif
-#if !defined(__ATTR_SAL)
-#define _In_z_
-#define _Out_
-#endif
 
-MODELICA_EXPORT MODELICA_RETURNNONNULLATTR const char* ModelicaStrings_substring(
-    _In_z_ const char* string, int startIndex, int endIndex) MODELICA_NONNULLATTR;
-MODELICA_EXPORT int ModelicaStrings_length(_In_z_ const char* string) MODELICA_NONNULLATTR;
-MODELICA_EXPORT int ModelicaStrings_skipWhiteSpace(_In_z_ const char* string,
-    int i) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaStrings_scanIdentifier(_In_z_ const char* string,
-    int startIndex, _Out_ int* nextIndex, _Out_ const char** identifier) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaStrings_scanInteger(_In_z_ const char* string,
-    int startIndex, int unsignedNumber, _Out_ int* nextIndex,
-    _Out_ int* integerNumber) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaStrings_scanReal(_In_z_ const char* string, int startIndex,
-    int unsignedNumber, _Out_ int* nextIndex, _Out_ double* number) MODELICA_NONNULLATTR;
-MODELICA_EXPORT void ModelicaStrings_scanString(_In_z_ const char* string, int startIndex,
-    _Out_ int* nextIndex, _Out_ const char** result) MODELICA_NONNULLATTR;
-MODELICA_EXPORT int ModelicaStrings_hashString(_In_z_ const char* str) MODELICA_NONNULLATTR;
+#include "ModelicaUtilities.h"
+#define HASH_FUNCTION HASH_AP
+#include "uthash.h"
+#undef uthash_fatal /* Ensure that nowhere in this file uses uthash_fatal by accident */
 
-MODELICA_EXPORT const char* ModelicaStrings_substring(const char* string, int startIndex, int endIndex) {
+_Ret_z_ const char* ModelicaStrings_substring(_In_z_ const char* string,
+                                      int startIndex, int endIndex) {
     /* Return string1(startIndex:endIndex) if endIndex >= startIndex,
        or return string1(startIndex:startIndex), if endIndex = 0.
        An assert is triggered, if startIndex/endIndex are not valid.
@@ -159,18 +120,18 @@
 
     /* Allocate memory and copy string */
     len2 = endIndex - startIndex + 1;
-    substring = ModelicaAllocateString(len2);
-    strncpy(substring, &string[startIndex-1], len2);
+    substring = ModelicaAllocateString((size_t)len2);
+    strncpy(substring, &string[startIndex-1], (size_t)len2);
     substring[len2] = '\0';
     return substring;
 }
 
-MODELICA_EXPORT int ModelicaStrings_length(const char* string) {
+int ModelicaStrings_length(_In_z_ const char* string) {
     /* Return the number of characters "string" */
     return (int) strlen(string);
 }
 
-MODELICA_EXPORT int ModelicaStrings_compare(const char* string1, const char* string2, int caseSensitive) {
+int ModelicaStrings_compare(_In_z_ const char* string1, _In_z_ const char* string2, int caseSensitive) {
     /* Compare two strings, optionally ignoring case */
     int result;
     if (string1 == 0 || string2 == 0) {
@@ -202,7 +163,7 @@
 
 #define MAX_TOKEN_SIZE 100
 
-MODELICA_EXPORT int ModelicaStrings_skipWhiteSpace(const char* string, int i) {
+int ModelicaStrings_skipWhiteSpace(_In_z_ const char* string, int i) {
     /* Return index in string after skipping ws, or position of terminating nul. */
     while (string[i-1] != '\0' && isspace((unsigned char)string[i-1])) {
         ++i;
@@ -271,7 +232,9 @@
 
 /* --------------- end of utility functions used in scanXXX functions ----------- */
 
-MODELICA_EXPORT void ModelicaStrings_scanIdentifier(const char* string, int startIndex, int* nextIndex, const char** identifier) {
+void ModelicaStrings_scanIdentifier(_In_z_ const char* string,
+                                    int startIndex, _Out_ int* nextIndex,
+                                    _Out_ const char** identifier) {
     int token_start = ModelicaStrings_skipWhiteSpace(string, startIndex);
     /* Index of first char of token, after ws. */
 
@@ -286,8 +249,8 @@
         }
 
         {
-            char* s = ModelicaAllocateString(token_length);
-            strncpy(s, string+token_start-1, token_length);
+            char* s = ModelicaAllocateString((size_t)token_length);
+            strncpy(s, string+token_start-1, (size_t)token_length);
             s[token_length] = '\0';
             *nextIndex = token_start + token_length;
             *identifier = s;
@@ -301,8 +264,9 @@
     return;
 }
 
-MODELICA_EXPORT void ModelicaStrings_scanInteger(const char* string, int startIndex, int unsignedNumber,
-                                 int* nextIndex, int* integerNumber) {
+void ModelicaStrings_scanInteger(_In_z_ const char* string,
+                                 int startIndex, int unsignedNumber,
+                                 _Out_ int* nextIndex, _Out_ int* integerNumber) {
     int sign = 0;
     /* Number of characters used for sign. */
 
@@ -324,7 +288,8 @@
                 (string[next] != '\0' && string[next] != '.'
                                       && string[next] != 'e'
                                       && string[next] != 'E') ) {
-#if defined(_MSC_VER) && _MSC_VER >= 1400
+#if defined(NO_LOCALE)
+#elif defined(_MSC_VER) && _MSC_VER >= 1400
                 _locale_t loc = _create_locale(LC_NUMERIC, "C");
 #elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
                 locale_t loc = newlocale(LC_NUMERIC, "C", NULL);
@@ -336,12 +301,12 @@
                 int x;
                 /* For receiving the result. */
 
-                strncpy(buf, string+token_start-1, sign + number_length);
+                strncpy(buf, string+token_start-1, (size_t)(sign + number_length));
                 buf[sign + number_length] = '\0';
-#if defined(_MSC_VER) && _MSC_VER >= 1400
+#if !defined(NO_LOCALE) && (defined(_MSC_VER) && _MSC_VER >= 1400)
                 x = (int)_strtol_l(buf, &endptr, 10, loc);
                 _free_locale(loc);
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
+#elif !defined(NO_LOCALE) && (defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3))
                 x = (int)strtol_l(buf, &endptr, 10, loc);
                 freelocale(loc);
 #else
@@ -353,9 +318,6 @@
                     return;
                 }
             }
-            else {
-                ++number_length;
-            }
         }
     }
 
@@ -365,8 +327,9 @@
     return;
 }
 
-MODELICA_EXPORT void ModelicaStrings_scanReal(const char* string, int startIndex, int unsignedNumber,
-                              int* nextIndex, double* number) {
+void ModelicaStrings_scanReal(_In_z_ const char* string, int startIndex,
+                              int unsignedNumber, _Out_ int* nextIndex,
+                              _Out_ double* number) {
     /*
     Grammar of real number:
 
@@ -434,7 +397,9 @@
     /* Convert accumulated characters into a number. */
 
     if (total_length > 0 && total_length < MAX_TOKEN_SIZE) {
-#if defined(_MSC_VER) && _MSC_VER >= 1400
+#if defined(NO_LOCALE)
+        const char* const dec = ".";
+#elif defined(_MSC_VER) && _MSC_VER >= 1400
         _locale_t loc = _create_locale(LC_NUMERIC, "C");
 #elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
         locale_t loc = newlocale(LC_NUMERIC, "C", NULL);
@@ -448,12 +413,12 @@
         double x;
         /* For receiving the result. */
 
-        strncpy(buf, string+token_start-1, total_length);
+        strncpy(buf, string+token_start-1, (size_t)total_length);
         buf[total_length] = '\0';
-#if defined(_MSC_VER) && _MSC_VER >= 1400
+#if !defined(NO_LOCALE) && (defined(_MSC_VER) && _MSC_VER >= 1400)
         x = _strtod_l(buf, &endptr, loc);
         _free_locale(loc);
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3)
+#elif !defined(NO_LOCALE) && (defined(__GLIBC__) && defined(__GLIBC_MINOR__) && ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= (2 << 16) + 3))
         x = strtod_l(buf, &endptr, loc);
         freelocale(loc);
 #else
@@ -484,8 +449,8 @@
     return;
 }
 
-MODELICA_EXPORT void ModelicaStrings_scanString(const char* string, int startIndex,
-                                int* nextIndex, const char** result) {
+void ModelicaStrings_scanString(_In_z_ const char* string, int startIndex,
+                                _Out_ int* nextIndex, _Out_ const char** result) {
     int i, token_start, past_token, token_length;
 
     token_length = 0;
@@ -514,8 +479,8 @@
     token_length = past_token-token_start-2;
 
     if (token_length > 0) {
-        char* s = ModelicaAllocateString(token_length);
-        strncpy(s, string+token_start, token_length);
+        char* s = ModelicaAllocateString((size_t)token_length);
+        strncpy(s, string+token_start, (size_t)token_length);
         s[token_length] = '\0';
         *result = s;
         *nextIndex = past_token;
@@ -528,35 +493,50 @@
     return;
 }
 
-MODELICA_EXPORT int ModelicaStrings_hashString(const char* inStr) {
-    /* Compute an unsigned int hash code from a character string
-     *
-     * Author: Arash Partow - 2002                                            *
-     * URL: http://www.partow.net                                             *
-     * URL: http://www.partow.net/programming/hashfunctions/index.html        *
-     *                                                                        *
-     * Copyright notice:                                                      *
-     * Free use of the General Purpose Hash Function Algorithms Library is    *
-     * permitted under the guidelines and in accordance with the most current *
-     * version of the Common Public License.                                  *
-     * http://www.opensource.org/licenses/cpl1.0.php                          *
-     */
-    unsigned int hash = 0xAAAAAAAA;
-    unsigned int i    = 0;
-    unsigned int len  = (unsigned int)strlen(inStr);
-    const unsigned char *str = (const unsigned char*)(inStr);
-    /* Use unsigned char to be independent of compiler settings */
+/* AP hash function macro variant of the one listed at
+   http://www.partow.net/programming/hashfunctions/index.html#APHashFunction
 
+   Copyright (C) 2002, Arash Partow
+
+   Permission is hereby granted, free of charge, to any person obtaining a copy
+   of this software and associated documentation files (the "Software"), to deal
+   in the Software without restriction, including without limitation the rights
+   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+   copies of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be included in all
+   copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+   SOFTWARE.
+*/
+#define HASH_AP(key, keylen, hash) \
+do { \
+    unsigned _hb_keylen = (unsigned)keylen; \
+    const unsigned char *_hb_key = (const unsigned char*)(key); \
+    unsigned int i; \
+    hash = 0xAAAAAAAA; \
+    for (i = 0; i < _hb_keylen; _hb_key++, i++) { \
+        hash ^= ((i & 1) == 0) ? (  (hash <<  7) ^ (*_hb_key) * (hash >> 3)) : \
+                                 (~((hash << 11) + ((*_hb_key) ^ (hash >> 5)))); \
+    } \
+} while (0)
+
+int ModelicaStrings_hashString(_In_z_ const char* str) {
+    /* Compute an unsigned int hash code from a character string */
+    size_t len = strlen(str);
     union hash_tag {
         unsigned int iu;
         int          is;
     } h;
 
-    for(i = 0; i < len; str++, i++) {
-        hash ^= ((i & 1) == 0) ? (  (hash <<  7) ^  (*str) * (hash >> 3)) :
-                                 (~((hash << 11) + ((*str) ^ (hash >> 5))));
-    }
+    HASH_VALUE(str, len, h.iu);
 
-    h.iu = hash;
     return h.is;
 }
Index: Modelica/Resources/C-Sources/ModelicaStrings.h
===================================================================
--- Modelica/Resources/C-Sources/ModelicaStrings.h	(nonexistent)
+++ Modelica/Resources/C-Sources/ModelicaStrings.h	(working copy)
@@ -0,0 +1,95 @@
+/* ModelicaStrings.h - External functions header for Modelica.Functions.Strings
+
+   Copyright (C) 2002-2017, Modelica Association and DLR
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   1. Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/* The functions are mostly non-portable. The following #define's are used
+   to define the system calls of the operating system
+
+   NO_LOCALE      : locale.h is not present (e.g. on AVR).
+   MODELICA_EXPORT: Prefix used for function calls. If not defined, blank is used
+                    Useful definition:
+                    - "__declspec(dllexport)" if included in a DLL and the
+                      functions shall be visible outside of the DLL
+*/
+
+#ifndef MODELICA_STRINGS_H_
+#define MODELICA_STRINGS_H_
+
+#include <stdlib.h>
+
+#if !defined(MODELICA_EXPORT)
+#if defined(__cplusplus)
+#define MODELICA_EXPORT extern "C"
+#else
+#define MODELICA_EXPORT
+#endif
+#endif
+
+/*
+ * Non-null pointers and esp. null-terminated strings need to be passed to
+ * external functions.
+ *
+ * The following macros handle nonnull attributes for GNU C and Microsoft SAL.
+ */
+#if defined(__GNUC__)
+#define MODELICA_NONNULLATTR __attribute__((nonnull))
+#if defined(__GNUC_MINOR__) && (__GNUC__ > 3 && __GNUC_MINOR__ > 8)
+#define MODELICA_RETURNNONNULLATTR __attribute__((returns_nonnull))
+#else
+#define MODELICA_RETURNNONNULLATTR
+#endif
+#elif defined(__ATTR_SAL)
+#define MODELICA_NONNULLATTR
+#define MODELICA_RETURNNONNULLATTR _Ret_z_ /* _Ret_notnull_ and null-terminated */
+#else
+#define MODELICA_NONNULLATTR
+#define MODELICA_RETURNNONNULLATTR
+#endif
+#if !defined(__ATTR_SAL)
+#define _In_z_
+#define _Out_
+#define _Ret_z_
+#endif
+
+MODELICA_EXPORT MODELICA_RETURNNONNULLATTR const char* ModelicaStrings_substring(
+    _In_z_ const char* string, int startIndex, int endIndex) MODELICA_NONNULLATTR;
+MODELICA_EXPORT int ModelicaStrings_length(_In_z_ const char* string) MODELICA_NONNULLATTR;
+MODELICA_EXPORT int ModelicaStrings_compare(_In_z_ const char* string1,
+    _In_z_ const char* string2, int caseSensitive) MODELICA_NONNULLATTR;
+MODELICA_EXPORT int ModelicaStrings_skipWhiteSpace(_In_z_ const char* string,
+    int i) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaStrings_scanIdentifier(_In_z_ const char* string,
+    int startIndex, _Out_ int* nextIndex, _Out_ const char** identifier) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaStrings_scanInteger(_In_z_ const char* string,
+    int startIndex, int unsignedNumber, _Out_ int* nextIndex,
+    _Out_ int* integerNumber) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaStrings_scanReal(_In_z_ const char* string, int startIndex,
+    int unsignedNumber, _Out_ int* nextIndex, _Out_ double* number) MODELICA_NONNULLATTR;
+MODELICA_EXPORT void ModelicaStrings_scanString(_In_z_ const char* string, int startIndex,
+    _Out_ int* nextIndex, _Out_ const char** result) MODELICA_NONNULLATTR;
+MODELICA_EXPORT int ModelicaStrings_hashString(_In_z_ const char* str) MODELICA_NONNULLATTR;
+
+#endif
Index: Modelica/Resources/C-Sources/ModelicaUtilities.h
===================================================================
--- Modelica/Resources/C-Sources/ModelicaUtilities.h	(revision 10440)
+++ Modelica/Resources/C-Sources/ModelicaUtilities.h	(working copy)
@@ -37,11 +37,12 @@
    this header file is shipped with the Modelica Standard Library.
 */
 
-#ifndef MODELICA_UTILITIES_H
-#define MODELICA_UTILITIES_H
+#ifndef MODELICA_UTILITIES_H_
+#define MODELICA_UTILITIES_H_
 
 #include <stddef.h>
 #include <stdarg.h>
+
 #if defined(__cplusplus)
 extern "C" {
 #endif
@@ -59,7 +60,7 @@
 #if __STDC_VERSION__ >= 201112L
 #define MODELICA_NORETURN _Noreturn
 #define MODELICA_NORETURNATTR
-#elif __cplusplus >= 201103L
+#elif defined(__cplusplus) && __cplusplus >= 201103L
 #if (defined(__GNUC__) && __GNUC__ >= 5) || \
     (defined(__GNUC__) && defined(__GNUC_MINOR__) && __GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 #define MODELICA_NORETURN [[noreturn]]
Index: Modelica/Resources/C-Sources/uthash.h
===================================================================
--- Modelica/Resources/C-Sources/uthash.h	(revision 10440)
+++ Modelica/Resources/C-Sources/uthash.h	(working copy)
@@ -1,5 +1,5 @@
 /*
-Copyright (c) 2003-2014, Troy D. Hanson     http://troydhanson.github.com/uthash/
+Copyright (c) 2003-2017, Troy D. Hanson     http://troydhanson.github.com/uthash/
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
@@ -24,6 +24,8 @@
 #ifndef UTHASH_H
 #define UTHASH_H
 
+#define UTHASH_VERSION 2.0.2
+
 #include <string.h>   /* memcmp,strlen */
 #include <stddef.h>   /* ptrdiff_t */
 #include <stdlib.h>   /* exit() */
@@ -51,12 +53,12 @@
 do {                                                                             \
   char **_da_dst = (char**)(&(dst));                                             \
   *_da_dst = (char*)(src);                                                       \
-} while(0)
+} while (0)
 #else
 #define DECLTYPE_ASSIGN(dst,src)                                                 \
 do {                                                                             \
   (dst) = DECLTYPE(dst)(src);                                                    \
-} while(0)
+} while (0)
 #endif
 
 /* a number of the hash function use uint32_t which isn't defined on Pre VS2010 */
@@ -76,8 +78,6 @@
 typedef unsigned char uint8_t;
 #endif
 
-#define UTHASH_VERSION 1.9.9
-
 #ifndef uthash_fatal
 #define uthash_fatal(msg) exit(-1)        /* fatal error (out of memory,etc) */
 #endif
@@ -87,6 +87,12 @@
 #ifndef uthash_free
 #define uthash_free(ptr,sz) free(ptr)     /* free fcn                        */
 #endif
+#ifndef uthash_strlen
+#define uthash_strlen(s) strlen(s)
+#endif
+#ifndef uthash_memcmp
+#define uthash_memcmp(a,b,n) memcmp(a,b,n)
+#endif
 
 #ifndef uthash_noexpand_fyi
 #define uthash_noexpand_fyi(tbl)          /* can be defined to log noexpand  */
@@ -100,22 +106,35 @@
 #define HASH_INITIAL_NUM_BUCKETS_LOG2 5U /* lg2 of initial number of buckets */
 #define HASH_BKT_CAPACITY_THRESH 10U     /* expand when bucket count reaches */
 
-/* calculate the element whose hash handle address is hhe */
+/* calculate the element whose hash handle address is hhp */
 #define ELMT_FROM_HH(tbl,hhp) ((void*)(((char*)(hhp)) - ((tbl)->hho)))
+/* calculate the hash handle from element address elp */
+#define HH_FROM_ELMT(tbl,elp) ((UT_hash_handle *)(((char*)(elp)) + ((tbl)->hho)))
 
-#define HASH_FIND(hh,head,keyptr,keylen,out)                                     \
+#define HASH_VALUE(keyptr,keylen,hashv)                                          \
 do {                                                                             \
-  out=NULL;                                                                      \
-  if (head != NULL) {                                                            \
-     unsigned _hf_bkt,_hf_hashv;                                                 \
-     HASH_FCN(keyptr,keylen, (head)->hh.tbl->num_buckets, _hf_hashv, _hf_bkt);   \
-     if (HASH_BLOOM_TEST((head)->hh.tbl, _hf_hashv) != 0) {                      \
-       HASH_FIND_IN_BKT((head)->hh.tbl, hh, (head)->hh.tbl->buckets[ _hf_bkt ],  \
-                        keyptr,keylen,out);                                      \
-     }                                                                           \
+  HASH_FCN(keyptr, keylen, hashv);                                               \
+} while (0)
+
+#define HASH_FIND_BYHASHVALUE(hh,head,keyptr,keylen,hashval,out)                 \
+do {                                                                             \
+  (out) = NULL;                                                                  \
+  if (head) {                                                                    \
+    unsigned _hf_bkt;                                                            \
+    HASH_TO_BKT(hashval, (head)->hh.tbl->num_buckets, _hf_bkt);                  \
+    if (HASH_BLOOM_TEST((head)->hh.tbl, hashval) != 0) {                         \
+      HASH_FIND_IN_BKT((head)->hh.tbl, hh, (head)->hh.tbl->buckets[ _hf_bkt ], keyptr, keylen, hashval, out); \
+    }                                                                            \
   }                                                                              \
 } while (0)
 
+#define HASH_FIND(hh,head,keyptr,keylen,out)                                     \
+do {                                                                             \
+  unsigned _hf_hashv;                                                            \
+  HASH_VALUE(keyptr, keylen, _hf_hashv);                                         \
+  HASH_FIND_BYHASHVALUE(hh, head, keyptr, keylen, _hf_hashv, out);               \
+} while (0)
+
 #ifdef HASH_BLOOM
 #define HASH_BLOOM_BITLEN (1UL << HASH_BLOOM)
 #define HASH_BLOOM_BYTELEN (HASH_BLOOM_BITLEN/8UL) + (((HASH_BLOOM_BITLEN%8UL)!=0UL) ? 1UL : 0UL)
@@ -167,50 +186,141 @@
           HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket));               \
   HASH_BLOOM_MAKE((head)->hh.tbl);                                               \
   (head)->hh.tbl->signature = HASH_SIGNATURE;                                    \
-} while(0)
+} while (0)
 
-#define HASH_ADD(hh,head,fieldname,keylen_in,add)                                \
-        HASH_ADD_KEYPTR(hh,head,&((add)->fieldname),keylen_in,add)
+#define HASH_REPLACE_BYHASHVALUE_INORDER(hh,head,fieldname,keylen_in,hashval,add,replaced,cmpfcn) \
+do {                                                                             \
+  (replaced) = NULL;                                                             \
+  HASH_FIND_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, replaced); \
+  if (replaced) {                                                                \
+     HASH_DELETE(hh, head, replaced);                                            \
+  }                                                                              \
+  HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, &((add)->fieldname), keylen_in, hashval, add, cmpfcn); \
+} while (0)
 
+#define HASH_REPLACE_BYHASHVALUE(hh,head,fieldname,keylen_in,hashval,add,replaced) \
+do {                                                                             \
+  (replaced) = NULL;                                                             \
+  HASH_FIND_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, replaced); \
+  if (replaced) {                                                                \
+     HASH_DELETE(hh, head, replaced);                                            \
+  }                                                                              \
+  HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, add); \
+} while (0)
+
 #define HASH_REPLACE(hh,head,fieldname,keylen_in,add,replaced)                   \
 do {                                                                             \
-  replaced=NULL;                                                                 \
-  HASH_FIND(hh,head,&((add)->fieldname),keylen_in,replaced);                     \
-  if (replaced!=NULL) {                                                          \
-     HASH_DELETE(hh,head,replaced);                                              \
+  unsigned _hr_hashv;                                                            \
+  HASH_VALUE(&((add)->fieldname), keylen_in, _hr_hashv);                         \
+  HASH_REPLACE_BYHASHVALUE(hh, head, fieldname, keylen_in, _hr_hashv, add, replaced); \
+} while (0)
+
+#define HASH_REPLACE_INORDER(hh,head,fieldname,keylen_in,add,replaced,cmpfcn)    \
+do {                                                                             \
+  unsigned _hr_hashv;                                                            \
+  HASH_VALUE(&((add)->fieldname), keylen_in, _hr_hashv);                         \
+  HASH_REPLACE_BYHASHVALUE_INORDER(hh, head, fieldname, keylen_in, _hr_hashv, add, replaced, cmpfcn); \
+} while (0)
+
+#define HASH_APPEND_LIST(hh, head, add)                                          \
+do {                                                                             \
+  (add)->hh.next = NULL;                                                         \
+  (add)->hh.prev = ELMT_FROM_HH((head)->hh.tbl, (head)->hh.tbl->tail);           \
+  (head)->hh.tbl->tail->next = (add);                                            \
+  (head)->hh.tbl->tail = &((add)->hh);                                           \
+} while (0)
+
+#define HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh,head,keyptr,keylen_in,hashval,add,cmpfcn) \
+do {                                                                             \
+  unsigned _ha_bkt;                                                              \
+  (add)->hh.hashv = (hashval);                                                   \
+  (add)->hh.key = (char*) (keyptr);                                              \
+  (add)->hh.keylen = (unsigned) (keylen_in);                                     \
+  if (!(head)) {                                                                 \
+    (add)->hh.next = NULL;                                                       \
+    (add)->hh.prev = NULL;                                                       \
+    (head) = (add);                                                              \
+    HASH_MAKE_TABLE(hh, head);                                                   \
+  } else {                                                                       \
+    void *_hs_iter = (head);                                                     \
+    (add)->hh.tbl = (head)->hh.tbl;                                              \
+    do {                                                                         \
+      if (cmpfcn(DECLTYPE(head)(_hs_iter), add) > 0)                             \
+        break;                                                                   \
+    } while ((_hs_iter = HH_FROM_ELMT((head)->hh.tbl, _hs_iter)->next));         \
+    if (_hs_iter) {                                                              \
+      (add)->hh.next = _hs_iter;                                                 \
+      if (((add)->hh.prev = HH_FROM_ELMT((head)->hh.tbl, _hs_iter)->prev)) {     \
+        HH_FROM_ELMT((head)->hh.tbl, (add)->hh.prev)->next = (add);              \
+      } else {                                                                   \
+        (head) = (add);                                                          \
+      }                                                                          \
+      HH_FROM_ELMT((head)->hh.tbl, _hs_iter)->prev = (add);                      \
+    } else {                                                                     \
+      HASH_APPEND_LIST(hh, head, add);                                           \
+    }                                                                            \
   }                                                                              \
-  HASH_ADD(hh,head,fieldname,keylen_in,add);                                     \
-} while(0)
+  (head)->hh.tbl->num_items++;                                                   \
+  HASH_TO_BKT(hashval, (head)->hh.tbl->num_buckets, _ha_bkt);                    \
+  HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt], &(add)->hh);                 \
+  HASH_BLOOM_ADD((head)->hh.tbl, hashval);                                       \
+  HASH_EMIT_KEY(hh, head, keyptr, keylen_in);                                    \
+  HASH_FSCK(hh, head);                                                           \
+} while (0)
 
+#define HASH_ADD_KEYPTR_INORDER(hh,head,keyptr,keylen_in,add,cmpfcn)             \
+do {                                                                             \
+  unsigned _hs_hashv;                                                            \
+  HASH_VALUE(keyptr, keylen_in, _hs_hashv);                                      \
+  HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, keyptr, keylen_in, _hs_hashv, add, cmpfcn); \
+} while (0)
+
+#define HASH_ADD_BYHASHVALUE_INORDER(hh,head,fieldname,keylen_in,hashval,add,cmpfcn) \
+  HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, &((add)->fieldname), keylen_in, hashval, add, cmpfcn)
+
+#define HASH_ADD_INORDER(hh,head,fieldname,keylen_in,add,cmpfcn)                 \
+  HASH_ADD_KEYPTR_INORDER(hh, head, &((add)->fieldname), keylen_in, add, cmpfcn)
+
+#define HASH_ADD_KEYPTR_BYHASHVALUE(hh,head,keyptr,keylen_in,hashval,add)        \
+do {                                                                             \
+  unsigned _ha_bkt;                                                              \
+  (add)->hh.hashv = (hashval);                                                   \
+  (add)->hh.key = (char*) (keyptr);                                              \
+  (add)->hh.keylen = (unsigned) (keylen_in);                                     \
+  if (!(head)) {                                                                 \
+    (add)->hh.next = NULL;                                                       \
+    (add)->hh.prev = NULL;                                                       \
+    (head) = (add);                                                              \
+    HASH_MAKE_TABLE(hh, head);                                                   \
+  } else {                                                                       \
+    (add)->hh.tbl = (head)->hh.tbl;                                              \
+    HASH_APPEND_LIST(hh, head, add);                                             \
+  }                                                                              \
+  (head)->hh.tbl->num_items++;                                                   \
+  HASH_TO_BKT(hashval, (head)->hh.tbl->num_buckets, _ha_bkt);                    \
+  HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt], &(add)->hh);                 \
+  HASH_BLOOM_ADD((head)->hh.tbl, hashval);                                       \
+  HASH_EMIT_KEY(hh, head, keyptr, keylen_in);                                    \
+  HASH_FSCK(hh, head);                                                           \
+} while (0)
+
 #define HASH_ADD_KEYPTR(hh,head,keyptr,keylen_in,add)                            \
 do {                                                                             \
- unsigned _ha_bkt;                                                               \
- (add)->hh.next = NULL;                                                          \
- (add)->hh.key = (char*)(keyptr);                                                \
- (add)->hh.keylen = (unsigned)(keylen_in);                                       \
- if (!(head)) {                                                                  \
-    head = (add);                                                                \
-    (head)->hh.prev = NULL;                                                      \
-    HASH_MAKE_TABLE(hh,head);                                                    \
- } else {                                                                        \
-    (head)->hh.tbl->tail->next = (add);                                          \
-    (add)->hh.prev = ELMT_FROM_HH((head)->hh.tbl, (head)->hh.tbl->tail);         \
-    (head)->hh.tbl->tail = &((add)->hh);                                         \
- }                                                                               \
- (head)->hh.tbl->num_items++;                                                    \
- (add)->hh.tbl = (head)->hh.tbl;                                                 \
- HASH_FCN(keyptr,keylen_in, (head)->hh.tbl->num_buckets,                         \
-         (add)->hh.hashv, _ha_bkt);                                              \
- HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt],&(add)->hh);                   \
- HASH_BLOOM_ADD((head)->hh.tbl,(add)->hh.hashv);                                 \
- HASH_EMIT_KEY(hh,head,keyptr,keylen_in);                                        \
- HASH_FSCK(hh,head);                                                             \
-} while(0)
+  unsigned _ha_hashv;                                                            \
+  HASH_VALUE(keyptr, keylen_in, _ha_hashv);                                      \
+  HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, keyptr, keylen_in, _ha_hashv, add);      \
+} while (0)
 
-#define HASH_TO_BKT( hashv, num_bkts, bkt )                                      \
+#define HASH_ADD_BYHASHVALUE(hh,head,fieldname,keylen_in,hashval,add)            \
+  HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, add)
+
+#define HASH_ADD(hh,head,fieldname,keylen_in,add)                                \
+  HASH_ADD_KEYPTR(hh, head, &((add)->fieldname), keylen_in, add)
+
+#define HASH_TO_BKT(hashv,num_bkts,bkt)                                          \
 do {                                                                             \
   bkt = ((hashv) & ((num_bkts) - 1U));                                           \
-} while(0)
+} while (0)
 
 /* delete "delptr" from the hash table.
  * "the usual" patch-up process for the app-order doubly-linked-list.
@@ -262,11 +372,11 @@
 
 /* convenience forms of HASH_FIND/HASH_ADD/HASH_DEL */
 #define HASH_FIND_STR(head,findstr,out)                                          \
-    HASH_FIND(hh,head,findstr,(unsigned)strlen(findstr),out)
+    HASH_FIND(hh,head,findstr,(unsigned)uthash_strlen(findstr),out)
 #define HASH_ADD_STR(head,strfield,add)                                          \
-    HASH_ADD(hh,head,strfield[0],(unsigned int)strlen(add->strfield),add)
+    HASH_ADD(hh,head,strfield[0],(unsigned)uthash_strlen(add->strfield),add)
 #define HASH_REPLACE_STR(head,strfield,add,replaced)                             \
-    HASH_REPLACE(hh,head,strfield[0],(unsigned)strlen(add->strfield),add,replaced)
+    HASH_REPLACE(hh,head,strfield[0],(unsigned)uthash_strlen(add->strfield),add,replaced)
 #define HASH_FIND_INT(head,findint,out)                                          \
     HASH_FIND(hh,head,findint,sizeof(int),out)
 #define HASH_ADD_INT(head,intfield,add)                                          \
@@ -364,7 +474,7 @@
 #endif
 
 /* The Bernstein hash function, used in Perl prior to v5.6. Note (x<<5+x)=x*33. */
-#define HASH_BER(key,keylen,num_bkts,hashv,bkt)                                  \
+#define HASH_BER(key,keylen,hashv)                                               \
 do {                                                                             \
   unsigned _hb_keylen=(unsigned)keylen;                                          \
   const unsigned char *_hb_key=(const unsigned char*)(key);                      \
@@ -372,13 +482,12 @@
   while (_hb_keylen-- != 0U) {                                                   \
       (hashv) = (((hashv) << 5) + (hashv)) + *_hb_key++;                         \
   }                                                                              \
-  bkt = (hashv) & (num_bkts-1U);                                                 \
 } while (0)
 
 
 /* SAX/FNV/OAT/JEN hash functions are macro variants of those listed at
  * http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx */
-#define HASH_SAX(key,keylen,num_bkts,hashv,bkt)                                  \
+#define HASH_SAX(key,keylen,hashv)                                               \
 do {                                                                             \
   unsigned _sx_i;                                                                \
   const unsigned char *_hs_key=(const unsigned char*)(key);                      \
@@ -386,10 +495,9 @@
   for(_sx_i=0; _sx_i < keylen; _sx_i++) {                                        \
       hashv ^= (hashv << 5) + (hashv >> 2) + _hs_key[_sx_i];                     \
   }                                                                              \
-  bkt = hashv & (num_bkts-1U);                                                   \
 } while (0)
 /* FNV-1a variation */
-#define HASH_FNV(key,keylen,num_bkts,hashv,bkt)                                  \
+#define HASH_FNV(key,keylen,hashv)                                               \
 do {                                                                             \
   unsigned _fn_i;                                                                \
   const unsigned char *_hf_key=(const unsigned char*)(key);                      \
@@ -398,10 +506,9 @@
       hashv = hashv ^ _hf_key[_fn_i];                                            \
       hashv = hashv * 16777619U;                                                 \
   }                                                                              \
-  bkt = hashv & (num_bkts-1U);                                                   \
-} while(0)
+} while (0)
 
-#define HASH_OAT(key,keylen,num_bkts,hashv,bkt)                                  \
+#define HASH_OAT(key,keylen,hashv)                                               \
 do {                                                                             \
   unsigned _ho_i;                                                                \
   const unsigned char *_ho_key=(const unsigned char*)(key);                      \
@@ -414,8 +521,7 @@
   hashv += (hashv << 3);                                                         \
   hashv ^= (hashv >> 11);                                                        \
   hashv += (hashv << 15);                                                        \
-  bkt = hashv & (num_bkts-1U);                                                   \
-} while(0)
+} while (0)
 
 #define HASH_JEN_MIX(a,b,c)                                                      \
 do {                                                                             \
@@ -430,7 +536,7 @@
   c -= a; c -= b; c ^= ( b >> 15 );                                              \
 } while (0)
 
-#define HASH_JEN(key,keylen,num_bkts,hashv,bkt)                                  \
+#define HASH_JEN(key,keylen,hashv)                                               \
 do {                                                                             \
   unsigned _hj_i,_hj_j,_hj_k;                                                    \
   unsigned const char *_hj_key=(unsigned const char*)(key);                      \
@@ -468,8 +574,7 @@
      case 1:  _hj_i += _hj_key[0];                                               \
   }                                                                              \
   HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                             \
-  bkt = hashv & (num_bkts-1U);                                                   \
-} while(0)
+} while (0)
 
 /* The Paul Hsieh hash function */
 #undef get16bits
@@ -482,7 +587,7 @@
 #define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)             \
                        +(uint32_t)(((const uint8_t *)(d))[0]) )
 #endif
-#define HASH_SFH(key,keylen,num_bkts,hashv,bkt)                                  \
+#define HASH_SFH(key,keylen,hashv)                                               \
 do {                                                                             \
   unsigned const char *_sfh_key=(unsigned const char*)(key);                     \
   uint32_t _sfh_tmp, _sfh_len = (uint32_t)keylen;                                \
@@ -523,8 +628,7 @@
     hashv += hashv >> 17;                                                        \
     hashv ^= hashv << 25;                                                        \
     hashv += hashv >> 6;                                                         \
-    bkt = hashv & (num_bkts-1U);                                                 \
-} while(0)
+} while (0)
 
 #ifdef HASH_USING_NO_STRICT_ALIASING
 /* The MurmurHash exploits some CPU's (x86,x86_64) tolerance for unaligned reads.
@@ -566,9 +670,9 @@
   _h ^= _h >> 13;    \
   _h *= 0xc2b2ae35u; \
   _h ^= _h >> 16;    \
-} while(0)
+} while (0)
 
-#define HASH_MUR(key,keylen,num_bkts,hashv,bkt)                        \
+#define HASH_MUR(key,keylen,hashv)                                     \
 do {                                                                   \
   const uint8_t *_mur_data = (const uint8_t*)(key);                    \
   const int _mur_nblocks = (int)(keylen) / 4;                          \
@@ -603,26 +707,30 @@
   _mur_h1 ^= (uint32_t)(keylen);                                       \
   MUR_FMIX(_mur_h1);                                                   \
   hashv = _mur_h1;                                                     \
-  bkt = hashv & (num_bkts-1U);                                         \
-} while(0)
+} while (0)
 #endif  /* HASH_USING_NO_STRICT_ALIASING */
 
-/* key comparison function; return 0 if keys equal */
-#define HASH_KEYCMP(a,b,len) memcmp(a,b,(unsigned long)(len))
-
 /* iterate over items in a known bucket to find desired item */
-#define HASH_FIND_IN_BKT(tbl,hh,head,keyptr,keylen_in,out)                       \
+#define HASH_FIND_IN_BKT(tbl,hh,head,keyptr,keylen_in,hashval,out)               \
 do {                                                                             \
- if (head.hh_head != NULL) { DECLTYPE_ASSIGN(out,ELMT_FROM_HH(tbl,head.hh_head)); } \
- else { out=NULL; }                                                              \
- while (out != NULL) {                                                           \
-    if ((out)->hh.keylen == (keylen_in)) {                                       \
-        if ((HASH_KEYCMP((out)->hh.key,keyptr,keylen_in)) == 0) { break; }         \
+  if ((head).hh_head != NULL) {                                                  \
+    DECLTYPE_ASSIGN(out, ELMT_FROM_HH(tbl, (head).hh_head));                     \
+  } else {                                                                       \
+    (out) = NULL;                                                                \
+  }                                                                              \
+  while ((out) != NULL) {                                                        \
+    if ((out)->hh.hashv == (hashval) && (out)->hh.keylen == (keylen_in)) {       \
+      if (uthash_memcmp((out)->hh.key, keyptr, keylen_in) == 0) {                \
+        break;                                                                   \
+      }                                                                          \
     }                                                                            \
-    if ((out)->hh.hh_next != NULL) { DECLTYPE_ASSIGN(out,ELMT_FROM_HH(tbl,(out)->hh.hh_next)); } \
-    else { out = NULL; }                                                         \
- }                                                                               \
-} while(0)
+    if ((out)->hh.hh_next != NULL) {                                             \
+      DECLTYPE_ASSIGN(out, ELMT_FROM_HH(tbl, (out)->hh.hh_next));                \
+    } else {                                                                     \
+      (out) = NULL;                                                              \
+    }                                                                            \
+  }                                                                              \
+} while (0)
 
 /* add an item to a bucket  */
 #define HASH_ADD_TO_BKT(head,addhh)                                              \
@@ -636,7 +744,7 @@
      && ((addhh)->tbl->noexpand != 1U)) {                                        \
        HASH_EXPAND_BUCKETS((addhh)->tbl);                                        \
  }                                                                               \
-} while(0)
+} while (0)
 
 /* remove an item from a given bucket */
 #define HASH_DEL_IN_BKT(hh,head,hh_del)                                          \
@@ -726,7 +834,7 @@
         uthash_noexpand_fyi(tbl);                                                \
     }                                                                            \
     uthash_expand_fyi(tbl);                                                      \
-} while(0)
+} while (0)
 
 
 /* This is an adaptation of Simon Tatham's O(n log(n)) mergesort */
@@ -872,7 +980,7 @@
     uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                          \
     (head)=NULL;                                                                 \
   }                                                                              \
-} while(0)
+} while (0)
 
 #define HASH_OVERHEAD(hh,head)                                                   \
  ((head != NULL) ? (                                                             \
Index: Modelica/Resources/C-Sources/win32_dirent.c
===================================================================
--- Modelica/Resources/C-Sources/win32_dirent.c	(revision 10440)
+++ Modelica/Resources/C-Sources/win32_dirent.c	(working copy)
@@ -42,98 +42,98 @@
 DIR *
 opendir (const char *szPath)
 {
-  DIR *nd;
+    DIR *nd;
 
-  errno = 0;
+    errno = 0;
 
-  if (!szPath)
+    if (!szPath)
     {
-      errno = EFAULT;
-      return (DIR *) 0;
+        errno = EFAULT;
+        return (DIR *) 0;
     }
 
-  if (szPath[0] == '\0')
+    if (szPath[0] == '\0')
     {
-      errno = ENOTDIR;
-      return (DIR *) 0;
+        errno = ENOTDIR;
+        return (DIR *) 0;
     }
 
-  /* Attempt to determine if the given path really is a directory. */
-  {
+    /* Attempt to determine if the given path really is a directory. */
+    {
 #if defined(_MSC_VER)
-      struct _stat fileInfo;
-    if ( _stat(szPath, &fileInfo) != 0 ) {
+        struct _stat fileInfo;
+        if ( _stat(szPath, &fileInfo) != 0 ) {
 #else
-      struct stat fileInfo;
-    if ( stat(szPath, &fileInfo) != 0 ) {
+        struct stat fileInfo;
+        if ( stat(szPath, &fileInfo) != 0 ) {
 #endif
-      /* call GetLastError for more error info */
-      errno = ENOENT;
-      return (DIR *) 0;
-    }
+            /* call GetLastError for more error info */
+            errno = ENOENT;
+            return (DIR *) 0;
+        }
 
-    if ( !(fileInfo.st_mode & S_IFDIR) ) {
-      /* Error, entry exists but not a directory. */
-      errno = ENOTDIR;
-      return (DIR *) 0;
+        if ( !(fileInfo.st_mode & S_IFDIR) ) {
+            /* Error, entry exists but not a directory. */
+            errno = ENOTDIR;
+            return (DIR *) 0;
+        }
     }
-  }
 
-  /* Allocate enough space to store DIR structure and the complete
-   * directory path given. */
-  nd = (DIR *) malloc (sizeof (DIR) + strlen (szPath) + strlen (SLASH) +
-             strlen (SUFFIX));
+    /* Allocate enough space to store DIR structure and the complete
+     * directory path given. */
+    nd = (DIR *) malloc (sizeof (DIR) + strlen (szPath) + strlen (SLASH) +
+                         strlen (SUFFIX));
 
-  if (!nd)
+    if (!nd)
     {
-      /* Error, out of memory. */
-      errno = ENOMEM;
-      return (DIR *) 0;
+        /* Error, out of memory. */
+        errno = ENOMEM;
+        return (DIR *) 0;
     }
 
-  /* Create the search expression. */
-  strcpy (nd->dd_name, szPath);
+    /* Create the search expression. */
+    strcpy (nd->dd_name, szPath);
 
-  /* Add on a slash if the path does not end with one. */
-  if (nd->dd_name[0] != '\0' &&
-      nd->dd_name[strlen (nd->dd_name) - 1] != '/' &&
-      nd->dd_name[strlen (nd->dd_name) - 1] != '\\')
+    /* Add on a slash if the path does not end with one. */
+    if (nd->dd_name[0] != '\0' &&
+            nd->dd_name[strlen (nd->dd_name) - 1] != '/' &&
+            nd->dd_name[strlen (nd->dd_name) - 1] != '\\')
     {
-      strcat (nd->dd_name, SLASH);
+        strcat (nd->dd_name, SLASH);
     }
 
-  /* Add on the search pattern */
-  strcat (nd->dd_name, SUFFIX);
+    /* Add on the search pattern */
+    strcat (nd->dd_name, SUFFIX);
 
-  /* Initialize handle to -1 so that a premature closedir doesn't try
-   * to call _findclose on it. */
-  nd->dd_handle = -1;
+    /* Initialize handle to -1 so that a premature closedir doesn't try
+     * to call _findclose on it. */
+    nd->dd_handle = -1;
 
-  /* Initialize the status. */
-  nd->dd_stat = 0;
+    /* Initialize the status. */
+    nd->dd_stat = 0;
 
-  /* Initialize the dirent structure. ino and reclen are invalid under
-   * Win32, and name simply points at the appropriate part of the
-   * findfirst_t structure. */
-  nd->dd_dir.d_ino = 0;
-  nd->dd_dir.d_reclen = 0;
-  nd->dd_dir.d_namlen = 0;
-  nd->dd_dir.d_name = nd->dd_dta.name;
+    /* Initialize the dirent structure. ino and reclen are invalid under
+     * Win32, and name simply points at the appropriate part of the
+     * findfirst_t structure. */
+    nd->dd_dir.d_ino = 0;
+    nd->dd_dir.d_reclen = 0;
+    nd->dd_dir.d_namlen = 0;
+    nd->dd_dir.d_name = nd->dd_dta.name;
 
 
-  /* Start the search, in order that the user may still
-     change the current directory afterwards
-  */
-  nd->dd_handle = (long)_findfirst (nd->dd_name, &(nd->dd_dta));
-  if (nd->dd_handle == -1) {
-     /* Whoops! Seems there are no files in that
-      * directory. */
-     nd->dd_stat = -1;
-  } else {
-     nd->dd_stat = 1;
-  }
+    /* Start the search, in order that the user may still
+       change the current directory afterwards
+    */
+    nd->dd_handle = (long)_findfirst (nd->dd_name, &(nd->dd_dta));
+    if (nd->dd_handle == -1) {
+        /* Whoops! Seems there are no files in that
+         * directory. */
+        nd->dd_stat = -1;
+    } else {
+        nd->dd_stat = 1;
+    }
 
-  return nd;
+    return nd;
 }
 
 
@@ -146,57 +146,57 @@
 struct dirent *
 readdir (DIR * dirp)
 {
-  errno = 0;
+    errno = 0;
 
-  /* Check for valid DIR struct. */
-  if (!dirp)
+    /* Check for valid DIR struct. */
+    if (!dirp)
     {
-      errno = EFAULT;
-      return (struct dirent *) 0;
+        errno = EFAULT;
+        return (struct dirent *) 0;
     }
 
-  if (dirp->dd_dir.d_name != dirp->dd_dta.name)
+    if (dirp->dd_dir.d_name != dirp->dd_dta.name)
     {
-      /* The structure does not seem to be set up correctly. */
-      errno = EINVAL;
-      return (struct dirent *) 0;
+        /* The structure does not seem to be set up correctly. */
+        errno = EINVAL;
+        return (struct dirent *) 0;
     }
 
-  if (dirp->dd_stat < 0)
+    if (dirp->dd_stat < 0)
     {
-      /* We have already returned all files in the directory
-       * (or the structure has an invalid dd_stat). */
-      return (struct dirent *) 0;
+        /* We have already returned all files in the directory
+         * (or the structure has an invalid dd_stat). */
+        return (struct dirent *) 0;
     }
-  else
+    else
     {
-      /* Get the next search entry. */
-      if (_findnext (dirp->dd_handle, &(dirp->dd_dta)))
-   {
-     /* We are off the end */
-     errno = 0;
-     _findclose (dirp->dd_handle);
-     dirp->dd_handle = -1;
-     dirp->dd_stat = -1;
-   }
-      else
-   {
-     /* Update the status to indicate the correct
-      * number. */
-     dirp->dd_stat++;
-   }
+        /* Get the next search entry. */
+        if (_findnext (dirp->dd_handle, &(dirp->dd_dta)))
+        {
+            /* We are off the end */
+            errno = 0;
+            _findclose (dirp->dd_handle);
+            dirp->dd_handle = -1;
+            dirp->dd_stat = -1;
+        }
+        else
+        {
+            /* Update the status to indicate the correct
+             * number. */
+            dirp->dd_stat++;
+        }
     }
 
-  if (dirp->dd_stat > 0)
+    if (dirp->dd_stat > 0)
     {
-      /* Successfully got an entry. Everything about the file is
-       * already appropriately filled in except the length of the
-       * file name. */
-      dirp->dd_dir.d_namlen = (unsigned short)strlen (dirp->dd_dir.d_name);
-      return &dirp->dd_dir;
+        /* Successfully got an entry. Everything about the file is
+         * already appropriately filled in except the length of the
+         * file name. */
+        dirp->dd_dir.d_namlen = (unsigned short)strlen (dirp->dd_dir.d_name);
+        return &dirp->dd_dir;
     }
 
-  return (struct dirent *) 0;
+    return (struct dirent *) 0;
 }
 
 
@@ -208,26 +208,26 @@
 int
 closedir (DIR * dirp)
 {
-  int rc;
+    int rc;
 
-  errno = 0;
-  rc = 0;
+    errno = 0;
+    rc = 0;
 
-  if (!dirp)
+    if (!dirp)
     {
-      errno = EFAULT;
-      return -1;
+        errno = EFAULT;
+        return -1;
     }
 
-  if (dirp->dd_handle != -1)
+    if (dirp->dd_handle != -1)
     {
-      rc = _findclose (dirp->dd_handle);
+        rc = _findclose (dirp->dd_handle);
     }
 
-  /* Delete the dir structure. */
-  free (dirp);
+    /* Delete the dir structure. */
+    free (dirp);
 
-  return rc;
+    return rc;
 }
 
 /*
@@ -239,21 +239,21 @@
 void
 rewinddir (DIR * dirp)
 {
-  errno = 0;
+    errno = 0;
 
-  if (!dirp)
+    if (!dirp)
     {
-      errno = EFAULT;
-      return;
+        errno = EFAULT;
+        return;
     }
 
-  if (dirp->dd_handle != -1)
+    if (dirp->dd_handle != -1)
     {
-      _findclose (dirp->dd_handle);
+        _findclose (dirp->dd_handle);
     }
 
-  dirp->dd_handle = -1;
-  dirp->dd_stat = 0;
+    dirp->dd_handle = -1;
+    dirp->dd_stat = 0;
 }
 
 /*
@@ -265,14 +265,14 @@
 long
 telldir (DIR * dirp)
 {
-  errno = 0;
+    errno = 0;
 
-  if (!dirp)
+    if (!dirp)
     {
-      errno = EFAULT;
-      return -1;
+        errno = EFAULT;
+        return -1;
     }
-  return dirp->dd_stat;
+    return dirp->dd_stat;
 }
 
 /*
@@ -287,36 +287,36 @@
 void
 seekdir (DIR * dirp, long lPos)
 {
-  errno = 0;
+    errno = 0;
 
-  if (!dirp)
+    if (!dirp)
     {
-      errno = EFAULT;
-      return;
+        errno = EFAULT;
+        return;
     }
 
-  if (lPos < -1)
+    if (lPos < -1)
     {
-      /* Seeking to an invalid position. */
-      errno = EINVAL;
-      return;
+        /* Seeking to an invalid position. */
+        errno = EINVAL;
+        return;
     }
-  else if (lPos == -1)
+    else if (lPos == -1)
     {
-      /* Seek past end. */
-      if (dirp->dd_handle != -1)
-   {
-     _findclose (dirp->dd_handle);
-   }
-      dirp->dd_handle = -1;
-      dirp->dd_stat = -1;
+        /* Seek past end. */
+        if (dirp->dd_handle != -1)
+        {
+            _findclose (dirp->dd_handle);
+        }
+        dirp->dd_handle = -1;
+        dirp->dd_stat = -1;
     }
-  else
+    else
     {
-      /* Rewind and read forward to the appropriate index. */
-      rewinddir (dirp);
+        /* Rewind and read forward to the appropriate index. */
+        rewinddir (dirp);
 
-      while ((dirp->dd_stat < lPos) && readdir (dirp))
-   ;
+        while ((dirp->dd_stat < lPos) && readdir (dirp))
+            ;
     }
 }
Index: Modelica/Resources/C-Sources/win32_dirent.h
===================================================================
--- Modelica/Resources/C-Sources/win32_dirent.h	(revision 10440)
+++ Modelica/Resources/C-Sources/win32_dirent.h	(working copy)
@@ -21,8 +21,8 @@
  *    since not needed in Modelica
  */
 
-#ifndef _DIRENT_H_
-#define _DIRENT_H_
+#ifndef _WIN32_DIRENT_H_
+#define _WIN32_DIRENT_H_
 
 #include <io.h>
 
@@ -32,12 +32,12 @@
 
 struct dirent
 {
- long  d_ino;          /* Always zero. */
- unsigned short d_reclen;   /* Always zero. */
- unsigned short d_namlen;   /* Length of name in d_name. */
- char*  d_name;          /* File name. */
- /* NOTE: The name in the dirent structure points to the name in the
-  *       finddata_t structure in the DIR. */
+    long d_ino;              /* Always zero. */
+    unsigned short d_reclen; /* Always zero. */
+    unsigned short d_namlen; /* Length of name in d_name. */
+    char* d_name;            /* File name. */
+    /* NOTE: The name in the dirent structure points to the name in the
+     *       finddata_t structure in the DIR. */
 };
 
 /*
@@ -46,39 +46,39 @@
  */
 typedef struct
 {
- /* disk transfer area for this dir */
- struct _finddata_t dd_dta;
+    /* disk transfer area for this dir */
+    struct _finddata_t dd_dta;
 
- /* dirent struct to return from dir (NOTE: this makes this thread
-  * safe as long as only one thread uses a particular DIR struct at
-  * a time) */
- struct dirent  dd_dir;
+    /* dirent struct to return from dir (NOTE: this makes this thread
+     * safe as long as only one thread uses a particular DIR struct at
+     * a time) */
+    struct dirent dd_dir;
 
- /* _findnext handle */
- long   dd_handle;
+    /* _findnext handle */
+    long dd_handle;
 
- /*
-         * Status of search:
-  *   0 = not started yet (next entry to read is first entry)
-  *  -1 = off the end
-  *   positive = 0 based index of next entry
-  */
- short   dd_stat;
+    /*
+     * Status of search:
+     *   0 = not started yet (next entry to read is first entry)
+     *  -1 = off the end
+     *   positive = 0 based index of next entry
+     */
+    short dd_stat;
 
- /* given path for dir with search pattern (struct is extended) */
- char   dd_name[1];
+    /* given path for dir with search pattern (struct is extended) */
+    char dd_name[1];
 } DIR;
 
 
-DIR*  opendir (const char*);
+DIR* opendir (const char*);
 struct dirent* readdir (DIR*);
-int  closedir (DIR*);
-void  rewinddir (DIR*);
-long  telldir (DIR*);
-void  seekdir (DIR*, long);
+int closedir (DIR*);
+void rewinddir (DIR*);
+long telldir (DIR*);
+void seekdir (DIR*, long);
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif /* Not _DIRENT_H_ */
+#endif /* Not _WIN32_DIRENT_H_ */
