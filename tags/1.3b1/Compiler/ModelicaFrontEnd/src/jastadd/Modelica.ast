/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/**
 * \mainpage API documentation of the JModelica.org Modelica Front-end
 *
 * The API documentation of the Modelica %compiler front-end is yet rudimentary. 
 * Also, the APIs for the Java classes contains several methods that are 
 * part of the internal JastAdd run-time system - these methods are not intended
 * to be used by the user.
 * 
 * We are currently working togehter with the JastAdd team to develop a 
 * documentation system where internal methods are hidden and where the user
 * API is exposed.
 *
 * The Modelica %compiler is organized into a number of different packages:
 * <ul>
 *   <li> org.jmodelica.modelica.parser containing parsers for Modelica
 *   and Flat Modelica code.</li>
 *   <li> org.jmodelica.modelica.compiler contains the actual %compiler, including
 *   the classes used to construct the Abstract Syntax Trees (ASTs) and the
 *   %compiler driver class ModelicaCompiler.</li>
 *   <li> org.jmodelica.util contains some helper classes which are independent
 *   of the AST classes.</li>
 * </ul>
 * 
 * Notice that the Java classes are not intended to be edited manually (with
 * the exception of the classes in org.jmodelica.util), but are rather 
 * automatically generated by the JastAdd tool. In order to extend or 
 * modify the functionality of the %compiler, edit the .%ast, .jrag and .jadd
 * files.
 *
 */


// Modelica abstract grammar



/**
 * \defgroup aspect_Flattening Aspect: Flattening
 */


/**
 * \package org.jmodelica.ast Package containing all AST classes.
 */

abstract BaseNode;

abstract Root : BaseNode;

ParserHandler : BaseNode;

/**
 * A class representing the root node of a source AST.
 */
SourceRoot : Root ::= Program ;
 

Program : BaseNode ::= 
	        UnstructuredEntity:StoredDefinition* 
            /UnknownClassDecl/
            /UnknownComponentDecl/
            /PredefinedType:BaseClassDecl*/ 
            /BuiltInType:ClassDecl*/   
            /BuiltInFunction:BaseClassDecl*/
            /LibNode*/
            /InstProgramRoot/;

StoredDefinition : BaseNode ::= [Within] Element*;

Within : BaseNode ::= [PackageName:ParseAccess];

abstract ClassDecl : Element;
abstract BaseClassDecl : ClassDecl ::= VisibilityType 
									   [Encapsulated] 
	                                   [Partial] 
	                                   Restriction 
	                                   Name:IdDecl  
                                       [Redeclare]
	                                   [Final]
	                                   [Inner]
	                                   [Outer]
	                                   [Replaceable]
	                                   [ConstrainingClause]
                                       [ConstrainingClauseComment:Comment];

UnknownClassDecl : FullClassDecl;

PN_FullClassDecl : BaseClassDecl ::= [StringComment] 
                                     Composition 
                                     <EndName:String>;
	                      
FullClassDecl : BaseClassDecl ::= [StringComment]  
                                  Equation:AbstractEquation* 
                                  Algorithm*
                                  Super:ExtendsClause*  
                                  Import:ImportClause* 
                                  ClassDecl* 
                                  ComponentDecl*
                                  Annotation* 
                                  [ExternalClause] 
                                  <EndName:String>;

LibClassDecl : FullClassDecl ::= LibNode*;
LibNode : BaseNode ::= <FileName:String> <Name:String> <Structured:boolean> <Version:String> /StoredDefinition/;

// TODO: Why does ShortClassDecl have type_prefix:es?
PN_ShortClassDecl : BaseClassDecl ::= [TypePrefixFlow] 
                                      [TypePrefixVariability]
                                      [TypePrefixInputOutput] 
                                      ClassName:Access  
                                      [ArraySubscripts] 
                                      [ClassModification] 
                                      Comment; 

ShortClassDecl : BaseClassDecl ::= ExtendsClauseShortClass;

ExtendsClauseShortClass : ExtendsClause ::= [TypePrefixFlow] 
                                            [TypePrefixVariability]
                                            [TypePrefixInputOutput] 
                                            [ArraySubscripts] 
                                            Comment; 
                            
PN_ExtendClassDecl : PN_FullClassDecl ::= [ClassModification];
                                
ExtendClassDecl : FullClassDecl;
                                   
PrimitiveClassDecl : FullClassDecl;
RealClassDecl      : PrimitiveClassDecl;
IntegerClassDecl   : PrimitiveClassDecl;
BooleanClassDecl   : PrimitiveClassDecl;
StringClassDecl    : PrimitiveClassDecl;

BuiltInClassDecl : ClassDecl ::= Name:IdDecl;
//RealType : BuiltInClassDecl ::=;
//IntegerType : BuiltInClassDecl ::=;
//StringType : BuiltInClassDecl ::=;
//BooleanType : BuiltInClassDecl ::=;

ConstrainingClause : BaseNode ::= Access [ClassModification];

abstract Restriction : BaseNode;
Model     : Restriction;
Block     : Restriction;
MClass    : Restriction;
Connector : Restriction;
ExpandableConnector : Connector;
MType     : Restriction;
MPackage  : Restriction;
Function  : Restriction;
Record    : Restriction;

Replaceable  : BaseNode;
Redeclare    : BaseNode;
Encapsulated : BaseNode;
Partial      : BaseNode;
Inner        : BaseNode;
Outer        : BaseNode;

abstract VisibilityType : BaseNode;
PublicVisibilityType    : VisibilityType;
ProtectedVisibilityType : VisibilityType;
UnknownVisibilityType   : VisibilityType;

Composition : BaseNode ::= Clause* [ExternalClause];

ExternalClause : BaseNode ::= [ExternalLanguage] 
                              [ExternalFunctionCall] 
                              [Annotation1:Annotation] 
                              [Annotation2:Annotation];
                   
ExternalFunctionCall : BaseNode ::= [ReturnVar:Access] FunctionName:IdDecl Arg:Exp*;

ExternalLanguage : BaseNode ::= <Language>;

abstract Clause : BaseNode;

abstract ElementList : Clause ::= Element*;
PublicElementList    : ElementList;
ProtectedElementList : ElementList;
EquationClause       : Clause ::= AbstractEquation*;
Algorithm            : Clause ::= [Initial] Statement*;

abstract Element : Clause;
ElementAnnotation       : Element ::= Annotation;
PN_ExtendsClause        : Element ::= Super:Access [ClassModification] [Annotation];
ExtendsClause           : Element ::= VisibilityType Super:Access [ClassModification] [Annotation];
InlineExtendsClause     : ExtendsClause;
abstract ImportClause   : Element ::= PackageName:Access Comment;
ImportClauseQualified   : ImportClause;
//ImportClauseSingleDefinition : ImportClause;
ImportClauseUnqualified : ImportClause;
ImportClauseRename      : ImportClause ::= IdDecl;

abstract AbstractComponentDecl : Element;
UnknownComponentDecl : ComponentDecl;
abstract BaseComponentDecl : AbstractComponentDecl ::= 
	                       [Redeclare] 
                           [Final] 
                           [Inner] 
                           [Outer] 
                           [Replaceable] 
                           [TypePrefixFlow] 
                           [TypePrefixVariability] 
                           [TypePrefixInputOutput] 
                           ClassName:Access 
                           [TypeArraySubscripts:ArraySubscripts];

ComponentClause : BaseComponentDecl ::=  VisibilityType 
                                         Name:PN_ComponentDecl* 
                                         [ConstrainingClause] 
                                         Comment;

ComponentDecl : BaseComponentDecl ::= VisibilityType 
                                      Name:IdDecl 
                                      [VarArraySubscripts:ArraySubscripts] 
                                      [Modification] 
                                      [ConditionalAttribute]
                                      Comment 
                                      [ConstrainingClause] 
                                      CCComment:Comment;

PN_ComponentClause : BaseComponentDecl ::=  Name:PN_ComponentDecl* 
                                            [ConstrainingClause] 
                                            Comment;
                                            
PN_ComponentDecl : BaseNode ::= Name:IdDecl 
                                [VarArraySubscripts:ArraySubscripts] 
                                [Modification] 
                                [ConditionalAttribute]
                                Comment;

abstract TypePrefix     : BaseNode;
abstract TypePrefixFlow : TypePrefix;
Flow       : TypePrefixFlow;
Stream     : TypePrefixFlow;
abstract TypePrefixVariability : TypePrefix;
Continuous : TypePrefixVariability;
Discrete   : TypePrefixVariability;
Parameter  : TypePrefixVariability;
Constant   : TypePrefixVariability;
abstract TypePrefixInputOutput : TypePrefix;
Input      : TypePrefixInputOutput;
Output     : TypePrefixInputOutput;

Comment       : BaseNode ::= [StringComment] [Annotation];
StringComment : BaseNode ::= <Comment:String>;

// Annotations and modifications
Each  : BaseNode;
Final : BaseNode;

ConditionalAttribute : BaseNode ::= Exp;

abstract Modification : BaseNode;
CompleteModification  : Modification ::= ClassModification [ValueModification];
ValueModification     : Modification ::= Exp;
//AssignModification    : Modification ::= Exp;

ClassModification : Modification ::= Argument*;
abstract Argument : Modification ::= [Each] [Final];

abstract NamedModification   : Argument ::= Name:Access;
abstract ElementModification : NamedModification ::= [Modification] [StringComment];
// ClassModification : ElementModification; // is a(M.x=3) valid if M is a class?
ComponentModification : ElementModification; 
abstract ElementRedeclare    : NamedModification;
ClassRedeclare        : ElementRedeclare ::= BaseClassDecl;
PN_ComponentRedeclare : ElementRedeclare ::= BaseComponentDecl;
ComponentRedeclare    : ElementRedeclare ::= ComponentDecl;

abstract Annotation : BaseNode;

ParseAnnotation : Annotation ::= ClassModification;

abstract AbstractExp : BaseNode;
abstract Exp : AbstractExp;

abstract AbstractEquationModifier : BaseNode;
abstract AbstractEquation         : BaseNode ::= [AbstractEquationModifier] Comment;
Initial              : AbstractEquationModifier ::=;
Equation             : AbstractEquation ::= Left:Exp Right:Exp;
EquationAnnotation   : AbstractEquation ::= Annotation;
ConnectClause        : AbstractEquation ::= Comment Connector1:Access Connector2:Access;
ConditionalEquationE : AbstractEquation ::= IfExp:Exp IfEqns:AbstractEquation*
                                            ElseIfClauseE*
                                            ElseEqns:AbstractEquation*;
ElseIfClauseE        : BaseNode         ::= IfExp:Exp IfEqns:AbstractEquation*;
ForClauseE           : AbstractEquation ::= ForIndex* AbstractEquation*;
WhenClauseE          : AbstractEquation ::= WhenExp:Exp WhenEqns:AbstractEquation*
                                            ElseWhenClauseE*;
ElseWhenClauseE      : BaseNode         ::= WhenExp:Exp WhenEqns:AbstractEquation*;         
FunctionCallEquation : AbstractEquation ::= Left:FunctionCallLeft* Call:FunctionCall;

FunctionCallLeft : BaseNode ::= [Access];
ForIndex : BaseNode ::= ForIndexDecl [Exp];
// ForIndexDecl is introduced basically to make the name-analysis simpler:
// lookupDecl is supposed to return a ComponentDecls.
ForIndexDecl : ComponentDecl; // Is this really ok: FIXME! 
         
abstract Statement    : BaseNode  ::= Comment;
AssignStmt          : Statement ::= Left:Access Right:Exp;
FunctionCallStmt    : Statement ::= Left:FunctionCallLeft* FunctionCall;
BreakStmt           : Statement;
ReturnStmt          : Statement;
abstract IfWhenStmt   : Statement ::= IfWhenClause*;
IfStmt              : IfWhenStmt ::= ElseStmt:Statement*;
WhenStmt            : IfWhenStmt;
abstract IfWhenClause : BaseNode  ::= Test:Exp Statement*;
IfClause            : IfWhenClause;
WhenClause          : IfWhenClause;
ForStmt             : Statement ::= ForIndex* ForStmt:Statement*;
WhileStmt           : Statement ::= Test:Exp WhileStmt:Statement*;
AlgorithmAnnotation : Statement ::= Annotation;

IfExp     : Exp ::= IfExp:Exp ThenExp:Exp ElseIfExp* ElseExp:Exp;
ElseIfExp : Exp ::= IfExp:Exp ThenExp:Exp;

abstract BinExp : Exp ::= Left:Exp Right:Exp;

abstract ArtmBinExp : BinExp;
DotAddExp : ArtmBinExp;
DotSubExp : ArtmBinExp;
DotMulExp : ArtmBinExp;
DotDivExp : ArtmBinExp;
DotPowExp : ArtmBinExp; // Easy to make parser take care of this: should be a Primary
AddExp : DotAddExp;
SubExp : DotSubExp;
MulExp : DotMulExp;
DivExp : DotDivExp;
PowExp : DotPowExp; // Easy to make parser take care of this: should be a Primary
NegExp : Exp ::= Exp;

RealLitExp    : Exp ::= <UNSIGNED_NUMBER>;
IntegerLitExp : Exp ::= <UNSIGNED_INTEGER>;
StringLitExp  : Exp ::= <STRING>;
abstract BooleanLitExp : Exp;
BooleanLitExpTrue  : BooleanLitExp;
BooleanLitExpFalse : BooleanLitExp;

FunctionCall : Exp ::= Name:Access [FunctionArguments];

FunctionArguments : BaseNode::= Exp* NamedArgument*;
NamedArgument     : BaseNode::= Name:Access Exp;

IterExp  : Exp ::= Exp ForIndex*;
RangeExp : Exp ::= Exp*;

abstract LogBinExp : BinExp;
LtExp  : LogBinExp;
LeqExp : LogBinExp;
GtExp  : LogBinExp;
GeqExp : LogBinExp;
EqExp  : LogBinExp;
NeqExp : LogBinExp;
NotExp : Exp ::= Exp;
OrExp  : LogBinExp;
AndExp : LogBinExp;

IdDecl : BaseNode ::= <ID>;

DerExp : Exp ::= Exp;

AccessExp : Exp ::= Access;

abstract Access : BaseNode ::= <ID>;
Dot             : Access ::= Left:Access Right:Access;
ArrayAccess     : Access ::= [ArraySubscripts];
ParseAccess     : ArrayAccess;
ClassAccess     : Access;
AmbiguousAccess : ArrayAccess;
ComponentAccess : ArrayAccess;

ArrayConstructor : Exp ::= FunctionArguments;
Matrix           : Exp ::= Row:MatrixRow*;
MatrixRow        : Exp ::= Exp*;

ArraySubscripts : BaseNode ::= Subscript*;
abstract Subscript : BaseNode;
ColonSubscript : Subscript::=;
ExpSubscript   : Subscript ::= Exp;

TimeExp : Exp;
EndExp  : Exp;

// Dummy node used in the compilation
PN_DummyClause : Clause;
