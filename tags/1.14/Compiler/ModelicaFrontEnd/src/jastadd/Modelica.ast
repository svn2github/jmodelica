/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/**
 * \mainpage API documentation of the JModelica.org Modelica Front-end
 *
 * The API documentation of the Modelica %compiler front-end is yet rudimentary. 
 * Also, the APIs for the Java classes contains several methods that are 
 * part of the internal JastAdd run-time system - these methods are not intended
 * to be used by the user.
 * 
 * We are currently working together with the JastAdd team to develop a 
 * documentation system where internal methods are hidden and where the user
 * API is exposed.
 *
 * The Modelica %compiler is organized into a number of different packages:
 * <ul>
 *   <li> org.jmodelica.modelica.parser containing parsers for Modelica
 *   and Flat Modelica code.</li>
 *   <li> org.jmodelica.modelica.compiler contains the actual %compiler, including
 *   the classes used to construct the Abstract Syntax Trees (ASTs) and the
 *   %compiler driver class ModelicaCompiler.</li>
 *   <li> org.jmodelica.util contains some helper classes which are independent
 *   of the AST classes.</li>
 * </ul>
 * 
 * Notice that the Java classes are not intended to be edited manually (with
 * the exception of the classes in org.jmodelica.util), but are rather 
 * automatically generated by the JastAdd tool. In order to extend or 
 * modify the functionality of the %compiler, edit the .%ast, .jrag and .jadd
 * files.
 *
 */


// Modelica abstract grammar



/**
 * \defgroup aspect_Flattening Aspect: Flattening
 */


/**
 * \package org.jmodelica.ast Package containing all AST classes.
 */

abstract BaseNode;

abstract Root : BaseNode;

ParserHandler : BaseNode;

abstract SourceBaseNode : BaseNode;

/**
 * A class representing the root node of a source AST.
 */
SourceRoot : Root ::= Program ;
 

Program : SourceBaseNode ::= 
	        UnstructuredEntity:StoredDefinition* 
            /UnknownClassDecl/
            /UnknownComponentDecl/
            /EnumBaseDecl:EnumClassDecl/
            /PredefinedType:BaseClassDecl*/ 
            /BuiltInType:ClassDecl*/   
            /BuiltInFunction:BaseClassDecl*/
            /LibNode*/
            /InstProgramRoot/;

StoredDefinition : SourceBaseNode ::= [Within] Element*;

Within : SourceBaseNode ::= [PackageName:Access];

abstract ClassDecl : Element       ::= Name:IdDecl;
abstract BaseClassDecl : ClassDecl ::= VisibilityType 
                                       [Encapsulated] 
                                       [Partial] 
                                       Restriction 
                                       [Redeclare]
                                       [Final]
                                       [Inner]
                                       [Outer]
                                       [Replaceable]
                                       [ConstrainingClause]
                                       [ConstrainingClauseComment:Comment];

UnknownClassDecl : FullClassDecl;

PN_FullClassDecl : BaseClassDecl ::= [StringComment] 
                                     Composition 
                                     [Annotation]
                                     EndDecl;
	                      
FullClassDecl : BaseClassDecl ::= [StringComment]  
                                  Equation:AbstractEquation* 
                                  Algorithm*
                                  Super:ExtendsClause*  
                                  Import:ImportClause* 
                                  ClassDecl* 
                                  ComponentDecl*
                                  ElementModification:Modification* 
                                  [ExternalClause] 
                                  [Annotation] 
                                  EndDecl;

LibClassDecl : FullClassDecl ::= LibNode*;
LibNode : SourceBaseNode ::= <FileName:String> <Name:String> <Structured:boolean> <Version:String> /StoredDefinition/;

PN_ShortClassDecl : BaseClassDecl ::= [TypePrefixFlow] 
                                      [TypePrefixVariability]
                                      [TypePrefixInputOutput] 
                                      ClassName:Access  
                                      [ArraySubscripts] 
                                      [ClassModification] 
                                      Comment; 

ShortClassDecl : BaseClassDecl ::= ExtendsClauseShortClass;

ExtendsClauseShortClass : ExtendsClause ::= [TypePrefixFlow] 
                                            [TypePrefixVariability]
                                            [TypePrefixInputOutput] 
                                            [ArraySubscripts] 
                                            Comment; 
                            
PN_ExtendClassDecl : PN_FullClassDecl ::= [ClassModification];
                                
ExtendClassDecl : FullClassDecl;
                                   
PrimitiveClassDecl : FullClassDecl;
RealClassDecl      : PrimitiveClassDecl;
IntegerClassDecl   : PrimitiveClassDecl;
BooleanClassDecl   : PrimitiveClassDecl;
StringClassDecl    : PrimitiveClassDecl;
EnumClassDecl      : PrimitiveClassDecl ::= <Symbol:Symbol>; // <Sumbol> is necessary to achieve formatted pretty print.

PN_EnumDecl : BaseClassDecl ::= <Symbol:Symbol> EnumSpecification Comment;  // <Sumbol> is necessary to achieve formatted pretty print.
abstract EnumSpecification : SourceBaseNode;
EnumLiteralList : EnumSpecification ::= EnumLiteral*;
EnumUnspecified : EnumSpecification;
EnumLiteral : SourceBaseNode ::= IdDecl Comment;

EnumLiteralDecl : ComponentDecl;

BuiltInClassDecl : ClassDecl;

ConstrainingClause : SourceBaseNode ::= Access [ClassModification];

abstract Restriction : SourceBaseNode;
Model               : Restriction;
Block               : Restriction;
MClass              : Restriction;
Connector           : Restriction;
ExpandableConnector : Connector;
MType               : Restriction;
MPackage            : Restriction;
Function            : Restriction;
Record              : Restriction;
OperatorRecord      : Record;
Operator            : Restriction;
OperatorFunction    : Function;

Replaceable  : SourceBaseNode;
Redeclare    : SourceBaseNode;
Encapsulated : SourceBaseNode;
Partial      : SourceBaseNode;
Inner        : SourceBaseNode;
Outer        : SourceBaseNode;

abstract VisibilityType : SourceBaseNode;
PublicVisibilityType    : VisibilityType;
ProtectedVisibilityType : VisibilityType;
UnknownVisibilityType   : VisibilityType;

Composition : SourceBaseNode ::= Clause* [ExternalClause];

ExternalClause : SourceBaseNode ::= [ExternalLanguage] 
                              [ExternalFunctionCall] 
                              [Annotation];
                   
ExternalFunctionCall : SourceBaseNode ::= [ReturnVar:Access] FunctionName:IdDecl Arg:Exp*;

ExternalLanguage : SourceBaseNode ::= <Language>;

abstract Clause : SourceBaseNode;

abstract ElementList  : Clause ::= Element*;
PublicElementList     : ElementList;
ProtectedElementList  : ElementList;
EquationClause        : Clause ::= AbstractEquation*;
InitialEquationClause : EquationClause;
Algorithm             : Clause ::= [Initial] Statement*;

abstract Element : Clause;
PN_ExtendsClause        : Element ::= Super:Access [ClassModification] [Annotation];
ExtendsClause           : Element ::= VisibilityType Super:Access [ClassModification] [Annotation];
InlineExtendsClause     : ExtendsClause;
abstract ImportClause   : Element ::= PackageName:Access Comment;
ImportClauseQualified   : ImportClause;
//ImportClauseSingleDefinition : ImportClause;
ImportClauseUnqualified : ImportClause;
ImportClauseRename      : ImportClause ::= IdDecl;

abstract AbstractComponentDecl : Element;
UnknownComponentDecl : ComponentDecl;
abstract BaseComponentDecl : AbstractComponentDecl ::= 
	                       [Redeclare] 
                           [Final] 
                           [Inner] 
                           [Outer] 
                           [Replaceable] 
                           [TypePrefixFlow] 
                           [TypePrefixVariability] 
                           [TypePrefixInputOutput] 
                           ClassName:Access 
                           [TypeArraySubscripts:ArraySubscripts];

ComponentClause : BaseComponentDecl ::=  VisibilityType 
                                         Name:PN_ComponentDecl* 
                                         [ConstrainingClause] 
                                         Comment;

ComponentDecl : BaseComponentDecl ::= VisibilityType 
                                      Name:IdDecl 
                                      [VarArraySubscripts:ArraySubscripts] 
                                      [Modification] 
                                      [ConditionalAttribute]
                                      Comment 
                                      [ConstrainingClause] 
                                      CCComment:Comment;

SiblingComponentDecl : ComponentDecl ::= <Siblings:java.util.List<SiblingComponentDecl>>;

PN_ComponentClause : BaseComponentDecl ::=  Name:PN_ComponentDecl* 
                                            [ConstrainingClause] 
                                            Comment;
                                            
PN_ComponentDecl : SourceBaseNode ::= Name:IdDecl 
                                [VarArraySubscripts:ArraySubscripts] 
                                [Modification] 
                                [ConditionalAttribute]
                                Comment;

abstract TypePrefix     : SourceBaseNode;
abstract TypePrefixFlow : TypePrefix;
Flow       : TypePrefixFlow;
Stream     : TypePrefixFlow;
abstract TypePrefixVariability : TypePrefix;
Continuous : TypePrefixVariability;
Discrete   : TypePrefixVariability;
Parameter  : TypePrefixVariability;
Constant   : TypePrefixVariability;
abstract TypePrefixInputOutput : TypePrefix;
Input      : TypePrefixInputOutput;
Output     : TypePrefixInputOutput;

Comment       : SourceBaseNode ::= [StringComment] [Annotation];
StringComment : SourceBaseNode ::= <Comment:String>;

// Annotations and modifications
Each  : SourceBaseNode;
Final : SourceBaseNode;

ConditionalAttribute : SourceBaseNode ::= Exp;

abstract Modification : SourceBaseNode;
CompleteModification  : Modification ::= ClassModification [ValueModification];
ValueModification     : Modification ::= Exp;
//AssignModification    : Modification ::= Exp;

ClassModification : Modification ::= Argument*;
abstract Argument : Modification ::= [Each] [Final];

abstract NamedModification   : Argument ::= Name:Access;
abstract ElementModification : NamedModification ::= [Modification] [StringComment];
// ClassModification : ElementModification; // is a(M.x=3) valid if M is a class?
ComponentModification : ElementModification; 
abstract ElementRedeclare    : NamedModification;
ClassRedeclare        : ElementRedeclare ::= BaseClassDecl;
PN_ComponentRedeclare : ElementRedeclare ::= BaseComponentDecl;
ComponentRedeclare    : ElementRedeclare ::= ComponentDecl;

abstract Annotation : SourceBaseNode;

ParseAnnotation : Annotation ::= ClassModification;

abstract AbstractExp : SourceBaseNode;
abstract Exp : AbstractExp;

abstract AbstractEquationModifier : SourceBaseNode;
abstract AbstractEquation         : SourceBaseNode ::= [AbstractEquationModifier] Comment;
Initial              : AbstractEquationModifier;
Equation             : AbstractEquation ::= Left:Exp Right:Exp;
ConnectClause        : AbstractEquation ::= Comment Connector1:Access Connector2:Access;
abstract IfWhenElseEquation       : AbstractEquation ::= AbstractEquation*;
abstract IfWhenEquation           : IfWhenElseEquation ::= Test:Exp [Else:IfWhenElseEquation];
IfEquation           : IfWhenEquation;
WhenEquation         : IfWhenEquation; 
ElseEquation         : IfWhenElseEquation;
ForClauseE           : AbstractEquation ::= ForIndex* AbstractEquation*;
FunctionCallEquation : AbstractEquation ::= Left:FunctionCallLeft* Call:FunctionCall;

FunctionCallLeft : SourceBaseNode ::= [Access];
ForIndex : SourceBaseNode ::= ForIndexDecl [Exp];
// ForIndexDecl is introduced basically to make the name-analysis simpler:
// lookupDecl is supposed to return a ComponentDecls.
ForIndexDecl : ComponentDecl; // Is this really ok: FIXME! 
         
abstract Statement    : SourceBaseNode  ::= Comment;
AssignStmt          : Statement ::= Left:Access Right:Exp;
FunctionCallStmt    : Statement ::= Left:FunctionCallLeft* FunctionCall;
BreakStmt           : Statement;
ReturnStmt          : Statement;
abstract IfWhenStmt   : Statement ::= IfWhenClause*;
IfStmt              : IfWhenStmt ::= [ElseClause];
WhenStmt            : IfWhenStmt;
ElseClause          : SourceBaseNode ::= Stmt:Statement*;
abstract IfWhenClause : SourceBaseNode  ::= Test:Exp Statement*;
IfClause            : IfWhenClause;
WhenClause          : IfWhenClause;
ForStmt             : Statement ::= ForIndex* ForStmtList;
ForStmtList         : SourceBaseNode ::= Stmt:Statement*;
WhileStmt           : Statement ::= Test:Exp WhileStmt:Statement*;
AlgorithmAnnotation : Statement ::= Annotation;

IfExp     : Exp ::= IfExp:Exp ThenExp:Exp ElseExp:Exp;

abstract BinExp : Exp ::= Left:Exp Right:Exp;

abstract ArtmBinExp : BinExp;
DotAddExp : ArtmBinExp;
DotSubExp : ArtmBinExp;
DotMulExp : ArtmBinExp;
DotDivExp : ArtmBinExp;
DotPowExp : ArtmBinExp; // Easy to make parser take care of this: should be a Primary
AddExp : DotAddExp;
SubExp : DotSubExp;
MulExp : DotMulExp;
DivExp : DotDivExp;
PowExp : DotPowExp; // Easy to make parser take care of this: should be a Primary
NegExp : Exp ::= Exp;

RealLitExp    : Exp ::= <UNSIGNED_NUMBER>;
IntegerLitExp : Exp ::= <UNSIGNED_INTEGER>;
StringLitExp  : Exp ::= <STRING>;
abstract BooleanLitExp : Exp;
BooleanLitExpTrue  : BooleanLitExp;
BooleanLitExpFalse : BooleanLitExp;

FunctionCall : Exp ::= Name:Access [FunctionArguments];
PartialFunctionCall : FunctionCall;

FunctionArguments : SourceBaseNode::= Exp* NamedArgument*;
NamedArgument     : SourceBaseNode::= Name:Access Exp;

IterExp  : Exp ::= Exp ForIndex*;
RangeExp : Exp ::= Exp*;

abstract LogBinExp : BinExp;
LtExp  : LogBinExp;
LeqExp : LogBinExp;
GtExp  : LogBinExp;
GeqExp : LogBinExp;
EqExp  : LogBinExp;
NeqExp : LogBinExp;
NotExp : Exp ::= Exp;
OrExp  : LogBinExp;
AndExp : LogBinExp;

IdDecl : SourceBaseNode ::= <ID>;

DerExp : Exp ::= Exp;

AccessExp : Exp ::= Access;

abstract Access : SourceBaseNode;
abstract NamedAccess : Access ::= <ID>;
Dot             : Access      ::= Access*;
PN_Dot          : Access      ::= Left:Access Right:Access;
GlobalAccess    : Access      ::= Access;
ArrayAccess     : NamedAccess ::= [ArraySubscripts];
ParseAccess     : ArrayAccess;
ClassAccess     : NamedAccess;
AmbiguousAccess : ArrayAccess;
ComponentAccess : ArrayAccess;

ArrayConstructor : Exp ::= FunctionArguments;
Matrix           : Exp ::= Row:MatrixRow*;
MatrixRow        : Exp ::= Exp*;

ArraySubscripts : SourceBaseNode ::= Subscript*;
abstract Subscript : SourceBaseNode;
ColonSubscript : Subscript::=;
ExpSubscript   : Subscript ::= Exp;

TimeExp : Exp;
EndExp  : Exp;

EndDecl : SourceBaseNode ::= <EndID:String>;

// Dummy node used in the compilation
PN_DummyClause : Clause;
